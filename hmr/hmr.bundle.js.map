{"version":3,"file":"hmr.bundle.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8CAA8C;AAC9C;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CkD;AACR;AACsC;AACF;AACN;AACA;AACR;AACU;AACnE;AACA;AACP;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB;AACjB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,+DAAgB;AAC5B;AACA;AACA,kEAAkE,4BAA4B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B,qFAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,EAAE,eAAe,EAAE,OAAO;AACrG;AACA;AACA;AACA,SAAS;AACT,8BAA8B,yEAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAAmB;AAC1C;AACA;AACA,YAAY,6EAAe;AAC3B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,uFAAoB;AAClD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,SAAS;AACT;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,gBAAgB;AAC9F,gBAAgB,wBAAwB,EAAE,0EAAkB;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,sEAAa;AAClD;AACA;AACA;AACA,YAAY,4EAAmB;AAC/B,mFAAmF,gBAAgB;AACnG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrPiD;AACuB;AACjE;AACP,eAAe,0DAAY,CAAC,qFAAmB;AAC/C;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChB+C;AAC6B;AAC1B;AACA;AAC3C;AACP;AACA;AACA;AACA;AACA,mBAAmB,+EAA+E;AAClG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAa;AAC5C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa,6DAAa;AAC1B,4CAA4C,4DAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY,6DAAa;AACzB;AACA;AACA,YAAY,8DAAc;AAC1B;AACA,mBAAmB,4DAAS;AAC5B;AACA,YAAY,0DAAU;AACtB;AACA;AACA,eAAe,4DAAS;AACxB,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACvEuC;AAChC,2BAA2B,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9B4E;AACL;AACjB;AAC/C;AACP;AACA;AACA;AACA;AACA,qBAAqB,0DAAU;AAC/B,4BAA4B,KAAK,4BAA4B,sBAAsB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAa;AACxC,6BAA6B,6DAAa;AAC1C;AACA;AACA,iBAAiB,mEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAc;AAClD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,QAAQ,oFAAkB;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC7DO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9FO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;;;;;;;;;;;;;AChBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBO;AACP;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpB+C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,qCAAqC;AACrC,yCAAyC;AACzC;AACA,SAAS;AACT;AACA,yBAAyB;AACzB;AACA;AACA,oBAAoB,4DAAS;AAC7B,qBAAqB;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;AC3EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClBkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAgB;AACxB,sCAAsC;AACtC,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACzB+D;AACxD;AACP;AACA,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC,EAAE,4EAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe,EAAE,4EAAmB;AAChE;AACA;AACA;AACA;AACA,wBAAwB,sDAAsD;AAC9E;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzCmE;AACN;AACkB;AACjB;AAC9D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD,EAAE,4FAA2B;AACpG;AACA;AACA;AACA,IAAI,gFAAqB;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,gFAAqB;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,mBAAmB,0EAAsB;AACzC,0CAA0C,uDAAY,EAAE,yDAAc;AACtE;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClCgD;AACS;AACe;AACvB;AACmB;AAC7D;AACP,+BAA+B,WAAW,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,mCAAmC,yDAAc,aAAa,yDAAc;AAC5E,iBAAiB,UAAU;AAC3B;AACA;AACA,QAAQ,8DAAc;AACtB,iBAAiB,wBAAwB;AACzC;AACA;AACA,mFAAmF,gBAAgB;AACnG,aAAa;AACb;AACO;AACP,EAAE,gBAAgB;AAClB;AACA;AACA;AACA;AACA;AACA,2BAA2B,qFAAmB;AAC9C,sBAAsB,WAAW;AACjC;AACA,SAAS;AACT;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC;AAClC;AACA,QAAQ,iFAAiB;AACzB;AACA;AACA;AACA,eAAe,sEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACtFA;AACO,sGAAsG,WAAW,GAAG;AAC3H,eAAe,GAAG;AACX;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD,KAAK;AACL,aAAa;AACb;AACA;;;;;;;;;;;;;;;;;ACjBO;AACP;AACA;AACO;AACP;AACA;AACO;AACP,+EAA+E;AAC/E;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACdqD;AACD;AACpD,wBAAwB;AACxB,kBAAkB;AAClB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAc;AAC7B;AACA;AACA,yDAAyD;AACzD;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpHoE;AACnB;AACkC;AAC5E;AACP,QAAQ,8DAAc;AACtB,qDAAqD,0DAAY;AACjE,QAAQ,6DAAc;AACtB;AACA;AACA;AACA,gCAAgC,iEAAkB;AAClD;AACA;AACA;AACA,gBAAgB;AAChB;AACA,QAAQ,6DAAa;AACrB;AACA;AACA,oCAAoC,0DAAY;AAChD;AACA;AACA,QAAQ,iEAAiB;AACzB,uCAAuC;AACvC;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA;;;;;;;;;;;;;;;AC5BkE;AAC3D;AACP;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,kBAAkB,+EAAsB;AACxC,0BAA0B;AAC1B;AACA;AACA;;;;;;;;;;;;;;;;;ACXkE;AACpB;AACoB;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uIAAuI,MAAM;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAe;AAC3B;AACA;AACA,YAAY,8DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+EAAgB;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACzCgF;AACd;AACU;AACrB;AACJ;AACF;AACuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA,QAAQ,8DAAc;AACtB;AACA;AACA,QAAQ,6DAAa;AACrB;AACA;AACA,QAAQ,0DAAU;AAClB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oEAAe;AAC1C;AACA;AACA,mBAAmB,6FAAuB;AAC1C;AACA,WAAW,qFAAmB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B,4DAAU,GAAG;AAC5C,YAAY,0DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+EAAgB;AACnC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxEiD;AACE;AACL;AACuB;AAC9D;AACP;AACA;AACA;AACA,oCAAoC;AACpC,+CAA+C,IAAI,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mDAAmD,4DAAU,GAAG,MAAM,0DAAY;AAClF;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mEAAmE,4CAA4C;AAC/G;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvGO;AACP;AACA,EAAE,uBAAuB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4CAA4C;AAC5C;AACA;AACA;;;;;;;;;;;;;;AC1BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBkE;AAClE,0EAA0E,IAAI;AACvE;AACP;AACA;AACA,+CAA+C,IAAI;AACnD;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,QAAQ,+EAAgB;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACfiD;AACH;AAC9C;AACA,uDAAM;AACN;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAAM;AACN;AACA;AACA;AACA;AACA,uBAAuB,uDAAM;AAC7B;AACA;AACA,6DAA6D,uBAAuB,MAAM,oBAAoB;AAC9G,kCAAkC,0DAAkB;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAiD;AAClF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,uDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kBAAkB,0DAAkB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,uDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChIA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACbA,wDAAwD;AACV;AAC9C;AACO;AACP,IAAI,uDAAM;AACV;AACA;AACO;AACP,IAAI,uDAAM;AACV;AACA;AACO;AACP,IAAI,uDAAM;AACV;AACA;AACO;AACP,IAAI,uDAAM;AACV;AACA;;;;;;;;;;;;;;;;;;;AClBmD;AACH;AACkC;AACpC;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,YAAY,8DAAe;AAC3B;AACA;AACA;AACA,YAAY,8DAAe;AAC3B;AACA,8BAA8B,uDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAc;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;ACnFiE;AAC1D;AACP;AACA;AACA;AACA;AACA,IAAI,8DAAe;AACnB;AACA;AACA;AACA,IAAI,6DAAc;AAClB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChBgD;AACD;AACC;AAC0B;AACJ;AAC/D;AACP;AACA;AACA;AACA,QAAQ,6DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mFAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAa;AAC1B,4BAA4B,4DAAS;AACrC;AACA;AACA;AACA,+BAA+B,uFAAoB;AACnD;AACA,wBAAwB;AACxB;AACA;AACA;AACA,IAAI,6DAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACzDgF;AACR;AACT;AACR;AAC+B;AAClB;AACI;AACE;AACnE;AACP,wCAAwC;AACxC;AACA;AACA;AACA,wBAAwB,8DAAc;AACtC;AACA;AACA,6BAA6B;AAC7B;AACA,IAAI,uFAAoB;AACxB;AACA;AACA,eAAe,mGAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAU;AAClB;AACA,2BAA2B,oEAAe,2CAA2C;AACrF;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,0BAA0B,qFAAmB;AAC7C;AACA;AACA;AACA,QAAQ,iEAAiB;AACzB,wCAAwC;AACxC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAU;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,iFAAiB;AAChC;AACA;AACA,WAAW,qFAAmB;AAC9B;AACA;;;;;;SC3EA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;ACNA;;AAEA,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,sEAAuB;;AAE1D;AACA,YAAY,6BAA6B;;AAEzC;;AAEA;AACA,aAAa,iCAAiC;AAC9C,aAAa,wBAAwB;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS,sDAAsD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,0DAAO,CAAC,EAAE,IAAI,GAAG,WAAW,CAAC,CAAC;;AAEvD,eAAe,WAAW;AAC1B;AACA;AACA,cAAc;AACd,MAAM;AACN,kDAAkD,QAAQ,IAAI,YAAY;AAC1E;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA,WAAW,gBAAgB;AAC3B;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,YAAY;AACxB;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA,cAAc,6CAA6C;AAC3D,GAAG,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,mDAAmD,eAAe;AAClE,GAAG;;AAEH;;AAEA;AACA;;AAEA,WAAW,iBAAiB;AAC5B;;AAEA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,gBAAgB,aAAa;AAC7B,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH","sources":["webpack:///./hmr/web/ lazy ^.*\\","webpack:///./node_modules/taggedjs/js/Subject.js","webpack:///./node_modules/taggedjs/js/Tag.class.js","webpack:///./node_modules/taggedjs/js/Tag.utils.js","webpack:///./node_modules/taggedjs/js/TagSupport.class.js","webpack:///./node_modules/taggedjs/js/ValueSubject.js","webpack:///./node_modules/taggedjs/js/bindSubjectCallback.function.js","webpack:///./node_modules/taggedjs/js/checkDestroyPrevious.function.js","webpack:///./node_modules/taggedjs/js/deepFunctions.js","webpack:///./node_modules/taggedjs/js/elementDestroyCheck.function.js","webpack:///./node_modules/taggedjs/js/elementInitCheck.js","webpack:///./node_modules/taggedjs/js/errors.js","webpack:///./node_modules/taggedjs/js/hasTagSupportChanged.function.js","webpack:///./node_modules/taggedjs/js/inputAttribute.js","webpack:///./node_modules/taggedjs/js/interpolateAttributes.js","webpack:///./node_modules/taggedjs/js/interpolateContentTemplates.js","webpack:///./node_modules/taggedjs/js/interpolateElement.js","webpack:///./node_modules/taggedjs/js/interpolateTemplate.js","webpack:///./node_modules/taggedjs/js/interpolations.js","webpack:///./node_modules/taggedjs/js/isInstance.js","webpack:///./node_modules/taggedjs/js/isLikeTags.function.js","webpack:///./node_modules/taggedjs/js/processAttribute.function.js","webpack:///./node_modules/taggedjs/js/processNewValue.function.js","webpack:///./node_modules/taggedjs/js/processRegularValue.function.js","webpack:///./node_modules/taggedjs/js/processSubjectComponent.function.js","webpack:///./node_modules/taggedjs/js/processSubjectValue.function.js","webpack:///./node_modules/taggedjs/js/processTagArray.js","webpack:///./node_modules/taggedjs/js/processTagResult.function.js","webpack:///./node_modules/taggedjs/js/render.js","webpack:///./node_modules/taggedjs/js/scanTextAreaValue.function.js","webpack:///./node_modules/taggedjs/js/set.function.js","webpack:///./node_modules/taggedjs/js/setUse.function.js","webpack:///./node_modules/taggedjs/js/tagRunner.js","webpack:///./node_modules/taggedjs/js/templater.utils.js","webpack:///./node_modules/taggedjs/js/updateExistingTag.function.js","webpack:///./node_modules/taggedjs/js/updateExistingTagComponent.function.js","webpack:///./node_modules/taggedjs/js/updateExistingValue.function.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./hmr/web/hmr.js"],"sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./hmr/web lazy recursive ^.*\\\\?.*$\";\nmodule.exports = webpackEmptyAsyncContext;","export class Subject {\n    value;\n    isSubject = true;\n    subscribers = [];\n    // unsubcount = 0 // 🔬 testing\n    constructor(value) {\n        this.value = value;\n    }\n    subscribe(callback) {\n        this.subscribers.push(callback);\n        SubjectClass.globalSubs.push(callback); // 🔬 testing\n        const countSubject = SubjectClass.globalSubCount$;\n        SubjectClass.globalSubCount$.set(countSubject.value + 1);\n        const unsubscribe = () => {\n            unsubscribe.unsubscribe();\n        };\n        // Return a function to unsubscribe from the BehaviorSubject\n        unsubscribe.unsubscribe = () => {\n            removeSubFromArray(this.subscribers, callback);\n            removeSubFromArray(SubjectClass.globalSubs, callback); // 🔬 testing\n            SubjectClass.globalSubCount$.set(countSubject.value - 1);\n            // any double unsubscribes will be ignored\n            unsubscribe.unsubscribe = () => undefined;\n        };\n        return unsubscribe;\n    }\n    set(value) {\n        this.value = value;\n        // Notify all subscribers with the new value\n        this.subscribers.forEach((callback) => {\n            callback.value = value;\n            callback(value);\n        });\n    }\n    next = this.set;\n}\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.indexOf(callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nconst SubjectClass = Subject;\nSubjectClass.globalSubs = []; // 🔬 for testing\nSubjectClass.globalSubCount$ = new Subject(); // for ease of debugging\nSubjectClass.globalSubCount$.set(0);\n//# sourceMappingURL=Subject.js.map","import { runBeforeDestroy } from \"./tagRunner.js\";\nimport { buildClones } from \"./render.js\";\nimport { interpolateElement, interpolateString } from \"./interpolateElement.js\";\nimport { afterElmBuild, subscribeToTemplate } from \"./interpolateTemplate.js\";\nimport { elementDestroyCheck } from \"./elementDestroyCheck.function.js\";\nimport { updateExistingValue } from \"./updateExistingValue.function.js\";\nimport { processNewValue } from \"./processNewValue.function.js\";\nimport { checkDestroyPrevious } from \"./checkDestroyPrevious.function.js\";\nexport const variablePrefix = '__tagvar';\nexport const escapeVariable = '--' + variablePrefix + '--';\nconst prefixSearch = new RegExp(variablePrefix, 'g');\nexport const escapeSearch = new RegExp(escapeVariable, 'g');\nexport class ArrayValueNeverSet {\n    isArrayValueNeverSet = true;\n}\nexport class Tag {\n    strings;\n    values;\n    isTag = true;\n    clones = []; // elements on document. Needed at destroy process to know what to destroy\n    cloneSubs = []; // subscriptions created by clones\n    children = []; // tags on me\n    tagSupport;\n    // only present when a child of a tag\n    ownerTag;\n    // insertBefore?: Element\n    appElement; // only seen on this.getAppElement().appElement\n    // present only when an array. Populated by this.key()\n    arrayValue = new ArrayValueNeverSet();\n    constructor(strings, values) {\n        this.strings = strings;\n        this.values = values;\n    }\n    /** Used for array, such as array.map(), calls aka array.map(x => html``.key(x)) */\n    key(arrayValue) {\n        this.arrayValue = arrayValue;\n        return this;\n    }\n    async destroy(options = {\n        stagger: 0,\n        byParent: false, // Only destroy clones of direct children\n    }) {\n        // the isComponent check maybe able to be removed\n        const isComponent = this.tagSupport ? true : false;\n        if (isComponent) {\n            runBeforeDestroy(this.tagSupport, this);\n        }\n        this.destroySubscriptions();\n        const promises = this.children.map((kid) => kid.destroy({ ...options, byParent: true }));\n        this.children.length = 0;\n        if (this.ownerTag) {\n            this.ownerTag.children = this.ownerTag.children.filter(child => child !== this);\n        }\n        if (!options.byParent) {\n            options.stagger = await this.destroyClones(options);\n        }\n        await Promise.all(promises);\n        return options.stagger;\n    }\n    destroySubscriptions() {\n        this.cloneSubs.forEach(cloneSub => cloneSub.unsubscribe());\n        this.cloneSubs.length = 0;\n    }\n    async destroyClones({ stagger } = {\n        stagger: 0,\n    }) {\n        let hasPromise = false;\n        const promises = this.clones.reverse().map((clone, index) => {\n            let promise;\n            if (clone.ondestroy) {\n                promise = elementDestroyCheck(clone, stagger);\n            }\n            const next = () => {\n                clone.parentNode?.removeChild(clone);\n                const ownerTag = this.ownerTag;\n                if (ownerTag) {\n                    // Sometimes my clones were first registered to my owner, remove them\n                    ownerTag.clones = ownerTag.clones.filter(compareClone => compareClone !== clone);\n                }\n            };\n            if (promise instanceof Promise) {\n                hasPromise = true;\n                promise.then(next);\n            }\n            else {\n                next();\n            }\n            return promise;\n        });\n        this.clones.length = 0; // tag maybe used for something else\n        if (hasPromise) {\n            await Promise.all(promises);\n        }\n        return stagger;\n    }\n    updateByTag(tag) {\n        this.updateConfig(tag.strings, tag.values);\n        this.tagSupport.templater = tag.tagSupport.templater;\n        this.tagSupport.propsConfig = { ...tag.tagSupport.propsConfig };\n        this.tagSupport.newest = tag;\n        this.tagSupport.templater.newest = tag;\n    }\n    lastTemplateString = undefined; // used to compare templates for updates\n    updateConfig(strings, values) {\n        this.strings = strings;\n        this.updateValues(values);\n    }\n    getTemplate() {\n        const string = this.strings.map((string, index) => {\n            const safeString = string.replace(prefixSearch, escapeVariable);\n            const endString = safeString + (this.values.length > index ? `{${variablePrefix}${index}}` : '');\n            // const trimString = index === 0 || index === this.strings.length-1 ? endString.trim() : endString\n            const trimString = endString.replace(/>\\s*/g, '>').replace(/\\s*</g, '<');\n            return trimString;\n        }).join('');\n        const interpolation = interpolateString(string);\n        this.lastTemplateString = interpolation.string;\n        return {\n            interpolation,\n            // string,\n            string: interpolation.string,\n            strings: this.strings,\n            values: this.values,\n            context: this.tagSupport?.memory.context || {},\n        };\n    }\n    isLikeTag(tag) {\n        const { string } = tag.getTemplate();\n        // TODO: most likely remove?\n        if (!this.lastTemplateString) {\n            throw new Error('no template here');\n        }\n        const stringMatched = string === this.lastTemplateString;\n        if (!stringMatched || tag.values.length !== this.values.length) {\n            return false;\n        }\n        const allVarsMatch = tag.values.every((value, index) => {\n            const compareTo = this.values[index];\n            const isFunctions = value instanceof Function && compareTo instanceof Function;\n            if (isFunctions) {\n                const stringMatch = value.toString() === compareTo.toString();\n                if (stringMatch) {\n                    return true;\n                }\n                return false;\n            }\n            return true;\n        });\n        if (allVarsMatch) {\n            return true;\n        }\n        return false;\n    }\n    update() {\n        return this.updateContext(this.tagSupport.memory.context);\n    }\n    updateValues(values) {\n        this.values = values;\n        return this.updateContext(this.tagSupport.memory.context);\n    }\n    updateContext(context) {\n        const seenContext = [];\n        this.strings.map((_string, index) => {\n            const variableName = variablePrefix + index;\n            const hasValue = this.values.length > index;\n            const value = this.values[index];\n            // is something already there?\n            const existing = variableName in context;\n            seenContext.push(variableName);\n            if (existing) {\n                const existing = context[variableName];\n                return updateExistingValue(existing, value, this);\n            }\n            // 🆕 First time values below\n            processNewValue(hasValue, value, context, variableName, this);\n        });\n        // Support reduction in context\n        Object.entries(context).forEach(([key, subject]) => {\n            if (seenContext.includes(key)) {\n                return;\n            }\n            const destroyed = checkDestroyPrevious(subject, undefined);\n        });\n        return context;\n    }\n    getAppElement() {\n        let tag = this;\n        while (tag.ownerTag) {\n            tag = tag.ownerTag;\n        }\n        return tag;\n    }\n    /** Used during HMR only where static content itself could have been edited */\n    rebuild() {\n        // const insertBefore = this.insertBefore\n        const insertBefore = this.tagSupport.templater.insertBefore;\n        if (!insertBefore) {\n            const err = new Error('Cannot rebuild. Previous insertBefore element is not defined on tag');\n            err.tag = this;\n            throw err;\n        }\n        this.buildBeforeElement(insertBefore, {\n            forceElement: true,\n            counts: { added: 0, removed: 0 },\n        });\n    }\n    buildBeforeElement(insertBefore, options = {\n        forceElement: false,\n        counts: { added: 0, removed: 0 },\n    }) {\n        // this.insertBefore = insertBefore\n        this.tagSupport.templater.insertBefore = insertBefore;\n        const context = this.update();\n        const template = this.getTemplate();\n        const elementContainer = document.createElement('div');\n        elementContainer.id = 'tag-temp-holder';\n        // render content with a first child that we can know is our first element\n        elementContainer.innerHTML = `<template id=\"temp-template-tag-wrap\">${template.string}</template>`;\n        const { clones, tagComponents } = interpolateElement(elementContainer, context, template, this, // ownerTag,\n        {\n            forceElement: options.forceElement,\n            counts: options.counts\n        });\n        this.clones.length = 0;\n        afterInterpolateElement(elementContainer, insertBefore, this, clones, options, context);\n        this.clones.forEach(clone => afterElmBuild(clone, options, context, this));\n        // Any tag components that were found should be processed AFTER the owner processes its elements\n        let isForceElement = options.forceElement;\n        tagComponents.forEach(tagComponent => {\n            subscribeToTemplate(tagComponent.insertBefore, // temporary,\n            tagComponent.subject, tagComponent.ownerTag, clones, options.counts, { isForceElement });\n            afterInterpolateElement(elementContainer, insertBefore, this, clones, options, context);\n        });\n        // return this.clones\n        return clones;\n    }\n}\nfunction afterInterpolateElement(container, insertBefore, tag, intClones, options, context) {\n    const clones = buildClones(container, insertBefore);\n    tag.clones.push(...clones);\n    // remove component clones from ownerTag\n    if (intClones.length) {\n        tag.clones = tag.clones.filter(cloneFilter => !intClones.find(clone => clone === cloneFilter));\n    }\n}\n//# sourceMappingURL=Tag.class.js.map","import { ValueSubject } from \"./ValueSubject.js\";\nimport { bindSubjectCallback } from \"./bindSubjectCallback.function.js\";\nexport function getSubjectFunction(value, tag) {\n    return new ValueSubject(bindSubjectCallback(value, tag));\n}\nexport function setValueRedraw(templater, // latest tag function to call for rendering\nexisting, ownerTag) {\n    // redraw does not communicate to parent\n    templater.redraw = () => {\n        const existingTag = existing.tag;\n        const tagSupport = existingTag?.tagSupport || templater.tagSupport;\n        const { retag } = templater.renderWithSupport(tagSupport, existingTag, ownerTag);\n        existing.set(templater);\n        return retag;\n    };\n}\n//# sourceMappingURL=Tag.utils.js.map","import { deepClone } from \"./deepFunctions.js\";\nimport { isTagArray, isTagComponent, isTagInstance } from \"./isInstance.js\";\nimport { getStateValue } from \"./set.function.js\";\nimport { alterProps } from \"./templater.utils.js\";\nexport class TagSupport {\n    templater;\n    children;\n    propsConfig;\n    memory = {\n        context: {}, // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n        state: {\n            newest: [],\n        },\n        providers: [],\n        /** Indicator of re-rending. Saves from double rending something already rendered */\n        renderCount: 0,\n    };\n    updateState() {\n        this.memory.state.newest.forEach(newest => {\n            newest.lastValue = getStateValue(newest);\n        });\n    }\n    constructor(templater, children, // children tags passed in as arguments\n    props) {\n        this.templater = templater;\n        this.children = children;\n        const latestCloned = alterProps(props, templater);\n        this.propsConfig = {\n            latest: props,\n            latestCloned, // assume its HTML children and then detect\n            clonedProps: latestCloned, // maybe duplicate\n            lastClonedKidValues: children.value.map(kid => {\n                const cloneValues = cloneValueArray(kid.values);\n                return cloneValues;\n            })\n        };\n        // if the latest props are not HTML children, then clone the props for later render cycles to compare\n        if (!isTagInstance(props)) {\n            this.propsConfig.latestCloned = deepClone(latestCloned);\n            this.propsConfig.clonedProps = this.propsConfig.latestCloned;\n        }\n    }\n    // TODO: these below may not be in use\n    oldest;\n    newest;\n    mutatingRender() {\n        const message = 'Tag function \"render()\" was called in sync but can only be called async';\n        console.error(message, { tagSupport: this });\n        throw new Error(message);\n    } // loaded later and only callable async\n    render() {\n        ++this.memory.renderCount;\n        return this.mutatingRender();\n    } // ensure this function still works even during deconstructing\n}\nfunction cloneValueArray(values) {\n    return values.map((value) => {\n        const tag = value;\n        if (isTagInstance(tag)) {\n            return cloneValueArray(tag.values);\n        }\n        if (isTagComponent(tag)) {\n            const tagComponent = tag;\n            return deepClone(tagComponent.tagSupport.propsConfig.latestCloned);\n        }\n        if (isTagArray(tag)) {\n            return cloneValueArray(tag);\n        }\n        return deepClone(value);\n    });\n}\n//# sourceMappingURL=TagSupport.class.js.map","import { Subject } from './Subject.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const unsubscribe = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value);\n        return unsubscribe;\n    }\n}\n//# sourceMappingURL=ValueSubject.js.map","/** File largely responsible for reacting to element events, such as onclick */\nexport function bindSubjectCallback(value, tag) {\n    // Is this children? No override needed\n    if (value.isChildOverride) {\n        return value;\n    }\n    const subjectFunction = (element, args) => runTagCallback(value, tag, element, args);\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    return subjectFunction;\n}\nexport function runTagCallback(value, tag, bindTo, args) {\n    const tagSupport = tag.tagSupport;\n    const renderCount = tagSupport ? tagSupport.memory.renderCount : 0;\n    const method = value.bind(bindTo);\n    const callbackResult = method(...args);\n    const sameRenderCount = renderCount === tagSupport.memory.renderCount;\n    if (tagSupport && !sameRenderCount) {\n        return; // already rendered\n    }\n    tagSupport.render();\n    if (callbackResult instanceof Promise) {\n        return callbackResult.then(() => {\n            tagSupport.render();\n            return 'promise-no-data-ever';\n        });\n    }\n    // Caller always expects a Promise\n    return 'no-data-ever';\n}\n//# sourceMappingURL=bindSubjectCallback.function.js.map","import { isTagArray, isTagComponent, isTagInstance } from \"./isInstance.js\";\nimport { destroySimpleValue } from \"./processSubjectValue.function.js\";\nimport { isLikeTags } from \"./isLikeTags.function.js\";\nexport function checkDestroyPrevious(existing, // existing.value is the old value\nnewValue) {\n    const existingSubArray = existing;\n    const wasArray = existingSubArray.lastArray;\n    // no longer an array\n    if (wasArray && !isTagArray(newValue)) {\n        wasArray.forEach(({ tag }) => destroyArrayTag(tag, { added: 0, removed: 0 }));\n        delete existing.lastArray;\n        return 1;\n    }\n    const tagSubject = existing;\n    const existingTag = tagSubject.tag;\n    // no longer tag or component?\n    if (existingTag) {\n        const isValueTag = isTagInstance(newValue);\n        const isSubjectTag = isTagInstance(existing.value);\n        if (isSubjectTag && isValueTag) {\n            const newTag = newValue;\n            if (!isLikeTags(newTag, existingTag)) {\n                destroyTagMemory(existingTag, tagSubject);\n                return 2;\n            }\n            return false;\n        }\n        const isValueTagComponent = isTagComponent(newValue);\n        if (isValueTagComponent) {\n            return false; // its still a tag component\n        }\n        destroyTagMemory(existingTag, tagSubject);\n        return 3;\n    }\n    const displaySubject = existing;\n    const hasLastValue = 'lastValue' in displaySubject;\n    const lastValue = displaySubject.lastValue; // TODO: we maybe able to use displaySubject.value and remove concept of lastValue\n    // was simple value but now something bigger\n    if (hasLastValue && lastValue !== newValue) {\n        destroySimpleValue(displaySubject.template, displaySubject);\n        return 4;\n    }\n    return false;\n}\nexport function destroyTagMemory(existingTag, existingSubject) {\n    delete existingSubject.tag;\n    delete existingSubject.tagSupport;\n    existingTag.destroy();\n}\nexport function destroyArrayTag(tag, counts) {\n    tag.children.forEach(child => child.destroy({\n        stagger: counts.removed++,\n        // byParent: false\n        // byParent: true,\n    }));\n    tag.destroy({\n        stagger: counts.removed,\n        // byParent: false\n        // byParent: true,\n    });\n}\n//# sourceMappingURL=checkDestroyPrevious.function.js.map","export function deepClone(obj) {\n    return makeDeepClone(obj, new WeakMap());\n}\nfunction makeDeepClone(obj, visited) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj)) {\n        return visited.get(obj);\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Register the cloned object to avoid cyclic references\n    visited.set(obj, clone);\n    // Clone each property or element of the object or array\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], visited);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clone[key] = makeDeepClone(obj[key], visited);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2) {\n    return isDeepEqual(obj1, obj2, new WeakMap());\n}\nfunction isDeepEqual(obj1, obj2, visited) {\n    if (obj1 === obj2 || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    if (typeof obj1 !== 'object' ||\n        typeof obj2 !== 'object' ||\n        obj1 === null ||\n        obj2 === null) {\n        return false;\n    }\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj1)) {\n        return true;\n    }\n    // Register the cloned object to avoid cyclic references\n    visited.set(obj1, 0);\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], visited)) {\n            /*\n            if(isSameFunctions(obj1[key], obj2[key])) {\n              continue\n            }\n            */\n            return false;\n        }\n    }\n    // Check if obj1 and obj2 are both arrays\n    if (Array.isArray(obj1) && Array.isArray(obj2)) {\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (let i = 0; i < obj1.length; i++) {\n            if (!isDeepEqual(obj1[i], obj2[i], visited)) {\n                return false;\n            }\n        }\n    }\n    else if (Array.isArray(obj1) || Array.isArray(obj2)) {\n        // One is an array, and the other is not\n        return false;\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = fn0 instanceof Function && fn1 instanceof Function;\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n//# sourceMappingURL=deepFunctions.js.map","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    if (!onDestroyDoubleWrap) {\n        return;\n    }\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    if (!onDestroy) {\n        return;\n    }\n    const event = { target: nextSibling, stagger };\n    return onDestroy(event);\n}\n//# sourceMappingURL=elementDestroyCheck.function.js.map","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n//# sourceMappingURL=elementInitCheck.js.map","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\n//# sourceMappingURL=errors.js.map","import { deepEqual } from \"./deepFunctions.js\";\nexport function hasTagSupportChanged(oldTagSupport, newTagSupport) {\n    if (oldTagSupport === newTagSupport) {\n        throw new Error('something here');\n    }\n    const oldProps = oldTagSupport.propsConfig.latest;\n    const latestProps = newTagSupport.propsConfig.latest;\n    const oldClonedProps = oldTagSupport.propsConfig.latestCloned;\n    const propsChanged = hasPropChanges(latestProps, oldClonedProps, oldProps);\n    // if no changes detected, no need to continue to rendering further tags\n    if (propsChanged) {\n        return true;\n    }\n    const kidsChanged = hasKidsChanged(oldTagSupport, newTagSupport);\n    // we already know props didn't change and if kids didn't either, than don't render\n    return kidsChanged;\n}\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\ncompareToProps) {\n    const isCommonEqual = props === undefined && props === compareToProps;\n    if (isCommonEqual) {\n        return false;\n    }\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    // check all prop functions match\n    if (typeof (props) === 'object') {\n        if (!pastCloneProps) {\n            return true;\n        }\n        castedProps = { ...props };\n        castedPastProps = { ...(pastCloneProps || {}) };\n        const allFunctionsMatch = Object.entries(castedProps).every(([key, value]) => {\n            /*if(!(key in (castedPastProps as any))) {\n              return false\n            }*/\n            let compare = castedPastProps[key];\n            if (!(value instanceof Function)) {\n                return true; // this will be checked in deepEqual\n            }\n            if (!(compare instanceof Function)) {\n                return false; // its a function now but was not before\n            }\n            // ensure we are comparing apples to apples as function get wrapped\n            if (compare.original) {\n                compare = compare.original;\n            }\n            const original = value.original;\n            if (original) {\n                value = value.original;\n            }\n            if (value.toString() !== compare.toString()) {\n                return false; // both are function but not the same\n            }\n            delete castedProps[key]; // its a function and not needed to be compared\n            delete castedPastProps[key]; // its a function and not needed to be compared\n            return true;\n        });\n        if (!allFunctionsMatch) {\n            return true; // a change has been detected by function comparisons\n        }\n    }\n    const isEqual = deepEqual(pastCloneProps, props);\n    return !isEqual; // if equal then no changes\n}\nexport function hasKidsChanged(oldTagSupport, newTagSupport) {\n    const oldCloneKidValues = oldTagSupport.propsConfig.lastClonedKidValues;\n    const newClonedKidValues = newTagSupport.propsConfig.lastClonedKidValues;\n    const everySame = oldCloneKidValues.every((set, index) => {\n        const x = newClonedKidValues[index];\n        return set.every((item, index) => item === x[index]);\n    });\n    return !everySame;\n}\n//# sourceMappingURL=hasTagSupportChanged.function.js.map","export function inputAttribute(name, value, element) {\n    const names = name.split('.');\n    // style.position = \"absolute\"\n    if (names[0] === 'style') {\n        element.style[names[1]] = value;\n    }\n    // Example: class.width-full = \"true\"\n    if (names[0] === 'class') {\n        names.shift();\n        if (value) {\n            names.forEach(name => element.classList.add(name));\n        }\n        else {\n            names.forEach(name => element.classList.remove(name));\n        }\n        return;\n    }\n}\n//# sourceMappingURL=inputAttribute.js.map","import { processAttribute } from \"./processAttribute.function.js\";\nfunction howToSetAttribute(element, name, value) {\n    /*\n    if(name === 'class'){\n      value.split(' ').forEach(className => child.classList.add(className))\n      return\n    }\n    */\n    element.setAttribute(name, value);\n}\nfunction howToSetInputValue(element, name, value) {\n    element[name] = value;\n}\nexport function interpolateAttributes(child, scope, ownerTag) {\n    const attrNames = child.getAttributeNames();\n    let howToSet = howToSetAttribute;\n    attrNames.forEach(attrName => {\n        if (child.nodeName === 'INPUT' && attrName === 'value') {\n            howToSet = howToSetInputValue;\n        }\n        const value = child.getAttribute(attrName);\n        processAttribute(attrName, value, child, scope, ownerTag, howToSet);\n        howToSet = howToSetAttribute; // put back\n    });\n}\n//# sourceMappingURL=interpolateAttributes.js.map","import { interpolateTemplate } from \"./interpolateTemplate.js\";\nexport function interpolateContentTemplates(element, context, tag, options, children) {\n    if (!children || element.tagName === 'TEMPLATE') {\n        return { clones: [], tagComponents: [] }; // done\n    }\n    // counting for animation stagger computing\n    const counts = options.counts;\n    const clones = [];\n    const tagComponents = [];\n    const childArray = new Array(...children);\n    childArray.forEach(child => {\n        const { clones: nextClones, tagComponent } = interpolateTemplate(child, context, tag, counts, options);\n        clones.push(...nextClones);\n        if (tagComponent) {\n            tagComponents.push(tagComponent);\n            return;\n        }\n        if (child.children) {\n            const nextKids = new Array(...child.children);\n            nextKids.forEach((subChild, index) => {\n                // IF <template end /> its a variable to be processed\n                if (isRenderEndTemplate(subChild)) {\n                    const { tagComponent } = interpolateTemplate(subChild, context, tag, counts, options);\n                    if (tagComponent) {\n                        tagComponents.push(tagComponent);\n                    }\n                }\n                const { clones: nextClones, tagComponents: nextTagComponent } = interpolateContentTemplates(subChild, context, tag, options, subChild.children);\n                clones.push(...nextClones);\n                tagComponents.push(...nextTagComponent);\n            });\n        }\n    });\n    return { clones, tagComponents };\n}\nfunction isRenderEndTemplate(child) {\n    const isTemplate = child.tagName === 'TEMPLATE';\n    return isTemplate &&\n        child.getAttribute('interpolate') !== undefined &&\n        child.getAttribute('end') !== undefined;\n}\n//# sourceMappingURL=interpolateContentTemplates.js.map","import { interpolateAttributes } from \"./interpolateAttributes.js\";\nimport { interpolateToTemplates } from \"./interpolations.js\";\nimport { interpolateContentTemplates } from \"./interpolateContentTemplates.js\";\nimport { escapeSearch, variablePrefix } from \"./Tag.class.js\";\n/** Review elements within an element */\nexport function interpolateElement(container, context, // variables used to evaluate\ninterpolatedTemplates, tagOwner, options) {\n    const clones = [];\n    const tagComponents = [];\n    const result = interpolatedTemplates.interpolation;\n    const template = container.children[0];\n    const children = template.content.children;\n    if (result.keys.length) {\n        const { clones: nextClones, tagComponents: nextTagComponents } = interpolateContentTemplates(container, context, tagOwner, options, children);\n        clones.push(...nextClones);\n        tagComponents.push(...nextTagComponents);\n    }\n    interpolateAttributes(container, context, tagOwner);\n    processChildrenAttributes(children, context, tagOwner);\n    return { clones, tagComponents };\n}\nfunction processChildrenAttributes(children, context, ownerTag) {\n    new Array(...children).forEach(child => {\n        interpolateAttributes(child, context, ownerTag);\n        if (child.children) {\n            processChildrenAttributes(child.children, context, ownerTag);\n        }\n    });\n}\nexport function interpolateString(string) {\n    const result = interpolateToTemplates(string);\n    result.string = result.string.replace(escapeSearch, variablePrefix);\n    return result;\n}\n//# sourceMappingURL=interpolateElement.js.map","import { variablePrefix } from \"./Tag.class.js\";\nimport { elementInitCheck } from \"./elementInitCheck.js\";\nimport { processSubjectValue } from \"./processSubjectValue.function.js\";\nimport { isTagComponent } from \"./isInstance.js\";\nimport { scanTextAreaValue } from \"./scanTextAreaValue.function.js\";\nexport function interpolateTemplate(insertBefore, // <template end interpolate /> (will be removed)\ncontext, // variable scope of {`__tagvar${index}`:'x'}\nownerTag, // Tag class\ncounts, // used for animation stagger computing\noptions) {\n    const clones = [];\n    if (!insertBefore.hasAttribute('end')) {\n        return { clones }; // only care about <template end>\n    }\n    const variableName = insertBefore.getAttribute('id');\n    if (variableName?.substring(0, variablePrefix.length) !== variablePrefix) {\n        return { clones }; // ignore, not a tagVar\n    }\n    const existingSubject = context[variableName];\n    if (isTagComponent(existingSubject.value)) {\n        return { clones, tagComponent: { ownerTag, subject: existingSubject, insertBefore } };\n    }\n    let isForceElement = options.forceElement;\n    subscribeToTemplate(insertBefore, existingSubject, ownerTag, clones, counts, { isForceElement });\n    return { clones };\n}\nexport function subscribeToTemplate(insertBefore, subject, ownerTag, clones, counts, // used for animation stagger computing\n{ isForceElement }) {\n    const callback = (value) => {\n        const clone = subject.clone;\n        if (clone) {\n            insertBefore = clone;\n        }\n        const nextClones = processSubjectValue(value, subject, insertBefore, ownerTag, {\n            counts: { ...counts },\n            forceElement: isForceElement,\n        });\n        if (isForceElement) {\n            isForceElement = false; // only can happen once\n        }\n        clones.push(...nextClones);\n    };\n    const sub = subject.subscribe(callback);\n    ownerTag.cloneSubs.push(sub);\n    return clones;\n}\n// Function to update the value of x\nexport function updateBetweenTemplates(value, lastFirstChild) {\n    const parent = lastFirstChild.parentNode;\n    // mimic React skipping to display EXCEPT for true does display on page\n    if (value === undefined || value === false || value === null) { // || value === true\n        value = '';\n    }\n    // Insert the new value (never use innerHTML here)\n    const textNode = document.createTextNode(value); // never innerHTML\n    parent.insertBefore(textNode, lastFirstChild);\n    /* remove existing nodes */\n    parent.removeChild(lastFirstChild);\n    return textNode;\n}\nexport function afterElmBuild(elm, options, context, ownerTag) {\n    if (!elm.getAttribute) {\n        return;\n    }\n    const tagName = elm.nodeName; // elm.tagName\n    if (tagName === 'TEXTAREA') {\n        scanTextAreaValue(elm, context, ownerTag);\n    }\n    let diff = options.counts.added;\n    if (!options.forceElement) {\n        diff = elementInitCheck(elm, options.counts) - diff;\n    }\n    if (elm.children) {\n        const subCounts = {\n            added: options.counts.added, // - diff,\n            removed: options.counts.removed,\n        };\n        new Array(...elm.children).forEach((child, index) => {\n            const subOptions = {\n                ...options,\n                counts: options.counts,\n            };\n            return afterElmBuild(child, subOptions, context, ownerTag);\n        });\n    }\n}\n//# sourceMappingURL=interpolateTemplate.js.map","// support arrow functions in attributes\nexport const interpolateReplace = /(?:<[^>]*?(?:(?:\\s+\\w+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)))*\\s*)\\/?>)|({__tagvar[^}]+})/g;\n/** replaces ${x} with <template id=\"x-start\"></template><template id=\"x-end\"></template> */\nexport function interpolateToTemplates(template) {\n    const keys = [];\n    const string = template.replace(interpolateReplace, (match, expression) => {\n        if (match.startsWith('<')) {\n            // If the match is an HTML tag, don't replace\n            return match;\n        }\n        const noBraces = expression.substring(1, expression.length - 1);\n        const id = noBraces;\n        keys.push(id);\n        return `<template interpolate end id=\"${id}\"></template>`;\n    });\n    return { string, keys };\n}\n//# sourceMappingURL=interpolations.js.map","export function isTagComponent(value) {\n    return value?.isTemplater === true;\n}\nexport function isTagInstance(tag) {\n    return tag?.isTag === true;\n}\nexport function isSubjectInstance(subject) {\n    return (subject?.isSubject === true || subject?.subscribe) ? true : false; // subject?.isSubject === true || \n}\nexport function isTagArray(value) {\n    return value instanceof Array && value.every(x => isTagInstance(x));\n}\n//# sourceMappingURL=isInstance.js.map","export function isLikeTags(tag0, tag1) {\n    if (tag0.strings.length !== tag1.strings.length) {\n        return false;\n    }\n    const everyStringMatched = tag0.strings.every((string, index) => tag1.strings[index] === string);\n    if (!everyStringMatched) {\n        return false;\n    }\n    const valuesLengthsMatch = tag0.values.length === tag1.values.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=isLikeTags.function.js.map","import { inputAttribute } from \"./inputAttribute.js\";\nimport { isSubjectInstance } from \"./isInstance.js\";\nconst startRegX = /^\\s*{__tagvar/;\nconst endRegX = /}\\s*$/;\nfunction isTagVar(value) {\n    return value && value.search(startRegX) >= 0 && value.search(endRegX) >= 0;\n}\nexport function processAttribute(attrName, value, child, scope, ownerTag, howToSet) {\n    if (isTagVar(value)) {\n        return processScopedNameValueAttr(attrName, value, child, scope, ownerTag, howToSet);\n    }\n    if (isTagVar(attrName)) {\n        const contextValueSubject = getContextValueByVarString(scope, attrName);\n        let lastValue;\n        // the above callback gets called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe((value) => {\n            processNameOnlyAttr(value, lastValue, child, ownerTag, howToSet);\n            lastValue = value;\n        });\n        ownerTag.cloneSubs.push(sub); // this is where unsubscribe is picked up\n        child.removeAttribute(attrName);\n        return;\n    }\n    // Non dynamic\n    const isSpecial = isSpecialAttr(attrName);\n    if (isSpecial) {\n        return inputAttribute(attrName, value, child);\n    }\n}\nfunction processScopedNameValueAttr(attrName, value, // {__tagVarN}\nchild, scope, ownerTag, howToSet) {\n    // get the code inside the brackets like \"variable0\" or \"{variable0}\"\n    const result = getContextValueByVarString(scope, value);\n    return processNameValueAttr(attrName, result, child, ownerTag, howToSet);\n}\nfunction getContextValueByVarString(scope, value) {\n    const code = value.replace('{', '').split('').reverse().join('').replace('}', '').split('').reverse().join('');\n    return scope[code];\n}\nfunction processNameOnlyAttr(attrValue, lastValue, child, ownerTag, howToSet) {\n    if (lastValue && lastValue != attrValue) {\n        if (typeof (lastValue) === 'string') {\n            child.removeAttribute(lastValue);\n        }\n        else if (lastValue instanceof Object) {\n            Object.entries(lastValue).forEach(([name]) => child.removeAttribute(name));\n        }\n    }\n    if (typeof (attrValue) === 'string') {\n        if (!attrValue.length) {\n            return;\n        }\n        processNameValueAttr(attrValue, '', child, ownerTag, howToSet);\n        return;\n    }\n    if (attrValue instanceof Object) {\n        Object.entries(attrValue).forEach(([name, value]) => processNameValueAttr(name, value, child, ownerTag, howToSet));\n        return;\n    }\n}\nfunction processNameValueAttr(attrName, result, child, ownerTag, howToSet) {\n    const isSpecial = isSpecialAttr(attrName);\n    // attach as callback?\n    if (result instanceof Function) {\n        const action = function (...args) {\n            return result(child, args);\n        };\n        child[attrName].action = action;\n        // child.addEventListener(attrName, action)\n    }\n    // Most every variable comes in here since everything is made a ValueSubject\n    if (isSubjectInstance(result)) {\n        child.removeAttribute(attrName);\n        const callback = (newAttrValue) => {\n            return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = result.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        ownerTag.cloneSubs.push(sub);\n        return;\n    }\n    howToSet(child, attrName, result);\n    // child.setAttribute(attrName, result.value)\n    return;\n}\nfunction processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet) {\n    if (newAttrValue instanceof Function) {\n        ;\n        child[attrName] = function (...args) {\n            const result = newAttrValue(child, args);\n            return result;\n        };\n        child[attrName].tagFunction = newAttrValue;\n        return;\n    }\n    if (isSpecial) {\n        inputAttribute(attrName, newAttrValue, child);\n        return;\n    }\n    if (newAttrValue) {\n        howToSet(child, attrName, newAttrValue);\n        return;\n    }\n    const isDeadValue = newAttrValue === undefined || newAttrValue === false || newAttrValue === null;\n    if (isDeadValue) {\n        child.removeAttribute(attrName);\n        return;\n    }\n    // value is 0\n    howToSet(child, attrName, newAttrValue);\n}\n/** Looking for (class | style) followed by a period */\nfunction isSpecialAttr(attrName) {\n    return attrName.search(/^(class|style)(\\.)/) >= 0;\n}\n//# sourceMappingURL=processAttribute.function.js.map","import { getSubjectFunction, setValueRedraw } from \"./Tag.utils.js\";\nimport { ValueSubject } from \"./ValueSubject.js\";\nimport { isSubjectInstance, isTagComponent, isTagInstance } from \"./isInstance.js\";\nexport function processNewValue(hasValue, value, context, variableName, ownerTag) {\n    if (isTagComponent(value)) {\n        const existing = context[variableName] = new ValueSubject(value);\n        setValueRedraw(value, existing, ownerTag);\n        return;\n    }\n    if (value instanceof Function) {\n        context[variableName] = getSubjectFunction(value, ownerTag);\n        return;\n    }\n    if (!hasValue) {\n        return; // more strings than values, stop here\n    }\n    if (isTagInstance(value)) {\n        value.ownerTag = ownerTag;\n        ownerTag.children.push(value);\n        context[variableName] = new ValueSubject(value);\n        return;\n    }\n    if (isSubjectInstance(value)) {\n        context[variableName] = value; // its already a value subject\n        return;\n    }\n    context[variableName] = new ValueSubject(value);\n}\n//# sourceMappingURL=processNewValue.function.js.map","import { updateBetweenTemplates } from \"./interpolateTemplate.js\";\nexport function processRegularValue(value, result, // could be tag via result.tag\ntemplate) {\n    result.template = template;\n    const before = result.clone || template; // Either the template is on the doc OR its the first element we last put on doc\n    result.lastValue = value;\n    // Processing of regular values\n    const clone = updateBetweenTemplates(value, before);\n    result.clone = clone; // remember single element put down, for future updates\n    return [];\n}\n//# sourceMappingURL=processRegularValue.function.js.map","import { runBeforeRedraw, runBeforeRender } from \"./tagRunner.js\";\nimport { setUse } from \"./setUse.function.js\";\nimport { processTagResult } from \"./processTagResult.function.js\";\nexport function processSubjectComponent(value, subject, template, ownerTag, options) {\n    // Check if function component is wrapped in a tag() call\n    // TODO: This below check not needed in production mode\n    if (value.tagged !== true) {\n        let name = value.wrapper.original.name || value.wrapper.original.constructor?.name;\n        if (name === 'Function') {\n            name = undefined;\n        }\n        const label = name || value.wrapper.original.toString().substring(0, 120);\n        const error = new Error(`Not a tag component. Wrap your function with tag(). Example tag(props => html\\`\\`) on component:\\n\\n${label}\\n\\n`);\n        throw error;\n    }\n    const templater = value;\n    templater.insertBefore = template;\n    const tagSupport = value.tagSupport;\n    let retag = templater.newest;\n    const providers = setUse.memory.providerConfig;\n    providers.ownerTag = ownerTag;\n    const isFirstTime = !retag || options.forceElement;\n    if (isFirstTime) {\n        if (retag) {\n            // runBeforeRedraw(tagSupport, retag)\n            runBeforeRedraw(tagSupport, templater.oldest);\n        }\n        else {\n            runBeforeRender(tagSupport, ownerTag);\n        }\n        const result = templater.renderWithSupport(tagSupport, subject.tag, ownerTag);\n        retag = result.retag;\n        templater.newest = retag;\n    }\n    ownerTag.children.push(retag);\n    tagSupport.templater = retag.tagSupport.templater;\n    const clones = processTagResult(retag, subject, // The element set here will be removed from document. Also result.tag will be added in here\n    template, // <template end interpolate /> (will be removed)\n    options);\n    return clones;\n}\n//# sourceMappingURL=processSubjectComponent.function.js.map","import { processSubjectComponent } from \"./processSubjectComponent.function.js\";\nimport { processTagResult } from \"./processTagResult.function.js\";\nimport { isTagArray, isTagComponent, isTagInstance } from \"./isInstance.js\";\nimport { processTagArray } from \"./processTagArray.js\";\nimport { TagSupport } from \"./TagSupport.class.js\";\nimport { ValueSubject } from \"./ValueSubject.js\";\nimport { processRegularValue } from \"./processRegularValue.function.js\";\nvar ValueTypes;\n(function (ValueTypes) {\n    ValueTypes[\"tag\"] = \"tag\";\n    ValueTypes[\"tagArray\"] = \"tag-array\";\n    ValueTypes[\"tagComponent\"] = \"tag-component\";\n    ValueTypes[\"value\"] = \"value\";\n})(ValueTypes || (ValueTypes = {}));\nfunction getValueType(value) {\n    if (isTagComponent(value)) {\n        return ValueTypes.tagComponent;\n    }\n    if (isTagInstance(value)) {\n        return ValueTypes.tag;\n    }\n    if (isTagArray(value)) {\n        return ValueTypes.tagArray;\n    }\n    return ValueTypes.value;\n}\nexport function processSubjectValue(value, result, // could be tag via result.tag\ntemplate, // <template end interpolate /> (will be removed)\nownerTag, // owner\noptions) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.tag:\n            return processTag(value, result, template, ownerTag, options);\n        case ValueTypes.tagArray:\n            const clones = processTagArray(result, value, template, ownerTag, options);\n            return clones;\n        case ValueTypes.tagComponent:\n            return processSubjectComponent(value, result, template, ownerTag, options);\n    }\n    return processRegularValue(value, result, template);\n}\nexport function processTag(value, result, // could be tag via result.tag\ntemplate, // <template end interpolate /> (will be removed)\nownerTag, // owner\noptions) {\n    // first time seeing this tag?\n    if (!value.tagSupport) {\n        value.tagSupport = new TagSupport({}, // the template is provided via html`` call\n        new ValueSubject([]));\n        // asking me to render will cause my parent to render\n        value.tagSupport.mutatingRender = () => {\n            ownerTag.tagSupport.render();\n        };\n        value.tagSupport.oldest = value.tagSupport.oldest || value;\n        ownerTag.children.push(value);\n        value.ownerTag = ownerTag;\n    }\n    result.template = template;\n    const clones = processTagResult(value, result, // Function will attach result.tag\n    template, options);\n    return clones;\n}\nexport function destroySimpleValue(template, subject) {\n    const clone = subject.clone;\n    const parent = clone.parentNode;\n    // put the template back down\n    parent.insertBefore(template, clone);\n    parent.removeChild(clone);\n    delete subject.clone;\n    delete subject.lastValue;\n}\n//# sourceMappingURL=processSubjectValue.function.js.map","import { ValueSubject } from \"./ValueSubject.js\";\nimport { TagSupport } from \"./TagSupport.class.js\";\nimport { ArrayNoKeyError } from \"./errors.js\";\nimport { destroyArrayTag } from \"./checkDestroyPrevious.function.js\";\nexport function processTagArray(result, value, // arry of Tag classes\ntemplate, // <template end interpolate />\nownerTag, options) {\n    // const clones: Clones = []\n    const clones = ownerTag.clones; // []\n    result.lastArray = result.lastArray || []; // {tag, index}[] populated in processTagResult\n    result.template = template;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    result.lastArray = result.lastArray.filter((item, index) => {\n        const newLength = value.length - 1;\n        const at = index - removed;\n        const lessLength = newLength < at;\n        const subTag = value[index - removed];\n        const subArrayValue = subTag?.arrayValue;\n        const destroyItem = lessLength || !areLikeValues(subArrayValue, item.tag.arrayValue);\n        if (destroyItem) {\n            const last = result.lastArray[index];\n            const tag = last.tag;\n            destroyArrayTag(tag, options.counts);\n            ++removed;\n            // ++options.counts.removed\n            return false;\n        }\n        return true;\n    });\n    // const masterBefore = template || (template as any).clone\n    const before = template || template.clone;\n    value.forEach((subTag, index) => {\n        const previous = result.lastArray[index];\n        const previousSupport = subTag.tagSupport || previous?.tag.tagSupport;\n        subTag.tagSupport = previousSupport || new TagSupport({}, new ValueSubject([]));\n        if (previousSupport) {\n            previousSupport.newest = subTag;\n        }\n        else {\n            subTag.tagSupport.mutatingRender = () => {\n                ownerTag.tagSupport.render(); // call owner for needed updates\n                return subTag;\n            };\n            ownerTag.children.push(subTag);\n        }\n        subTag.ownerTag = ownerTag;\n        // check for html``.key()\n        const keyNotSet = subTag.arrayValue;\n        if (keyNotSet?.isArrayValueNeverSet) {\n            const details = {\n                template: subTag.getTemplate().string,\n                array: value,\n                ownerTagContent: ownerTag.lastTemplateString,\n            };\n            const message = 'Use html`...`.key(item) instead of html`...` to template an Array';\n            console.error(message, details);\n            const err = new ArrayNoKeyError(message, details);\n            throw err;\n        }\n        const couldBeSame = result.lastArray.length > index;\n        if (couldBeSame) {\n            const isSame = areLikeValues(previous.tag.arrayValue, subTag.arrayValue);\n            if (isSame) {\n                subTag.tagSupport = subTag.tagSupport || previous.tag.tagSupport;\n                previous.tag.updateByTag(subTag);\n                return [];\n            }\n            return [];\n        }\n        const nextClones = processAddTagArrayItem(before, subTag, result, index, options);\n        clones.push(...nextClones);\n    });\n    return clones;\n}\nfunction processAddTagArrayItem(before, subTag, result, index, options) {\n    const lastValue = {\n        tag: subTag, index\n    };\n    // Added to previous array\n    result.lastArray.push(lastValue);\n    const counts = {\n        added: options.counts.added + index,\n        removed: options.counts.removed,\n    };\n    const lastFirstChild = before; // tag.clones[0] // insertBefore.lastFirstChild    \n    const nextClones = subTag.buildBeforeElement(lastFirstChild, { counts, forceElement: options.forceElement });\n    // subTag.clones.push(...nextClones)\n    // ;(lastValue as any).clones = nextClones\n    return nextClones;\n}\n/** compare two values. If both values are arrays then the items will be compared */\nfunction areLikeValues(valueA, valueB) {\n    if (valueA === valueB) {\n        return true;\n    }\n    const bothArrays = valueA instanceof Array && valueB instanceof Array;\n    const matchLengths = bothArrays && valueA.length == valueB.length;\n    if (matchLengths) {\n        return valueA.every((item, index) => item == valueB[index]);\n    }\n    return false;\n}\n//# sourceMappingURL=processTagArray.js.map","export function processTagResult(tag, result, // used for recording past and current value\ninsertBefore, // <template end interpolate />\n{ counts, forceElement, }) {\n    // *if appears we already have seen\n    const subjectTag = result;\n    const rTag = subjectTag.tag;\n    if (rTag && !forceElement) {\n        // are we just updating an if we already had?\n        if (rTag.isLikeTag(tag)) {\n            // components\n            if (result instanceof Function) {\n                const newTag = result(rTag.tagSupport);\n                rTag.updateByTag(newTag);\n                return [];\n            }\n            rTag.updateByTag(tag);\n            return []; // no clones created in element already on stage\n        }\n    }\n    const clones = tag.buildBeforeElement(insertBefore, {\n        counts,\n        forceElement,\n    });\n    subjectTag.tag = subjectTag.tag || tag; // let reprocessing know we saw this previously as an if\n    return clones;\n}\n//# sourceMappingURL=processTagResult.function.js.map","export function buildClones(temporary, insertBefore) {\n    const clones = [];\n    const template = temporary.children[0];\n    let nextSibling = template.content.firstChild;\n    while (nextSibling) {\n        const nextNextSibling = nextSibling.nextSibling;\n        buildSibling(nextSibling, insertBefore);\n        clones.push(nextSibling);\n        nextSibling = nextNextSibling;\n    }\n    return clones;\n}\nfunction buildSibling(nextSibling, insertBefore) {\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(nextSibling, insertBefore);\n}\n//# sourceMappingURL=render.js.map","import { processAttribute } from \"./processAttribute.function.js\";\nconst search = new RegExp('\\\\s*<template interpolate end id=\"__tagvar(\\\\d{1,4})\"([^>]*)></template>(\\\\s*)');\nexport function scanTextAreaValue(textarea, context, ownerTag) {\n    const value = textarea.value;\n    if (value.search(search) >= 0) {\n        const match = value.match(/__tagvar(\\d{1,4})/);\n        const token = match ? match[0] : '';\n        const dynamic = '{' + token + '}';\n        textarea.value = '';\n        textarea.setAttribute('text-var-value', dynamic);\n        const howToSet = (_elm, _name, value) => textarea.value = value;\n        processAttribute('text-var-value', dynamic, // realValue, // context[token].value,\n        textarea, context, ownerTag, howToSet);\n    }\n}\n//# sourceMappingURL=scanTextAreaValue.function.js.map","import { StateMismatchError } from \"./errors.js\";\nimport { setUse } from \"./setUse.function.js\";\n// TODO: rename\nsetUse.memory.stateConfig = {\n    array: [], // state memory on the first render\n    rearray: [], // state memory to be used before the next render\n};\nexport function makeStateResult(initValue, push) {\n    // return initValue\n    const result = (y) => {\n        push.callback = y || (x => [initValue, initValue = x]);\n        return initValue;\n    };\n    return result;\n}\n/*\nconst waitingStates: (() => unknown)[] = []\nexport function onNextStateOnly(callback: () => unknown) {\n  const config: Config = setUse.memory.stateConfig\n  \n  if(!config.rearray.length) {\n    callback()\n    return\n  }\n\n  waitingStates.push(callback)\n}\n*/\nsetUse({\n    beforeRender: (tagSupport) => initState(tagSupport),\n    beforeRedraw: (tagSupport) => initState(tagSupport),\n    afterRender: (tagSupport) => {\n        const state = tagSupport.memory.state;\n        const config = setUse.memory.stateConfig;\n        if (config.rearray.length) {\n            if (config.rearray.length !== config.array.length) {\n                const message = `States lengths mismatched ${config.rearray.length} !== ${config.array.length}`;\n                const error = new StateMismatchError(message, {\n                    oldStates: config.array,\n                    newStates: config.rearray,\n                    component: tagSupport.templater?.wrapper.original\n                });\n                throw error;\n            }\n        }\n        config.rearray = []; // clean up any previous runs\n        state.newest = [...config.array];\n        // config.array.length = 0\n        config.array = [];\n        // waitingStates.forEach(callback => callback())\n        // waitingStates.length = 0\n    }\n});\nexport function getStateValue(\n// state: StateConfig,\nstate) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [oldValue] = oldState;\n    const [checkValue] = callback(oldValue); // set back to original value\n    if (checkValue !== StateEchoBack) {\n        const message = 'State property not used correctly. Second item in array is not setting value as expected.\\n\\n' +\n            'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n            'For \"const\" state use `const name = state(default)()`\\n\\n' +\n            'Problem state:\\n' + (callback ? callback.toString() : JSON.stringify(state)) + '\\n';\n        console.error(message, { state, callback, oldState, oldValue, checkValue });\n        throw new Error(message);\n    }\n    return oldValue;\n}\nexport class StateEchoBack {\n}\nfunction initState(tagSupport) {\n    const state = tagSupport.memory.state;\n    const config = setUse.memory.stateConfig;\n    // TODO: This guard may no longer be needed\n    if (config.rearray.length) {\n        const message = 'last array not cleared';\n        console.error(message, {\n            config,\n            component: tagSupport.templater?.wrapper.original,\n            state,\n            expectedClearArray: config.rearray,\n        });\n        throw new StateMismatchError(message, {\n            config,\n            component: tagSupport.templater?.wrapper.original,\n            state,\n            expectedClearArray: config.rearray,\n        });\n    }\n    // TODO: this maybe redundant and not needed\n    config.rearray = []; // .length = 0\n    if (state?.newest.length) {\n        config.rearray.push(...state.newest);\n    }\n}\n/** Used for variables that need to remain the same variable during render passes */\nexport function set(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    let getSetMethod;\n    const restate = config.rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return oldValue;\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n//# sourceMappingURL=set.function.js.map","const tagUse = [];\nexport function setUse(use) {\n    // must provide defaults\n    const useMe = {\n        beforeRender: use.beforeRender || (() => undefined),\n        beforeRedraw: use.beforeRedraw || (() => undefined),\n        afterRender: use.afterRender || (() => undefined),\n        beforeDestroy: use.beforeDestroy || (() => undefined),\n    };\n    setUse.tagUse.push(useMe);\n}\nsetUse.tagUse = tagUse;\nsetUse.memory = {};\n//# sourceMappingURL=setUse.function.js.map","// TODO: This should be more like `new TaggedJs().use({})`\nimport { setUse } from \"./setUse.function.js\";\n// Life cycle 1\nexport function runBeforeRender(tagSupport, tagOwner) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeRender(tagSupport, tagOwner));\n}\n// Life cycle 2\nexport function runAfterRender(tagSupport, tag) {\n    setUse.tagUse.forEach(tagUse => tagUse.afterRender(tagSupport, tag));\n}\n// Life cycle 3\nexport function runBeforeRedraw(tagSupport, tag) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeRedraw(tagSupport, tag));\n}\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(tagSupport, tag) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeDestroy(tagSupport, tag));\n}\n//# sourceMappingURL=tagRunner.js.map","import { TagSupport } from \"./TagSupport.class.js\";\nimport { isTagInstance } from \"./isInstance.js\";\nimport { runAfterRender, runBeforeRedraw, runBeforeRender } from \"./tagRunner.js\";\nimport { setUse } from \"./setUse.function.js\";\nexport class TemplaterResult {\n    tagged;\n    wrapper;\n    insertBefore;\n    newest;\n    oldest;\n    tagSupport;\n    constructor(props, children) {\n        this.tagSupport = new TagSupport(this, children, props);\n    }\n    redraw;\n    isTemplater = true;\n    renderWithSupport(tagSupport, existingTag, ownerTag) {\n        /* BEFORE RENDER */\n        // signify to other operations that a rendering has occurred so they do not need to render again\n        ++tagSupport.memory.renderCount;\n        const runtimeOwnerTag = existingTag?.ownerTag || ownerTag;\n        // const insertBefore = tagSupport.templater.insertBefore\n        if (existingTag) {\n            tagSupport.propsConfig = { ...existingTag.tagSupport.propsConfig };\n            runBeforeRedraw(tagSupport, existingTag);\n        }\n        else {\n            // first time render\n            runBeforeRender(tagSupport, runtimeOwnerTag);\n            // TODO: Logic below most likely could live within providers.ts inside the runBeforeRender function\n            const providers = setUse.memory.providerConfig;\n            providers.ownerTag = runtimeOwnerTag;\n        }\n        /* END: BEFORE RENDER */\n        const templater = this;\n        const retag = templater.wrapper(tagSupport);\n        /* AFTER */\n        runAfterRender(tagSupport, retag);\n        templater.newest = retag;\n        retag.ownerTag = runtimeOwnerTag;\n        tagSupport.newest = retag;\n        return { remit: true, retag };\n    }\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProps(props, templater) {\n    function callback(toCall, callWith) {\n        const callbackResult = toCall(...callWith);\n        // const tag = templater.oldest as Tag\n        const tag = templater.newest;\n        // const tagSupport = tag.tagSupport\n        // const tagSupport = templater.tagSupport\n        const tagSupport = tag?.ownerTag?.tagSupport;\n        tagSupport.render();\n        return callbackResult;\n    }\n    const isPropTag = isTagInstance(props);\n    const watchProps = isPropTag ? 0 : props;\n    const newProps = resetFunctionProps(watchProps, callback);\n    return newProps;\n}\nfunction resetFunctionProps(props, callback) {\n    if (typeof (props) !== 'object') {\n        return props;\n    }\n    const newProps = props;\n    // BELOW: Do not clone because if first argument is object, the memory ref back is lost\n    // const newProps = {...props} \n    Object.entries(newProps).forEach(([name, value]) => {\n        if (value instanceof Function) {\n            const original = newProps[name].original;\n            if (original) {\n                return; // already previously converted\n            }\n            newProps[name] = (...args) => {\n                return callback(value, args);\n            };\n            newProps[name].original = value;\n            return;\n        }\n    });\n    return newProps;\n}\n//# sourceMappingURL=templater.utils.js.map","import { runAfterRender, runBeforeRedraw } from \"./tagRunner.js\";\nexport function updateExistingTag(templater, ogTag, existingSubject) {\n    const tagSupport = ogTag.tagSupport;\n    const oldest = tagSupport.oldest;\n    const newest = tagSupport.newest;\n    // runBeforeRedraw(oldest.tagSupport, newest || oldest)\n    runBeforeRedraw(oldest.tagSupport, oldest);\n    const retag = templater.wrapper(tagSupport);\n    templater.newest = retag;\n    tagSupport.newest = retag;\n    runAfterRender(oldest.tagSupport, oldest);\n    ogTag.updateByTag(retag);\n    // oldest.updateByTag(retag)\n    existingSubject.set(templater);\n    return [];\n}\n//# sourceMappingURL=updateExistingTag.function.js.map","import { setValueRedraw } from \"./Tag.utils.js\";\nimport { deepClone } from \"./deepFunctions.js\";\nimport { isTagInstance } from \"./isInstance.js\";\nimport { hasTagSupportChanged } from \"./hasTagSupportChanged.function.js\";\nimport { destroyTagMemory } from \"./checkDestroyPrevious.function.js\";\nexport function updateExistingTagComponent(tag, tempResult, existingSubject, subjectValue) {\n    let existingTag = existingSubject.tag;\n    // previously was something else, now a tag component\n    if (!existingTag) {\n        setValueRedraw(tempResult, existingSubject, tag);\n        tempResult.redraw();\n        return;\n    }\n    // tag existingTag\n    const oldWrapper = existingTag.tagSupport.templater.wrapper;\n    const newWrapper = tempResult.wrapper;\n    let isSameTag = false;\n    if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        isSameTag = oldFunction === newFunction;\n    }\n    const latestProps = tempResult.tagSupport.propsConfig.latest;\n    const oldTagSetup = existingTag.tagSupport;\n    oldTagSetup.propsConfig.latest = latestProps;\n    if (!isSameTag) {\n        destroyTagMemory(existingTag, existingSubject);\n    }\n    else {\n        const subjectTagSupport = subjectValue?.tagSupport;\n        // old props may have changed, reclone first\n        let oldCloneProps = subjectTagSupport.props;\n        // if the new props are NOT HTML children, then clone the props for later render cycle comparing\n        if (!isTagInstance(subjectTagSupport.props)) {\n            oldCloneProps = deepClone(subjectTagSupport.props);\n        }\n        if (existingTag) {\n            const newTagSupport = tempResult.tagSupport;\n            const hasChanged = hasTagSupportChanged(oldTagSetup, newTagSupport);\n            if (!hasChanged) {\n                return; // its the same tag component\n            }\n        }\n    }\n    setValueRedraw(tempResult, existingSubject, tag);\n    oldTagSetup.templater = tempResult;\n    const redraw = tempResult.redraw();\n    if (!existingTag.isLikeTag(redraw)) {\n        existingTag.destroy();\n        existingSubject.tagSupport = redraw.tagSupport;\n        existingSubject.tag = redraw;\n        oldTagSetup.oldest = redraw;\n    }\n    oldTagSetup.newest = redraw;\n    oldTagSetup.propsConfig = { ...tempResult.tagSupport.propsConfig };\n    return;\n}\n//# sourceMappingURL=updateExistingTagComponent.function.js.map","import { isSubjectInstance, isTagArray, isTagComponent } from \"./isInstance.js\";\nimport { bindSubjectCallback } from \"./bindSubjectCallback.function.js\";\nimport { processTag } from \"./processSubjectValue.function.js\";\nimport { processTagArray } from \"./processTagArray.js\";\nimport { updateExistingTagComponent } from \"./updateExistingTagComponent.function.js\";\nimport { updateExistingTag } from \"./updateExistingTag.function.js\";\nimport { processRegularValue } from \"./processRegularValue.function.js\";\nimport { checkDestroyPrevious } from \"./checkDestroyPrevious.function.js\";\nexport function updateExistingValue(subject, value, ownerTag) {\n    const subjectValue = subject.value; // old value\n    const subjectSubArray = subject;\n    const subjectSubTag = subject;\n    const isChildSubject = subjectSubArray.isChildSubject;\n    const isComponent = isTagComponent(value);\n    // If we are working with tag component 2nd argument children, the value has to be digged\n    if (isChildSubject) {\n        value = value.value; // A subject contains the value\n    }\n    checkDestroyPrevious(subject, value);\n    // handle already seen tag components\n    if (isComponent) {\n        return updateExistingTagComponent(ownerTag, value, // latest value\n        subjectSubTag, subjectValue);\n    }\n    // was component but no longer\n    const subjectTag = subjectSubTag.tag;\n    if (subjectTag) {\n        handleStillTag(subjectTag, subject, value, ownerTag);\n        return;\n    }\n    // its another tag array\n    if (isTagArray(value)) {\n        const insertBefore = subjectSubArray.template || subjectSubTag.tag?.tagSupport.templater.insertBefore;\n        const nextClones = processTagArray(subject, value, insertBefore, ownerTag, { counts: {\n                added: 0,\n                removed: 0,\n            } });\n        ownerTag.clones.push(...nextClones);\n        return;\n    }\n    // now its a function\n    if (value instanceof Function) {\n        subjectSubTag.set(bindSubjectCallback(value, ownerTag));\n        return;\n    }\n    // we have been given a subject\n    if (isSubjectInstance(value)) {\n        subjectSubTag.set(value.value); // let ValueSubject now of newest value\n        return;\n    }\n    subjectSubTag.set(value); // let ValueSubject now of newest value\n    return;\n}\nfunction handleStillTag(existingTag, existing, value, ownerTag) {\n    const oldWrapper = existingTag.tagSupport.templater.wrapper;\n    const newWrapper = value?.wrapper;\n    const wrapMatch = oldWrapper && newWrapper && oldWrapper?.original === newWrapper?.original;\n    // TODO: We shouldn't need both of these\n    const isSameTag = value && existingTag.lastTemplateString === value.lastTemplateString;\n    const isSameTag2 = value && value.getTemplate && existingTag.isLikeTag(value);\n    if (isSameTag || isSameTag2) {\n        return processTag(value, existing, existing.template, ownerTag, // existingTag, // tag,\n        {\n            counts: {\n                added: 0,\n                removed: 0,\n            }\n        });\n    }\n    if (wrapMatch) {\n        return updateExistingTag(value, existingTag, existing);\n    }\n    const subject = existing;\n    return processRegularValue(value, subject, subject.template);\n}\n//# sourceMappingURL=updateExistingValue.function.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/** client code */\n\nconst { variablePrefix } = require(\"taggedjs/js/Tag.class\");\n\n// do not use another import as it wont be same memory as running app\n// import { redrawTag, Tag, tagElement } from \"taggedjs\"\n\nreconnect()\n\n/**\n * @typedef {import(\"taggedjs\").TagComponent} TagComponent\n * @typedef {import(\"taggedjs\").Tag} Tag\n */\n\nfunction reconnect() {\n  const socket = new WebSocket('ws://localhost:3000');\n\n  // Listen for WebSocket errors\n  socket.addEventListener('error', (event) => {\n    console.error('WebSocket error:', event);\n  })\n\n  // Connection opened\n  socket.addEventListener('open', (event) => {\n    console.info('WebSocket connection opened:', event);\n  })\n\n  // Listen for messages from the server\n  socket.addEventListener('message', async (event) => {\n    console.info('Message from server:', event.data, event.data);\n\n    if(event.data==='Connected to the WebSocket endpoint') {\n      // immediately overwrite existing running app\n      rebuildApps()        \n      return\n    }\n\n    runElementSelector()\n  })\n\n  // Connection closed\n  socket.addEventListener('close', (event) => {\n    console.info('WebSocket connection closed:', event);\n\n    reconnect()\n  })\n}\n\nfunction runElementSelector() {\n  forEachApp(app => {\n    updateByElement(app)\n  })\n}\n\nfunction forEachApp(method) {\n  const array = [...document.querySelectorAll('app')]\n  array.forEach(method)\n}\n\n/**\n * @returns {Promise<{tagName: string, newApp: any, newTemplater: () => Tag}[]>}\n */\nasync function discoverTags() {\n  const baseArray = document.querySelectorAll('[tag]')\n  const array = [...baseArray]\n  \n  const promises = array.map(async element => {\n    const url = element.getAttribute('url')\n    const tagName = element.getAttribute('name')\n\n    const newApp = await import(`${url}?${Date.now()}`)\n\n    /** @type {() => Tag} */\n    try {\n      const newTemplater = newApp[tagName]()\n      return {newApp, newTemplater, tagName}\n    } catch(err) {\n      console.error(`Could not load tag by name ${tagName}`, {newApp, url})\n      throw err\n    }\n  })\n\n  const results = await Promise.all(promises)\n\n  return results\n}\n\n/** @type {TagComponent{}} */\nlet lastTags = []\n\nasync function updateByElement(\n  app\n) {\n  /** @type {TagComponent[]} */\n  const oldTags = lastTags\n  const oldSetUse = app.setUse\n    \n  const tags = await discoverTags()\n\n  // loop new tags looking for matching old\n  tags.forEach(async tag => {\n    const { newApp, newTemplater } = tag\n    const { redrawTag } = newApp.hmr\n    \n    /** @type {TagComponent[]} */\n    const newTags = newTemplater.wrapper.original.tags\n    const newSetUse = newTemplater.wrapper.original.setUse\n    oldSetUse.tagUse = newSetUse.tagUse\n    // update old middleware to use new memory\n    Object.assign(oldSetUse.memory, newSetUse.memory)\n    \n    // bind the old and new together\n    newSetUse.memory = oldSetUse.memory\n  \n    /** @type {{oldTag: Tag, newTag: Tag}[]} */\n    const tagChangeStates = oldTags.reduce((all, oldTag, loopIndex) => {\n      let newTag = newTags.find(newTag => newTag.toString() === oldTag.toString())\n      \n      if(!newTag) {\n        const tagIndex = oldTag.tagIndex\n        if(tagIndex !== undefined) {\n          newTag = newTags[tagIndex]\n        }\n\n        all.push({oldTag, newTag})\n      }\n\n      return all\n    }, [])\n  \n    if(!tagChangeStates.length) {\n      console.warn('No old tags changed', {\n        newTags, oldTags\n      })\n    }\n  \n    const matchedTagCounts = oldTags.length === newTags.length\n  \n    newTags.forEach((newTag, index) => {\n      let oldTag = oldTags.find(oldTag => newTag.toString() === oldTag.toString())\n  \n      let tagIndex = null\n      if(!oldTag && tagChangeStates[0].newTag) {\n        // const tagIndex = newTag.tagSupport.templater.wrapper.tagIndex // newTag.tagIndex\n        tagIndex = newTag.tagIndex\n        if( matchedTagCounts ) {\n          oldTag = oldTags[ tagIndex ]\n        }\n      }\n      \n      if(!oldTag) {\n        if(tagChangeStates[0].newTag) {\n          const message = 'HMR has two tags'\n  \n          console.warn(message, {\n            first: tagChangeStates[0].newTag,\n            second: newTag,\n            equal: newTag === tagChangeStates[0].newTag,\n            oldTags,\n            newTags,\n            tagIndex,\n          })\n          throw new Error(message)\n        }\n        tagChangeStates[0].newTag = newTag\n      }\n    })\n  \n    if(tagChangeStates.length) {\n      const compareTag = tagChangeStates[0].oldTag\n      \n      // Check to rebuild the MAIN APP\n      const oldTemplater = lastApp.tagSupport.templater\n      const match0 = oldTemplater.wrapper.original === compareTag\n      const match1 = oldTemplater.wrapper.original.toString() === compareTag.toString()\n      if(match0 || match1) {\n        const newTag = tagChangeStates[0].newTag\n        lastApp.tagSupport.templater.wrapper.original = newTag\n        await lastApp.destroy()\n        lastApp = await rebuildTag(lastApp, redrawTag)\n        lastTags = newTags\n        return\n      }\n  \n      const count = await replaceTemplater(lastApp, tagChangeStates[0], redrawTag)\n      \n      if(count <= 0) {\n        console.warn('✋ No components were updated', tagChangeStates[0])\n      } else {\n        console.debug(`✅ Replaced and update components ${count}`, tagChangeStates[0])\n      }\n    }\n  \n    lastTags = newTags\n  \n    console.info('✅ ✅ ✅ rebuilt', )\n  })\n}\n\nasync function rebuildTag(\n  /** @type {Tag} */\n  tag,\n  redrawTag,\n  ownerTag,\n) {\n  /** @type {{retag: Tag}} */\n  const { retag } = redrawTag(\n    tag.tagSupport,\n    tag.tagSupport.templater,\n    tag, // existingTag\n    ownerTag, // TODO: not needed\n  )\n\n  retag.tagSupport.templater.insertBefore = tag.tagSupport.templater.insertBefore\n\n  retag.rebuild()\n\n  if(tag.ownerTag) {\n    retag.ownerTag.children.push(retag)\n  }\n\n  return retag\n}\n\nasync function replaceTemplater(\n  /** @type {Tag} */\n  tag,\n  /** @type {{oldTag: TagComponent, newTag: TagComponent}} */\n  {oldTag, newTag},\n  redrawTag,\n  ) {\n  let  count = 0\n  const promises = tag.values.map(async (value, index) => {\n    if(!value || !value.isTemplater) {\n      return\n    }\n\n    const match0 = value.wrapper.original === oldTag\n    const match1 = value.wrapper.original.toString() === oldTag.toString()\n\n    // Check to rebuild a component within an app\n    if(match0 || match1) {\n      const tagSupport = tag.tagSupport\n      // const tagSupport = oldTag.tagSupport\n      const memory = tagSupport.memory\n      const context = memory.context\n      const contextSubject = context[ variablePrefix + index ]\n      value.wrapper.original = newTag\n      const contextSupport = contextSubject.tag.tagSupport\n      contextSupport.templater.wrapper.original = newTag\n      \n      await contextSubject.tag.destroy()\n      // destroyContextClones(contextSubject.tag.tagSupport.memory.context)\n      \n      contextSubject.tag = await rebuildTag(contextSubject.tag, redrawTag, tag)\n      \n      ++count\n\n      return\n    }\n  })\n  \n  await Promise.all(promises)\n\n  const subPromises = tag.children.map(async child => {\n    count = count + await replaceTemplater(child, {oldTag, newTag}, redrawTag)\n  })\n\n  await Promise.all(subPromises)\n\n  return count\n}\n\n/** @type {Tag | undefined} */\nlet lastApp;\n\nfunction rebuildApps() {\n  forEachApp(element => {\n    discoverTags().then(apps => {\n      apps.forEach(({newApp, tagName}) => {\n        const { tagElement } = newApp.hmr\n        const result = tagElement(newApp[tagName], element, {test:1})\n        \n        lastTags = result.tags\n        lastApp = result.tag\n  \n        return result\n      })\n    })\n  })\n}\n\nfunction destroyContextClones(context) {\n  Object.values(context).forEach(context => {\n    if(context.clone) {\n      delete context.clone\n    }\n\n    if(context.tag) {\n      destroyContextClones(context.tag.tagSupport.memory.context)\n    }\n  })\n}\n"],"names":[],"sourceRoot":""}