{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///../main/ts/tag/update/processFirstSubject.utils.ts","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///../main/ts/tag/isLikeTags.function.ts","webpack:///../main/ts/tag/destroyTag.function.ts","webpack:///../main/ts/insertAfter.function.ts","webpack:///../main/ts/tag/checkDestroyPrevious.function.ts","webpack:///../main/ts/isInstance.ts","webpack:///../main/ts/subject/combineLatest.function.ts","webpack:///../main/ts/subject/subject.utils.ts","webpack:///../main/ts/subject/Subject.class.ts","webpack:///../main/ts/subject/ValueSubject.ts","webpack:///../main/ts/tag/getSupportInCycle.function.ts","webpack:///../main/ts/state/setUse.function.ts","webpack:///../main/ts/errors.ts","webpack:///../main/ts/state/state.utils.ts","webpack:///../main/ts/state/syncStates.function.ts","webpack:///../main/ts/state/state.function.ts","webpack:///../main/ts/state/watch.function.ts","webpack:///../main/ts/state/subject.function.ts","webpack:///../main/ts/state/letState.function.ts","webpack:///../main/ts/deepFunctions.ts","webpack:///../main/ts/state/providers.ts","webpack:///../main/ts/state/provider.utils.ts","webpack:///../main/ts/tag/tagRunner.ts","webpack:///../main/ts/tag/render/renderTagOnly.function.ts","webpack:///../main/ts/tag/render/renderWithSupport.function.ts","webpack:///../main/ts/tag/render/renderExistingTag.function.ts","webpack:///../main/ts/tag/render/renderTagSupport.function.ts","webpack:///../main/ts/state/callbackMaker.function.ts","webpack:///../main/ts/state/onInit.ts","webpack:///../main/ts/state/onDestroy.ts","webpack:///../main/ts/state/children.ts","webpack:///../main/ts/tag/Tag.class.ts","webpack:///../main/ts/tag/TemplaterResult.class.ts","webpack:///../main/ts/tag/kidsToTagArraySubject.function.ts","webpack:///../main/ts/tag/tag.utils.ts","webpack:///../main/ts/interpolations/bindSubjectCallback.function.ts","webpack:///../main/ts/tag/cloneValueArray.function.ts","webpack:///../main/ts/tag/destroy.support.ts","webpack:///../main/ts/tag/update/processNewValue.function.ts","webpack:///../main/ts/tag/setTagPlaceholder.function.ts","webpack:///../main/ts/interpolations/inputAttribute.ts","webpack:///../main/ts/interpolations/processAttribute.function.ts","webpack:///../main/ts/interpolations/interpolateAttributes.ts","webpack:///../main/ts/interpolations/interpolations.ts","webpack:///../main/ts/tag/update/processTagResult.function.ts","webpack:///../main/ts/tag/update/processSubjectComponent.function.ts","webpack:///../main/ts/tag/render/renderSubjectComponent.function.ts","webpack:///../main/ts/tag/update/processTag.function.ts","webpack:///../main/ts/tag/update/processTagArray.ts","webpack:///../main/ts/updateBeforeTemplate.function.ts","webpack:///../main/ts/tag/update/processRegularValue.function.ts","webpack:///../main/ts/tag/update/processFirstSubjectValue.function.ts","webpack:///../main/ts/interpolations/scanTextAreaValue.function.ts","webpack:///../main/ts/tag/hasPropChanges.function.ts","webpack:///../main/ts/tag/hasTagSupportChanged.function.ts","webpack:///../main/ts/alterProps.function.ts","webpack:///../main/ts/tag/update/updateExistingTagComponent.function.ts","webpack:///../main/ts/tag/update/updateExistingValue.function.ts","webpack:///../main/ts/interpolations/interpolateTemplate.ts","webpack:///../main/ts/interpolations/elementInitCheck.ts","webpack:///../main/ts/interpolations/interpolateContentTemplates.ts","webpack:///../main/ts/interpolations/interpolateElement.ts","webpack:///../main/ts/interpolations/afterInterpolateElement.function.ts","webpack:///../main/ts/render.ts","webpack:///../main/ts/tag/TagSupport.class.ts","webpack:///../main/ts/tag/update/updateContextItem.function.ts","webpack:///../main/ts/tag/elementDestroyCheck.function.ts","webpack:///../main/ts/tag/tag.ts","webpack:///../main/ts/tag/getTagWrap.function.ts","webpack:///../main/ts/tag/html.ts","webpack:///../main/ts/tag/tagElement.ts","webpack:///../main/ts/index.ts","webpack:///./src/attributeDebug.component.ts","webpack:///./src/ContentDebug.component.ts","webpack:///../main/ts/subject/will.functions.ts","webpack:///./src/tableDebug.component.ts","webpack:///./src/renderCount.component.ts","webpack:///./src/PropsDebug.component.ts","webpack:///../main/ts/state/letProp.function.ts","webpack:///./node_modules/taggedjs-animate/js/createFx.function.js","webpack:///./node_modules/taggedjs-animate/js/index.js","webpack:///./src/arrayTests.ts","webpack:///./src/intervalDebug.ts","webpack:///./src/tagJsDebug.ts","webpack:///./src/tagSwitchDebug.component.ts","webpack:///./src/mirroring.tag.ts","webpack:///./src/innerHtmlTests.ts","webpack:///./src/childTests.ts","webpack:///./src/elmSelectors.ts","webpack:///./src/expect.ts","webpack:///./src/expect.html.ts","webpack:///./src/tests.ts","webpack:///./src/mouseover.tag.ts","webpack:///./src/countersDebug.ts","webpack:///./src/providerDebug.ts","webpack:///./src/watchTesting.tag.ts","webpack:///./src/oneRender.tag.ts","webpack:///./src/app.tag.ts","webpack:///./src/isolatedApp.ts","webpack:///./src/app.function.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import { isSubjectInstance, isTagArray } from '../../isInstance'\nimport { TagArraySubject } from './processTagArray'\nimport { TemplaterResult } from '../TemplaterResult.class'\nimport { Clones } from '../../interpolations/Clones.type'\nimport { Counts, Template } from '../../interpolations/interpolateTemplate'\nimport { DisplaySubject, TagSubject } from '../../subject.types'\nimport { ValueSubject } from '../../subject/ValueSubject'\nimport { RegularValue } from './processRegularValue.function'\nimport { Callback } from '../../interpolations/bindSubjectCallback.function'\nimport { Tag } from '../Tag.class'\nimport { Subject } from '../../subject'\nimport { isSimpleType } from '../checkDestroyPrevious.function'\n\nexport enum ValueTypes {\n  unknown = 'unknown',\n  \n  tag = 'tag', // this one might be bad\n  templater = 'templater',\n  tagComponent = 'tag-component',\n  \n  tagArray = 'tag-array',\n  subject = 'subject',\n  \n  date = 'date',\n  string = 'string',\n  boolean = 'boolean',\n  function = 'function',\n  undefined = 'undefined',\n}\n\nexport function getValueType(value: any): ValueTypes {\n  if(value === undefined || value === null) {\n    return ValueTypes.undefined\n  }\n\n  const type = typeof(value)\n  \n  if(value instanceof Function) {\n    return ValueTypes.function\n  }\n  \n  if(type === 'object') {\n    if(value instanceof Date) {\n      return ValueTypes.date\n    }\n  \n    if(isSimpleType(type)) {\n      return type as ValueTypes\n    }\n\n\n    const tagJsType = value.tagJsType\n    if(tagJsType) {\n      const included = [\n        ValueTypes.tagComponent,\n        ValueTypes.templater,\n        ValueTypes.tag,\n      ].includes(tagJsType)\n  \n      if(included) {\n        return tagJsType\n      }\n    }\n\n    if (isTagArray(value)) {\n      return ValueTypes.tagArray\n    }\n  \n    if(isSubjectInstance(value)) {\n      return ValueTypes.subject\n    }\n  }\n\n  return ValueTypes.unknown\n}\n\nexport type processOptions = {\n  counts: Counts // used to count stagger\n}\n\nexport type ClonesAndPromise = {\n  clones: Clones\n}\n\nexport type InterpolateSubject = (ValueSubject<undefined> | TagArraySubject | TagSubject | DisplaySubject | ValueSubject<Callback>) & {\n  clone?: Element | Text | Template\n}\n\n// what can be put down with ${}\nexport type TemplateValue = Tag | TemplaterResult | (Tag | TemplaterResult)[] | RegularValue | Subject<any> | Callback\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { Tag } from \"./Tag.class\"\nimport { TagSupport } from \"./TagSupport.class\"\nimport { TemplaterResult } from \"./TemplaterResult.class\"\n\nexport function isLikeTags(\n  tagSupport0: TagSupport | Tag, // new\n  tagSupport1: TagSupport, // previous\n): Boolean {\n  const templater0 = tagSupport0.templater as TemplaterResult | undefined\n  const templater1 = tagSupport1.templater as TemplaterResult\n  \n  const tag0 = templater0?.tag || (tagSupport0 as Tag)\n  const tag1 = templater1.tag as Tag\n\n  const strings0 = tag0.strings\n  const strings1 = tagSupport1.strings || tag1.strings\n  if(strings0.length !== strings1.length) {\n    return false\n  }\n\n  const everyStringMatched = strings0.every((string,index) => strings1[index] === string)\n  if(!everyStringMatched) {\n    return false\n  }\n\n  const values0 = tagSupport0.values || tag0.values\n  const values1 = tagSupport1.values || tag1.values\n  return isLikeValueSets(values0, values1)\n}\n\nexport function isLikeValueSets(values0:any[], values1:any[]) {\n  const valuesLengthsMatch = values0.length === values1.length\n  if(!valuesLengthsMatch) {\n    return false\n  }\n\n  const allVarsMatch = values1.every((value, index)=> {\n    const compareTo = values0[index]\n    const isFunctions = value instanceof Function && compareTo instanceof Function\n    \n    if(isFunctions) {\n      const stringMatch = value.toString() === compareTo.toString()\n      if(stringMatch) {\n        return true\n      }\n\n      return false\n    }\n\n    return true // deepEqual(value, compareTo)\n  })\n\n  if(allVarsMatch) {\n    return true\n  }\n\n  return false\n}\n","import { TagSubject, WasTagSubject } from '../subject.types'\nimport { TagSupport } from './TagSupport.class'\n\nexport function destroyTagMemory(\n  oldTagSupport: TagSupport,\n) {\n  // must destroy oldest which is tag with elements on stage\n  const oldest = oldTagSupport.global.oldest as TagSupport\n  oldest.destroy()\n\n  destroyTagSupportPast(oldTagSupport)\n  \n  oldTagSupport.global.context = {}\n}\n\nexport function destroyTagSupportPast(oldTagSupport: TagSupport) {\n  delete oldTagSupport.global.oldest\n  delete oldTagSupport.global.newest\n}\n","import { InsertBefore } from \"./interpolations/Clones.type\"\n\n// Function to insert element after reference element\nexport function insertAfter(\n  newNode: InsertBefore,\n  referenceNode: InsertBefore\n) {\n  const parentNode = referenceNode.parentNode as ParentNode\n  parentNode.insertBefore(newNode, referenceNode.nextSibling)\n}\n","import { DisplaySubject, TagSubject } from '../subject.types'\nimport { isStaticTag } from '../isInstance'\nimport { InterpolateSubject, ValueTypes, getValueType } from './update/processFirstSubject.utils'\nimport { TagArraySubject } from './update/processTagArray'\nimport { isLikeTags } from './isLikeTags.function'\nimport { Counts } from '../interpolations/interpolateTemplate'\nimport { destroyTagMemory, destroyTagSupportPast } from './destroyTag.function'\nimport { InsertBefore } from '../interpolations/Clones.type'\nimport { insertAfter } from '../insertAfter.function'\nimport { TagSupport } from './TagSupport.class'\n\nexport function checkDestroyPrevious(\n  subject: InterpolateSubject, // existing.value is the old value\n  newValue: unknown,\n  insertBefore: InsertBefore,\n) {\n  const displaySubject = subject as DisplaySubject\n  const hasLastValue = 'lastValue' in displaySubject\n  const lastValue = displaySubject.lastValue // TODO: we maybe able to use displaySubject.value and remove concept of lastValue\n\n  // was simple value but now something bigger\n  if(hasLastValue && lastValue !== newValue) {\n    // below is faster than using getValueType\n    const newType = typeof(newValue)\n    if( isSimpleType(newType) && typeof(lastValue) === newType ) {\n      return false\n    }\n\n    if(newValue instanceof Function && (lastValue as any) instanceof Function) {\n      return false\n    }\n\n    destroySimpleValue(insertBefore, displaySubject)\n    return 'changed-simple-value'\n  }\n\n  const valueType = getValueType(newValue)\n  const arraySubject = subject as TagArraySubject\n  const wasArray = arraySubject.lastArray\n  \n  // no longer an array\n  if (wasArray && valueType!==ValueTypes.tagArray) {\n    const placeholderElm = arraySubject.placeholder as Text\n    delete arraySubject.lastArray\n    delete arraySubject.placeholder\n    insertAfter(insertBefore, placeholderElm)\n\n    \n    for (let index = wasArray.length - 1; index >= 0; --index) {\n      const {tagSupport} = wasArray[index]\n      destroyArrayTag(tagSupport, {added:0, removed:0})\n    }\n\n    return 'array'\n  }\n\n  const tagSubject = subject as TagSubject\n  const lastSupport = tagSubject.tagSupport\n  \n  // no longer tag or component?\n  if(lastSupport) {\n    const isValueTag = isStaticTag(newValue)\n    const isSubjectTag = isStaticTag(subject.value)\n\n    if(isSubjectTag && isValueTag) {\n      const newTag = newValue as TagSupport\n      \n      // its a different tag now\n      if(!isLikeTags(newTag, lastSupport)) {\n        // put template back down\n        restoreTagMarker(lastSupport)\n        destroyTagMemory(lastSupport)\n        return 2\n      }\n\n      return false\n    }\n\n    if(valueType === ValueTypes.tagComponent) {\n      return false // its still a tag component\n    }\n\n\n    if(newValue && (newValue as any).oneRender) {\n      return false\n    }\n\n    // put template back down\n    restoreTagMarker(lastSupport)\n\n    // destroy old component, value is not a component\n    destroyTagMemory(lastSupport)\n    return 'different-tag'\n  }\n\n  return false\n}\n\nexport function isSimpleType(value: any) {\n  return ['string','number','boolean'].includes(value)\n}\n\nexport function destroyArrayTag(\n  tagSupport: TagSupport,\n  counts: Counts,\n) {\n  destroyTagSupportPast(tagSupport)\n\n  tagSupport.destroy({\n    stagger: counts.removed++,\n  })\n\n  const insertBefore = tagSupport.global.insertBefore as Element\n  const parentNode = insertBefore.parentNode as ParentNode\n  parentNode.removeChild(insertBefore)\n}\n\nfunction destroySimpleValue(\n  insertBefore: InsertBefore, // always a template tag\n  subject: DisplaySubject,\n) {\n  const clone = subject.clone as Element\n  const parent = clone.parentNode as ParentNode\n  \n\n  // 1 put the template back down\n  parent.insertBefore(insertBefore, clone)\n  parent.removeChild(clone)\n  \n  delete subject.clone\n  delete subject.lastValue\n}\n\nexport function restoreTagMarker(\n  lastSupport: TagSupport,\n) {\n  const insertBefore = lastSupport.global.insertBefore as Element\n  const global = lastSupport.global\n  const placeholderElm = global.placeholder\n  if(placeholderElm) {\n    insertAfter(insertBefore, placeholderElm)\n    delete global.placeholder\n  }\n}\n","import { SubjectLike } from \"./subject/subject.utils\"\nimport { Tag } from \"./tag/Tag.class\"\nimport { ValueTypes } from \"./tag/update/processFirstSubject.utils\"\nimport { TemplaterResult } from \"./tag/TemplaterResult.class\"\n\nexport function isStaticTag(\n  value?: TemplaterResult | Tag | unknown\n) {\n  return [\n    ValueTypes.tag,\n    ValueTypes.templater,\n  ].includes( (value as any)?.tagJsType )\n}\n\nexport function isTagTemplater(\n  value?: TemplaterResult | unknown\n) {\n  return (value as TemplaterResult)?.tagJsType === ValueTypes.templater\n}\n\n// TODO: whats the difference between isTagClass and isTagComponent\nexport function isTagComponent(\n  value?: TemplaterResult | unknown\n) {\n  return (value as TemplaterResult)?.tagJsType === ValueTypes.tagComponent\n}\n\nexport function isTagClass(\n  value?: Tag | unknown\n) {\n  return (value as Tag)?.tagJsType === ValueTypes.tag\n}\n\n// isSubjectLike\nexport function isSubjectInstance(\n  subject?: SubjectLike<any> | any\n): Boolean {\n  return (subject?.isSubject === true || subject?.subscribe) ? true : false // subject?.isSubject === true || \n}\n\nexport function isTagArray(value: unknown) {\n  return value instanceof Array && value.every(x => [\n    ValueTypes.tag, ValueTypes.templater, ValueTypes.tag, ValueTypes.tagComponent\n  ].includes( x?.tagJsType ))\n}\n","import { Subject } from \"./Subject.class\"\nimport { SubjectSubscriber, Subscription } from \"./subject.utils\"\n\nexport function combineLatest(\n  subjects: Subject<any>[],\n): Subject<any> {\n  const output = new Subject()\n  \n  const subscribe = (\n    callback: SubjectSubscriber<any>\n  ) => {\n    const valuesSeen: true[] = []\n    const values: any[] = []    \n    const setValue = (x: any, index: number) => {\n      valuesSeen[index] = true\n      values[index] = x\n      const countMatched = valuesSeen.length === subjects.length\n\n      if(!countMatched) {\n        return\n      }\n\n      for (let index = valuesSeen.length - 1; index >= 0; --index) {\n        if(!valuesSeen[index]) {\n          return\n        }\n      }\n\n      // everyone has reported values\n      callback(values, subscription)\n    }\n\n    const clones = [...subjects]\n    const firstSub = clones.shift() as Subject<any>\n    const subscription: Subscription<any> = firstSub.subscribe(x => setValue(x, 0))\n    \n    const subscriptions = clones.map((subject, index) => subject.subscribe(x => setValue(x, index + 1)))\n\n    subscription.subscriptions = subscriptions\n\n    return subscription\n  }\n\n  output.subscribeWith = subscribe\n\n  return output\n}","import { Subject } from \"./Subject.class\"\n\nexport type Resolve<T> = (x: T) => any\n\nexport type Subscription<T> = ((arg: T) => void) & {\n  callback: SubjectSubscriber<T>,\n  unsubscribe: () => Subscription<T>\n  add: (sub: Subscription<T>) => Subscription<T>\n  next: (value?: T) => any\n  subscriptions: Subscription<T>[] // support for combing subjects\n}\n\nexport type SubjectSubscriber<T> = (\n  value: T,\n  subscription: Subscription<T>, // allows immediate unsubscribe\n) => unknown\n\nexport type SubjectLike<T> = {\n  subscribe?: (callback: SubjectSubscriber<T>) => any,\n  isSubject?: boolean\n}\n\nexport type Closer<T> = {\n  createCallback: (callback: (result: T) => any) => any\n  subscribe: (subject: SubjectLike<T>) => any\n}\n\nexport type Handler<T> = (x: any) => T\nexport type setHandler<T> = (x: Handler<T>) => any\n\nexport interface UnaryFunction<T, R, RESOLVE> {\n  (\n    source: T, // lastValue\n    pipeUtils: PipeUtils<RESOLVE>,\n  ): R;\n}\n\nexport interface OperatorFunction<T, R, RESOLVE> extends UnaryFunction<T, R, RESOLVE> {}\n\nexport type PipeUtils<H> = {\n  setHandler: setHandler<H>\n  next: (newValue: any) => any\n}\n\nfunction removeSubFromArray(\n  subscribers: Subscription<any>[],\n  callback: SubjectSubscriber<any>,\n) {\n  const index = subscribers.findIndex(sub => sub.callback === callback)\n  if (index !== -1) {\n    subscribers.splice(index, 1)\n  }\n}\n\nexport function getSubscription<T>(\n  subject: Subject<T>,\n  callback: SubjectSubscriber<any>\n) {\n  const countSubject = Subject.globalSubCount$ as {value: number}\n  Subject.globalSubCount$.set( countSubject.value + 1 )\n\n  const subscription: Subscription<any> = () => {\n    subscription.unsubscribe()\n  }\n\n  subscription.callback = callback\n  subscription.subscriptions = []\n\n  // Return a function to unsubscribe from the BehaviorSubject\n  subscription.unsubscribe = () => {\n    removeSubFromArray(subject.subscribers, callback) // each will be called when update comes in\n    // removeSubFromArray(Subject.globalSubs, callback) // 🔬 testing\n    Subject.globalSubCount$.set( countSubject.value - 1 )\n    \n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription\n\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions\n    for (let index = subscriptions.length - 1; index >= 0; --index) {\n      subscriptions[index].unsubscribe()\n    }\n    \n    return subscription\n  }\n\n  subscription.add = (sub: Subscription<T>) => {\n    subscription.subscriptions.push( sub )\n    return subscription\n  }\n\n  subscription.next = (value: any) => {\n    callback(value, subscription)\n  }\n\n  return subscription\n}\n\nexport function runPipedMethods(\n  value: any,\n  methods: OperatorFunction<any, any, any>[],\n  onComplete: (lastValue: any) => any\n) {\n  const cloneMethods = [...methods]\n  \n  const firstMethod = cloneMethods.shift() as OperatorFunction<any, any, any>\n\n  const next = (newValue: any) => {\n    if(cloneMethods.length) {\n      return runPipedMethods(newValue, cloneMethods, onComplete)\n    }\n\n    onComplete(newValue)\n  }\n\n  let handler: Handler<any> = next\n\n  const setHandler: setHandler<any> = (x: Handler<any>) => handler = x\n  const pipeUtils = {setHandler, next}\n  const methodResponse = firstMethod(value, pipeUtils)\n  handler(methodResponse)\n}\n","import { isSubjectInstance } from \"../isInstance\"\nimport { combineLatest } from \"./combineLatest.function\"\nimport { OperatorFunction, SubjectLike, SubjectSubscriber, Subscription, getSubscription, runPipedMethods } from \"./subject.utils\"\n\nexport type OnSubscription<T> = (subscription: Subscription<T>) => unknown\n\nexport class Subject<T> implements SubjectLike<T> {\n  methods: OperatorFunction<any, any, any>[] = []\n  isSubject = true\n  subscribers: Subscription<T>[] = []\n  subscribeWith?: (x: SubjectSubscriber<T>) => Subscription<T>\n  _value?: T\n\n  constructor(\n    value?: T,\n    public onSubscription?: OnSubscription<T>\n  ) {\n    this._value = value\n  }\n\n  get value() {\n    return this._value\n  }\n\n  set value(newValue) {\n    this._value = newValue;\n    this.set(newValue)\n  }\n\n  subscribe(callback: SubjectSubscriber<T>) {\n    const subscription = getSubscription(this, callback)\n\n    // are we within a pipe?\n    const subscribeWith = this.subscribeWith\n    if(subscribeWith) {\n      // are we in a pipe?\n      if(this.methods.length) {\n        const orgCallback = callback\n        callback = (\n          value: any,\n          // subscription: Subscription,\n        ) => {\n          runPipedMethods(\n            value,\n            this.methods,\n            lastValue => orgCallback(lastValue, subscription)\n          )\n        }\n      }\n\n      return subscribeWith(callback)\n    }\n\n    this.subscribers.push(subscription)\n    // Subject.globalSubs.push(subscription) // 🔬 testing\n    const count = Subject.globalSubCount$.value as number\n    Subject.globalSubCount$.set(count + 1) // 🔬 testing\n    \n    if(this.onSubscription) {\n      this.onSubscription(subscription)\n    }\n    \n    return subscription\n  }\n\n  set(value?: any) {\n    this._value = value\n    \n    // Notify all subscribers with the new value\n    const subs = [...this.subscribers] // subs may change as we call callbacks\n    const length = subs.length\n    for (let index=0; index < length; ++index) {\n      const sub = subs[index]\n      sub.callback(value, sub)\n    }\n  }\n  // next() is available for rxjs compatibility\n  next = this.set\n\n  toPromise(): Promise<T> {\n    return new Promise(res => {\n      this.subscribe((x, subscription) => {\n        subscription.unsubscribe()\n        res(x)\n      })\n    })\n  }\n\n  /** like toPromise but faster */\n  toCallback(callback: (x: T) => any) {\n    this.subscribe((x, subscription) => {\n      subscription.unsubscribe()\n      callback(x)\n    })\n    return this\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Subject<T>;\n  pipe<A, RESOLVE>(op1: OperatorFunction<T, A, RESOLVE>): Subject<A>;\n  pipe<A, B, RESOLVE>(op1: OperatorFunction<T, A, RESOLVE>, op2: OperatorFunction<A, B, RESOLVE>): Subject<B>;\n  pipe<A, B, C, RESOLVE>(op1: OperatorFunction<T, A, RESOLVE>, op2: OperatorFunction<A, B, RESOLVE>, op3: OperatorFunction<B, C, RESOLVE>): Subject<C>;\n  pipe<A, B, C, D, RESOLVE>(\n    op1: OperatorFunction<T, A, RESOLVE>,\n    op2: OperatorFunction<A, B, RESOLVE>,\n    op3: OperatorFunction<B, C, RESOLVE>,\n    op4: OperatorFunction<C, D, RESOLVE>\n  ): Subject<D>;\n  pipe<A, B, C, D, E, RESOLVE>(\n    op1: OperatorFunction<T, A, RESOLVE>,\n    op2: OperatorFunction<A, B, RESOLVE>,\n    op3: OperatorFunction<B, C, RESOLVE>,\n    op4: OperatorFunction<C, D, RESOLVE>,\n    op5: OperatorFunction<D, E, RESOLVE>\n  ): Subject<E>;\n  pipe<A, B, C, D, E, F, RESOLVE>(\n    op1: OperatorFunction<T, A, RESOLVE>,\n    op2: OperatorFunction<A, B, RESOLVE>,\n    op3: OperatorFunction<B, C, RESOLVE>,\n    op4: OperatorFunction<C, D, RESOLVE>,\n    op5: OperatorFunction<D, E, RESOLVE>,\n    op6: OperatorFunction<E, F, RESOLVE>\n  ): Subject<F>;\n  pipe<A, B, C, D, E, F, G, RESOLVE>(\n    op1: OperatorFunction<T, A, RESOLVE>,\n    op2: OperatorFunction<A, B, RESOLVE>,\n    op3: OperatorFunction<B, C, RESOLVE>,\n    op4: OperatorFunction<C, D, RESOLVE>,\n    op5: OperatorFunction<D, E, RESOLVE>,\n    op6: OperatorFunction<E, F, RESOLVE>,\n    op7: OperatorFunction<F, G, RESOLVE>\n  ): Subject<G>;\n  pipe<A, B, C, D, E, F, G, H, RESOLVE>(\n    op1: OperatorFunction<T, A, RESOLVE>,\n    op2: OperatorFunction<A, B, RESOLVE>,\n    op3: OperatorFunction<B, C, RESOLVE>,\n    op4: OperatorFunction<C, D, RESOLVE>,\n    op5: OperatorFunction<D, E, RESOLVE>,\n    op6: OperatorFunction<E, F, RESOLVE>,\n    op7: OperatorFunction<F, G, RESOLVE>,\n    op8: OperatorFunction<G, H, RESOLVE>\n  ): Subject<H>;\n  pipe<A, B, C, D, E, F, G, H, I, RESOLVE>(\n    op1: OperatorFunction<T, A, RESOLVE>,\n    op2: OperatorFunction<A, B, RESOLVE>,\n    op3: OperatorFunction<B, C, RESOLVE>,\n    op4: OperatorFunction<C, D, RESOLVE>,\n    op5: OperatorFunction<D, E, RESOLVE>,\n    op6: OperatorFunction<E, F, RESOLVE>,\n    op7: OperatorFunction<F, G, RESOLVE>,\n    op8: OperatorFunction<G, H, RESOLVE>,\n    op9: OperatorFunction<H, I, RESOLVE>\n  ): Subject<I>;\n  pipe<A, B, C, D, E, F, G, H, I, RESOLVE>(\n    op1: OperatorFunction<T, A, RESOLVE>,\n    op2: OperatorFunction<A, B, RESOLVE>,\n    op3: OperatorFunction<B, C, RESOLVE>,\n    op4: OperatorFunction<C, D, RESOLVE>,\n    op5: OperatorFunction<D, E, RESOLVE>,\n    op6: OperatorFunction<E, F, RESOLVE>,\n    op7: OperatorFunction<F, G, RESOLVE>,\n    op8: OperatorFunction<G, H, RESOLVE>,\n    op9: OperatorFunction<H, I, RESOLVE>,\n    ...operations: OperatorFunction<any, any, any>[]\n  ): Subject<unknown>;\n  pipe(...operations: OperatorFunction<any, any, any>[]): Subject<any> {\n    const subject = new Subject(this._value)\n    subject.methods = operations\n    subject.subscribeWith = (x) => this.subscribe(x as any)\n    subject.set = x => this.set(x)\n    subject.next = subject.set\n    return subject\n  }\n\n  static all<A, B, C, D, E, F>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C, Subject<D> | D, Subject<E> | E, Subject<F> | F]): Subject<[A,B,C,D,E,F]>\n  static all<A, B, C, D, E>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C, Subject<D> | D, Subject<E> | E]): Subject<[A,B,C,D,E]>\n  static all<A, B, C, D>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C, Subject<D> | D]): Subject<[A,B,C,D]>\n  static all<A, B, C>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C]): Subject<[A,B,C]>\n  static all<A, B>(args: [Subject<A> | A, Subject<B> | B]): Subject<[A,B]>\n  static all<A>(args: [Subject<A> | A]): Subject<[A]>\n  static all(args: any[]): Subject<any> {\n    const switched = args.map(arg => {\n      if(isSubjectInstance(arg)) return arg;\n\n      // Call the callback immediately with the current value\n      const x = new Subject(arg, subscription => {\n        subscription.next(arg)\n        return subscription    \n      })\n\n      return x\n    })\n\n    return combineLatest(switched as Subject<any>[]) as any\n  }\n\n  static globalSubCount$ = new Subject<number>(0) // for ease of debugging\n}\n","import { Subject } from './Subject.class'\nimport { SubjectSubscriber, Subscription } from './subject.utils'\n\ntype ValueSubjectSubscriber<T> = (\n  value: T,\n  subscription: Subscription<T>,\n) => unknown\n\nexport class ValueSubject<T> extends Subject<T> {\n  declare _value: T\n\n  constructor(value: T) {\n    super(value)\n  }\n\n  get value() {\n    return this._value\n  }\n\n  set value(newValue) {\n    this._value = newValue;\n    this.set(newValue)\n  }\n\n  subscribe(callback: ValueSubjectSubscriber<T>) {\n    const subscription = super.subscribe(callback as SubjectSubscriber<T>)\n    \n    // Call the callback immediately with the current value\n    callback(this._value, subscription)\n\n    return subscription\n  }\n}\n","import { setUse } from '../state'\n\nexport function getSupportInCycle() {\n  return setUse.memory.stateConfig.tagSupport\n}\n","import { BaseTagSupport, TagSupport } from '../tag/TagSupport.class'\nimport { ProviderConfig } from './providers'\nimport { Config } from './state.utils'\n\nconst tagUse: TagUse[] = []\n\ninterface TagUse {\n  // runs only one time at creation of component html elements\n  beforeRender: (tagSupport: BaseTagSupport, ownerTag?: TagSupport) => void\n  \n  // runs every render\n  beforeRedraw: (tagSupport: BaseTagSupport, tag: TagSupport) => void\n  \n  // runs every render\n  afterRender: (tagSupport: BaseTagSupport, ownerTagSupport?: TagSupport) => void\n  \n  beforeDestroy: (tagSupport: BaseTagSupport, tag: TagSupport) => void\n}\n\nexport type UseOptions = {\n  beforeRender?: (\n    tagSupport: BaseTagSupport,\n    ownerTag?: TagSupport, // not defined on tagElement app\n  ) => void\n  beforeRedraw?: (tagSupport: BaseTagSupport, tag: TagSupport) => void\n  afterRender?: (tagSupport: BaseTagSupport, ownerTagSupport?: TagSupport) => void\n  beforeDestroy?: (tagSupport: BaseTagSupport, tag: TagSupport) => void\n}\n\nexport function setUse(use: UseOptions) {\n  // must provide defaults\n  const useMe: TagUse = {\n    beforeRender: use.beforeRender || (() => undefined),\n    beforeRedraw: use.beforeRedraw || (() => undefined),\n    afterRender: use.afterRender || (() => undefined),\n    beforeDestroy: use.beforeDestroy || (() => undefined),\n  }\n\n  setUse.tagUse.push(useMe)\n}\n\nsetUse.tagUse = tagUse\nsetUse.memory = {} as UseMemory\n\ntype UseMemory = (Record<string,any> & {\n  stateConfig: Config\n  providerConfig: ProviderConfig\n  currentSupport: TagSupport // tag being rendered\n})\n","export type TagErrorDetails = Record<string, unknown>\nexport type TagErrorFullDetails = Record<string, unknown> & {errorCode: string}\n\nexport class TagError extends Error {\n  details: TagErrorFullDetails\n\n  constructor(\n    message: string,\n    errorCode: string,\n    details: Record<string, unknown> = {},\n  ) {\n    super(message);\n    this.name = TagError.name;\n    this.details = {...details, errorCode}\n  }\n}\n\nexport class ArrayNoKeyError extends TagError {\n  constructor(message: string, details?: TagErrorDetails) {\n    super(message, 'array-no-key-error', details);\n    this.name = ArrayNoKeyError.name;\n  }\n}\n\nexport class StateMismatchError extends TagError {\n  constructor(message: string, details?: TagErrorDetails) {\n    super(message, 'state-mismatch-error', details);\n    this.name = StateMismatchError.name;\n  }\n}\n\nexport class SyncCallbackError extends TagError {\n  constructor(message: string, details?: TagErrorDetails) {\n    super(message, 'sync-callback-error', details);\n    this.name = SyncCallbackError.name;\n  }\n}\n","import { StateMismatchError } from '../errors'\nimport { BaseTagSupport } from '../tag/TagSupport.class'\nimport { Wrapper } from '../tag/TemplaterResult.class'\nimport { setUse } from './setUse.function'\n\nexport type StateConfig<T> = (x: T) => [T, T]\n\nexport type StateConfigItem<T> = {\n  get: () => T // TODO: only a convenience, not needed, remove\n  callback?: StateConfig<T>\n  lastValue?: T\n  defaultValue?: T\n  watch?: T // when this value changes, the state becomes this value\n}\n\nexport type Config = {\n  tagSupport?: BaseTagSupport\n  array: State // state memory on the first render\n  rearray?: State // state memory to be used before the next render\n}\n\nexport type State = StateConfigItem<any>[]\n\nsetUse.memory.stateConfig = {\n  array: [] as State, // state memory on the first render\n  // rearray: [] as State,\n} as Config\n\nexport type GetSet<T> = (y: T) => [T, T]\n\nconst beforeRender = (tagSupport: BaseTagSupport) => initState(tagSupport)\n\nsetUse({\n  beforeRender,\n  beforeRedraw: beforeRender,\n  afterRender: (\n    tagSupport: BaseTagSupport,\n  ) => {\n    const memory = tagSupport.memory\n    const config: Config = setUse.memory.stateConfig\n    const rearray = config.rearray as unknown as State[]\n    \n    if(rearray.length) {\n      if(rearray.length !== config.array.length) {\n        const message = `States lengths have changed ${rearray.length} !== ${config.array.length}. State tracking requires the same amount of function calls every render. Typically this errors is thrown when a state like function call occurs only for certain conditions or when a function is intended to be wrapped with a tag() call`\n        const wrapper = tagSupport.templater?.wrapper as Wrapper\n        const details = {\n          oldStates: config.array,\n          newStates: config.rearray,\n          tagFunction: wrapper.parentWrap.original,\n        }\n        const error = new StateMismatchError(message,details)\n        console.warn(message,details)\n        throw error\n      }\n    }\n    \n    delete config.rearray // clean up any previous runs\n    delete config.tagSupport\n\n    memory.state.length = 0\n    memory.state.push(...config.array)\n    const state = memory.state\n    for (let index = state.length - 1; index >= 0; --index) {\n      const item = state[index]\n      item.lastValue = getStateValue(item) // set last values\n    }\n    \n    config.array = []\n  }\n})\n\nexport function getStateValue<T>(\n  state: StateConfigItem<T>,\n) {\n  const callback = state.callback\n  \n  if(!callback) {\n    return state.defaultValue\n  }\n\n  const [value,checkValue] = getCallbackValue(callback)\n\n  if(checkValue !== StateEchoBack) {\n    const message = 'State property not used correctly. Second item in array is not setting value as expected.\\n\\n' +\n    'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n    'For \"const\" state use `const name = state(default)()`\\n\\n' +\n    'Problem state:\\n' + (callback ? callback.toString() : JSON.stringify(state)) +'\\n'\n    \n    console.error(message, {state, callback, value, checkValue})\n    \n    throw new Error(message)\n  }\n\n  return value\n}\n\nexport class StateEchoBack {}\n\nfunction initState(\n  tagSupport: BaseTagSupport\n) {\n  const memory = tagSupport.memory\n  const state = memory.state as State\n  const config: Config = setUse.memory.stateConfig\n  \n  // TODO: The following two blocks of code are state protects, have a production mode that removes this checks\n  /*\n  if (config.rearray) {\n    checkStateMismatch(tagSupport, config, state)\n  }\n  */\n\n  config.rearray = []\n  const stateLength = state?.length\n  if(stateLength) {\n    for (let index=0; index < stateLength; ++index) {\n      getStateValue(state[index])\n    }\n    config.rearray.push( ...state )\n  }\n\n  config.tagSupport = tagSupport\n}\n\n/*\nfunction checkStateMismatch(\n  tagSupport: BaseTagSupport,\n  config: Config,\n  state: State,\n) {\n  const wrapper = tagSupport.templater?.wrapper as Wrapper\n  const wasWrapper = config.tagSupport?.templater.wrapper as Wrapper\n  const message = 'last state not cleared. Possibly in the middle of rendering one component and another is trying to render'\n\n  if(!wasWrapper) {\n    return // its not a component or was not a component before\n  }\n\n  console.error(message, {\n    config,\n    tagFunction: wrapper.parentWrap.original,\n    wasInMiddleOf: wasWrapper.parentWrap.original,\n    state,\n    expectedClearArray: config.rearray,\n  })\n\n  throw new StateMismatchError(message, {\n    config,\n    tagFunction: wrapper.parentWrap.original,\n    state,\n    expectedClearArray: config.rearray,\n  })\n}\n*/\n\nexport function getCallbackValue<T>(\n  callback: StateConfig<T>\n): [T, T] {\n  const oldState = callback(StateEchoBack as any) // get value and set to undefined\n  const [value] = oldState\n  const [checkValue] = callback( value ) // set back to original value\n  return [value, checkValue]\n}\n","import { State } from \"./state.utils\"\n\nexport function syncStates(\n  stateFrom: State,\n  stateTo: State,\n) {\n  for (let index = stateFrom.length - 1; index >= 0; --index) {\n    const state = stateFrom[index]\n    const fromValue = state.get()\n    const callback = stateTo[index].callback\n\n    if(callback) {\n      callback( fromValue ) // set the value\n    }\n    \n    stateTo[index].lastValue = fromValue // record the value\n  }\n}\n","import { TagSupport } from '../tag/TagSupport.class'\nimport { setUse } from './setUse.function'\nimport { Config, StateConfig, State, StateConfigItem, getStateValue } from './state.utils'\nimport { syncStates } from './syncStates.function'\n\n/** Used for variables that need to remain the same variable during render passes */\nexport function state <T>(\n  defaultValue: T | (() => T),\n): T {\n  const config: Config = setUse.memory.stateConfig\n  let getSetMethod: StateConfig<T>\n  const rearray = config.rearray as State\n\n  const restate = rearray[config.array.length]\n  if(restate) {\n    let oldValue = getStateValue(restate) as T\n    getSetMethod = ((x: T) => [oldValue, oldValue = x])\n    const push: StateConfigItem<T> = {\n      get: () => getStateValue(push) as T,\n      callback: getSetMethod,\n      lastValue: oldValue,\n      defaultValue: restate.defaultValue,\n    }\n\n    config.array.push(push)\n\n    return oldValue\n  }\n\n  // State first time run\n  const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue\n  let initValue = defaultFn()\n\n  // the state is actually intended to be a function\n  if(initValue instanceof Function) {\n    const oldState = config.array\n    const tagSupport = config.tagSupport as TagSupport\n    const original = initValue\n    \n    initValue = ((...args: any[]) => {\n      const global = tagSupport.global\n      const newest = global.newest as TagSupport\n      const newState = newest.memory.state\n      \n      syncStates(newState, oldState)\n\n      const result = original(...args)\n      \n      syncStates(oldState, newState)\n      \n      return result\n    }) as any\n\n    ;(initValue as any).original = original\n  }\n\n  getSetMethod = ((x: T) => [initValue, initValue = x])\n  const push: StateConfigItem<T> = {\n    get: () => getStateValue(push) as T,\n    callback: getSetMethod,\n    lastValue: initValue,\n    defaultValue: initValue,\n  }\n  config.array.push(push)\n  \n  return initValue\n}\n","import { Subject, ValueSubject } from '../subject'\nimport { TagSupport } from '../tag/TagSupport.class'\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function'\nimport { setUse } from './setUse.function'\nimport { state } from './state.function'\nimport { syncStates } from './syncStates.function'\n\nexport type WatchCallback<T> = (\n  currentValues: any[],\n  previousValues: any[] | undefined // first run this is undefined\n) => T | ((currentValues: any[]) => T) | (() => T)\n\ntype WatchOperators<T> = {\n  setup: WatchSetup<T>,\n  /** When an item in watch array changes, callback function will be triggered. Does not trigger on initial watch setup. */\n  noInit: (<T>(\n    currentValues: any[],\n    callback: WatchCallback<T>\n  ) => T | undefined) & MasterWatch<T>\n  \n  /** When an item in watch array changes, callback function will be triggered */\n  asSubject: (<T>(\n    currentValues: any[],\n    callback: WatchCallback<T>\n  ) => Subject<T>) & MasterWatch<T>\n  \n  /** When an item in watch array changes and all values are truthy then callback function will be triggered */\n  truthy: (<T>(\n    currentValues: any[],\n    callback: WatchCallback<T>\n  ) => T | undefined) & MasterWatch<T>\n}\n\ntype WatchResult<T> = ((\n  currentValues: any[],\n  callback: WatchCallback<T>\n) => T) & WatchOperators<T>\n\ntype MasterWatch<T> = ((\n  currentValues: any[],\n  callback: WatchCallback<T>\n) => T) & WatchOperators<T>\n\n/**\n * When an item in watch array changes, callback function will be triggered. Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = (<T>(\n  currentValues: any[],\n  callback: WatchCallback<T>\n): T => {\n  return setupWatch(currentValues, callback)\n}) as MasterWatch<any>\n\nconst defaultFinally = <T>(x: T) => x\n\ntype WatchSetup<R> = {\n  init?: (currentValues: any[], previousValues: any[]) => R\n  final?: (x: any) => any,\n  before?: (currentValues: any[]) => boolean,\n}\n\nfunction newWatch<T, R>(\n  setup: WatchSetup<R>\n): WatchResult<T> {\n  const method = <T>(\n    currentValues: any[],\n    callback: WatchCallback<T>  \n  ) => {\n    return setupWatch(currentValues, callback, setup)\n  }\n\n  method.setup = setup\n\n  defineOnMethod(() => method as any, method)\n  \n  return method as any\n}\n\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2 \n * @returns \n */\nconst setupWatch = <T, R>(\n  currentValues: any[],\n  callback: WatchCallback<T>,\n  {\n    init,\n    before = () => true,\n    final = defaultFinally,  \n  }: WatchSetup<R> = {}\n): T => {\n  let previous = state({\n    pastResult: undefined as T,\n    values: undefined as unknown as any[],\n  })\n\n  const previousValues = previous.values\n\n  // First time running watch?\n  if(previousValues === undefined) {\n    if(!before(currentValues)) {\n      previous.values = currentValues\n      return previous.pastResult // do not continue\n    }\n  \n    const castedInit = init || callback\n    const result = castedInit(currentValues, previousValues)\n    previous.pastResult = final(result)\n    previous.values = currentValues\n    return previous.pastResult\n  }\n\n  const allExact = currentValues.every((item, index) =>\n    item === (previousValues as any[])[index]\n  )\n  if(allExact) {\n    return previous.pastResult\n  }\n\n  if(!before(currentValues)) {\n    previous.values = currentValues\n    return previous.pastResult // do not continue\n  }\n\n  const result = callback(currentValues, previousValues) as T\n  previous.pastResult = final(result)\n  previousValues.length = 0\n  previousValues.push(...currentValues)\n\n  return previous.pastResult\n}\n\nfunction defineOnMethod<R>(\n  getWatch: () => WatchResult<unknown>,\n  attachTo: R\n): R {  \n  Object.defineProperty(attachTo, 'noInit', {\n    get() {\n      const watch = getWatch()\n      watch.setup.init = () => undefined\n      return watch\n    },\n  })\n\n  Object.defineProperty(attachTo, 'asSubject', {\n    get() {\n      const oldWatch = getWatch()\n      \n      const method = <T>(\n        currentValues: any[],\n        callback: WatchCallback<T>  \n      ) => {\n        const originalState = state(() => (getSupportInCycle() as TagSupport).memory.state)\n        const subject = state(() => new ValueSubject<any>(undefined))\n        \n        setupWatch(\n          currentValues,\n          (currentValues, previousValues) => {\n            const setTo = callback(currentValues, previousValues)\n            \n            if(originalState.length) {\n              const newestState = setUse.memory.stateConfig.array\n              syncStates(\n                newestState,\n                originalState,\n              )\n            }\n\n            subject.set( setTo )\n          },\n          oldWatch.setup\n        )\n\n        return subject\n      }\n\n      method.setup = oldWatch.setup\n\n      defineOnMethod(() => method as any, method)\n      \n      return method\n      /*\n      method.setup = setup\n    \n      defineOnMethod(() => method as any, method)\n      \n      return method as any\n\n      \n      const oldWatch = getWatch()\n      const watch = newWatch( oldWatch.setup )\n      // const watch = getWatch()\n      \n      const subject = state(() => new Subject())\n      watch.setup.final = (x: any) => {\n        subject.set(x)\n        return subject\n      }\n      return watch\n      */\n    },\n  })\n\n  Object.defineProperty(attachTo, 'truthy', {\n    get() {\n      const watch = getWatch()\n      watch.setup.before = (currentValues: any[]) => currentValues.every(x => x)\n      return watch\n    },\n  })\n\n  return attachTo\n}\n\ndefineOnMethod(() => newWatch({}), watch)\n","import { OnSubscription, Subject, ValueSubject } from \"../subject\";\nimport { TagSupport } from \"../tag/TagSupport.class\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function\";\nimport { setUse } from \"./setUse.function\";\nimport { state } from \"./state.function\";\nimport { syncStates } from \"./syncStates.function\";\n\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject<T>(\n  value?: T,\n  onSubscription?: OnSubscription<T>\n) {\n  const oldestState = state(() => setUse.memory.stateConfig.array)\n  const nowTagSupport = getSupportInCycle() as TagSupport\n  return state(() => {\n    const subject = new Subject(value, onSubscription).pipe(x => {\n      syncStates(nowTagSupport.memory.state, oldestState)\n      return x\n    })\n    return subject\n  })\n}\n\nsubject.value = <T>(value: T) => {\n  const oldestState = state(() => setUse.memory.stateConfig.array)\n  const nowTagSupport = getSupportInCycle() as TagSupport\n  return state(() => {\n    const subject = new ValueSubject(value).pipe(x => {\n      syncStates(nowTagSupport.memory.state, oldestState)\n      return x\n    })\n    return subject\n  })  \n}\n\nfunction all<A, B, C, D, E, F>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C, Subject<D> | D, Subject<E> | E, Subject<F> | F]): Subject<[A,B,C,D,E,F]>\nfunction all<A, B, C, D, E>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C, Subject<D> | D, Subject<E> | E]): Subject<[A,B,C,D,E]>\nfunction all<A, B, C, D>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C, Subject<D> | D]): Subject<[A,B,C,D]>\nfunction all<A, B, C>(args: [Subject<A> | A, Subject<B> | B, Subject<C> | C]): Subject<[A,B,C]>\nfunction all<A, B>(args: [Subject<A> | A, Subject<B> | B]): Subject<[A,B]>\nfunction all<A>(args: [Subject<A> | A]): Subject<[A]>\nfunction all(args: any[]): Subject<any> {\n  const oldestState = state(() => setUse.memory.stateConfig.array)\n  const nowTagSupport = getSupportInCycle() as TagSupport\n  return Subject.all(args as any).pipe(x => {\n    syncStates(nowTagSupport.memory.state, oldestState)\n    return x\n  })\n}\n\nsubject.all = all","import { Config, GetSet, StateConfig, State, StateConfigItem, getStateValue } from './state.utils'\nimport { setUse } from './setUse.function'\n\n/** Used for variables that need to remain the same variable during render passes */\nexport function letState <T>(\n  defaultValue: T | (() => T),\n): ((getSet: GetSet<T>) => T) {\n  const config: Config = setUse.memory.stateConfig\n  const rearray = config.rearray as State\n  let getSetMethod: StateConfig<T>  \n\n  const restate = rearray[config.array.length]\n  \n  if(restate) {\n    let oldValue = getStateValue(restate) as T\n\n    getSetMethod = ((x: T) => [oldValue, oldValue = x])\n    const push: StateConfigItem<T> = {\n      get: () => getStateValue(push) as T,\n      callback: getSetMethod,\n      lastValue: oldValue,\n      defaultValue: restate.defaultValue,\n    }\n\n    config.array.push(push)\n\n    return makeStateResult(oldValue, push)\n  }\n\n  // State first time run\n  const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue\n  let initValue = defaultFn()\n\n  getSetMethod = ((x: T) => [initValue, initValue = x])\n  const push: StateConfigItem<T> = {\n    get: () => getStateValue(push) as T,\n    callback: getSetMethod,\n    lastValue: initValue,\n    defaultValue: initValue,\n  }\n  config.array.push(push)\n  \n  return makeStateResult(initValue, push)\n}\n\nfunction makeStateResult<T>(\n  initValue: T,\n  push: StateConfigItem<T>,\n) {\n  // return initValue\n  const result =  (y: any) => {\n    push.callback = y || (x => [initValue, initValue = x])\n\n    return initValue\n  }\n\n  return result\n}\n","export function deepClone(\n  obj: any,\n) {\n  return makeDeepClone(obj, new WeakMap())\n}\n\nfunction makeDeepClone(\n  obj: any,\n  visited: WeakMap<any, any>\n) {\n  // If obj is a primitive type or null, return it directly\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  // If obj is already visited, return the cloned reference\n  if (visited.has(obj)) {\n    return visited.get(obj)\n  }\n\n  // Handle special cases like Date and RegExp\n  if (obj instanceof Date) {\n    return new Date(obj)\n  }\n\n  if (obj instanceof RegExp) {\n    return new RegExp(obj)\n  }\n\n  // Create an empty object or array with the same prototype\n  const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n\n  // Register the cloned object to avoid cyclic references\n  visited.set(obj, clone)\n\n  // Clone each property or element of the object or array\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      clone[i] = makeDeepClone(obj[i], visited)\n    }\n  } else {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        clone[key] = makeDeepClone(obj[key], visited)\n      }\n    }\n  }\n\n  return clone;\n}\n\nexport function deepEqual(\n  obj1: any,\n  obj2: any,\n) {\n  return isDeepEqual(obj1, obj2, new WeakMap())\n}\n\nfunction isDeepEqual(\n  obj1: any,\n  obj2: any,\n  visited: WeakMap<any, any>,\n) {\n  const directEqual = obj1 === obj2\n  if (directEqual || isSameFunctions(obj1,obj2)) {\n    return true\n  }\n\n  // If obj is already visited, return the cloned reference\n  if (visited.has(obj1)) {\n    return true\n  }\n  \n  if(typeof obj1 === 'object' && typeof obj2 === 'object') {\n    // both are dates and were already determined not the same\n    if(obj1 instanceof Date && obj2 instanceof Date) {\n      return obj1.getTime() === obj2.getTime()\n    }\n\n    // Register the cloned object to avoid cyclic references\n    visited.set(obj1, 0)\n\n    // Check if obj1 and obj2 are both arrays\n    if (Array.isArray(obj1) && Array.isArray(obj2)) {\n      return isArrayDeepEqual(obj1, obj2, visited)\n    } else if (Array.isArray(obj1) || Array.isArray(obj2)) {\n      // One is an array, and the other is not\n      return false\n    }\n\n    return isObjectDeepEqual(obj1, obj2, visited)\n  }\n\n  return false\n}\n\n\nfunction isObjectDeepEqual(\n  obj1: any,\n  obj2: any,\n  visited: WeakMap<any, any>,\n) {\n  const keys1 = Object.keys(obj1)\n  const keys2 = Object.keys(obj2)\n\n  if (keys1.length === 0 && keys2.length === 0) {\n    return true\n  }\n\n  if (keys1.length !== keys2.length) {\n    return false\n  }\n\n  for (const key of keys1) {\n    const keyFound = keys2.includes(key)\n    if (!keyFound || !isDeepEqual(obj1[key], obj2[key], visited)) {\n      return false\n    }\n  }\n\n  return true\n}\n\n\nfunction isArrayDeepEqual(\n  obj1: any[],\n  obj2: any[],\n  visited: WeakMap<any, any>,\n) {\n  if (obj1.length !== obj2.length) {\n    return false\n  }\n\n  for (let i = 0; i < obj1.length; i++) {\n    if (!isDeepEqual(obj1[i], obj2[i], visited)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isSameFunctions(\n  fn0: Function,\n  fn1: Function\n): Boolean {\n  const bothFunction = fn0 instanceof Function && fn1 instanceof Function\n  return bothFunction && fn0.toString() === fn1.toString()\n}\n","import { deepClone } from '../deepFunctions'\nimport { BaseTagSupport, TagSupport } from '../tag/TagSupport.class'\nimport { setUse } from './setUse.function'\nimport { state } from './state.function'\n\nexport type Provider = {\n  constructMethod: any\n  instance: any\n  clone: any\n  stateDiff: number\n}\n\ntype ProviderConstructor<T> = (new (...args: any[]) => T) | (() => T)\n\nexport type ProviderConfig = {\n  providers: Provider[]\n  ownerSupport?: TagSupport\n}\n\nsetUse.memory.providerConfig = {\n  providers: [] as Provider[],\n  ownerSupport: undefined,\n}\n\ntype functionProvider<T> = () => T\ntype classProvider<T> = new (...args: any[]) => T\ntype Construct<T> = classProvider<T> | functionProvider<T>\ntype ConstructMethod<T> = Construct<T> & {\n  compareTo: string\n}\n\nexport const providers = {\n  create: <T>(\n    constructMethod: Construct<T>\n  ): T => {\n    const stateDiffMemory = state(() => ({stateDiff: 0, provider: undefined as any as Provider}))\n\n    // mimic how many states were called the first time\n    if(stateDiffMemory.stateDiff) {\n      for(let x = stateDiffMemory.stateDiff; x > 0; --x){\n        state(undefined)\n      }\n      const result = state(undefined) as T\n      // stateDiffMemory.provider.constructMethod.compareTo = compareTo\n      return result\n    }\n\n    const result = state(() => {\n      const memory = setUse.memory\n      const stateConfig = memory.stateConfig\n      const oldStateCount = stateConfig.array.length\n      // Providers with provider requirements just need to use providers.create() and providers.inject()\n      const instance: T = 'prototype' in constructMethod ? new (constructMethod as classProvider<T>)() : (constructMethod as functionProvider<T>)()\n  \n      const stateDiff = stateConfig.array.length - oldStateCount\n      \n      const config = memory.providerConfig\n      const provider = {\n        constructMethod,\n        instance,\n        clone: deepClone(instance),\n        stateDiff,\n      } as Provider\n\n      stateDiffMemory.provider = provider\n      config.providers.push(provider)\n      stateDiffMemory.stateDiff = stateDiff\n\n      return instance\n    })\n\n    const cm = constructMethod as ConstructMethod<T>\n    // const compareTo = cm.compareTo = cm.compareTo || cm.toString()\n    const compareTo = cm.compareTo = cm.toString()\n    stateDiffMemory.provider.constructMethod.compareTo = compareTo\n\n    return result\n  },\n  \n  /**\n   * @template T\n   * @param {(new (...args: any[]) => T) | () => T} constructor \n   * @returns {T}\n   */\n  inject: <T>(constructor: ProviderConstructor<T>): T => {\n    // find once, return same every time after\n    return state(() => {\n      const config = setUse.memory.providerConfig\n      const cm = constructor as ConstructMethod<T>\n      const compareTo = cm.compareTo = cm.compareTo || constructor.toString()\n\n      let owner = {\n        ownerTagSupport: config.ownerSupport\n      } as TagSupport\n    \n      while(owner.ownerTagSupport) {\n        const ownerProviders = owner.ownerTagSupport.global.providers\n  \n        const provider = ownerProviders.find(provider => {\n          const constructorMatch = provider.constructMethod.compareTo === compareTo\n          \n          if(constructorMatch) {\n            return true\n          }\n        })\n  \n        if(provider) {\n          provider.clone = deepClone(provider.instance) // keep a copy of the latest before any change occur\n          config.providers.push(provider)\n          return provider.instance\n        }\n  \n        owner = owner.ownerTagSupport // cause reloop checking next parent\n      }\n      \n      const msg = `Could not inject provider: ${constructor.name} ${constructor}`\n      console.warn(`${msg}. Available providers`, config.providers)\n      throw new Error(msg)  \n    })\n  }\n}\n\nsetUse({ // providers\n  beforeRender: (\n    tagSupport: BaseTagSupport,\n    ownerSupport?: TagSupport,\n  ) => {\n    run(tagSupport, ownerSupport)\n  },\n  beforeRedraw: (\n    tagSupport: BaseTagSupport,\n    newTagSupport: TagSupport,\n  ) => {\n    run(tagSupport, newTagSupport.ownerTagSupport)\n  },\n  afterRender: (\n    tagSupport: BaseTagSupport,\n    // tag: Tag\n  ) => {\n    const config = setUse.memory.providerConfig\n    tagSupport.global.providers = [...config.providers]\n    config.providers.length = 0\n  }\n})\n\nfunction run(\n  tagSupport: BaseTagSupport,\n  ownerSupport?: TagSupport,\n) {\n  const config = setUse.memory.providerConfig  \n  config.ownerSupport = ownerSupport\n  \n  if(tagSupport.global.providers.length) {\n    config.providers.length = 0\n    config.providers.push(...tagSupport.global.providers)\n  }\n}\n","import { deepClone, deepEqual } from '../deepFunctions'\nimport { Provider } from './providers'\nimport { renderTagSupport } from '../tag/render/renderTagSupport.function'\nimport { TagSupport } from '../tag/TagSupport.class'\n\nexport function providersChangeCheck(\n  tagSupport: TagSupport\n) {\n  const global = tagSupport.global\n  const providersWithChanges = global.providers.filter(provider =>\n    !deepEqual(provider.instance, provider.clone)\n  )\n\n  // reset clones\n  for (let index = providersWithChanges.length - 1; index >= 0; --index) {\n    const provider = providersWithChanges[index]\n    const appSupport = tagSupport.getAppTagSupport()\n\n    handleProviderChanges(appSupport, provider)\n\n    provider.clone = deepClone(provider.instance)\n  }\n}\n\nfunction handleProviderChanges(\n  appSupport: TagSupport,\n  provider: Provider,\n) {\n  const tagsWithProvider = getTagsWithProvider(appSupport, provider)\n\n  for (let index = tagsWithProvider.length - 1; index >= 0; --index) {\n    const {tagSupport, renderCount, provider} = tagsWithProvider[index]\n    if(tagSupport.global.deleted) {\n      continue // i was deleted after another tag processed\n    }\n\n    const notRendered = renderCount === tagSupport.global.renderCount\n    if(notRendered) {\n      provider.clone = deepClone(provider.instance)\n      renderTagSupport(\n        tagSupport,\n        false,\n      )\n      continue\n    }\n  }\n}\n\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(\n  tagSupport: TagSupport,\n  provider: Provider,\n  memory: TagWithProvider[] = []\n) {\n  const global = tagSupport.global\n  const compare = global.providers\n  const hasProvider = compare.find(\n    xProvider => xProvider.constructMethod.compareTo === provider.constructMethod.compareTo\n  )\n  \n  if(hasProvider) {\n    memory.push({\n      tagSupport,\n      renderCount: global.renderCount,\n      provider: hasProvider,\n    })\n  }\n\n  const childTags = tagSupport.childTags\n  for (let index = childTags.length - 1; index >= 0; --index) {\n    getTagsWithProvider(\n      childTags[index],\n      provider,\n      memory,\n    )\n  }\n\n  return memory\n}\n\ntype TagWithProvider = {\n  tagSupport: TagSupport\n  renderCount: number\n  provider: Provider,\n}\n","import { BaseTagSupport, TagSupport } from './TagSupport.class'\nimport { setUse } from '../state'\nimport { Subject } from '../subject'\nimport { getSupportInCycle } from './getSupportInCycle.function'\n\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nsetUse.memory.tagClosed$ = new Subject<TagSupport>(undefined, subscription => {\n  if( !getSupportInCycle() ) {\n    subscription.next() // we are not currently processing so process now\n  }\n})\n\n// Life cycle 1\nexport function runBeforeRender(\n  tagSupport: BaseTagSupport,\n  ownerSupport?: TagSupport,\n) {\n  const tagUse = setUse.tagUse\n  const length = tagUse.length\n  for (let index=0; index < length; ++index) {\n    tagUse[index].beforeRender(tagSupport, ownerSupport)\n  }\n}\n\n// Life cycle 2\nexport function runAfterRender(\n  tagSupport: BaseTagSupport,\n  ownerTagSupport?: TagSupport,\n) {\n  const tagUse = setUse.tagUse\n  const length = tagUse.length\n  for (let index=0; index < length; ++index) {\n    tagUse[index].afterRender(tagSupport, ownerTagSupport)\n  }\n\n  setUse.memory.tagClosed$.next(ownerTagSupport)\n}\n\n// Life cycle 3\nexport function runBeforeRedraw(\n  tagSupport: BaseTagSupport,\n  ownerTagSupport: TagSupport,\n) {\n  const tagUse = setUse.tagUse\n  const length = tagUse.length\n  for (let index=0; index < length; ++index) {\n    tagUse[index].beforeRedraw(tagSupport, ownerTagSupport)\n  }\n}\n\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(\n  tagSupport: BaseTagSupport,\n  ownerTagSupport: TagSupport,\n) {\n  const tagUse = setUse.tagUse\n  const length = tagUse.length\n  for (let index=0; index < length; ++index) {\n    tagUse[index].beforeDestroy(tagSupport, ownerTagSupport)\n  }\n}\n","import { BaseTagSupport, TagSupport } from '../TagSupport.class'\nimport { runBeforeRedraw, runBeforeRender } from '../tagRunner'\nimport { setUse } from '../../state'\nimport { runAfterRender } from '../tagRunner'\nimport { TagSubject } from '../../subject.types'\nimport { Wrapper } from '../TemplaterResult.class'\n\nexport function renderTagOnly(\n  newTagSupport: TagSupport,\n  lastSupport: TagSupport | undefined,\n  subject: TagSubject,\n  ownerSupport?: TagSupport,\n): TagSupport {\n  const oldRenderCount = newTagSupport.global.renderCount\n\n  beforeWithRender(newTagSupport, ownerSupport, lastSupport)\n  \n  const templater = newTagSupport.templater\n\n  // NEW TAG CREATED HERE\n  const wrapper = templater.wrapper as Wrapper\n  let reSupport = wrapper(newTagSupport, subject)\n  /* AFTER */\n\n  runAfterRender(newTagSupport, ownerSupport)\n\n  // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n  if(reSupport.global.renderCount > oldRenderCount + 1) {\n    return newTagSupport.global.newest as TagSupport\n  }\n  \n  newTagSupport.global.newest = reSupport\n\n  return reSupport\n}\n\nfunction beforeWithRender(\n  tagSupport: BaseTagSupport, // new\n  ownerSupport?: TagSupport,\n  lastSupport?: TagSupport,\n) {\n  const lastOwnerSupport = lastSupport?.ownerTagSupport\n  const runtimeOwnerSupport: TagSupport | undefined = lastOwnerSupport || ownerSupport\n\n  if(lastSupport) {\n    const lastState = lastSupport.memory.state\n    const memory = tagSupport.memory\n    // memory.state.length = 0\n    // memory.state.push(...lastState)\n    memory.state = [...lastState]\n    tagSupport.global = lastSupport.global\n\n    runBeforeRedraw(tagSupport, lastSupport)\n  } else {\n    // first time render\n    runBeforeRender(tagSupport, runtimeOwnerSupport)\n\n    // TODO: Logic below most likely could live within providers.ts inside the runBeforeRender function\n    const providers = setUse.memory.providerConfig\n    providers.ownerSupport = runtimeOwnerSupport\n  }\n}","import { TagSupport } from '../TagSupport.class'\nimport { isLikeTags } from '../isLikeTags.function'\nimport { destroyTagMemory } from '../destroyTag.function'\nimport { TagSubject, WasTagSubject } from '../../subject.types'\nimport { renderTagOnly } from './renderTagOnly.function'\n\nexport function renderWithSupport(\n  newTagSupport: TagSupport,\n  lastSupport: TagSupport | undefined, // previous\n  subject: TagSubject, // events & memory\n  ownerSupport?: TagSupport, // who to report to\n): TagSupport {\n  const reSupport = renderTagOnly(\n    newTagSupport, lastSupport, subject, ownerSupport,\n  )\n\n  const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport)\n  if(!isLikeTag) {\n    destroyUnlikeTags(\n      lastSupport,\n      reSupport,\n      subject,\n    )\n  }\n\n  const lastOwnerSupport = lastSupport?.ownerTagSupport\n  reSupport.ownerTagSupport = (ownerSupport || lastOwnerSupport) as TagSupport\n\n  return reSupport\n}\n\nfunction destroyUnlikeTags(\n  lastSupport: TagSupport, // old\n  reSupport: TagSupport, // new\n  subject: TagSubject,\n) {\n  const oldGlobal = lastSupport.global\n  const insertBefore = oldGlobal.insertBefore as Element\n  \n  destroyTagMemory(lastSupport)\n\n  // when a tag is destroyed, disconnect the globals\n  reSupport.global = {...oldGlobal} // break memory references\n  const global = reSupport.global\n  \n  global.insertBefore = insertBefore\n  global.deleted = false\n  \n  delete global.oldest\n  delete global.newest\n  delete (subject as WasTagSubject).tagSupport\n}\n","import { BaseTagSupport, TagSupport } from '../TagSupport.class'\nimport { providersChangeCheck } from '../../state/provider.utils'\nimport { TagSubject } from '../../subject.types'\nimport { isLikeTags } from '../isLikeTags.function'\nimport { renderWithSupport } from './renderWithSupport.function'\n\n/** Returns true when rendering owner is not needed. Returns false when rendering owner should occur */\nexport function renderExistingTag(\n  oldestSupport: TagSupport, // oldest with elements on html\n  newSupport: TagSupport, // new to be rendered\n  ownerSupport: BaseTagSupport, // ownerSupport\n  subject: TagSubject,\n): TagSupport {\n  const lastSupport = subject.tagSupport as TagSupport\n  const global = lastSupport.global\n  \n  // share point between renders\n  newSupport.global = global\n\n  const preRenderCount = global.renderCount\n  providersChangeCheck(oldestSupport)\n\n  // When the providers were checked, a render to myself occurred and I do not need to re-render again\n  const prevSupport = global.newest as TagSupport\n  if(preRenderCount !== global.renderCount) {\n    oldestSupport.updateBy(prevSupport)\n    return prevSupport // already rendered during triggered events\n  }\n\n  const toRedrawTag = prevSupport || lastSupport || global.oldest\n\n  const reSupport = renderWithSupport(\n    newSupport,\n    toRedrawTag,\n    subject,\n    ownerSupport as TagSupport,\n  )\n\n  const oldest = global.oldest || oldestSupport\n  reSupport.global.oldest = oldest\n\n  // TODO: renderWithSupport already does an isLikeTags compare\n  if(isLikeTags(prevSupport, reSupport)) {\n    subject.tagSupport = reSupport\n    oldest.updateBy(reSupport)\n  }\n  \n  return reSupport\n}\n","import { TagSupport } from '../TagSupport.class'\nimport { deepEqual } from '../../deepFunctions'\nimport { renderExistingTag } from './renderExistingTag.function'\nimport { Props } from '../../Props'\n\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderTagSupport(\n  tagSupport: TagSupport, // must be latest/newest state render\n  renderUp: boolean,\n): TagSupport {\n  const global = tagSupport.global\n  const templater = tagSupport.templater\n  \n  // is it just a vanilla tag, not component?\n  \n  if( !templater.wrapper ) {// || isTagTemplater(templater) \n    const ownerTag = tagSupport.ownerTagSupport as TagSupport\n    ++global.renderCount\n    return renderTagSupport(ownerTag, true)\n  }\n\n  const subject = tagSupport.subject\n  \n  let ownerSupport: undefined | TagSupport\n  let selfPropChange = false\n  const shouldRenderUp = renderUp && tagSupport\n\n  if(shouldRenderUp) {\n    ownerSupport = tagSupport.ownerTagSupport\n    if(ownerSupport) {\n      const nowProps = templater.props as Props\n      const latestProps = tagSupport.propsConfig.latestCloned\n      selfPropChange = !nowProps.every((props, index) => deepEqual(props, latestProps[index]))\n    }\n  }\n\n  const oldest = tagSupport.global.oldest as TagSupport\n  const tag = renderExistingTag(\n    oldest,\n    tagSupport,\n    ownerSupport as TagSupport, // useTagSupport,\n    subject,\n  )\n\n  const renderOwner = ownerSupport && selfPropChange\n  if(renderOwner) {  \n    const ownerTagSupport = ownerSupport as TagSupport\n    \n    renderTagSupport(\n      ownerTagSupport,\n      true,\n    )\n\n    return tag\n  }\n\n  return tag\n}\n","import { BaseTagSupport, TagSupport } from \"../tag/TagSupport.class\"\nimport { setUse } from \"./setUse.function\"\nimport { State } from \"./state.utils\"\nimport { renderTagSupport } from \"../tag/render/renderTagSupport.function\"\nimport { SyncCallbackError } from \"../errors\"\nimport { syncStates } from \"./syncStates.function\"\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function\"\n\ntype Callback<A,B,C,D,E,F, T> = (\n  a: A, b: B, c: C, d: D, e: E, f: F,\n) => T\n\n\nlet innerCallback = <A,B,C,D,E,F, T>(\n  callback: Callback<A,B,C,D,E,F,T>\n) => (a?:A, b?:B, c?:C, d?:D, e?:E, f?:F): T => {\n  throw new SyncCallbackError('Callback function was called immediately in sync and must instead be call async')\n}\nexport const callbackMaker = () => innerCallback\n\nconst originalGetter = innerCallback // callbackMaker\n\nsetUse({\n  beforeRender: (tagSupport: BaseTagSupport) => initMemory(tagSupport),\n  beforeRedraw: (tagSupport: BaseTagSupport) => initMemory(tagSupport),\n  afterRender: (tagSupport: BaseTagSupport) => {\n    ;(tagSupport.global as any).callbackMaker = true\n    innerCallback = originalGetter // prevent crossing callbacks with another tag\n  },\n})\n\nexport function callback<A,B,C,D,E,F, T>(\n  callback: Callback<A, B, C, D, E, F, T>\n): () => T {\n  const tagSupport = getSupportInCycle()\n\n  if(!tagSupport) {\n    const error = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering')\n    throw error\n  }\n\n  const oldState = setUse.memory.stateConfig.array\n  const trigger = (...args: any[]) => {\n    const callbackMaker = (tagSupport.global as any).callbackMaker\n    \n    if(callbackMaker) {\n      return triggerStateUpdate(tagSupport, callback, oldState, ...args)\n    }\n\n    return (callback as any)(...args)\n  }\n\n  return trigger\n}\n\nfunction initMemory (tagSupport: BaseTagSupport) {\n  const oldState: State = setUse.memory.stateConfig.array\n  innerCallback = (\n    callback: Callback<any, any, any, any, any, any, any>\n  ) => {    \n    const trigger = (...args: any[]) => {\n      const callbackMaker = (tagSupport.global as any).callbackMaker\n      \n      if(callbackMaker) {\n        return triggerStateUpdate(tagSupport, callback, oldState, ...args)\n      }\n\n      return (callback as any)(...args)\n    }\n\n    return trigger\n  }\n}\n\nfunction triggerStateUpdate<T>(\n  tagSupport: BaseTagSupport,\n  callback: Callback<any, any,any, any, any, any, T>,\n  oldState: State,\n  ...args: any[]\n): T {\n  const state = tagSupport.memory.state  \n\n  // ensure that the oldest has the latest values first\n  syncStates(state, oldState)\n  \n  // run the callback\n  const maybePromise = callback(...args as [any,any,any,any,any,any])\n\n  // send the oldest state changes into the newest\n  syncStates(oldState, state)\n  \n  /*\n  if(tagSupport.global.deleted) {\n    return maybePromise // While running callback the tag was deleted. Often that happens\n  }\n  */\n\n  renderTagSupport(\n    tagSupport as TagSupport,\n    false,\n  )\n\n  if(maybePromise instanceof Promise) {\n    maybePromise.finally(() => {\n      // send the oldest state changes into the newest\n      syncStates(oldState, state)\n\n      renderTagSupport(\n        tagSupport as TagSupport,\n        false,\n      )\n    })\n  }\n\n  // return undefined as T\n  return maybePromise\n}\n","import { BaseTagSupport, TagSupport } from \"../tag/TagSupport.class\"\nimport { setUse } from \"./setUse.function\"\n\nexport type OnInitCallback = () => unknown\n\nfunction setCurrentTagSupport(support: BaseTagSupport | TagSupport) {\n  setUse.memory.currentSupport = support as TagSupport\n}\n\nexport function onInit(\n  callback: OnInitCallback\n) {\n  const tagSupport = setUse.memory.currentSupport\n  if(!tagSupport.global.init) {\n    tagSupport.global.init = callback\n    callback() // fire init\n  }\n}\n\nsetUse({\n  beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n  beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n})\n","import { BaseTagSupport, TagSupport } from \"../tag/TagSupport.class\"\nimport { setUse } from \"./setUse.function\"\n\nexport type OnDestroyCallback = () => unknown\n\nfunction setCurrentTagSupport(support: BaseTagSupport | TagSupport) {\n  setUse.memory.destroyCurrentSupport = support as TagSupport\n}\n\nexport function onDestroy(\n  callback: OnDestroyCallback\n) {\n  const tagSupport = setUse.memory.destroyCurrentSupport as TagSupport\n  tagSupport.global.destroyCallback = callback\n}\n\nsetUse({\n  beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n  beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n  beforeDestroy: (tagSupport) => {\n    const callback = tagSupport.global.destroyCallback\n\n    if(callback) {\n      callback()\n    }\n  }\n})\n\n","import { BaseTagSupport, TagSupport } from \"../tag/TagSupport.class\"\nimport { setUse } from \"./setUse.function\"\n\nfunction setCurrentTagSupport(support: BaseTagSupport | TagSupport) {\n  setUse.memory.childrenCurrentSupport = support as TagSupport\n}\n\nexport function children() {\n  const tagSupport = setUse.memory.childrenCurrentSupport as TagSupport\n  const children = tagSupport.templater.children\n  return children\n}\n\nsetUse({\n  beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n  beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n})\n","import { Counts } from '../interpolations/interpolateTemplate'\nimport { State } from '../state'\nimport { InterpolatedTemplates } from '../interpolations/interpolations'\nimport { InterpolateSubject, ValueTypes } from './update/processFirstSubject.utils'\nimport { TemplaterResult } from './TemplaterResult.class'\nimport { TagValues } from './html'\n\nexport const variablePrefix = '__tagvar'\nexport const escapeVariable = '--' + variablePrefix + '--'\n\nexport const escapeSearch = new RegExp(escapeVariable, 'g')\n\nexport type Context = {\n  [index: string]: InterpolateSubject // ValueSubject<unknown>\n}\nexport type TagMemory = {\n  // context: Context\n  state: State\n}\n\nexport interface TagTemplate {\n  interpolation: InterpolatedTemplates,\n  string: string,\n  strings: string[],\n  values: unknown[],\n  context: Context,\n}\n\nexport class Tag {\n  tagJsType = ValueTypes.tag\n\n  // present only when an array. Populated by Tag.key()\n  memory = {\n  } as {\n    arrayValue?: unknown\n  }\n\n  templater!: TemplaterResult\n  \n  constructor(\n    public strings: string[],\n    public values: any[],\n  ) {}\n\n  /** Used for array, such as array.map(), calls aka array.map(x => html``.key(x)) */\n  key(arrayValue: unknown) {\n    this.memory.arrayValue = arrayValue\n    return this\n  }\n\n  // TODO: Is this just a fake function that can be data typed?\n  children?: {strings: string[] | TemplateStringsArray, values: TagValues}\n  html(\n    strings: string[] | TemplateStringsArray,\n    ...values: TagValues\n  ) {\n    this.children = {strings, values}\n    return this\n  }\n}\n\nexport type ElementBuildOptions = {\n  counts: Counts\n}\n","import { Context, Tag } from './Tag.class'\nimport { BaseTagSupport, TagSupport } from './TagSupport.class'\nimport { Props } from '../Props'\nimport { TagChildren, TagWrapper } from './tag.utils'\nimport { Provider } from '../state/providers'\nimport { OnDestroyCallback } from '../state/onDestroy'\nimport { TagSubject } from '../subject.types'\nimport { OnInitCallback } from '../state/onInit'\nimport { Subscription } from '../subject/subject.utils'\nimport { InsertBefore } from '../interpolations/Clones.type'\nimport { TagValues } from './html'\nimport { ValueSubject } from '../subject'\nimport { kidsToTagArraySubject } from './kidsToTagArraySubject.function'\n\nexport type OriginalFunction = (() => Tag) & {compareTo: string}\n\nexport type Wrapper = ((\n  tagSupport: BaseTagSupport,\n  subject: TagSubject,\n) => TagSupport) & {\n  parentWrap: TagWrapper<any>\n}\n\nexport type TagGlobal = {\n  oldest?: TagSupport\n  newest?: TagSupport\n  context: Context // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n  providers: Provider[]\n  /** Indicator of re-rending. Saves from double rending something already rendered */\n  renderCount: number\n  deleted: boolean\n  isApp?: boolean // root element\n  \n  // ALWAYS template tag\n  insertBefore?: InsertBefore // what element put down before\n  placeholder?: Text // when insertBefore is taken up, the last element becomes or understanding of where to redraw to\n\n\n  subscriptions: Subscription<any>[] // subscriptions created by clones\n  \n  destroyCallback?: OnDestroyCallback // what to run when destroyed, used for onDestroy\n  init?: OnInitCallback // what to run when init complete, used for onInit\n}\n\nexport class TemplaterResult {\n  tagJsType = 'templater'\n  tagged!: boolean\n  wrapper?: Wrapper\n\n  madeChildIntoSubject = false\n  \n  tag?: Tag\n  children: TagChildren = new ValueSubject([] as Tag[])\n\n  constructor(public props: Props) {}\n\n  html(\n    strings: string[] | TemplateStringsArray,\n    ...values: TagValues\n  ) {\n    const children = new Tag(strings as string[], values)\n    const { childSubject, madeSubject } = kidsToTagArraySubject(children)\n    this.children = childSubject\n    \n    this.madeChildIntoSubject = madeSubject\n    return this\n  }\n}\n","import { Tag } from './Tag.class'\nimport { isSubjectInstance, isTagArray } from '../isInstance'\nimport { ValueSubject } from '../subject/ValueSubject'\nimport { TagChildrenInput, TagComponent, TagWrapper, tags } from './tag.utils'\n\nexport function kidsToTagArraySubject(\n  children?: TagChildrenInput\n): {\n  childSubject: ValueSubject<Tag[]>,\n  madeSubject: boolean // was converted into a subject\n} {\n  if(isSubjectInstance(children)) {\n    return {childSubject: children as ValueSubject<Tag[]>, madeSubject: false}\n  }\n  \n  const kidArray = children as Tag[]\n  if(isTagArray(kidArray)) {\n    return {childSubject: new ValueSubject(children as Tag[]), madeSubject: true}\n  }\n\n  const kid = children as Tag\n  if(kid) {\n    kid.memory.arrayValue = 0\n    return {childSubject: new ValueSubject([kid]), madeSubject: true}\n  }\n\n  return {\n    childSubject: new ValueSubject<Tag[]>([]),\n    madeSubject: true // was converted into a subject\n  }\n}\n","import { Tag } from './Tag.class'\nimport { TemplaterResult, Wrapper } from './TemplaterResult.class'\nimport { ValueSubject } from '../subject/ValueSubject'\nimport { setUse } from '../state'\n\nexport type TagChildren = ValueSubject<Tag[]> & { lastArray?: Tag[] }\nexport type TagChildrenInput = Tag[] | Tag | TagChildren\n\nexport type TagComponent = ((...args:  any[]) => Tag) & {\n  tags?: TagWrapper<any>[]\n  setUse?: typeof setUse\n  tagIndex?: number\n}\n\nexport const tags: TagWrapper<any>[] = []\n\nexport type TagWrapper<T> = ((\n  ...props: T[]\n) => TemplaterResult) & {\n  original: (...args: any[]) => any\n  compareTo: string\n  isTag: boolean\n  oneRender?: true\n}\n\nexport type TagMaker = ((...args: any[]) => Tag) | ((...args: any[]) => (...args: any[]) => Tag)\n","/** File largely responsible for reacting to element events, such as onclick */\n\nimport { TagSupport } from \"../tag/TagSupport.class\"\nimport { renderTagSupport } from \"../tag/render/renderTagSupport.function\"\n\nexport type Callback = (...args: any[]) => any & {\n  isChildOverride?: true // if this is set, then a parent tag passed children to a tag/component\n}\n\nexport function bindSubjectCallback(\n  value: Callback,\n  tagSupport: TagSupport,\n) {\n  // Is this children? No override needed\n  if((value as any).isChildOverride) {\n    return value\n  }\n\n  const subjectFunction = (\n    element: Element, args: any[]\n  ) => runTagCallback(value, tagSupport, element, args)\n\n  // link back to original. Mostly used for <div oninit ondestroy> animations\n  subjectFunction.tagFunction = value\n\n  return subjectFunction\n}\n\nexport function runTagCallback(\n  value: Callback,\n  tagSupport: TagSupport,\n  bindTo: unknown,\n  args: any[],\n) {\n  const myGlobal = tagSupport.global\n  const renderCount = myGlobal.renderCount\n  const method = value.bind(bindTo)\n  const callbackResult = method(...args)\n  const sameRenderCount = renderCount === myGlobal.renderCount\n  const skipRender = !sameRenderCount || myGlobal.deleted\n  \n  // already rendered OR tag was deleted before event processing\n  if(skipRender) {\n    if(callbackResult instanceof Promise) {\n      return callbackResult.then(() => {\n        return 'promise-no-data-ever' // tag was deleted during event processing\n      })\n    }\n    return 'no-data-ever' // already rendered\n  }\n\n  const newest = renderTagSupport(\n    myGlobal.newest as TagSupport,\n    true, // renderUp - callback may have changed props so also check to render up\n  )\n\n  myGlobal.newest = newest\n\n  if(callbackResult instanceof Promise) {\n    return callbackResult.then(() => {\n      if(myGlobal.deleted) {\n        return 'promise-no-data-ever' // tag was deleted during event processing\n      }\n\n      const newest = renderTagSupport(\n        myGlobal.newest as TagSupport,\n        true,\n      )\n\n      myGlobal.newest = newest\n\n      return 'promise-no-data-ever'\n    })\n  }\n\n  // Caller always expects a Promise\n  return 'no-data-ever'\n}\n","import { Tag } from './Tag.class'\nimport { deepClone } from '../deepFunctions'\nimport { TemplaterResult } from './TemplaterResult.class'\nimport { ValueTypes, getValueType } from './update/processFirstSubject.utils'\n\nexport function cloneValueArray<T>(values: (T | Tag | Tag[])[]): T[] {\n  return values.map((value) => {\n    const tag = value as Tag\n\n    switch(getValueType(value)) {\n      case ValueTypes.tagComponent:\n        const tagComponent = value as TemplaterResult\n        return deepClone(tagComponent.props)\n      \n      case ValueTypes.tag:\n      case ValueTypes.templater:\n        return cloneValueArray(tag.values)\n\n      case ValueTypes.tagArray:\n        return cloneValueArray(tag as unknown as Tag[])\n    }\n\n    return deepClone(value)\n  })\n}\n","import { TagSupport } from './TagSupport.class'\n\nexport type DestroyOptions = {\n  stagger: number\n  byParent?: boolean // who's destroying me? if byParent, ignore possible animations\n}\n\nexport function getChildTagsToDestroy(\n  childTags: TagSupport[],\n  allTags: TagSupport[] = [],\n): TagSupport[] {\n  for (let index = childTags.length - 1; index >= 0; --index) {\n    const cTag = childTags[index]\n\n    allTags.push(cTag)\n    childTags.splice(index, 1)\n    getChildTagsToDestroy(cTag.childTags, allTags)\n  }\n\n  return allTags\n}\n","import { Tag } from '../Tag.class'\nimport { DisplaySubject, TagSubject } from '../../subject.types'\nimport { ValueSubject } from '../../subject/ValueSubject'\nimport { TemplaterResult } from '../TemplaterResult.class'\nimport { TagSupport } from '../TagSupport.class'\nimport { InterpolateSubject, TemplateValue, ValueTypes, getValueType } from './processFirstSubject.utils'\n\nexport function processNewValue(\n  value: TemplateValue,\n  ownerSupport: TagSupport,\n): InterpolateSubject {\n  const valueType = getValueType(value)\n  switch (valueType) {\n    case ValueTypes.tagComponent:\n      const tagSubject = new ValueSubject(value) as TagSubject\n      return tagSubject\n\n    case ValueTypes.templater:\n      const templater = value as TemplaterResult\n      const tag = templater.tag as Tag\n      return processNewTag(tag, ownerSupport)\n    \n    case ValueTypes.tag:\n      return processNewTag(value as Tag, ownerSupport)\n\n    case ValueTypes.subject:\n      return value as ValueSubject<any>\n  }\n\n  return new ValueSubject(value) as unknown as DisplaySubject\n}\n\nfunction processNewTag(\n  value: Tag,\n  ownerSupport: TagSupport\n) {  \n  const tag = value as Tag\n  \n  let templater = tag.templater\n  if(!templater) {\n    templater = new TemplaterResult([])\n    templater.tag = tag\n    tag.templater = templater\n  }\n\n  const subject = new ValueSubject(templater) as TagSubject\n\n  subject.tagSupport = new TagSupport(\n    templater,\n    ownerSupport,\n    subject\n  )\n\n  return subject\n}\n","import { InsertBefore } from '../interpolations/Clones.type'\nimport { TagGlobal } from './TemplaterResult.class'\n\nexport function setTagPlaceholder(\n  global: TagGlobal,\n) {\n  const insertBefore = global.insertBefore as InsertBefore\n  return global.placeholder = swapInsertBefore(insertBefore)\n}\n\nexport function swapInsertBefore(\n  insertBefore: InsertBefore\n) {\n  const placeholder = document.createTextNode('')\n  const parentNode = insertBefore.parentNode as ParentNode\n  parentNode.insertBefore(placeholder, insertBefore)\n  parentNode.removeChild(insertBefore)\n  return placeholder\n}\n","export function inputAttribute(\n  name: string,\n  value: any,\n  element: Element,\n) {\n  const names = name.split('.')\n\n  // style.position = \"absolute\"\n  if(names[0] === 'style') {\n    (element as any).style[names[1]] = value\n  }\n\n  // Example: class.width-full = \"true\"\n  if(names[0] === 'class') {\n    names.shift()\n    if(value) {\n      for (let index=0; index < names.length; ++index) {\n        element.classList.add(names[index])\n      }\n    } else {\n      for (let index=0; index < names.length; ++index) {\n        element.classList.remove(names[index])\n      }\n    }\n  }\n}\n","import { inputAttribute } from './inputAttribute'\nimport { isSubjectInstance } from '../isInstance'\nimport { Context, Tag } from '../tag/Tag.class'\nimport { HowToSet } from './interpolateAttributes'\nimport { bindSubjectCallback } from './bindSubjectCallback.function'\nimport { TagSupport } from '../tag/TagSupport.class'\n\nconst startRegX = /^\\s*{__tagvar/\nconst endRegX = /}\\s*$/\nfunction isTagVar(value: string | null) {\n  return value && value.search(startRegX) >= 0 && value.search(endRegX) >= 0\n}\n\nexport function processAttribute(\n  attrName: string,\n  value: string | null,\n  child: Element,\n  scope: Context,\n  ownerSupport: TagSupport,\n  howToSet: HowToSet,\n) {\n  if ( isTagVar(value) ) {  \n    return processScopedNameValueAttr(\n      attrName,\n      value as string,\n      child,\n      scope,\n      ownerSupport,\n      howToSet,\n    )\n  }\n\n  if( isTagVar(attrName) ) {  \n    const contextValueSubject = getContextValueByVarString(scope, attrName)\n    let lastValue: any;\n\n    // the above callback gets called immediately since its a ValueSubject()\n    const sub = contextValueSubject.subscribe((value: any) => {\n      processNameOnlyAttr(\n        value,\n        lastValue,\n        child,\n        ownerSupport,\n        howToSet,\n      )\n\n      lastValue = value\n    })\n    ownerSupport.global.subscriptions.push(sub) // this is where unsubscribe is picked up\n    child.removeAttribute(attrName)\n\n    return\n  }\n\n  // Non dynamic\n  const isSpecial = isSpecialAttr(attrName)\n  if (isSpecial) {\n    return inputAttribute(attrName, value, child)\n  }\n}\n\nfunction processScopedNameValueAttr(\n  attrName: string,\n  value: string, // {__tagVarN}\n  child: Element,\n  scope: Context,\n  ownerSupport: TagSupport,\n  howToSet: HowToSet\n) {\n  // get the code inside the brackets like \"variable0\" or \"{variable0}\"\n  const result = getContextValueByVarString(scope, value)\n  return processNameValueAttr(\n    attrName,\n    result,\n    child,\n    ownerSupport,\n    howToSet\n  )\n}\n\nfunction getContextValueByVarString(\n  scope: Context,\n  value: string,\n) {\n  const code = value.replace('{','').split('').reverse().join('').replace('}','').split('').reverse().join('')\n  return scope[code]\n}\nfunction processNameOnlyAttr(\n  attrValue: string | Record<string, any>,\n  lastValue: string | Record<string, any> | undefined,\n  child: Element,\n  ownerSupport: TagSupport,\n  howToSet: HowToSet,\n) {\n  if(lastValue && lastValue != attrValue) {\n    if(typeof(lastValue) === 'string') {\n      child.removeAttribute(lastValue as string)\n    } else if(lastValue instanceof Object) {\n      for (const name in lastValue) {\n        child.removeAttribute(name)\n      }\n    }\n  }\n\n  if(typeof(attrValue) === 'string') {\n    if(!attrValue.length) {\n      return\n    }\n\n    processNameValueAttr(\n      attrValue as string,\n      '',\n      child,\n      ownerSupport,\n      howToSet,\n    )\n\n    return\n  }\n\n  if(attrValue instanceof Object) {\n    for (const name in attrValue) {\n      processNameValueAttr(\n        name,\n        attrValue[name],\n        child,\n        ownerSupport,\n        howToSet,\n      )\n    }\n  }\n}\n\nfunction processNameValueAttr(\n  attrName: string,\n  result: any,\n  child: Element,\n  ownerSupport: TagSupport,\n  howToSet: HowToSet\n) {\n  const isSpecial = isSpecialAttr(attrName)\n\n  if(result instanceof Function) {\n    const action = function(...args: any[]) {\n      const result2 = result(child, args)\n      return result2\n    }\n    \n    ;(child as any)[attrName].action = action\n  }\n\n  // Most every variable comes in here since everything is made a ValueSubject\n  if(isSubjectInstance(result)) {\n    child.removeAttribute(attrName)\n    const callback = (newAttrValue: any) => {            \n      // should the function be wrapped so every time its called we re-render?\n      if(newAttrValue instanceof Function) {\n        const wrapper = ownerSupport.templater.wrapper\n        const parentWrap = wrapper?.parentWrap\n        const oneRender = parentWrap?.oneRender\n        if(!oneRender) {\n          newAttrValue = bindSubjectCallback(newAttrValue, ownerSupport)\n        } \n      }\n      \n      return processAttributeSubjectValue(\n        newAttrValue,\n        child,\n        attrName,\n        isSpecial,\n        howToSet,\n      )\n    }\n\n    // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n    const sub = result.subscribe(callback as any)\n    \n    // Record subscription for later unsubscribe when element destroyed\n    ownerSupport.global.subscriptions.push(sub)\n\n    return\n  }\n\n  howToSet(child, attrName, result)\n  // child.setAttribute(attrName, result.value)\n  return\n}\n\nexport type NoDisplayValue = false | null | undefined\ntype DisplayValue = ((...args: unknown[]) => unknown) | string | boolean\n\nfunction processAttributeSubjectValue(\n  newAttrValue: DisplayValue | NoDisplayValue,\n  child: Element,\n  attrName: string,\n  isSpecial: boolean,\n  howToSet: HowToSet,\n) {  \n  if(newAttrValue instanceof Function) {\n    const fun = function(...args: any[]) {\n      return newAttrValue(child, args)\n    }\n\n    // access to original function\n    fun.tagFunction = newAttrValue\n\n    ;(child as any)[attrName] = fun\n\n    return\n  }\n\n  if (isSpecial) {\n    inputAttribute(attrName, newAttrValue, child)\n    return\n  }\n\n  if(newAttrValue) {\n    howToSet(child, attrName, newAttrValue as string)\n    return\n  }\n\n  const isDeadValue = [undefined, false, null].includes(newAttrValue as NoDisplayValue)\n  if(isDeadValue) {\n    child.removeAttribute(attrName)\n    return\n  }\n\n  // value is 0\n  howToSet(child, attrName, newAttrValue as string)\n}\n\n/** Looking for (class | style) followed by a period */\nfunction isSpecialAttr(\n  attrName: string | String\n) {\n  return attrName.search(/^(class|style)(\\.)/) >= 0\n}\n","import { Context } from \"../tag/Tag.class\"\nimport { TagSupport } from \"../tag/TagSupport.class\"\nimport { processAttribute } from \"./processAttribute.function\"\n\nexport type HowToSet = (element: Element, name: string, value: string) => any\n\nfunction howToSetAttribute(\n  element: Element,\n  name: string,\n  value: string\n) {\n  element.setAttribute(name, value)\n}\n\nfunction howToSetInputValue(\n  element: Element,\n  name: string,\n  value: string\n) {\n  (element as any)[name] = value\n}\n\nexport function interpolateAttributes(\n  child: Element,\n  scope: Context,\n  ownerSupport: TagSupport,\n) {\n  const attrNames = child.getAttributeNames()\n\n  let howToSet = howToSetAttribute\n\n  for (let index = 0; index < attrNames.length; ++index) {\n    const attrName = attrNames[index]\n    if(child.nodeName === 'INPUT' && attrName === 'value') {\n      howToSet = howToSetInputValue\n    }\n\n    const value = child.getAttribute(attrName)\n    processAttribute(attrName, value, child, scope, ownerSupport, howToSet)\n\n    howToSet = howToSetAttribute // put back\n  }\n}\n","// support arrow functions in attributes\nexport const interpolateReplace = /(?:<[^>]*?(?:(?:\\s+\\w+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)))*\\s*)\\/?>)|({__tagvar[^}]+})/g\n\n// stops after arrow function\n// export const interpolateReplace = /(?:<[^>]*>)|({__tagvar[^}]+})/g\n\nexport type InterpolatedTemplates = {\n  string: string\n  keys: string[]\n}\n\n/** replaces ${x} with <template id=\"x-start\"></template><template id=\"x-end\"></template> */\nexport function interpolateToTemplates(\n  template: string,\n): InterpolatedTemplates {\n  const keys: string[] = []\n  const string = template.replace(interpolateReplace, (match, expression) => {\n    if (match.startsWith('<')) {\n      // If the match is an HTML tag, don't replace\n      return match\n    }\n    \n    const noBraces = expression.substring(1, expression.length-1)\n    const id = noBraces\n    keys.push(id)\n    return `<template interpolate end id=\"${id}\"></template>`\n  })\n\n  return { string, keys }\n}\n","import { Counts } from '../../interpolations/interpolateTemplate'\nimport { TagArraySubject } from './processTagArray'\nimport { TagSubject } from '../../subject.types'\nimport { InsertBefore } from '../../interpolations/Clones.type'\nimport { TagSupport } from '../TagSupport.class'\n\nexport function processTagResult(\n  tagSupport: TagSupport,\n  subject: TagArraySubject | TagSubject | Function, // used for recording past and current value\n  insertBefore: InsertBefore, // <template end interpolate />\n  {\n    counts,\n  }: {\n    counts: Counts\n  },\n) {\n  // *if appears we already have seen\n  const subjectTag = subject as TagSubject\n  const lastSupport = subjectTag.tagSupport\n  const prevSupport = lastSupport?.global.oldest || undefined\n  const justUpdate = prevSupport\n  \n  if(prevSupport && justUpdate) {\n    return processTagResultUpdate(tagSupport, subjectTag, prevSupport)\n  }\n\n  tagSupport.buildBeforeElement(insertBefore, {\n    counts,\n  })\n}\n\n\nfunction processTagResultUpdate(\n  tagSupport: TagSupport,\n  subject: TagSubject | ((x: TagSupport) => TagSupport), // used for recording past and current value\n  prevSupport: TagSupport,\n) {\n  // components\n  if(subject instanceof Function) {\n    const newSupport = subject(prevSupport)\n    prevSupport.updateBy(newSupport)\n    // we have to store previous states somewhere, put on the function given\n    ;(subject as unknown as TagSubject).tagSupport = newSupport\n    return\n  }\n\n  prevSupport.updateBy(tagSupport)\n  subject.tagSupport = tagSupport\n\n  return\n}\n","import { TemplaterResult, Wrapper } from '../TemplaterResult.class'\nimport { setUse } from '../../state'\nimport { Counts } from '../../interpolations/interpolateTemplate'\nimport { processTagResult } from './processTagResult.function'\nimport { TagSubject } from '../../subject.types'\nimport { TagSupport } from '../TagSupport.class'\nimport { InsertBefore } from '../../interpolations/Clones.type'\nimport { renderSubjectComponent } from '../render/renderSubjectComponent.function'\n\nexport function processSubjectComponent(\n  templater: TemplaterResult,\n  subject: TagSubject,\n  insertBefore: InsertBefore,\n  ownerSupport: TagSupport,\n  options: {counts: Counts},\n): TagSupport {\n  // Check if function component is wrapped in a tag() call\n  // TODO: This below check not needed in production mode\n  if(templater.tagged !== true) {\n    const wrapper = templater.wrapper as Wrapper\n    const original = wrapper.parentWrap.original\n    let name: string | undefined = original.name || original.constructor?.name\n\n    if(name === 'Function') {\n      name = undefined\n    }\n\n    const label = name || original.toString().substring(0,120)\n    const error = new Error(`Not a tag component. Wrap your function with tag(). Example tag(props => html\\`\\`) on component:\\n\\n${label}\\n\\n`)\n    throw error\n  }\n\n  const tagSupport = new TagSupport(\n    templater,\n    ownerSupport,\n    subject,\n  )\n\n  let reSupport = subject.tagSupport\n  const global = tagSupport.global = reSupport?.global || tagSupport.global\n  global.insertBefore = insertBefore\n  \n  const providers = setUse.memory.providerConfig\n  providers.ownerSupport = ownerSupport\n  \n  const isRender = !reSupport\n  if(isRender) {\n    const support = reSupport || tagSupport\n    reSupport = renderSubjectComponent(\n      subject,\n      support,\n      ownerSupport,\n    )\n  }\n\n  processTagResult(\n    reSupport,\n    subject, // The element set here will be removed from document. Also result.tag will be added in here\n    insertBefore, // <template end interpolate /> (will be removed)\n    options,\n  )\n\n  return reSupport\n}\n\n","import { renderWithSupport } from './renderWithSupport.function'\nimport { TagSubject } from '../../subject.types'\nimport { TagSupport } from '../TagSupport.class'\n\nexport function renderSubjectComponent(\n  subject: TagSubject,\n  reSupport: TagSupport,\n  ownerSupport: TagSupport,\n): TagSupport {\n  const preClones = ownerSupport.clones.map(clone => clone)\n  \n  reSupport = renderWithSupport(\n    reSupport,\n    subject.tagSupport, // existing tag\n    subject,\n    ownerSupport,\n  )\n\n  reSupport.global.newest = reSupport\n\n  if(ownerSupport.clones.length > preClones.length) {\n    const myClones = ownerSupport.clones.filter(fClone => !preClones.find(clone => clone === fClone))\n    reSupport.clones.push(...myClones)\n  }\n\n  ownerSupport.childTags.push(reSupport)\n\n  return reSupport\n}","import { InsertBefore } from '../../interpolations/Clones.type'\nimport { Tag } from '../Tag.class'\nimport { TagSubject } from '../../subject.types'\nimport { TagSupport } from '../TagSupport.class'\nimport { TemplaterResult, Wrapper } from '../TemplaterResult.class'\nimport { ValueSubject } from '../../subject'\nimport { Props } from '../../Props'\n\n/** Could be a regular tag or a component. Both are Tag.class */\nexport function processTag(\n  templater: TemplaterResult,\n  insertBefore: InsertBefore,\n  ownerSupport: TagSupport, // owner\n  subject: TagSubject, // could be tag via result.tag\n) {\n  let tagSupport: TagSupport = subject.tagSupport\n  \n  // first time seeing this tag?\n  if(!tagSupport) {\n    tagSupport = newTagSupportByTemplater(templater, ownerSupport, subject)\n  }\n  \n  subject.tagSupport = tagSupport\n  tagSupport.ownerTagSupport = ownerSupport\n  tagSupport.buildBeforeElement(\n    insertBefore, {\n      counts: {added:0, removed:0},\n    }\n  )\n}\n\nexport function setupNewTemplater(\n  tagSupport: TagSupport,\n  ownerSupport: TagSupport,\n  subject: TagSubject,\n) {\n  tagSupport.global.oldest = tagSupport\n  tagSupport.global.newest = tagSupport\n\n  // asking me to render will cause my parent to render\n  tagSupport.ownerTagSupport = ownerSupport\n  subject.tagSupport = tagSupport\n}\n\nexport function tagFakeTemplater(\n  tag: Tag\n) {\n  const templater = getFakeTemplater()\n  templater.tag = tag\n  tag.templater = templater\n\n  return templater\n}\n\nexport function getFakeTemplater() {\n  const fake = {\n    children: new ValueSubject<Tag[]>([]), // no children\n    \n    // props: {} as Props,\n    props: [] as Props,\n    \n    isTag: true,\n    tagJsType: 'templater',\n    tagged: false,\n    \n    madeChildIntoSubject: false,\n    html: () => fake\n  } as TemplaterResult\n\n  return fake\n}\n\nexport function newTagSupportByTemplater(\n  templater: TemplaterResult,\n  ownerSupport: TagSupport,\n  subject: TagSubject,\n) {\n  const tagSupport = new TagSupport(\n    templater,\n    ownerSupport,\n    subject,\n  )\n\n  setupNewTemplater(tagSupport, ownerSupport, subject)\n\n  ownerSupport.childTags.push(tagSupport)\n\n  return tagSupport\n}","import { Clones, InsertBefore } from '../../interpolations/Clones.type'\nimport { Tag } from '../Tag.class'\nimport { ValueSubject } from '../../subject/ValueSubject'\nimport { Counts } from '../../interpolations/interpolateTemplate'\nimport { ArrayNoKeyError } from '../../errors'\nimport { destroyArrayTag } from '../checkDestroyPrevious.function'\nimport { setupNewTemplater, tagFakeTemplater } from './processTag.function'\nimport { TagSupport } from '../TagSupport.class'\nimport { TemplaterResult } from '../TemplaterResult.class'\nimport { isTagClass } from '../../isInstance'\nimport { TagSubject } from '../../subject.types'\n\nexport type LastArrayItem = {\n  tagSupport: TagSupport\n  index: number\n  deleted?: boolean\n}\n\nexport type TagArraySubject = ValueSubject<Tag[]> & {\n  insertBefore: InsertBefore // template tag\n  placeholder?: Text // template tag\n  lastArray?: LastArrayItem[] // previous array that may have been processed\n}\n\nexport function processTagArray(\n  subject: TagArraySubject,\n  value: (TemplaterResult | Tag)[], // arry of Tag classes\n  insertBefore: InsertBefore, // <template end interpolate />\n  ownerSupport: TagSupport,\n  options: {\n    counts: Counts\n  },\n): Clones {\n  const clones: Clones = ownerSupport.clones // []\n  let lastArray = subject.lastArray = subject.lastArray || []\n\n  if(!subject.placeholder) {\n    setPlaceholderElm(insertBefore, subject)\n  }\n\n  const runtimeInsertBefore = subject.placeholder as Text // || insertBefore\n\n  let removed = 0\n  \n  /** 🗑️ remove previous items first */\n  lastArray = subject.lastArray = subject.lastArray.filter((\n    item: LastArrayItem,\n    index: number,\n  ) => {\n    const newLength = value.length-1\n    const at = index - removed\n    const lessLength = newLength < at\n    const subValue = value[index - removed]\n    const subTag = subValue as Tag | undefined\n\n    // const tag = subTag?.templater.tag as Tag\n    const lastTag = item.tagSupport.templater.tag as Tag\n    const newArrayValue = subTag?.memory.arrayValue\n    const lastArrayValue = lastTag.memory.arrayValue\n    const destroyItem = lessLength || !areLikeValues(newArrayValue, lastArrayValue)\n    \n    if(destroyItem) {\n      const last = lastArray[index]\n      const tagSupport = last.tagSupport\n      destroyArrayTag(tagSupport, options.counts)\n      last.deleted = true\n\n      ++removed\n      ++options.counts.removed\n      \n      return false\n    }\n\n    return true\n  })\n\n  const length = value.length\n  for (let index=0; index < length; ++index) {\n    const item = value[index]\n    const previous = lastArray[index]\n    const previousSupport = previous?.tagSupport\n    const subTag = item as Tag\n\n    if(isTagClass(subTag) && !subTag.templater) {\n      tagFakeTemplater(subTag)\n    }\n\n    const tagSupport: TagSupport = new TagSupport(\n      subTag.templater,\n      ownerSupport,\n      new ValueSubject(undefined) as unknown as TagSubject\n    )\n\n    if(previousSupport) {\n      setupNewTemplater(tagSupport as TagSupport, ownerSupport, previousSupport.subject)\n      const global = previousSupport.global\n      tagSupport.global = global\n      global.newest = tagSupport\n    }\n    \n    // check for html``.key()\n    const keySet = 'arrayValue' in subTag.memory\n    if (!keySet) {\n      const details = {\n        template: tagSupport.getTemplate().string,\n        array: value,\n      }\n      const message = 'Use html`...`.key(item) instead of html`...` to template an Array'\n      console.error(message, details)\n      const err = new ArrayNoKeyError(message, details)\n      throw err\n    }\n    \n    const couldBeSame = lastArray.length > index\n    if (couldBeSame) {\n      const prevSupport = previous.tagSupport\n      const prevGlobal = prevSupport.global\n      \n      // subTag.tagSupport = subTag.tagSupport || prevSupport\n      const oldest = prevGlobal.oldest as TagSupport\n      oldest.updateBy(tagSupport)\n      // return []\n      continue\n    }\n\n    processAddTagArrayItem(\n      runtimeInsertBefore,\n      tagSupport,\n      index,\n      options,\n      lastArray,\n    )\n\n    ownerSupport.childTags.push(tagSupport)  \n  }\n\n  return clones\n}\n\nfunction setPlaceholderElm(\n  insertBefore: InsertBefore,\n  subject: TagArraySubject,\n) {\n  if(insertBefore.nodeName !== 'TEMPLATE') {\n    subject.placeholder = insertBefore as Text\n    return\n  }\n\n  const placeholder = subject.placeholder = document.createTextNode('')\n  const parentNode = insertBefore.parentNode as ParentNode\n  parentNode.insertBefore(placeholder, insertBefore)\n  parentNode.removeChild(insertBefore)\n}\n\n\nfunction processAddTagArrayItem(\n  before: Text,\n  tagSupport: TagSupport,\n  index: number,\n  options: {\n    counts: Counts\n  },\n  lastArray: LastArrayItem[],\n) {\n  const lastValue = {\n    tagSupport, index\n  }\n  \n  // Added to previous array\n  lastArray.push(lastValue)\n\n  const counts: Counts = {\n    added: options.counts.added + index,\n    removed: options.counts.removed,\n  }\n\n  const fragment = document.createDocumentFragment()\n  const newTempElm = document.createElement('template')\n  fragment.appendChild(newTempElm)\n\n  tagSupport.buildBeforeElement(\n    newTempElm, // before,\n    {counts}\n  )\n\n  const parent = before.parentNode as ParentNode\n  parent.insertBefore(fragment, before)\n}\n\n/** compare two values. If both values are arrays then the items will be compared */\nfunction areLikeValues(valueA: unknown, valueB: unknown): Boolean {\n  if(valueA === valueB) {\n    return true\n  }\n\n  const bothArrays = valueA instanceof Array && valueB instanceof Array\n  const matchLengths = bothArrays && valueA.length == valueB.length\n  if(matchLengths) {\n    return valueA.every((item, index) => item == valueB[index])\n  }\n\n  return false\n}\n","import { InsertBefore } from \"./interpolations/Clones.type\"\nimport { NoDisplayValue } from \"./interpolations/processAttribute.function\"\n\n// Function to update the value of x\nexport function updateBeforeTemplate(\n  value: string, // value should be casted before calling here\n  lastFirstChild: InsertBefore,\n) {\n  const parent = lastFirstChild.parentNode as ParentNode\n\n  // Insert the new value (never use innerHTML here)\n  const textNode = document.createTextNode(value) // never innerHTML\n  parent.insertBefore(textNode, lastFirstChild)\n\n  /* remove existing nodes */\n  parent.removeChild(lastFirstChild)\n\n  return textNode\n}\n\ntype TextableValue = string | boolean | number | NoDisplayValue\n\nexport function castTextValue(\n  value: TextableValue\n) {\n  // mimic React skipping to display EXCEPT for true does display on page\n  if([undefined,false,null].includes(value as NoDisplayValue)) { // || value === true\n    return ''\n  }\n\n  return value as string\n}","import { InsertBefore } from '../../interpolations/Clones.type'\nimport { DisplaySubject } from '../../subject.types'\nimport { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function'\n\nexport type RegularValue = string | number | undefined | boolean\n\nexport function processRegularValue(\n  value: RegularValue,\n  subject: DisplaySubject, // could be tag via subject.tag\n  insertBefore: InsertBefore, // <template end interpolate /> (will be removed)\n) {\n  subject.insertBefore = insertBefore\n  const before = subject.clone || insertBefore // Either the template is on the doc OR its the first element we last put on doc\n\n  // matches but also was defined at some point\n  if(subject.lastValue === value && 'lastValue' in subject) {\n    return // no need to update display, its the same\n  }\n\n  subject.lastValue = value\n  const castedValue = castTextValue(value)\n  \n  // replace existing string?\n  const oldClone = subject.clone\n  if(oldClone) {\n    oldClone.textContent = castedValue\n    return\n  }\n  \n  // Processing of regular values\n  const clone = updateBeforeTemplate(\n    castedValue,\n    before, // this will be removed\n  )\n\n  subject.clone = clone // remember single element put down, for future updates\n}\n\nexport function processFirstRegularValue(\n  value: RegularValue,\n  subject: DisplaySubject, // could be tag via subject.tag\n  insertBefore: InsertBefore, // <template end interpolate /> (will be removed)\n) {\n  subject.lastValue = value\n  const castedValue = castTextValue(value)\n   \n  // Processing of regular values\n  const clone = updateBeforeTemplate(\n    castedValue,\n    insertBefore, // this will be removed\n  )\n\n  subject.clone = clone // remember single element put down, for future updates \n}","import { processSubjectComponent } from './processSubjectComponent.function'\nimport { TagArraySubject, processTagArray } from './processTagArray'\nimport { TemplaterResult, Wrapper } from '../TemplaterResult.class'\nimport { InsertBefore } from '../../interpolations/Clones.type'\nimport { DisplaySubject, TagSubject } from '../../subject.types'\nimport { RegularValue, processFirstRegularValue } from './processRegularValue.function'\nimport { newTagSupportByTemplater, processTag, tagFakeTemplater } from './processTag.function'\nimport { TagSupport } from '../TagSupport.class'\nimport { Tag } from '../Tag.class'\nimport { InterpolateSubject, TemplateValue, ValueTypes, getValueType, processOptions } from './processFirstSubject.utils'\nimport { renderTagOnly } from '../render/renderTagOnly.function'\n\nexport function processFirstSubjectValue(\n  value: TemplateValue,\n  subject: InterpolateSubject, // could be tag via result.tag\n  insertBefore: InsertBefore, // <template end interpolate /> (will be removed)\n  ownerSupport: TagSupport, // owner\n  options: processOptions, // {added:0, removed:0}\n) {\n  const valueType = getValueType(value)\n\n  switch (valueType) {\n    case ValueTypes.templater:\n      processTag(\n        value as TemplaterResult,\n        insertBefore,\n        ownerSupport,\n        subject as TagSubject,\n      )\n      return\n\n    case ValueTypes.tag:\n      const tag = value as Tag\n      let templater = tag.templater\n\n      if(!templater) {\n        templater = tagFakeTemplater(tag)\n      }\n\n      processTag(\n        templater,\n        insertBefore,\n        ownerSupport,\n        subject as TagSubject,\n      )\n      return\n  \n    case ValueTypes.tagArray:\n      return processTagArray(\n        subject as TagArraySubject,\n        value as (Tag | TemplaterResult)[],\n        insertBefore,\n        ownerSupport,\n        options\n      )\n    \n    case ValueTypes.tagComponent:\n      processSubjectComponent(\n        value as TemplaterResult,\n        subject as TagSubject,\n        insertBefore,\n        ownerSupport,\n        options,\n      )\n      return\n    \n    case ValueTypes.function:\n      const v = value as Wrapper\n      if((v as any).oneRender) {\n        const templater = new TemplaterResult([])\n        templater.tagJsType = 'oneRender'\n        const tagSupport = newTagSupportByTemplater(\n          templater, ownerSupport, subject as TagSubject\n        )\n\n        let tag: Tag\n        const wrap = () => {\n          templater.tag = tag || ((v as any)())\n          return tagSupport\n        }\n        // const wrap = () => ((v as any)())\n\n        templater.wrapper = wrap as any\n        wrap.parentWrap = wrap\n        wrap.oneRender = true\n        ;(wrap.parentWrap as any).original = v\n        \n        renderTagOnly(tagSupport, tagSupport, subject as TagSubject, ownerSupport)\n        // call inner function\n        // templater.tag = (v as any)() as Tag\n        \n        processTag(\n          templater, insertBefore, ownerSupport, subject as TagSubject\n        )\n        return\n      }\n      break\n  }\n\n  processFirstRegularValue(\n    value as RegularValue,\n    subject as DisplaySubject,\n    insertBefore,\n  )\n}\n","import { Context } from '../tag/Tag.class'\nimport { TagSupport } from '../tag/TagSupport.class'\nimport { HowToSet } from './interpolateAttributes'\nimport { processAttribute } from './processAttribute.function'\n\nconst search = new RegExp('\\\\s*<template interpolate end id=\"__tagvar(\\\\d{1,4})\"([^>]*)></template>(\\\\s*)')\n\nexport function scanTextAreaValue(\n  textarea: HTMLTextAreaElement,\n  context: Context,\n  ownerSupport: TagSupport,\n) {\n  const value = textarea.value\n  if( value.search(search) >=0 ) {\n    const match = value.match(/__tagvar(\\d{1,4})/);\n    const token = match ? match[0] : ''\n    const dynamic = '{' + token + '}'\n    textarea.value = ''\n    textarea.setAttribute('text-var-value', dynamic)\n\n    const howToSet: HowToSet = (_elm, _name, value: string) => textarea.value = value\n\n    processAttribute(\n      'text-var-value',\n      dynamic, // realValue, // context[token].value,\n      textarea,\n      context,\n      ownerSupport,\n      howToSet,\n    )  \n  }\n}\n","import { Props } from \"../Props\"\nimport { deepEqual } from \"../deepFunctions\"\n\n/**\n * \n * @param props \n * @param pastCloneProps \n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(\n  props: Props, // natural props\n  pastCloneProps: Props, // previously cloned props\n  // newTemplater: TemplaterResult,\n): number | false {\n  /*\n  const isCommonEqual = props === undefined && props === compareToProps\n  if(isCommonEqual) {\n    return false\n  }\n  */\n  let castedProps: Props = props\n  let castedPastProps: Props = pastCloneProps\n\n  // check all prop functions match\n  if(typeof(props) === 'object') {\n    if(!pastCloneProps) {\n      return 3\n    }\n\n    // castedProps = {...props}\n    castedProps = [...props]\n    // castedPastProps = {...(pastCloneProps || {})}\n    castedPastProps = [...(pastCloneProps || [])]\n    \n    const allFunctionsMatch = castedProps.every((value, index) => {      \n      let compare = castedPastProps[index]\n\n      if(value && typeof(value) === 'object') {\n        const subCastedProps = {...value}\n        const subCompareProps = {...compare || {}} as any\n        const matched = Object.entries(subCastedProps).every(([key, value]) => {\n          return compareProps(value, subCompareProps[key], () => {\n            delete (subCastedProps as any)[key] // its a function and not needed to be compared\n            delete (subCompareProps as any)[key] // its a function and not needed to be compared\n          })\n        })\n        return matched\n      }\n\n      return compareProps(value, compare, () => {\n        castedProps.splice(index, 1)\n        castedPastProps.splice(index, 1)\n      })\n    })\n\n    if(!allFunctionsMatch) {\n      return 6 // a change has been detected by function comparisons\n    }\n  }\n\n  // const isEqual = deepEqual(castedPastProps, castedProps)\n  // return isEqual ? false : 7 // if equal then no changes\n  return false\n}\n\n/** returning a number means true good comparison */\nfunction compareProps(\n  value: unknown,\n  compare: unknown,\n  onDelete: () => any,\n) {\n\n  if(!(value instanceof Function)) {\n    return deepEqual(value, compare) ? 4 : false\n  }\n\n  const compareFn = compare as Function\n  if(!(compareFn instanceof Function)) {\n    return false // its a function now but was not before\n  }\n\n  // ensure we are comparing apples to apples as function get wrapped\n  const compareOriginal = (compare as any)?.original\n  if(compareOriginal) {\n    compare = compareOriginal\n  }\n\n  const original = (value as any).original\n  if(original) {\n    value = (value as any).original\n  }\n  \n  const valueString = (value as any).toString()\n  const compareString = (compare as any).toString()\n  if(valueString === compareString) {\n    onDelete()\n    return 3 // both are function the same\n  }\n\n  onDelete()\n\n  return 5\n}","import { BaseTagSupport } from \"./TagSupport.class\"\nimport { TemplaterResult } from \"./TemplaterResult.class\"\nimport { hasPropChanges } from \"./hasPropChanges.function\"\n\nexport function hasTagSupportChanged(\n  oldTagSupport: BaseTagSupport,\n  newTagSupport: BaseTagSupport,\n  newTemplater: TemplaterResult,\n): number | false {  \n  const latestProps = newTemplater.props // newTagSupport.propsConfig.latest\n  const pastCloneProps = oldTagSupport.propsConfig.latestCloned\n  const propsChanged = hasPropChanges(latestProps, pastCloneProps)\n\n  // if no changes detected, no need to continue to rendering further tags\n  if(propsChanged) {\n    return propsChanged\n  }\n\n  const kidsChanged = hasKidsChanged(oldTagSupport, newTagSupport)\n\n  // we already know props didn't change and if kids didn't either, than don't render\n  return kidsChanged\n}\n\nexport function hasKidsChanged(\n  oldTagSupport: BaseTagSupport,\n  newTagSupport: BaseTagSupport,\n): number | false {\n  const oldCloneKidValues = oldTagSupport.propsConfig.lastClonedKidValues\n  const newClonedKidValues = newTagSupport.propsConfig.lastClonedKidValues\n\n  const everySame = oldCloneKidValues.every((set, index) => {\n    const x = newClonedKidValues[index]\n    return set.every((item, index) => item === x[index])\n  })\n\n  return everySame ? false : 9\n}\n","import { TagSupport } from './tag/TagSupport.class'\nimport { deepClone, deepEqual } from './deepFunctions'\nimport { isStaticTag } from './isInstance'\nimport { renderTagSupport } from './tag/render/renderTagSupport.function'\nimport { setUse } from './state'\nimport { getSupportInCycle } from './tag/getSupportInCycle.function'\n\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProps(\n  props: unknown,\n  ownerSupport: TagSupport,\n) {\n  const isPropTag = isStaticTag(props)\n  const watchProps = isPropTag ? 0 : props\n  const newProps = resetFunctionProps(watchProps, ownerSupport)\n\n  return newProps\n}\n\nfunction resetFunctionProps(\n  newProps: any,\n  ownerSupport: TagSupport,\n) {\n  if(typeof(newProps)!=='object' || !ownerSupport) {\n    return newProps\n  }\n\n  // BELOW: Do not clone because if first argument is object, the memory ref back is lost\n  // const newProps = {...props} \n\n  for(const name in newProps){\n    const value = newProps[name]\n    if(!(value instanceof Function)) {\n      continue\n    }\n\n    const toCall = newProps[name].toCall\n    \n    if(toCall) {\n      continue // already previously converted\n    }\n\n    newProps[name] = (...args: any[]) =>\n      newProps[name].toCall(...args) // what gets called can switch over parent state changes\n\n    // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n    newProps[name].toCall = (...args: any[]) =>\n      callbackPropOwner(value, args, ownerSupport)\n\n    newProps[name].original = value\n  }\n\n  return newProps\n}\n\nexport function callbackPropOwner(\n  toCall: Function,\n  callWith: any,\n  ownerSupport: TagSupport,\n) {\n  // const renderCount = ownerSupport.global.renderCount\n  const cycle = getSupportInCycle()\n\n  const result = toCall(...callWith)\n  const run = () => {\n    const lastestOwner = ownerSupport.global.newest as TagSupport\n\n    if(cycle) {\n      // appears a prop function was called sync/immediately so lets see if owner changed state\n      const allMatched = lastestOwner.memory.state.every(state => {\n        const lastValue = state.lastValue\n        const get = state.get()\n        const equal = deepEqual(\n          deepClone(lastValue),\n          get,\n        )\n  \n        return equal\n      })\n    \n      if(allMatched) {\n        return result // owner did not change\n      }\n    }\n\n    const newest = renderTagSupport(\n      lastestOwner,\n      true,\n    )\n\n    lastestOwner.global.newest = newest\n\n    return result\n  }\n\n  if(!cycle) {\n    return run()\n  }\n  \n  setUse.memory.tagClosed$.toCallback(run)\n\n  return result\n}\n","import { TagSubject } from '../../subject.types'\nimport { hasTagSupportChanged } from '../hasTagSupportChanged.function'\nimport { TagSupport } from '../TagSupport.class'\nimport { processSubjectComponent } from './processSubjectComponent.function'\nimport { destroyTagMemory } from '../destroyTag.function'\nimport { renderTagSupport } from '../render/renderTagSupport.function'\nimport { InsertBefore } from '../../interpolations/Clones.type'\nimport { callbackPropOwner } from '../../alterProps.function'\nimport { isLikeTags } from '../isLikeTags.function'\n\nexport function updateExistingTagComponent(\n  ownerSupport: TagSupport,\n  tagSupport: TagSupport, // lastest\n  subject: TagSubject,\n  insertBefore: InsertBefore,\n): TagSupport {\n  let lastSupport = subject.tagSupport?.global.newest as TagSupport // || subject.tagSupport\n  let oldestTag = lastSupport.global.oldest\n  \n  const oldWrapper = lastSupport.templater.wrapper\n  const newWrapper = tagSupport.templater.wrapper\n  let isSameTag = false\n\n  if(oldWrapper && newWrapper) {\n    const oldFunction = oldWrapper.parentWrap.original\n    const newFunction = newWrapper.parentWrap.original\n\n    // string compare both functions\n    isSameTag = oldFunction === newFunction\n  }\n\n  const templater = tagSupport.templater\n\n  if(!isSameTag) {\n    const oldestSupport = lastSupport.global.oldest as TagSupport\n    destroyTagMemory(oldestSupport)\n  \n    return processSubjectComponent(\n      templater,\n      subject,\n      insertBefore,\n      ownerSupport,\n      {\n        counts: {added: 0, removed: 0},\n      }\n    )\n  } else {\n    const hasChanged = hasTagSupportChanged(lastSupport, tagSupport, templater)    \n    if(!hasChanged) {\n      // if the new props are an object then implicitly since no change, the old props are an object\n      const newProps = templater.props\n      syncFunctionProps(\n        lastSupport,\n        ownerSupport,\n        newProps, // resetProps,\n      )\n\n      return lastSupport // its the same tag component\n    }\n  }\n\n  \n  const previous = lastSupport.global.newest as TagSupport\n  const newSupport = renderTagSupport(\n    tagSupport,\n    false,\n  )\n\n  lastSupport = subject.tagSupport as TagSupport\n\n  const newOldest = newSupport.global.oldest\n  const hasOldest = newOldest ? true : false\n  if(!hasOldest) {\n    return buildNewTag(\n      newSupport,\n      insertBefore,\n      lastSupport,\n      subject\n    )\n  }\n  \n  if(newOldest && templater.children.value.length) {\n    const oldKidsSub = newOldest.templater.children\n    oldKidsSub.set(templater.children.value)\n  }\n\n  // detect if both the function is the same and the return is the same\n  const isLikeTag = isSameTag && isLikeTags(previous, newSupport)\n\n  if(isLikeTag) {\n    subject.tagSupport = newSupport\n    \n    ;(oldestTag as TagSupport).updateBy(newSupport) // the oldest tag has element references\n\n    return newSupport\n  } else {\n    // Although function looked the same it returned a different html result\n    if(isSameTag && lastSupport) {\n      destroyTagMemory(lastSupport)\n      newSupport.global.context = {} // do not share previous outputs\n    }\n    oldestTag = undefined\n  }\n  \n\n  if(!oldestTag) {\n    lastSupport = newSupport\n    buildNewTag(\n      newSupport,\n      lastSupport.global.insertBefore as Element,\n      lastSupport,\n      subject,\n    )\n  }\n\n  lastSupport.global.newest = newSupport\n\n  return newSupport\n}\n\nfunction buildNewTag(\n  newSupport: TagSupport,\n  oldInsertBefore: Element | Text | ChildNode,\n  oldTagSupport: TagSupport,\n  subject: TagSubject,\n) {\n  newSupport.buildBeforeElement(oldInsertBefore, {\n    counts: {added: 0, removed: 0},\n  })\n\n  newSupport.global.oldest = newSupport\n  newSupport.global.newest = newSupport\n  oldTagSupport.global.oldest = newSupport\n  oldTagSupport.global.newest = newSupport\n  subject.tagSupport = newSupport\n\n  return newSupport\n}\n\nfunction syncFunctionProps(\n  lastSupport: TagSupport,\n  ownerSupport: TagSupport,\n  newPropsArray: any[],\n) {\n  lastSupport = lastSupport.global.newest || lastSupport as TagSupport\n  const priorPropConfig = lastSupport.propsConfig\n  const priorPropsArray = priorPropConfig.latestCloned\n  const prevSupport = ownerSupport.global.newest as TagSupport\n\n  for (let index = newPropsArray.length - 1; index >= 0; --index) {\n    const argPosition = newPropsArray[index]\n    if(typeof(argPosition) !== 'object') {\n      return\n    }\n\n    const priorProps = priorPropsArray[index] as Record<string, any>\n\n    if (typeof(priorProps) !== 'object') {\n      return\n    }\n\n    for (const name in argPosition) {\n      const value = argPosition[name]\n\n      if(!(value instanceof Function)) {\n        continue\n      }\n  \n      const newCallback = argPosition[name] // || value\n      const original = newCallback instanceof Function && newCallback.toCall\n      if(original) {\n        continue // already previously converted\n      }\n  \n      // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n      priorProps[name].toCall = (...args: any[]) => {\n        return callbackPropOwner(\n          newCallback, // value, // newOriginal,\n          args,\n          prevSupport,\n        )\n      }\n    }\n  }\n}\n","import { DisplaySubject, TagSubject } from '../../subject.types'\nimport { TagSupport } from '../TagSupport.class'\nimport { TemplaterResult } from '../TemplaterResult.class'\nimport { isTagClass, isTagTemplater } from '../../isInstance'\nimport { InterpolateSubject, TemplateValue, ValueTypes, getValueType } from './processFirstSubject.utils'\nimport { TagArraySubject, processTagArray } from './processTagArray'\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function'\nimport { RegularValue, processRegularValue } from './processRegularValue.function'\nimport { checkDestroyPrevious, restoreTagMarker } from '../checkDestroyPrevious.function'\nimport { ValueSubject } from '../../subject/ValueSubject'\nimport { processSubjectComponent } from './processSubjectComponent.function'\nimport { isLikeTags } from '../isLikeTags.function'\nimport { setupNewTemplater, getFakeTemplater, processTag } from './processTag.function'\nimport { InsertBefore } from '../../interpolations/Clones.type'\nimport { Tag } from '../Tag.class'\nimport { swapInsertBefore } from '../setTagPlaceholder.function'\n\nexport function updateExistingValue(\n  subject: InterpolateSubject,\n  value: TemplateValue,\n  ownerSupport: TagSupport,\n  insertBefore: InsertBefore,\n): InterpolateSubject {\n  const subjectTag = subject as TagSubject\n  const valueType = getValueType(value)\n  \n  checkDestroyPrevious(subject, value, insertBefore)\n\n  // handle already seen tag components\n  if(valueType === ValueTypes.tagComponent) {\n    return prepareUpdateToComponent(\n      value as TemplaterResult,\n      subjectTag,\n      insertBefore,\n      ownerSupport,\n    )\n  }\n  \n  // was component but no longer\n  const tagSupport = subjectTag.tagSupport\n  if( tagSupport ) {\n    if(valueType === ValueTypes.function) {\n      return subjectTag // its a oneRender tag\n    }\n\n    handleStillTag(\n      subject as TagSubject,\n      value as TemplaterResult,\n      ownerSupport\n    )\n\n    return subjectTag\n  }\n\n  switch (valueType) {\n    case ValueTypes.tagArray:\n      processTagArray(\n        subject as TagArraySubject,\n        value as (TemplaterResult | Tag)[],\n        insertBefore, // oldInsertBefore as InsertBefore,\n        ownerSupport,\n        {counts: {\n          added: 0,\n          removed: 0,\n        }}\n      )\n  \n      return subject\n\n    case ValueTypes.templater:\n      processTag(\n        value as TemplaterResult,\n        insertBefore,\n        ownerSupport,\n        subjectTag,\n      )\n      return subjectTag\n    \n    case ValueTypes.tag:\n      const tag = value as Tag\n      let templater = tag.templater\n  \n      if(!templater) {\n        templater = getFakeTemplater()\n        tag.templater = templater\n        templater.tag = tag\n      }\n  \n      processTag(\n        templater,\n        insertBefore,\n        ownerSupport,\n        subjectTag,\n      )\n\n      return subjectTag\n\n    case ValueTypes.subject:\n      return value as ValueSubject<any>\n\n    // now its a useless function (we don't automatically call functions)\n    case ValueTypes.function:\n      // const bound = bindSubjectCallback(value as Callback, ownerSupport)\n      // subject.set(bound)\n      if(!subject.clone) {\n        subject.clone = swapInsertBefore(insertBefore)\n      }\n\n      return subject\n  }\n\n  // This will cause all other values to render\n  processRegularValue(\n    value as RegularValue,\n    subject as DisplaySubject,\n    insertBefore,\n  )\n\n  return subjectTag\n}\n\nfunction handleStillTag(\n  subject: TagSubject,\n  value: Tag | TemplateValue,\n  ownerSupport: TagSupport,\n) {\n  const lastSupport = subject.tagSupport\n  let templater = value as TemplaterResult\n  const isClass = isTagClass(value)\n\n  if(isClass) {\n    const tag = value as Tag\n    templater = tag.templater\n    if(!templater) {\n      templater = new TemplaterResult([])\n      templater.tag = tag\n      tag.templater = templater\n    }\n  }\n  \n  const valueSupport = new TagSupport(\n    templater,\n    ownerSupport,\n    subject,\n  )\n\n  if(isClass) {\n    valueSupport.global = lastSupport.global\n  }\n  \n  const isSameTag = value && isLikeTags(lastSupport, valueSupport)\n\n  if(isTagTemplater(value)) {\n    setupNewTemplater(valueSupport, ownerSupport, subject)\n  }\n\n  if(isSameTag) {\n    lastSupport.updateBy(valueSupport)\n    return\n  }\n\n  if(isSameTag) {\n    // const subjectTag = subject as TagSubject\n    const global = lastSupport.global\n    const insertBefore = global.insertBefore as InsertBefore\n\n    return processTag(\n      templater,\n      insertBefore,\n      ownerSupport,\n      subject,\n    )\n  }\n\n  return processRegularValue(\n    value as RegularValue,\n    subject as unknown as DisplaySubject,\n    (subject as unknown as DisplaySubject).insertBefore,\n  )\n}\n\nfunction prepareUpdateToComponent(\n  templater: TemplaterResult,\n  subjectTag: TagSubject,\n  insertBefore: InsertBefore,\n  ownerSupport: TagSupport,\n): TagSubject {\n  // When last value was not a component\n  if(!subjectTag.tagSupport) {\n    processSubjectComponent(\n      templater,\n      subjectTag,\n      insertBefore, // oldInsertBefore as InsertBefore,\n      ownerSupport,\n      {\n        counts: {added: 0, removed: 0},\n      }\n    )\n\n    return subjectTag\n  }\n  \n  const tagSupport = new TagSupport(\n    templater,\n    ownerSupport,\n    subjectTag,\n  )\n\n  const subjectSup = subjectTag.tagSupport\n  const prevSupport = subjectSup.global.newest\n  if(prevSupport) {\n    const newestState = prevSupport.memory.state\n    tagSupport.memory.state.length = 0\n    tagSupport.memory.state.push(...newestState)\n  } else {\n    restoreTagMarker(subjectSup)\n\n    processSubjectComponent(\n      templater, subjectTag, insertBefore, ownerSupport,\n      {\n        counts: {added: 0, removed: 0},\n      }\n    )\n    return subjectTag\n  }\n  tagSupport.global = subjectSup.global\n  subjectTag.tagSupport = tagSupport\n\n  updateExistingTagComponent(\n    ownerSupport,\n    tagSupport, // latest value\n    subjectTag,\n    insertBefore,\n  )\n\n  return subjectTag\n}\n","import { Context, ElementBuildOptions, variablePrefix } from \"../tag/Tag.class\"\nimport { InterpolateOptions } from \"./interpolateElement\"\nimport { elementInitCheck } from \"./elementInitCheck\"\nimport { Clones, InsertBefore } from \"./Clones.type\"\nimport { InterpolateSubject, TemplateValue } from \"../tag/update/processFirstSubject.utils\"\nimport { processFirstSubjectValue } from \"../tag/update/processFirstSubjectValue.function\"\nimport { isTagArray, isTagComponent } from \"../isInstance\"\nimport { scanTextAreaValue } from \"./scanTextAreaValue.function\"\nimport { updateExistingValue } from \"../tag/update/updateExistingValue.function\"\nimport { TagSupport } from \"../tag/TagSupport.class\"\nimport { TemplaterResult } from \"../tag/TemplaterResult.class\"\nimport { swapInsertBefore } from \"../tag/setTagPlaceholder.function\"\n\nexport type Template = Element & {clone?: any}\nexport type InterpolateComponentResult = {\n  subject: InterpolateSubject\n  insertBefore: Element | Text | Template\n  ownerSupport: TagSupport\n  variableName: string\n}\nexport type InterpolateTemplateResult = {\n  clones: Clones\n  tagComponent?: InterpolateComponentResult\n}\n\nexport function interpolateTemplate(\n  insertBefore: Template, // <template end interpolate /> (will be removed)\n  context: Context, // variable scope of {`__tagvar${index}`:'x'}\n  ownerSupport: TagSupport, // Tag class\n  counts: Counts, // used for animation stagger computing\n  options: InterpolateOptions,\n): InterpolateTemplateResult {\n  // TODO: THe clones array is useless here\n  const clones: Clones = []\n\n  if ( !insertBefore.hasAttribute('end') ) {\n    return {clones} // only care about <template end>\n  }\n\n  const variableName = insertBefore.getAttribute('id')\n  if(variableName?.substring(0, variablePrefix.length) !== variablePrefix) {\n    return {clones} // ignore, not a tagVar\n  }\n\n  const existingSubject = context[variableName]\n  const isDynamic = isTagComponent(existingSubject.value) || isTagArray(existingSubject.value)\n\n  // process dynamics later\n  if(isDynamic) {\n    return {\n      clones,\n      tagComponent: {\n        variableName,\n        ownerSupport,\n        subject: existingSubject,\n        insertBefore\n      }}\n  }\n  \n  subscribeToTemplate(\n    insertBefore,\n    existingSubject,\n    ownerSupport,\n    counts,\n  )\n\n  return {clones}\n}\n\nexport function subscribeToTemplate(\n  insertBefore: InsertBefore,\n  subject: InterpolateSubject,\n  ownerSupport: TagSupport,\n  counts: Counts, // used for animation stagger computing\n) {\n  let called = false\n  const onValue = (value: TemplateValue) => {\n    if(called) {\n      updateExistingValue(\n        subject,\n        value,\n        ownerSupport,\n        insertBefore, // needed incase type of value changed and a redraw required\n      )\n      return\n    }\n\n    const templater = value as TemplaterResult\n\n    processFirstSubjectValue(\n      templater,\n      subject,\n      insertBefore,\n      ownerSupport,\n      {\n        counts: {...counts},\n      },\n    )\n\n    called = true\n  }\n\n  let mutatingCallback = onValue\n\n  const callback = (value: TemplateValue) => mutatingCallback(value)\n  const sub = subject.subscribe(callback as any)\n  \n  // on subscribe, the Subject did NOT emit immediately. Lets pull the template off the document\n  if(insertBefore.parentNode) {\n    const clone = subject.clone = swapInsertBefore(insertBefore)\n    mutatingCallback = v => {\n      const parentNode = clone.parentNode as ParentNode\n      parentNode.insertBefore(insertBefore, clone)\n      parentNode.removeChild(clone)\n      delete subject.clone\n      mutatingCallback = onValue // all future calls will just produce value\n      onValue(v) // calls for rending\n    }\n  }\n  \n  ownerSupport.global.subscriptions.push(sub)\n}\n\nexport type Counts = {\n  added: number\n  removed: number // increased when item removed from array\n}\n\nexport function afterElmBuild(\n  elm: Element | ChildNode,\n  options: ElementBuildOptions,\n  context: Context,\n  ownerSupport: TagSupport,\n) {\n  if(!(elm as Element).getAttribute) {\n    return\n  }\n\n  const tagName = elm.nodeName // elm.tagName\n  if(tagName==='TEXTAREA') {\n    scanTextAreaValue(elm as HTMLTextAreaElement, context, ownerSupport)\n  }\n\n  let diff = options.counts.added\n  diff = elementInitCheck(elm, options.counts) - diff\n\n  if((elm as Element).children) {\n    const children = (elm as Element).children as any\n    for (let index = children.length - 1; index >= 0; --index) {\n      const child = children[index]\n      const subOptions = {\n        ...options,\n       counts: options.counts,\n      }\n  \n      return afterElmBuild(child, subOptions, context, ownerSupport)\n    }\n  }\n}\n","import { InputElementTargetEvent } from \"./ElementTargetEvent.interface\"\nimport { Counts } from \"./interpolateTemplate\"\n\nexport function elementInitCheck(\n  nextSibling: Element | ChildNode,\n  counts: Counts\n) {\n  const onInitDoubleWrap = (nextSibling as any).oninit\n  if (!onInitDoubleWrap) {\n    return counts.added\n  }\n\n  const onInitWrap = onInitDoubleWrap.tagFunction\n  if (!onInitWrap) {\n    return counts.added\n  }\n  \n  const onInit = onInitWrap.tagFunction\n  if (!onInit) {\n    return counts.added\n  }\n  \n  const event = { target: nextSibling, stagger: counts.added } as unknown as InputElementTargetEvent\n  onInit(event)\n  \n  return ++counts.added\n}\n","import { Clones } from \"./Clones.type\"\nimport { TagSupport } from \"../tag/TagSupport.class\"\nimport { InterpolateOptions } from \"./interpolateElement\"\nimport { InterpolateComponentResult, Template, interpolateTemplate } from \"./interpolateTemplate\"\n\nexport type InterpolatedContentTemplates = {\n  clones: Clones\n  tagComponents: InterpolateComponentResult[]\n}\n\nexport function interpolateContentTemplates(\n  context: any,\n  tagSupport: TagSupport,\n  options: InterpolateOptions,\n  children: HTMLCollection,\n): InterpolatedContentTemplates {\n  // counting for animation stagger computing\n  const counts = options.counts\n  const clones: Clones = []\n  const tagComponents: InterpolateComponentResult[] = []\n  const childLength = children.length\n  for (let index=childLength-1; index >= 0; --index) {\n    const child = children[index]\n    const {clones: nextClones, tagComponent} = interpolateTemplate(\n      child as Template,\n      context,\n      tagSupport,\n      counts,\n      options,\n    )\n\n    clones.push(...nextClones)\n\n    if(tagComponent) {\n      tagComponents.push(tagComponent)\n      continue\n    }\n      \n    if ( child.children ) {      \n      for (let index = child.children.length - 1; index >= 0; --index) {\n        const subChild = child.children[index]\n        // IF <template end /> its a variable to be processed\n        if ( isRenderEndTemplate(subChild) ) {\n          const {tagComponent} = interpolateTemplate(\n            subChild as Template,\n            context,\n            tagSupport,\n            counts,\n            options,\n          )\n\n          if(tagComponent) {\n            tagComponents.push(tagComponent)\n          }\n        }\n\n        const {clones:nextClones, tagComponents: nextTagComponent} = interpolateContentTemplates(\n          context,\n          tagSupport,\n          options,\n          subChild.children\n        )\n\n        clones.push( ...nextClones )\n        tagComponents.push( ...nextTagComponent )\n      }\n    }\n  }\n\n  return {clones, tagComponents}\n}\n\nfunction isRenderEndTemplate(child: Element) {\n  const isTemplate = child.tagName==='TEMPLATE'\n  return isTemplate &&\n  child.getAttribute('interpolate') !== undefined && \n  child.getAttribute('end') !== undefined\n}\n","import { interpolateAttributes } from \"./interpolateAttributes\"\nimport { interpolateToTemplates } from \"./interpolations\"\nimport { InterpolatedContentTemplates, interpolateContentTemplates } from \"./interpolateContentTemplates\"\nimport { Context, TagTemplate, escapeSearch, variablePrefix } from \"../tag/Tag.class\"\nimport { Clones } from \"./Clones.type\"\nimport { Counts, InterpolateComponentResult } from \"./interpolateTemplate\"\nimport { TagSupport } from \"../tag/TagSupport.class\"\n\nexport type InterpolateOptions = {\n  counts: Counts\n}\n\n/** Review elements within an element */\nexport function interpolateElement(\n  container: DocumentFragment, // element containing innerHTML to review interpolations\n  context: Context, // variables used to evaluate\n  interpolatedTemplates: TagTemplate,\n  ownerSupport: TagSupport,\n  options: InterpolateOptions,\n): InterpolatedContentTemplates {\n  const clones: Clones = []\n  const tagComponents: InterpolateComponentResult[] = []\n  const result = interpolatedTemplates.interpolation\n  const template = container.children[0] as HTMLTemplateElement\n  const children = template.content.children\n\n  if(result.keys.length) {\n    const {clones: nextClones, tagComponents: nextTagComponents} = interpolateContentTemplates(\n      context,\n      ownerSupport,\n      options,\n      children\n    )\n    clones.push( ...nextClones )\n    tagComponents.push( ...nextTagComponents )\n  }\n\n  interpolateAttributes(template, context, ownerSupport)\n  processChildrenAttributes(children, context, ownerSupport)\n\n  return {clones, tagComponents}\n}\n\nfunction processChildrenAttributes(\n  children: HTMLCollection,\n  context: Context,\n  ownerSupport: TagSupport,\n) {\n  for (let index=children.length-1; index >= 0; --index) {\n    const child = children[index]\n    interpolateAttributes(child, context, ownerSupport)\n  \n    if(child.children) {\n      processChildrenAttributes(child.children, context, ownerSupport)\n    }\n  }\n}\n\nexport function interpolateString(string: string) {\n  const result = interpolateToTemplates(string)\n  result.string = result.string.replace(escapeSearch, variablePrefix)\n  return result\n}\n","import { buildClones } from '../render'\nimport { afterElmBuild } from './interpolateTemplate'\nimport { InsertBefore } from './Clones.type'\nimport { Context, ElementBuildOptions } from '../tag/Tag.class'\nimport { TagSupport } from '../tag/TagSupport.class'\n\nexport function afterInterpolateElement(\n  container: DocumentFragment,\n  insertBefore: InsertBefore,\n  tagSupport: TagSupport,\n  context: Context,\n  options: ElementBuildOptions,\n) {\n  const clones = buildClones(container, insertBefore)\n  if(!clones.length) {\n    return clones\n  }\n\n  for (let index = clones.length - 1; index >= 0; --index) {\n    const clone = clones[index]\n    afterElmBuild(clone, options, context, tagSupport)\n    tagSupport.clones.push( clone )\n  }\n\n  return clones\n}\n","import { InsertBefore } from \"./interpolations/Clones.type\"\n\nexport function buildClones(\n  temporary: DocumentFragment,\n  insertBefore: InsertBefore,\n) {\n  const clones = []\n  const template = temporary.children[0] as HTMLTemplateElement\n  let nextSibling = template.content.firstChild\n  const fragment = document.createDocumentFragment()\n    \n  while (nextSibling) {\n    const nextNextSibling = nextSibling.nextSibling as ChildNode\n    clones.push(nextSibling)\n    fragment.appendChild(nextSibling)\n    nextSibling = nextNextSibling\n  }\n\n  if(insertBefore.parentNode) {\n    const parentNode = insertBefore.parentNode as ParentNode\n    parentNode.insertBefore(fragment, insertBefore)\n  }\n\n  return clones\n}\n","import { Props } from '../Props'\nimport { Context, ElementBuildOptions, Tag, TagMemory, TagTemplate, escapeVariable, variablePrefix } from './Tag.class'\nimport { deepClone } from '../deepFunctions'\nimport { isTagComponent } from '../isInstance'\nimport { State } from '../state'\nimport { TagGlobal, TemplaterResult } from './TemplaterResult.class'\nimport { TagSubject, WasTagSubject } from '../subject.types'\nimport { cloneValueArray } from './cloneValueArray.function'\nimport { restoreTagMarker } from './checkDestroyPrevious.function'\nimport { runBeforeDestroy } from './tagRunner'\nimport { DestroyOptions, getChildTagsToDestroy } from './destroy.support'\nimport { elementDestroyCheck } from './elementDestroyCheck.function'\nimport { updateContextItem } from './update/updateContextItem.function'\nimport { processNewValue } from './update/processNewValue.function'\nimport { InsertBefore } from '../interpolations/Clones.type'\nimport { setTagPlaceholder } from './setTagPlaceholder.function'\nimport { interpolateElement, interpolateString } from '../interpolations/interpolateElement'\nimport { subscribeToTemplate } from '../interpolations/interpolateTemplate'\nimport { afterInterpolateElement } from '../interpolations/afterInterpolateElement.function'\n\nconst prefixSearch = new RegExp(variablePrefix, 'g')\n\n/** used only for apps, otherwise use TagSupport */\nexport class BaseTagSupport {\n  isApp = true\n  appElement?: Element // only seen on this.getAppTagSupport().appElement\n\n  strings?: string[]\n  values?: any[]\n\n  propsConfig: {\n    latest: Props // new props NOT cloned props\n    latestCloned: Props\n    lastClonedKidValues: unknown[][]\n  }\n\n  // stays with current render\n  memory: TagMemory = {\n    state: [] as State,\n  }\n\n  clones: (Element | Text | ChildNode)[] = [] // elements on document. Needed at destroy process to know what to destroy\n\n  // travels with all rerenderings\n  global: TagGlobal = {\n    context: {}, // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n    providers: [],\n    /** Indicator of re-rending. Saves from double rending something already rendered */\n    renderCount: 0,\n    deleted: false,\n    subscriptions: [],\n  }\n\n  hasLiveElements = false\n\n  constructor(\n    public templater: TemplaterResult,\n    public subject: TagSubject,\n  ) {\n    const children = templater.children // children tags passed in as arguments\n    const kidValue = children.value\n    const props = templater.props  // natural props\n\n    const latestCloned = props.map(props => deepClone(props))\n    this.propsConfig = {\n      latest: props,\n      latestCloned, // assume its HTML children and then detect\n      lastClonedKidValues: kidValue.map(kid => {\n        const cloneValues = cloneValueArray(kid.values)\n        return cloneValues\n      })\n    }\n  }\n\n  /** Function that kicks off actually putting tags down as HTML elements */\n  buildBeforeElement(\n    insertBefore: InsertBefore,\n    options: ElementBuildOptions = {\n      counts: {added:0, removed: 0},\n    },\n  ) {\n    const subject = this.subject\n    const global = this.global\n    global.insertBefore = insertBefore\n\n    if(!global.placeholder) {\n      setTagPlaceholder(global)\n    }\n\n    const placeholderElm = global.placeholder as Text\n    \n    global.oldest = this as any as TagSupport\n    global.newest = this as any as TagSupport\n\n    subject.tagSupport = this as any as TagSupport\n    this.hasLiveElements = true\n\n    const context = this.update()\n    const template = this.getTemplate()\n    \n    const elementContainer = document.createDocumentFragment()\n    const tempDraw = document.createElement('template')\n    tempDraw.innerHTML = template.string\n    elementContainer.appendChild(tempDraw)\n\n    // Search/replace innerHTML variables but don't interpolate tag components just yet\n    const {tagComponents} = interpolateElement(\n      elementContainer,\n      context,\n      template,\n      this as any as TagSupport, // ownerSupport,\n      {\n        counts: options.counts\n      },\n    )\n\n    afterInterpolateElement(\n      elementContainer,\n      placeholderElm,\n      this as any as TagSupport, // ownerSupport\n      context,\n      options,\n    )\n\n    // Any tag components that were found should be processed AFTER the owner processes its elements. Avoid double processing of elements attributes like (oninit)=${}\n    const length = tagComponents.length\n    for (let index=0; index < length; ++index) {\n      const tagComponent = tagComponents[index]\n      \n      subscribeToTemplate(\n        tagComponent.insertBefore,\n        tagComponent.subject,\n        tagComponent.ownerSupport,\n        options.counts,\n      )\n\n      afterInterpolateElement(\n        elementContainer,\n        tagComponent.insertBefore,\n        tagComponent.ownerSupport,\n        context,\n        options,\n      )\n    }\n  }\n\n  getTemplate(): TagTemplate {\n    const thisTag = this.templater.tag as Tag\n    const strings = this.strings || thisTag.strings\n    const values = this.values || thisTag.values\n    \n    const string = strings.map((string, index) => {\n      const safeString = string.replace(prefixSearch, escapeVariable)\n      const endString = safeString + (values.length > index ? `{${variablePrefix}${index}}` : '')\n      const trimString = endString.replace(/>\\s*/g,'>').replace(/\\s*</g,'<')\n      return trimString\n    }).join('')\n\n    const interpolation = interpolateString(string)\n    return {\n      interpolation,\n      string: interpolation.string,\n      strings,\n      values,\n      context: this.global.context || {},\n    }\n  }\n\n  update() {\n    return this.updateContext( this.global.context )\n  }\n\n  updateContext(context: Context) {\n    const thisTag = this.templater.tag as Tag\n    const strings = this.strings || thisTag.strings\n    const values = this.values || thisTag.values\n\n    strings.map((_string, index) => {\n      const hasValue = values.length > index\n      if(!hasValue) {\n        return\n      }\n\n      const variableName = variablePrefix + index\n      const value = values[index]\n\n      // is something already there?\n      const exists = variableName in context\n\n      if(exists) {\n        return updateContextItem(context, variableName, value)\n      }\n\n      // 🆕 First time values below\n      context[variableName] = processNewValue(\n        value,\n        this as any as TagSupport,\n      )\n    })\n\n    return context\n  }\n}\n\nexport class TagSupport extends BaseTagSupport {\n  isApp = false\n  childTags: TagSupport[] = [] // tags on me\n  \n  constructor(\n    public templater: TemplaterResult, // at runtime rendering of a tag, it needs to be married to a new TagSupport()\n    public ownerTagSupport: TagSupport,\n    public subject: TagSubject,\n    public version: number = 0\n  ) {\n    super(templater, subject)\n  }\n\n  destroy(\n    options: DestroyOptions = {\n      stagger: 0,\n      byParent: false, // Only destroy clones of direct children\n    }\n  ): Promise<number> {\n    const firstDestroy = !options.byParent\n    const global = this.global\n    const subject = this.subject\n    const childTags = options.byParent ? [] : getChildTagsToDestroy(this.childTags)\n\n    if(firstDestroy && isTagComponent(this.templater)) {\n      runBeforeDestroy(this, this)\n    }\n\n    this.destroySubscriptions()\n    \n    // signify immediately child has been deleted (looked for during event processing)\n    for (let index = childTags.length - 1; index >= 0; --index) {\n      const child = childTags[index]\n      const subGlobal = child.global\n      delete subGlobal.newest\n      subGlobal.deleted = true\n\n      if(isTagComponent(child.templater)) {\n        runBeforeDestroy(child, child)\n      }\n    }\n\n    // HTML DOM manipulation. Put back down the template tag\n    const insertBefore = global.insertBefore as Element\n\n    if(insertBefore.nodeName === 'TEMPLATE') {\n      const placeholder = global.placeholder as Text\n      if(placeholder && !('arrayValue' in this.memory)) {\n        if(!options.byParent) {\n          restoreTagMarker(this)\n        }\n      }\n    }\n        \n    let mainPromise: Promise<number | (number | void | undefined)[]> | undefined\n\n    if(this.ownerTagSupport) {\n      this.ownerTagSupport.childTags = this.ownerTagSupport.childTags.filter(child => child !== this)\n    }\n\n    if( firstDestroy ) {\n      const {stagger, promise} = this.destroyClones(options)\n      options.stagger = stagger\n      \n      if(promise) {\n        mainPromise = promise\n      }\n    } else {\n      this.destroyClones()\n    }\n\n    // data reset\n    delete global.placeholder\n    global.context = {}\n    delete global.oldest\n    delete global.newest\n    global.deleted = true\n    this.childTags.length = 0\n    this.hasLiveElements = false\n    delete (subject as WasTagSubject).tagSupport\n\n    if(mainPromise) {\n      mainPromise = mainPromise.then(async () => {\n        const promises = childTags.map(kid => kid.destroy({stagger:0, byParent: true}))\n        return Promise.all(promises)\n      })\n    } else {\n      mainPromise = Promise.all(childTags.map(kid => kid.destroy({stagger:0, byParent: true})))\n    }\n\n    return mainPromise.then(() => options.stagger)\n  }\n\n  destroySubscriptions() {\n    const subs = this.global.subscriptions\n    for (let index = subs.length - 1; index >= 0; --index) {\n      subs[index].unsubscribe()\n    }\n    subs.length = 0\n  }\n\n  destroyClones(\n    {stagger}: DestroyOptions = {\n      stagger: 0,\n    }\n  ) {\n    const oldClones = [...this.clones]\n    this.clones.length = 0 // tag maybe used for something else\n\n    const promises = oldClones.map(\n      clone => this.checkCloneRemoval(clone, stagger)\n    ).filter(x => x) // only return promises\n\n    // check subjects that may have clones attached to them\n    const oldContext = this.global.context\n    for(const name in oldContext){\n      const value = oldContext[name]\n      const clone = value.clone\n      if(clone?.parentNode) {\n        clone.parentNode.removeChild(clone)\n      }\n    }\n    \n    if(promises.length) {\n      return {promise: Promise.all(promises), stagger}\n    }\n\n    return {stagger}\n  }\n\n  /** Reviews elements for the presences of ondestroy */\n  checkCloneRemoval(\n    clone: Element | Text | ChildNode,\n    stagger: number,\n  ) {\n    let promise: Promise<unknown> | undefined\n    \n    const customElm = clone as any\n    if( customElm.ondestroy ) {\n      promise = elementDestroyCheck(customElm, stagger)\n    }\n\n    const next = () => {\n      const parentNode = clone.parentNode as ParentNode\n      if(parentNode) {\n        parentNode.removeChild(clone)\n      }\n\n      const ownerSupport = this.ownerTagSupport\n      if(ownerSupport) {\n        // Sometimes my clones were first registered to my owner, remove them from owner\n        ownerSupport.clones = ownerSupport.clones.filter(compareClone => compareClone !== clone)\n      }\n    }\n\n    if(promise instanceof Promise) {\n      return promise.then(next)\n    } else {\n      next()\n    }\n\n    return promise\n  }\n\n  updateBy(tagSupport: TagSupport) {  \n    const tempTag = tagSupport.templater.tag as Tag\n    this.updateConfig(tempTag.strings, tempTag.values)\n  }\n  \n  updateConfig(strings: string[], values: any[]) {\n    this.strings = strings\n    this.updateValues(values)\n  }\n  \n  updateValues(values: any[]) {\n    this.values = values\n    return this.updateContext( this.global.context )\n  }\n\n  getAppTagSupport() {\n    let tag: TagSupport = this\n    \n    while(tag.ownerTagSupport) {\n      tag = tag.ownerTagSupport\n    }\n\n    return tag\n  }\n}\n\nfunction restoreTagMarkers(support: TagSupport) {\n  restoreTagMarker(support)\n  const childTags = support.childTags\n  for (let index = childTags.length - 1; index >= 0; --index) {\n    restoreTagMarkers(childTags[index].global.oldest as TagSupport)\n  }\n}\n","import { isSubjectInstance, isTagComponent } from '../../isInstance'\nimport { TemplateValue } from './processFirstSubject.utils'\nimport { TagSubject } from '../../subject.types'\nimport { Context } from '../Tag.class'\nimport { TagSupport } from '../TagSupport.class'\nimport { TemplaterResult, Wrapper } from '../TemplaterResult.class'\n\nexport function updateContextItem(\n  context: Context,\n  variableName: string,\n  value: TemplateValue\n) {\n  const subject = context[variableName]\n  const tagSubject = subject as TagSubject\n  const tagSupport = tagSubject.tagSupport\n\n  if(tagSupport) {\n    if(value) {\n      if( isTagComponent(value) ) {\n        const templater = value as TemplaterResult        \n        let newSupport = new TagSupport(\n          templater,\n          tagSupport.ownerTagSupport,\n          subject as TagSubject,\n        )\n        \n        // TODO: Need to review if this is used\n        if(isTagComponent(tagSupport)) {\n          console.warn('👉 deprecated code is being used #shareTemplaterGlobal 👈')\n          shareTemplaterGlobal(tagSupport, newSupport)\n        }\n      }\n    }\n  }\n\n  if(isSubjectInstance(value)) {\n    return // emits on its own\n  }\n\n  // listeners will evaluate updated values to possibly update display(s)\n  subject.set(value)\n  \n  return\n}\n\nfunction shareTemplaterGlobal(\n  oldTagSupport: TagSupport,\n  tagSupport: TagSupport,\n) {\n  const oldTemp = oldTagSupport.templater\n  const oldWrap = oldTemp.wrapper as Wrapper // tag versus component\n  const oldValueFn = oldWrap.parentWrap.original\n  \n  const templater = tagSupport.templater\n  const newWrapper = templater.wrapper\n  const newValueFn = newWrapper?.parentWrap.original\n  const fnMatched = oldValueFn === newValueFn\n\n  if(fnMatched) {\n    tagSupport.global = oldTagSupport.global\n    const newest = oldTagSupport.global.newest as TagSupport\n    if(newest) {\n      const prevState = newest.memory.state\n      tagSupport.memory.state.length = 0\n      tagSupport.memory.state.push(...prevState)\n      // tagSupport.memory.state = [...prevState]\n    }\n  }\n}\n","export function elementDestroyCheck<T>(\n  nextSibling: Element & {ondestroy?: (event: Event) => T},\n  stagger: number,\n): T | undefined {\n  const onDestroyDoubleWrap = nextSibling.ondestroy\n  if(!onDestroyDoubleWrap) {\n    return\n  }\n\n  const onDestroyWrap = (onDestroyDoubleWrap as any).tagFunction\n  if(!onDestroyWrap) {\n    return\n  }\n\n  const onDestroy = onDestroyWrap.tagFunction\n  if(!onDestroy) {\n    return\n  }\n\n  const event = {target: nextSibling, stagger} as unknown as Event\n  return onDestroy(event)\n}\n","import { Tag } from './Tag.class'\nimport { setUse } from '../state'\nimport { TemplaterResult, Wrapper } from './TemplaterResult.class'\nimport { TagComponent, TagWrapper, tags } from './tag.utils'\nimport { ValueTypes } from './update/processFirstSubject.utils'\nimport { getTagWrap } from './getTagWrap.function'\nimport { RouteProps } from './RouteProps.type'\nimport { html } from './html'\n\nexport type ToTag = (...props: any[]) => StateToTag | Tag\nexport type ToStateToTag = (...props: any[]) => StateToTag\nexport type StateToTag = (...state: any[]) => Tag\n\nlet tagCount = 0\n\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag<T extends ToTag>(\n  tagComponent: T\n): T & {original: Function} {\n  /** function developer triggers */\n  const parentWrap = (function tagWrapper(\n    ...props: (T | Tag | Tag[])[]\n  ): TemplaterResult {\n    const templater: TemplaterResult = new TemplaterResult(props)\n    templater.tagJsType = ValueTypes.tagComponent\n    \n    // attach memory back to original function that contains developer display logic\n    const innerTagWrap: Wrapper = getTagWrap(\n      templater,\n      parentWrap\n    )\n\n    if(!innerTagWrap.parentWrap) {\n      innerTagWrap.parentWrap = parentWrap\n    }\n    \n    templater.tagged = true\n    templater.wrapper = innerTagWrap as Wrapper\n\n    return templater\n  }) as TagWrapper<T>// we override the function provided and pretend original is what's returned\n  \n  ;(parentWrap as any).original = tagComponent\n  parentWrap.compareTo = (tagComponent as any).toString()\n\n  const tag = tagComponent as unknown as TagComponent\n  parentWrap.isTag = true\n  parentWrap.original = tag\n\n  // group tags together and have hmr pickup\n  tag.tags = tags\n  tag.setUse = setUse\n  tag.tagIndex = tagCount++ // needed for things like HMR\n  tags.push(parentWrap)\n\n  return parentWrap as unknown as (T & {original: Function})\n}\n\n/** Used to create a tag component that renders once and has no addition rendering cycles */\ntag.oneRender = (...props: any[]): (Tag | StateToTag) => {\n  throw new Error('Do not call function tag.oneRender but instead set it as: `(props) => tag.oneRender = (state) => html`` `')\n}\n\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.route = (routeProps: RouteProps): StateToTag => {\n  throw new Error('Do not call function tag.route but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `')\n}\n\nObject.defineProperty(tag, 'oneRender', {\n  set(oneRenderFunction: Function) {\n    (oneRenderFunction as any).oneRender = true\n  },\n})\n","import { TemplaterResult, Wrapper } from './TemplaterResult.class'\nimport { TagWrapper } from './tag.utils'\nimport { runTagCallback } from '../interpolations/bindSubjectCallback.function'\nimport { deepClone } from '../deepFunctions'\nimport { TagSupport } from './TagSupport.class'\nimport { TagSubject } from '../subject.types'\nimport { alterProps } from '../alterProps.function'\n\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(\n  templater: TemplaterResult,\n  result: TagWrapper<any>\n): Wrapper {\n  // this function gets called by taggedjs\n  const wrapper = function(\n    newTagSupport: TagSupport,\n    subject: TagSubject,\n  ): TagSupport {\n    const global = newTagSupport.global\n    ++global.renderCount\n        \n    const childSubject = templater.children\n    const lastArray = global.oldest?.templater.children.lastArray\n    if(lastArray) {\n      childSubject.lastArray = lastArray\n    }\n\n    // result.original\n    const originalFunction = result.original // (innerTagWrap as any).original as unknown as TagComponent\n    \n    let props = templater.props\n    let castedProps = props.map(props => alterProps(\n      props,\n      newTagSupport.ownerTagSupport,\n    ))\n    const latestCloned = props.map(props => deepClone(props)) // castedProps\n\n    // CALL ORIGINAL COMPONENT FUNCTION\n    let tag = originalFunction(...castedProps)\n\n    if(tag instanceof Function) {\n      tag = tag()\n    }\n\n    tag.templater = templater\n    templater.tag = tag\n\n    const tagSupport = new TagSupport(\n      templater,\n      newTagSupport.ownerTagSupport,\n      subject,\n      global.renderCount\n    )\n\n    tagSupport.global = global\n\n    tagSupport.propsConfig = {\n      latest: props,\n      latestCloned,\n      lastClonedKidValues: tagSupport.propsConfig.lastClonedKidValues,\n    }\n\n    tagSupport.memory = newTagSupport.memory // state handover\n\n    if( templater.madeChildIntoSubject ) {\n      const value = childSubject.value\n      for (let index = value.length - 1; index >= 0; --index) {\n        const kid = value[index]\n        const values = kid.values\n        for (let index = values.length - 1; index >= 0; --index) {\n          const value = values[index]\n          if(!(value instanceof Function)) {\n            continue\n          }\n\n          const valuesValue = kid.values[index]\n          \n          if(valuesValue.isChildOverride) {\n            continue // already overwritten\n          }\n\n          // all functions need to report to me\n          kid.values[index] = function(...args: unknown[]) {\n            const ownerSupport = tagSupport.ownerTagSupport\n            return runTagCallback(\n              value, // callback\n              ownerSupport,\n              this, // bindTo\n              args\n            )\n          }\n          \n          valuesValue.isChildOverride = true\n        }\n      }\n    }\n\n    return tagSupport\n  }\n\n  return wrapper as Wrapper\n}\n","import { InputElementTargetEvent } from \"../interpolations/ElementTargetEvent.interface\"\nimport { RegularValue } from \"../subject.types\"\nimport { Tag } from \"./Tag.class\"\n\nexport type TagValues = (((e: InputElementTargetEvent) => any) | RegularValue | null | undefined | Object)[]\n\nexport function html(\n  strings: string[] | TemplateStringsArray,\n  ...values: TagValues\n) {\n  return new Tag(strings as string[], values)\n}\n","import { BaseTagSupport, TagSupport } from './TagSupport.class'\nimport { runAfterRender, runBeforeRender } from './tagRunner'\nimport { TemplaterResult, Wrapper } from './TemplaterResult.class'\nimport { TagComponent, TagMaker} from './tag.utils'\nimport { ValueSubject } from '../subject/ValueSubject'\nimport { TagSubject } from '../subject.types'\n\nconst appElements: {\n  tagSupport: TagSupport\n  element: Element\n}[] = []\n\n/**\n * \n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns \n */\nexport function tagElement(\n  app: TagMaker, // (...args: unknown[]) => TemplaterResult,\n  element: HTMLElement | Element,\n  props?: unknown,\n): {\n  tagSupport: TagSupport\n  tags: TagComponent[]\n} {\n  const appElmIndex = appElements.findIndex(appElm => appElm.element === element)\n  if(appElmIndex >= 0) {\n    appElements[appElmIndex].tagSupport.destroy()\n    appElements.splice(appElmIndex, 1)\n    // an element already had an app on it\n    console.warn('Found and destroyed app element already rendered to element', {element})\n  }\n\n  // Create the app which returns [props, runOneTimeFunction]\n  const wrapper = app(props) as unknown as TemplaterResult\n\n  // have a function setup and call the tagWrapper with (props, {update, async, on})\n  const tagSupport = runWrapper(wrapper)\n  \n  // TODO: is the below needed?\n  tagSupport.appElement = element\n  tagSupport.isApp = true\n  tagSupport.global.isApp = true\n    \n  const templateElm = document.createElement('template')\n  templateElm.setAttribute('id', 'app-tag-' + appElements.length)\n  templateElm.setAttribute('app-tag-detail', appElements.length.toString())\n  \n  const fragment = document.createDocumentFragment()\n  fragment.appendChild(templateElm)\n\n  ;(element as any).destroy = async () => {\n    await tagSupport.destroy()\n    const insertBefore = tagSupport.global.insertBefore as Element\n    const parentNode = insertBefore.parentNode as ParentNode\n    parentNode.removeChild(insertBefore)\n  }\n  \n  tagSupport.buildBeforeElement(templateElm)\n\n  tagSupport.global.oldest = tagSupport\n  tagSupport.global.newest = tagSupport\n\n  ;(element as any).setUse = (app as any).original.setUse\n\n  appElements.push({element, tagSupport})\n  element.appendChild(fragment)\n\n  return {\n    tagSupport,\n    tags: (app as any).original.tags,\n  }\n}\n\nexport function runWrapper(\n  templater: TemplaterResult,\n) {\n  let newSupport = {} as TagSupport\n  const subject = new ValueSubject<TagSupport>(newSupport) as unknown as TagSubject\n    \n  newSupport = new BaseTagSupport(\n    templater,\n    subject,\n  ) as TagSupport\n\n  subject.set( templater )\n  \n  subject.tagSupport = newSupport\n  \n  runBeforeRender(newSupport, undefined as unknown as TagSupport)\n\n  // Call the apps function for our tag templater\n  const wrapper = templater.wrapper as Wrapper\n  const tagSupport = wrapper(\n    newSupport,\n    subject,\n  )\n\n  runAfterRender(newSupport, tagSupport)\n\n  return tagSupport\n}\n","export * from \"./tag/tag\"\nexport * from \"./tag/tag.utils\"\nexport * from \"./tag/html\"\nexport * from \"./errors\"\nexport * from \"./isInstance\"\nexport * from \"./state/index\"\nexport * from \"./subject/index\"\nexport * from \"./tag/TagSupport.class\"\nexport * from \"./interpolations/ElementTargetEvent.interface\"\nexport * from \"./interpolations/interpolateElement\"\n\nexport { tagElement } from \"./tag/tagElement\"\nexport { Tag } from \"./tag/Tag.class\"\nexport { runBeforeRender } from \"./tag/tagRunner\"\nexport { renderTagSupport } from \"./tag/render/renderTagSupport.function\"\nexport { renderWithSupport } from \"./tag/render/renderWithSupport.function\"\nexport { isLikeValueSets } from \"./tag/isLikeTags.function\"\n\nimport { renderTagOnly } from \"./tag/render/renderTagOnly.function\"\nimport { renderTagSupport } from \"./tag/render/renderTagSupport.function\"\nimport { renderWithSupport } from \"./tag/render/renderWithSupport.function\"\nimport { tagElement } from \"./tag/tagElement\"\nexport const hmr = {\n  tagElement, renderWithSupport, renderTagSupport,\n  renderTagOnly,\n}\n\nexport { Wrapper } from './tag/TemplaterResult.class'","import { html, letState, tag } from \"taggedjs\"\n\nexport const attributeDebug = tag(() => {\n  let selected: string = letState('a')(x => [selected, selected = x])\n  let isOrange: boolean = letState(true)(x => [isOrange, isOrange = x])\n\n  return html`\n    <input onchange=${(event: any) => selected = event.target.value} placeholder=\"a b or c\" />\n    <select id=\"select-sample-drop-down\">\n      ${['a','b','c'].map(item => html`\n        <option value=${item} ${item == selected ? 'selected' : ''}>${item} - ${item == selected ? 'true' : 'false'}</option>\n      `.key(item))}\n    </select>\n    <hr />\n    <h3>Special Attributes</h3>\n    <div>\n      <input type=\"checkbox\" onchange=${(event: any) => isOrange = event.target.checked} ${isOrange && 'checked'} /> - ${isOrange ? 'true' : 'false'}\n    </div>\n    <div style=\"display: flex;flex-wrap:wrap;gap:1em\">      \n      <div\n        style.background-color=${isOrange ? 'orange' : ''}\n        style.color=${isOrange ? 'black': ''}\n      >style.background-color=&dollar;{'orange'}</div>\n      \n      <div\n        class.background-orange=${isOrange ? true : false}\n        class.text-black=${isOrange ? true : false}\n      >class.background-orange=&dollar;{true}</div>\n      \n      <div class=${isOrange ? 'background-orange text-black' : ''}\n      >class=&dollar;{'background-orange text-black'}</div>\n      \n      <div ${{class: 'text-white' + (isOrange ? ' background-orange' : '')}}\n      >class=&dollar;{'background-orange'} but always white</div>\n    </div>\n    <style>\n      .background-orange {background-color:orange}\n      .text-black {color:black}\n      .text-white {color:white}\n    </style>\n  `\n})\n","import { html, tag, letState, ValueSubject, state, combineLatest, willPromise } from \"taggedjs\"\n\nexport const contentDebug = tag(() => {\n  const vs0 = state(() => new ValueSubject(0))\n  const vs1 = state(() => new ValueSubject(1))\n\n  let renderCount: number = letState(0)(x => [renderCount, renderCount=x])\n\n  ++renderCount\n\n  return html`\n    <div style=\"font-size:0.8em\">You should see \"0\" here => \"${0}\"</div>\n    <!--proof you cannot see false values -->\n    <div style=\"font-size:0.8em\">\n      <fieldset>\n        <legend>false test</legend>\n        You should see \"\" here => \"${false}\"\n      </fieldset>\n    </div>\n    <div style=\"font-size:0.8em\">\n      <fieldset>\n        <legend>null test</legend>\n        You should see \"\" here => \"${null}\"\n      </fieldset>\n    </div>\n    <div style=\"font-size:0.8em\">\n      <fieldset>\n        <legend>undefined test</legend>\n        You should see \"\" here => \"${undefined}\"\n      </fieldset>\n    </div>\n    <!--proof you can see true booleans -->\n    <div style=\"font-size:0.8em\">\n      <fieldset>\n        <legend>true test</legend>\n        You should see \"true\" here => \"${true}\"\n      </fieldset>\n    </div>\n    <!--proof you can try to use the tagVar syntax -->\n    <div style=\"font-size:0.8em\">You should see \"${'{'}22${'}'}\" here => \"{22}\"</div>\n    <div style=\"font-size:0.8em\">You should see \"${'{'}__tagVar0${'}'}\" here => \"{__tagVar0}\"</div>\n    <div style=\"font-size:0.8em\">should be a safe string no html \"&lt;div&gt;hello&lt;/div&gt;\" here => \"${'<div>hello</div>'}\"</div>\n    <div style=\"display:flex;flex-wrap:wrap;gap;1em\">\n      <fieldset style=\"flex:1\">\n        <legend>value subject</legend>\n        0 === ${vs0}\n      </fieldset>\n      \n      <fieldset style=\"flex:1\">\n        <legend>piped subject</legend>        \n        <span id=\"content-subject-pipe-display0\">55</span> ===\n        <span id=\"content-subject-pipe-display1\">${vs0.pipe(() => 55)}</span>\n      </fieldset>\n      \n      <fieldset style=\"flex:1\">\n        <legend>combineLatest</legend>\n        <span id=\"content-combineLatest-pipe-display0\">1</span> ===\n        <span id=\"content-combineLatest-pipe-display1\">${combineLatest([vs0, vs1]).pipe(x => x[1])}</span>\n      </fieldset>\n      \n      <fieldset style=\"flex:1\">\n        <legend>combineLatest piped html</legend>\n        <span id=\"content-combineLatest-pipeHtml-display0\"><b>bold 77</b></span> ===\n        <span id=\"content-combineLatest-pipeHtml-display1\">${\n          combineLatest([vs0, vs1]).pipe(\n            willPromise(x => Promise.resolve(html`<b>bold 77</b>`))\n          )\n        }</span>\n      </fieldset>\n    </div>\n    (render count ${renderCount})\n  `\n})","import { Subject } from \"./Subject.class\"\nimport { OperatorFunction, PipeUtils, SubjectLike } from \"./subject.utils\"\n\n\ntype WillCallback<T, R> = (lastValue: T, resolve: (result: R) => void) => void;\n\nexport function willCallback<T = any, R = any>(\n  callback: WillCallback<T, R>,\n): OperatorFunction<T, R, any> {\n  return ((lastValue: any, utils: any) => {\n    utils.setHandler(() => {\n      return undefined as any;\n    });\n\n    callback(lastValue, utils.next);\n  }) as any\n}\n\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise<T, H>(\n  callback: (\n    lastValue: T,\n  ) => Promise<H>\n): OperatorFunction<T, H, any> {\n  return ((lastValue: T, utils: any) => {\n    utils.setHandler(() => {\n      return undefined as any\n    }) // do nothing on initial return\n\n    const result = callback(lastValue) as Promise<any>\n\n    result.then(x => utils.next(x))\n  }) as any\n}\n\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = <T, H>(\n  callback: (\n    lastValue: T,\n  ) => SubjectLike<H>\n): OperatorFunction<T, H, any> => {\n  return ((lastValue: T, utils: PipeUtils<H>) => {\n    utils.setHandler(() => {\n      return undefined as any\n    }) // do nothing on initial return\n\n    const result = callback(lastValue) as Subject<H>\n\n    const subscription = result.subscribe(x => {\n      subscription.unsubscribe()\n      utils.next(x)\n    })\n  }) as any\n}\n","import { html, tag, letState } from \"taggedjs\"\n\nexport const tableDebug = tag(() => {\n  let showCell: boolean = letState(true)(x => [showCell, showCell = x])\n\n  return html`\n    <div style=\"max-height: 800px;overflow-y: scroll;\">\n      <table cellPadding=${5} cellSpacing=${5} border=\"1\">\n        <thead style=\"position: sticky;top: 0;\">\n          <tr>\n            <th>hello</th>\n            <th>hello</th>\n            ${showCell && html`\n              <td>hello 2 thead cell</td>\n            `}\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td>world</td>\n            <td>world</td>\n            ${showCell && html`\n              <td>world 2 tbody cell</td>\n            `}\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  `\n})\n","import { tag, html } from \"taggedjs\"\n\nexport const renderCountDiv = tag((\n  {renderCount, name}: {\n    renderCount: number\n    name: string\n  }\n) => html`<div><small>(${name} render count <span id=${name+'_render_count'}>${renderCount}</span>)</small></div>`)\n","import { watch, letState, html, tag, InputElementTargetEvent, onInit, letProp } from \"taggedjs\"\nimport { renderCountDiv } from \"./renderCount.component\"\nimport { watchTesting } from \"./watchTesting.tag\"\n\nexport const propsDebugMain = tag((_='propsDebugMain') => (\n  propNumber = letState(0)(x => [propNumber, propNumber = x]),\n  renderCount = letState(0)(x => [renderCount, renderCount = x]),\n  propsJson = letState({test:33, x:'y'})(x => [propsJson, propsJson = x]),\n  date = letState(() => new Date())(x => [date, date = x]),\n  syncPropNumber = letState(0)(x => [syncPropNumber, syncPropNumber = x]),\n  json = JSON.stringify(propsJson, null, 2),\n) => html`\n  <textarea id=\"props-debug-textarea\" wrap=\"off\"\n    onchange=${event => propsJson = JSON.parse(event.target.value)}\n    style=\"height:200px;font-size:0.6em;width:100%\"\n  >${ json }</textarea>\n  \n  <pre>${ json }</pre>\n  <div><small>(renderCount:${++renderCount})</small></div>\n  \n  <div>\n    <button id=\"propsDebug-🥩-0-button\"\n      onclick=${() => ++propNumber}\n    >🥩 propNumber ${propNumber}</button>\n    <span id=\"propsDebug-🥩-0-display\">${propNumber}</span>\n  </div>\n  \n  <fieldset>\n    <legend>child</legend>\n    ${propsDebug({\n      propNumber,\n      propsJson,\n      propNumberChange: x => {\n        propNumber = x\n      }\n    })}\n  </fieldset>\n\n  <fieldset>\n    <legend>sync props callback</legend>\n    🥡 syncPropNumber: <span id=\"sync-prop-number-display\">${syncPropNumber}</span>\n    <button onclick=${() => ++syncPropNumber}>🥡 ++</button>\n    <hr />\n    ${syncPropDebug({\n      syncPropNumber,\n      propNumberChange: x => {\n        syncPropNumber = x\n      },\n      nothingTest: x => x\n    })}\n  </fieldset>\n\n  <fieldset>\n    <legend>date prop</legend>\n    date:${date}\n    <input type=\"date\" value=${timestampToValues(date).date} onchange=${event => {\n      const newDateString = event.target.value\n      date = new Date(newDateString)\n    }} />\n    <hr />\n    ${propDateDebug({date})}\n  </fieldset>\n`)\n\nconst propDateDebug = tag(({date}: {date: Date}) => html`date:${date}`)\n\n/** Tests calling a property that is a function immediately which should cause rendering */\nconst syncPropDebug = tag((\n  {\n    syncPropNumber,\n    propNumberChange,\n    nothingTest,\n  }: {\n    syncPropNumber: number\n    propNumberChange: (x: number) => any\n    nothingTest: <T>(x: T) => T\n  }\n) => {\n  let counter = letState(0)(x => [counter, counter = x])\n\n  if(syncPropNumber % 2 === 1) {\n    propNumberChange(syncPropNumber = syncPropNumber + 1)\n  }\n  \n  return html`<!--syncPropDebug-->\n    <div>\n      🥡 syncPropNumber:<span id=\"sync-prop-child-display\">${syncPropNumber}</span>\n      <button id=\"sync-prop-child-button\" onclick=${() => propNumberChange(++syncPropNumber)}>🥡 ++</button>\n    </div>\n    <div>\n      <div>\n        counter:<span id=\"sync-prop-counter-display\">${counter}</span>\n      </div>\n      nothingTest<span id=\"nothing-prop-counter-display\">${nothingTest(counter)}</span>\n      <button id=\"nothing-prop-counter-button\" onclick=${() => nothingTest(++counter)}>++</button>\n    </div>\n  `\n})\n\nconst propsDebug = tag((\n  {\n    propNumber,\n    propsJson,\n    propNumberChange,\n  }: {\n    propNumber: number,\n    propNumberChange: (x: number) => unknown,\n    propsJson: any\n  }\n) => (\n  renderCount = letState(0)(x => [renderCount, renderCount=x]),\n  propNumberChangeCount = letState(0)(x => [propNumberChangeCount, propNumberChangeCount=x]),\n\n  // poor way to update an argument\n  myPropNumber = letState(propNumber)(x => [myPropNumber, myPropNumber=x]),\n  _ = watch([propNumber], () => myPropNumber = propNumber),\n  watchResults = watch([myPropNumber], () => ++propNumberChangeCount),\n\n  // simple way to locally only update an argument\n  __ = letProp(propNumber)(x => [propNumber, propNumber = x]),\n) => html`<!--propsDebug.js-->\n  <h3>Props Json</h3>\n  <textarea style=\"font-size:0.6em;height:200px;width:100%\" wrap=\"off\"\n    onchange=${event=> {\n      const value = JSON.parse(event.target.value)\n      Object.assign(propsJson, value)\n    }}\n  >${ JSON.stringify(propsJson, null, 2) }</textarea>\n  <pre>${ JSON.stringify(propsJson, null, 2) }</pre>\n  <hr />\n  \n  <h3>Props Number</h3>\n  <textarea style=\"font-size:0.6em;height:200px;width:100%;color:white;\" wrap=\"off\" disabled\n  >${ JSON.stringify(watchResults, null, 2) }</textarea>\n  \n  <div>\n    <button id=\"propsDebug-🥩-1-button\" onclick=${() => propNumberChange(++myPropNumber)}\n    >🐄 🥩 propNumber ${myPropNumber}</button>\n    <span id=\"propsDebug-🥩-1-display\">${myPropNumber}</span>\n  </div>\n\n  <div>\n    <button id=\"propsDebug-🥩-2-button\" onclick=${() => ++propNumber}\n    >🐄 🥩 local set propNumber ${propNumber}</button>\n    <span id=\"propsDebug-🥩-2-display\">${propNumber}</span>\n  </div>\n\n  <button\n    title=\"test of increasing render count and nothing else\"\n    onclick=${() => ++renderCount}\n  >renderCount ${++renderCount}</button>\n  \n  <button onclick=${() => ++myPropNumber}\n    title=\"only changes number locally but if change by parent than that is the number\"\n  >🐄 🥩 local set myPropNumber ${myPropNumber}</button>\n  \n  <div>\n    <small>\n      (propNumberChangeCount:<span id=\"propsDebug-🥩-change-display\">${propNumberChangeCount}</span>)\n    </small>\n  </div>\n  \n  <hr />\n\n  <h3>Fn update test</h3>\n  ${propFnUpdateTest({\n    propNumber: myPropNumber,\n    callback: () => ++myPropNumber\n  })}    \n`)\n\nconst propFnUpdateTest = tag(({\n  propNumber, callback,\n}: {\n  propNumber: number, callback: Function\n}) => {\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  ++renderCount\n\n  return html`\n    <button id=\"propsOneLevelFunUpdate-🥩-button\"\n      onclick=${callback}\n    >🐄 🥩 local & 1-parent increase ${propNumber}</button>\n    <span id=\"propsOneLevelFunUpdate-🥩-display\">${propNumber}</span>\n    ${renderCountDiv({renderCount, name: 'propFnUpdateTest'})}\n    <small style=\"opacity:.5\">the count here and within parent increases but not in parent parent</small>\n  `\n})\n\nfunction timestampToValues(\n  timestamp: number | Date | string\n) {\n  const date = new Date(timestamp);\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  const hours = String(date.getHours()).padStart(2, '0');\n  const minutes = String(date.getMinutes()).padStart(2, '0');\n\n  return {\n      date: `${year}-${month}-${day}`,\n      time: `${hours}:${minutes}`\n  };\n}\n","import { letState } from \"./letState.function\"\nimport { GetSet } from \"./state.utils\"\nimport { watch } from \"./watch.function\"\n\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp<T>(\n  prop: T,\n): ((getSet: GetSet<T>) => T) {\n  return getSetProp => {\n    let myProp = letState(prop)(getSetProp)\n    \n    watch([prop], () => getSetProp(myProp = prop))\n    \n    getSetProp(myProp)\n    \n    return myProp\n  }\n}\n","export function createFx({ fxIn, fxOut, staggerBy = 300, }) {\n    return {\n        in: (input) => animateInit({ fxName: fxIn, staggerBy, ...input }),\n        out: (input) => animateDestroy({ fxName: fxOut, staggerBy, capturePosition: true, ...input }),\n    };\n}\nconst animateInit = async ({ target, stagger, staggerBy, fxName = 'fadeInDown' }) => {\n    target.style.opacity = '0';\n    if (stagger) {\n        await wait(stagger * staggerBy);\n    }\n    target.style.opacity = '1';\n    target.classList.add('animate__animated', 'animate__' + fxName);\n};\nconst animateDestroy = async ({ target, stagger, capturePosition = true, fxName = 'fadeOutUp', staggerBy }) => {\n    if (capturePosition) {\n        captureElementPosition(target);\n    }\n    if (stagger) {\n        await wait(stagger * staggerBy);\n    }\n    target.classList.add('animate__animated', 'animate__' + fxName);\n    await wait(1000); // don't allow remove from stage until animation completed\n    target.classList.remove('animate__animated', 'animate__' + fxName);\n};\n// absolute\nexport function captureElementPosition(element) {\n    element.style.zIndex = element.style.zIndex || 1;\n    const toTop = element.offsetTop + 'px';\n    const toLeft = element.offsetLeft + 'px';\n    const toWidth = (element.clientWidth + (element.offsetWidth - element.clientWidth) + 1) + 'px';\n    const toHeight = (element.clientHeight + (element.offsetHeight - element.clientHeight) + 1) + 'px';\n    const fix = () => {\n        element.style.top = toTop;\n        element.style.left = toLeft;\n        element.style.width = toWidth;\n        element.style.height = toHeight;\n        element.style.position = 'absolute';\n    };\n    // element.style.position = 'fixed'\n    // allow other elements that are being removed to have a moment to figure out where they currently sit\n    setTimeout(fix, 0);\n}\nfunction wait(time) {\n    return new Promise((res) => {\n        setTimeout(res, time);\n    });\n}\n//# sourceMappingURL=createFx.function.js.map","import { createFx } from \"./createFx.function\";\nexport const { in: fadeInDown, out: fadeOutUp } = createFx({ fxIn: 'fadeInDown', fxOut: 'fadeOutUp' });\n//# sourceMappingURL=index.js.map","import { fadeInDown, fadeOutUp } from './animations'\nimport { renderCountDiv } from './renderCount.component'\nimport {html, state, letState, tag} from 'taggedjs'\n\nconst frameCount = 4\ntype Player = {\n  name: string\n  edit?: boolean\n  scores: any[]\n}\n\nexport const arrayTests = tag(function ArrayTests(){/* ArrayTests */\n  const players: Player[] = state([])\n  let renderCount: number = letState(0)(x => [renderCount, renderCount = x])\n\n  const getNewPlayer = () => ({\n    name: 'Person '+players.length,\n    scores: '0,'.repeat(/*frameCount*/0).split(',').map((_v, index) => ({\n      frame: index + 1,\n      score: Math.floor(Math.random() * 4) + 1\n    }))\n  })\n\n  ++renderCount\n\n  return html`<!--arrayTests.js-->\n    <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n      ${playersDisplay({players, getNewPlayer})}\n    </div>\n\n    <button id=\"array-test-push-item\" onclick=${() => {\n      players.push(getNewPlayer())\n    }}>push item ${players.length+1}</button>\n\n    <button onclick=${() => {\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n    }}>push 3 items</button>\n\n    <button onclick=${() => {\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n      players.push(getNewPlayer())\n    }}>push 9 items</button>\n\n    ${players.length > 0 && html`\n      <button oninit=${fadeInDown} ondestroy=${fadeOutUp}\n        style=\"--animate-duration: .1s;\"\n        onclick=${() => players.length = 0}\n      >remove all</button>\n    `}\n\n    ${renderCountDiv({renderCount, name: 'arrayTests.ts'})}\n  `\n})\n\nconst scoreData = tag((\n  {score, playerIndex}: {\n    playerIndex: number\n    score:{score: number, frame: number}\n  }\n) => {\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  \n  ++renderCount\n\n  return html`\n    frame:${score.frame}:\n    <button\n      id=${`score-data-${playerIndex}-${score.frame}-inside-button`}\n      onclick=${() => ++score.score}\n    >inner score button ++${score.score}</button>\n    <span id=${`score-data-${playerIndex}-${score.frame}-inside-display`}\n    >${score.score}</span>\n    <button onclick=${() => ++renderCount}>increase renderCount</button>\n    ${renderCountDiv({renderCount, name:'scoreData' + score.frame})}\n  `\n})\n\nconst playersDisplay = tag(({\n  players, getNewPlayer,\n}: {\n  players: Player[]\n  getNewPlayer: () => Player\n}) => {\n  const playersContent = players.map((player,index) => html`\n    <div oninit=${fadeInDown} ondestroy=${fadeOutUp}\n      style=\"background-color:black;--animate-duration: .1s;\"\n    >\n      <div>\n        name:${player.name}\n      </div>\n      <div>\n        index:${index}\n      </div>\n      \n      <div style=\"background-color:purple;padding:.5em\">\n        scores:${player.scores.map((score, playerIndex) => html`\n        <div style=\"border:1px solid white;--animate-duration: .1s;\"\n          oninit=${fadeInDown} ondestroy=${fadeOutUp}\n        >\n          <fieldset>\n            <legend>\n              <button id=${`score-data-${playerIndex}-${score.frame}-outside-button`}\n                onclick=${() => ++score.score}\n              >outer score button ++${score.score}</button>\n              <span id=${`score-data-${playerIndex}-${score.frame}-outside-display`}\n              >${score.score}</span>\n            </legend>\n            ${scoreData({score, playerIndex})}\n          </fieldset>\n        </div>\n      `.key(score))}</div>\n      \n      ${player.edit && html`\n        <button onclick=${() => {\n          players.splice(index,1);\n          player.edit = !player.edit\n        }}>remove</button>\n      `}\n      ${player.edit && html`\n        <button id=${'player-remove-promise-btn-' + index} onclick=${async () => {\n          player.edit = !player.edit\n          players.splice(index,1);\n        }}>remove by promise</button>\n      `}\n      <button id=${'player-edit-btn-' + index} onclick=${() => player.edit = !player.edit}>edit</button>\n      <button onclick=${() => {\n        players.splice(index,0,getNewPlayer())\n      }}>add before</button>\n    </div>\n  `.key(player))\n\n  return html`\n    <!-- playersLoop.js -->\n    ${playersContent}\n    <!-- end:playersLoop.js -->\n  `\n})","import { letState, html, tag, onInit, callbackMaker, onDestroy } from \"taggedjs\"\n\nconst test0interval = 3000\nconst test1interval = 6000\n\nexport const intervalTester0 = tag(() => {\n  let intervalCount: number = letState(0)(x => [intervalCount, intervalCount = x])\n  let intervalId: any = letState(undefined)(x => [intervalId, intervalId = x])\n  let intervalId2: any = letState(undefined)(x => [intervalId2, intervalId2 = x])\n  let renderCounter: number = letState(0)(x => [renderCounter, renderCounter = x])\n  let currentTime: number = letState(0)(x => [currentTime, currentTime = x])\n  \n  const callback = callbackMaker()\n  const increase = () => ++intervalCount\n\n  const startInterval = () => {\n    console.info('🟢 interval test 0 started...')\n    trackTime()\n\n    intervalId = setInterval(callback(() => {\n      increase()\n    }),test0interval)\n  }\n\n  const stopInterval = () => {\n    clearInterval(intervalId)\n    clearInterval(intervalId2)\n    intervalId = undefined\n    intervalId2 = undefined\n    console.info('🛑 interval test 0 stopped')\n  }\n\n  function trackTime() {\n    currentTime = 0\n    \n    intervalId2 = setInterval(callback(() => {\n      currentTime = currentTime + 500\n\n      if(currentTime >= test0interval) {\n        currentTime = 0\n      }      \n    }), 500)\n\n    console.info('▶️ interval started')\n  }\n\n  const toggle = () => {\n    if(intervalId || intervalId2) {\n      stopInterval()\n      return\n    }\n\n    startInterval()\n  }\n\n  const delayIncrease = () => setTimeout(callback(() => {\n    currentTime = currentTime + 200\n  }), 1000);\n\n  onInit(startInterval)\n  onDestroy(stopInterval)\n\n  ++renderCounter\n\n  return html`<!--intervalDebug.js-->\n    <div>interval type 1 at ${test0interval}ms</div>\n    intervalId: ${intervalId}\n    <button type=\"button\" onclick=${increase}>${intervalCount}:${renderCounter}</button>\n    <input type=\"range\" min=\"0\" max=${test0interval} step=\"1\" value=${currentTime} />\n    <div>\n      --${currentTime}--\n    </div>\n    <button type=\"button\" onclick=${toggle}\n      style.background-color=${intervalId || intervalId2 ? 'red' : 'green'}\n    >start/stop</button>\n    <button type=\"button\" onclick=${delayIncrease}>delay increase currentTime</button>\n  `\n})\n\nexport const intervalTester1 = tag(() => {  \n  let intervalCount: number = letState(0)(x => [intervalCount, intervalCount = x])\n  let intervalId: any = letState(undefined)(x => [intervalId, intervalId = x])\n  let intervalId2: any = letState(undefined)(x => [intervalId2, intervalId2 = x])\n  let renderCounter: number = letState(0)(x => [renderCounter, renderCounter = x])\n  let currentTime: number = letState(0)(x => [currentTime, currentTime = x])\n  \n  const callback = callbackMaker()\n  const increase = () => ++intervalCount\n\n  function trackTime() {\n    currentTime = 0\n    \n    intervalId2 = setInterval(callback(() => {\n      currentTime = currentTime + 500\n\n      if(currentTime >= test1interval) {\n        currentTime = 0\n      }\n    }), 500)\n  }\n\n  const destroy = () => {\n    clearInterval(intervalId)\n    clearInterval(intervalId2)\n    intervalId = undefined\n    intervalId2 = undefined\n    console.info('🔴 interval 1 stopped')\n  }\n\n  function toggleInterval() {\n    if(intervalId) {\n      return destroy()\n    }\n\n    console.info('🟢 interval test 1 started...')\n    trackTime()\n    intervalId = setInterval(callback(() => {\n      increase()\n      console.info('slow interval ran')\n    }),test1interval)\n  }\n\n  onInit(toggleInterval)\n  onDestroy(destroy)\n\n  ++renderCounter\n\n  return html`\n    <div>interval type 2 with ${test1interval}ms</div>\n    intervalId: ${intervalId}\n    <button type=\"button\" onclick=${increase}>${intervalCount}:${renderCounter}</button>\n    <input type=\"range\" min=\"0\" max=${test1interval} step=\"1\" value=${currentTime} />\n    <div>\n      --${currentTime}--\n    </div>\n    <button type=\"button\" onclick=${toggleInterval}\n      style.background-color=${intervalId ? 'red' : 'green'}\n    >start/stop</button>\n  `\n})\n","import { propsDebugMain } from \"./PropsDebug.component\"\nimport { arrayTests } from \"./arrayTests\"\nimport { intervalTester0, intervalTester1 } from \"./intervalDebug\"\nimport { html, tag, providers, letState } from \"taggedjs\"\nimport { renderCountDiv } from \"./renderCount.component\"\nimport { fadeInDown, fadeOutUp } from \"./animations\"\n\nexport const tagDebug = tag(() => {// tagDebug.js\n  let _firstState: string = letState('tagJsDebug.js')(x => [_firstState, _firstState = x])\n  let showIntervals: boolean = letState(false)(x => [showIntervals, showIntervals = x])\n  let renderCount: number = letState(0)(x => [renderCount, renderCount = x])\n\n  ++renderCount\n\n  return html`<!-- tagDebug.js -->\n    <h3 id=\"debugging\">Debugging</h3>\n    ${renderCountDiv({renderCount, name: 'tagJsDebug'})}\n\n    <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n      <fieldset style=\"flex:4 4 40em\">\n        <legend>arrays</legend>\n        ${arrayTests()}\n      </fieldset>\n    \n      <fieldset id=\"debug-intervals\" style=\"flex:2 2 20em\">\n        <legend>\n          Interval Testing\n        </legend>\n\n        <button\n          onclick=${() => showIntervals = !showIntervals}\n        >hide/show</button>\n\n        ${showIntervals && html`\n          <div oninit=${fadeInDown} ondestroy=${fadeOutUp}>\n            <div>${intervalTester0()}</div>\n            <hr />\n            <div>${intervalTester1()}</div>\n          </div>\n        `}\n      </fieldset>\n\n      <fieldset id=\"props-debug\" style=\"flex:2 2 20em\">\n        <legend>Props Debug</legend>\n        ${propsDebugMain(undefined)}\n      </fieldset>\n    </div>\n  `\n})\n","import { html, tag, letState, InputElementTargetEvent, Tag } from \"taggedjs\"\nimport { renderCountDiv } from \"./renderCount.component\"\n\ntype SelectedTag = null | string | undefined\n\nexport const tagSwitchDebug = tag((_t='tagSwitchDebug') => {\n  let selectedTag = letState(null as SelectedTag)(x => [selectedTag, selectedTag = x])\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  \n  function changeSelectedTag(event: InputElementTargetEvent) {\n    selectedTag = event.target.value\n\n    if(selectedTag === 'undefined') {\n      selectedTag = undefined\n    }\n\n    if(selectedTag === 'null') {\n      selectedTag = null\n    }\n  }\n\n  let tagOutput: string | Tag = 'select tag below'\n  switch (selectedTag) {\n    case null: tagOutput = 'null, select tag below'\n      break;\n    case \"\": tagOutput = html`<div id=\"empty-string-1\"></div>`\n      break;\n    case '1': tagOutput = tag1({title:'value switch'})\n      break;\n    case '2': tagOutput = tag2({title:'value switch'})\n      break;\n    case '3': tagOutput = tag3({title:'value switch'})\n      break;\n  }\n\n  let tagOutput2 = html`<div id=\"select-tag-above\">select tag above</div>`\n  switch (selectedTag) {\n    case null: tagOutput2 = html`<div id=\"select-tag-above\">null, select tag above</div>`\n      break;\n    case \"\": tagOutput2 = html`<div id=\"select-tag-above\">empty-string, select tag above</div>`\n      break;\n    case '1': tagOutput2 = tag1({title:'tag switch'})\n      break;\n    case '2': tagOutput2 = tag2({title:'tag switch'})\n      break;\n    case '3': tagOutput2 = tag3({title:'tag switch'})\n      break;\n  }\n\n  ++renderCount\n\n  return html`\n    <div id=\"selectTag-wrap\">\n      selectedTag: |${\n        selectedTag === null && 'null' ||\n        selectedTag === undefined && 'undefined' ||\n        selectedTag === '' && 'empty-string' ||\n        selectedTag\n      }|\n    </div>\n    \n    <select id=\"tag-switch-dropdown\" onchange=${changeSelectedTag}>\n\t    <option></option>\n      <!-- TODO: implement selected attribute --->\n\t    <option value=\"\" ${ typeof(selectedTag) === 'string' && !selectedTag.length ? {selected: true} : {} }>empty-string</option>\n\t    <option value=\"undefined\" ${ selectedTag === undefined ? {selected: true} : {} }>undefined</option>\n\t    <option value=\"null\" ${ selectedTag === null ? {selected: true} : {} }>null</option>\n\t    <option value=\"1\" ${ selectedTag === '1' ? {selected: true} : {} }>tag 1</option>\n\t    <option value=\"2\" ${ selectedTag === '2' ? {selected: true} : {} }>tag 2</option>\n\t    <option value=\"3\" ${ selectedTag === '3' ? {selected: true} : {} }>tag 3</option>\n    </select>\n\n    <div id=\"switch-tests-wrap\" style=\"display:flex;flex-wrap:wrap;gap:1em;\">\n      <div style=\"border:1px solid blue;flex-grow:1\">\n        <h3>Test 1 - string | Tag</h3>\n        <div>${tagOutput}</div>\n      </div>\n      \n      <div style=\"border:1px solid blue;flex-grow:1\">\n        <h3>Test 2 - Tag</h3>\n        <div>${tagOutput2}</div>\n      </div>\n      \n      <div style=\"border:1px solid blue;flex-grow:1\">\n        <h3>Test 3 - ternary (only 1 or 3 shows)</h3>\n        <div>${selectedTag === '3' ? tag3({title: 'ternary simple'}) : tag1({title: 'ternary simple'})}</div>\n      </div>\n\n      <div style=\"border:1px solid blue;flex-grow:1\">\n        <h3>Test 3.2 - ternary via prop (only 1 or 3 shows)</h3>\n        <div>${ternaryPropTest({selectedTag})}</div>\n      </div>\n\n      <div id=\"arraySwitching-test-wrap\" style=\"border:1px solid red;flex-grow:1\">\n        <h3>Test 4 - arraySwitching</h3>\n        <div id=\"arraySwitching-wrap\">${arraySwitching({selectedTag})}</div>\n      </div>\n    </div>\n    ${renderCountDiv({renderCount, name:'tagSwitchDebug'})}\n  `\n})\n\nexport const ternaryPropTest = tag((\n  {selectedTag}: {selectedTag: string | undefined | null}\n) => {\n  const outTag = selectedTag === '3' ? tag3({title: 'ternaryPropTest'}) : tag1({title: 'ternaryPropTest'})\n  return html`\n    <div id=\"ternaryPropTest-wrap\">\n      ${selectedTag}:${outTag}\n    </div>\n  `\n})\n\nexport const tag1 = tag(({title}: {title: string}) => {\n  let counter = letState(0)(x => [counter, counter = x])\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  ++renderCount\n  return html`\n    <div id=\"tag1\" style=\"border:1px solid orange;\">\n      <div id=\"tagSwitch-1-hello\">Hello 1 ${title} World</div>\n      <button onclick=${() => ++counter}>increase ${counter}</button>\n      ${renderCountDiv({renderCount, name:'tag1'})}\n    </div>\n  `\n})\n\nexport const tag2 = tag(({title}: {title: string}) => {\n  let counter = letState(0)(x => [counter, counter = x])\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  ++renderCount\n  return html`\n    <div id=\"tag2\" style=\"border:1px solid orange;\">\n      <div id=\"tagSwitch-2-hello\">Hello 2 ${title} World</div>\n      <button onclick=${() => ++counter}>increase ${counter}</button>\n      ${renderCountDiv({renderCount, name:'tag1'})}\n    </div>\n  `\n})\n\nexport const tag3 = tag(({title}: {title: string}) => {\n  let counter = letState(0)(x => [counter, counter = x])\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  ++renderCount\n  return html`\n    <div  id=\"tag3\" style=\"border:1px solid orange;\">\n      <div id=\"tagSwitch-3-hello\">Hello 3 ${title} World</div>\n      <button onclick=${() => ++counter}>increase ${counter}</button>\n      ${renderCountDiv({renderCount, name:'tag1'})}\n    </div>\n  `\n})\n\nexport const arraySwitching = tag((\n  {selectedTag}: {selectedTag: SelectedTag}\n) => {\n  switch (selectedTag) {\n    case undefined:\n      return html`its an undefined value`\n\n    case null:\n      return html`its a null value`\n\n    case '':\n      return html`` // tests how .previousSibling works\n\n    case '1':\n      // return html`${['a'].map(x => html`${tag1({title: `array ${selectedTag} ${x}`})}`.key(x))}`\n      return html`${tag1({title: `tag ${selectedTag}`})}`\n\n    case '2':\n      return html`${['b','c'].map(x => html`${tag2({title: `array ${selectedTag} ${x}`})}`.key(x))}`\n\n    case '3':\n      return html`${['d','e','f'].map(x => html`${tag3({title: `array ${selectedTag} ${x}`})}`.key(x))}`\n  }\n\n  return html`nothing to show for in arrays`\n})\n","import { html, tag, letState, onInit, state, Subject, callbackMaker } from \"taggedjs\"\n\nexport const mirroring = tag(() => {\n  const tag = tagCounter()\n\n  return html`\n    <fieldset>\n      <legend>counter0</legend>\n      ${tag}\n    </fieldset>\n    <fieldset>\n      <legend>counter1</legend>\n      ${tag}\n    </fieldset>\n  `\n})\n\n\nconst tagCounter = () => {\n  let counter = letState(0)(x => [counter, counter = x])\n\n  return html`\n    counter:<span>🪞<span id=\"mirror-counter-display\">${counter}</span></span>\n    <button id=\"mirror-counter-button\" onclick=${() => ++counter}>${counter}</button>\n  `\n}","import { html, letState, tag, Tag, ValueSubject, isSubjectInstance, isTagArray, TagChildren, children } from \"taggedjs\"\nimport { renderCountDiv } from \"./renderCount.component\"\n\nexport const innerHtmlTest = tag((\n  _props: unknown,\n  b:number,\n) => {\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  let counter = letState(0)(x => [counter, counter = x])\n\n  ++renderCount\n\n  return html`<!--innerHtmlTests.js-->\n    <fieldset id=\"innerHtmlTests-1\">\n      <legend>no props test</legend>\n      <div style=\"border:2px solid purple;\">${children()}</div>\n      <div>isSubjectInstance:${isSubjectInstance(children())}</div>\n      <div>isSubjectTagArray:${isTagArray(children().value)}</div>\n      <button id=\"innerHtmlTest-counter-button\"\n      onclick=${() => ++counter}>increase innerHtmlTest ${counter}</button>\n      <span id=\"innerHtmlTest-counter-display\">${counter}</span>\n      ${renderCountDiv({renderCount, name: 'innerHtmlTest'})}\n    </fieldset>\n  `\n})\n\nexport const innerHtmlPropsTest = tag((\n  x: number,\n) => {\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  let counter = letState(0)(x => [counter, counter = x])\n  \n  ++renderCount\n  \n  return html`<!--innerHtmlTests.js-->\n    <fieldset id=\"innerHtmlTests-2\">\n      <legend>innerHTML Props: ${x}</legend>\n      ${children()}\n      <button id=\"innerHtmlPropsTest-button\" onclick=${() => ++counter}\n      >increase innerHtmlPropsTest ${counter}</button>\n      <span id=\"innerHtmlPropsTest-display\">${counter}</span>\n      ${/*renderCountDiv(renderCount)*/ false}\n    </fieldset>\n  `\n})\n","import { children, Tag, TagChildren, html, letState, tag } from \"taggedjs\"\nimport { innerHtmlPropsTest, innerHtmlTest } from \"./innerHtmlTests\"\nimport { renderCountDiv } from \"./renderCount.component\"\n\nconst test22 = tag((a:number, b:number) => html`\n  <fieldset>\n    <legend>xxxxx</legend>  \n    <div>hello other world ${a} - ${b}</div>\n    <div style=\"border:2px solid red;\">***${children()}***</div>\n  </fieldset>\n`)\n\nexport const childTests = tag((_: string = 'childTests') => (\n  renderCount = letState(0)(x => [renderCount, renderCount = x]),\n  counter = letState(0)(x => [counter, counter = x]),\n) => html`\n  <fieldset id=\"children-test\" style=\"flex:2 2 20em\">\n    <legend>childTests</legend>\n\n    <hr />\n    <hr />\n    <hr />\n    ${test22(1,2).\n    html`\n      <div><hr />abc-123-${Date.now()}<hr /></div>\n    `}\n    <hr />\n    <hr />\n    <hr />\n    \n    ${innerHtmlTest({}, 2).\n    html`\n      <b>Field set body A</b>\n      <hr />\n      <button id=\"innerHtmlTest-childTests-button\"\n        onclick=${() => ++counter}\n      >🐮 increase childTests inside ${counter}:${renderCount}</button>\n      <span id=\"innerHtmlTest-childTests-display\">${counter}</span>\n      ${renderCountDiv({renderCount, name: 'childTests-innerHtmlTest'})}\n    `}\n\n    ${innerHtmlPropsTest(22).\n    html`\n      <b>Field set body B</b>\n      <hr />\n      <button id=\"innerHtmlPropsTest-childTests-button\"\n        onclick=${() => ++counter}\n      >🐮 increase childTests inside ${counter}</button>\n      <span id=\"innerHtmlPropsTest-childTests-display\">${counter}</span>\n      ${renderCountDiv({renderCount, name: 'innerHtmlPropsTest child'})}\n    `}\n\n    ${childAsPropTest({child: html`\n      hello child as prop test\n      <button id=\"child-as-prop-test-button\"\n        onclick=${() => ++counter}\n      >🐮 child as prop ${counter}</button>\n      <span id=\"child-as-prop-test-display\">${counter}</span>\n    `})}\n    \n    <hr />\n    \n    <button id=\"childTests-button\"\n      onclick=${() => ++counter}\n    >🐮 increase childTests outside ${counter} - ${renderCount}</button>\n    <span id=\"childTests-display\">${counter}</span>\n    ${renderCountDiv({renderCount, name:'childTests'})}\n  </fieldset>\n`)\n\nfunction childAsPropTest({child}: {child:Tag}) {\n  return html`\n    <fieldset>\n      <legend>child as prop</legend>\n      ${child}\n    </fieldset>\n  `\n}\n","\nexport function elmCount(selector: string) {\n  return document.querySelectorAll(selector).length\n}\n\nexport function queryOneInnerHTML(\n  query: string,\n  pos = 0\n) {\n  return document.querySelectorAll(query)[pos].innerHTML\n}\n\nexport function click(\n  query: string\n) {\n  return document.querySelectorAll(query).forEach(elm => (elm as HTMLElement).click())\n}\n\nexport function html(\n  query: string\n) {\n  let html = ''\n  document.querySelectorAll(query).forEach(elm => html = html + elm.innerHTML)\n  return html\n}\n\nexport function byId(id: string): HTMLElement {\n  return document.getElementById(id) as HTMLElement\n}\n\nexport function htmlById(id: string): string {\n  return (document.getElementById(id) as HTMLElement).innerHTML\n}\n\nexport function lastById(id: string): Element {\n  const elms = document.querySelectorAll('#' + id)\n  return elms[elms.length - 1]\n}\n","type Test = () => unknown\nconst onlyTests: Test[] = []\nlet tests: Test[] = []\nlet tab = 0\n\nexport function describe(label: string, run: () => any) {\n  tests.push(async () => {\n    const oldTests = tests\n    tests = []\n    \n    try {\n      console.debug('  '.repeat(tab) + '↘ ' + label)\n      \n      ++tab\n      await run()\n      await runTests(tests)\n      \n      --tab\n    } catch (error) {\n      --tab\n      // console.debug(' '.repeat(tab) + '❌ ' + label)\n      throw error\n    } finally {\n      tests = oldTests\n    }\n  })\n}\n\ndescribe.only = (label: string, run: () => any) => {\n  onlyTests.push(async () => {\n    const oldTests = tests\n    tests = []\n    \n    try {\n      console.debug('  '.repeat(tab) + '↘ ' + label)\n      \n      ++tab\n      \n      await run()\n      await runTests(tests)\n      \n      --tab\n    } catch (error) {\n      --tab\n      // console.debug(' '.repeat(tab) + '❌ ' + label)\n      throw error\n    } finally {\n      tests = oldTests\n    }\n  })\n}\n\nexport function it(label: string, run: () => any) {\n  tests.push(async () => {\n    try {\n      const start = Date.now()\n      await run()\n      const time = Date.now() - start\n      console.debug(' '.repeat(tab) + `✅ ${label} - ${time}ms`)\n    } catch (error) {\n      console.debug(' '.repeat(tab) + '❌ ' + label)\n      throw error\n    }\n  })\n}\n\nit.only = (label: string, run: () => any) => {\n  onlyTests.push(async () => {\n    try {\n      const start = Date.now()\n      await run()\n      const time = Date.now() - start\n      console.debug(`✅ ${label} - ${time}ms`)\n    } catch (error) {\n      console.debug('❌ ' + label)\n      throw error\n    }\n  })\n}\n\nit.skip = (label: string, run: () => any) => {\n  console.debug('⏭️ Skipped ' + label)\n}\n\nfunction clearTests() {\n  onlyTests.length = 0\n  tests.length = 0\n}\n\nexport async function execute() {\n  if(onlyTests.length) {\n    return runTests(onlyTests)\n  }\n  \n  return runTests(tests)\n}\n\nasync function runTests(tests: Test[]) {\n  for (const test of tests) {\n    try {\n      await test()\n    } catch (err) {\n      console.error(`Error testing ${test.name}`)\n      clearTests()\n      throw err\n    }\n  }\n  clearTests()\n}\n\nexport function expect(expected: unknown) {\n  return {\n    toBeDefined: () => {\n      if(expected !== undefined && expected !== null) {\n        return\n      }\n\n      const message = `Expected ${JSON.stringify(expected)} to be defined`\n      console.error(message, {expected})\n      throw new Error(message)\n    },\n    toBe: (received: unknown, customMessage?: string | Function) => {\n      if(expected === received) {\n        return\n      }\n\n      if(customMessage instanceof Function) {\n        customMessage = customMessage()\n      }\n\n      const message = customMessage || `Expected ${typeof(expected)} ${JSON.stringify(expected)} to be ${typeof(received)} ${JSON.stringify(received)}`\n      console.error(message, {received, expected})\n      throw new Error(message as string)\n    },\n    toBeGreaterThan: (amount: number, customMessage?: string) => {\n      const expectNum = expected as number\n      if(!isNaN(expectNum) && expectNum > amount) {\n        return\n      }\n\n      const message = customMessage || `Expected ${typeof(expected)} ${JSON.stringify(expected)} to be greater than amount`\n      console.error(message, {amount, expected})\n      throw new Error(message)\n    },\n    toBeLessThan: (amount: number, customMessage?: string) => {\n      const expectNum = expected as number\n      if(!isNaN(expectNum) && expectNum < amount) {\n        return\n      }\n\n      const message = customMessage || `Expected ${typeof(expected)} ${JSON.stringify(expected)} to be less than amount`\n      console.error(message, {amount, expected})\n      throw new Error(message)\n    }\n  }\n}\n","import { expect } from \"./expect\"\n\n/* all elements in each query must have the same html */\nexport function expectMatchedHtml(\n  ...queries: string[]\n) {\n  const elements = queries.reduce((all, query) => {\n      const elements = document.querySelectorAll(query)\n      all.push(...elements)\n      return all\n    }, [] as Element[]\n  )\n\n  expect(elements.length).toBeGreaterThan(0, 'Expected elements to be present in expectMatchedHtml() query but found none')\n\n  const lastElm = elements.pop() as Element\n  const lastHtml = lastElm.innerHTML\n  elements.every(elm =>\n    expect(lastHtml).toBe(elm.innerHTML, () => `expectMatchedHtml unmatched html - queries: ${queries.join(' - ')}`)\n  )\n}\n\nexport function expectHTML(\n  query: string,\n  innerHTML: string\n) {\n  const elements = document.querySelectorAll(query)\n  elements.forEach(element =>\n    expect(element.innerHTML).toBe(innerHTML, () => `Expected element ${query} innerHTML to be -->${innerHTML}<-- but it was -->${element.innerHTML}<--`)\n  )\n}\n\nexport function expectElmCount(\n  query: string,\n  count: number,\n  message?: string\n) {\n  const elements = document.querySelectorAll(query)\n  const found = elements.length\n\n  message = message || `Expected ${count} elements to match query ${query} but found ${found}`\n\n  expect(found).toBe(count, message)\n\n  return elements\n}\n\nexport function testDuelCounterElements(\n  ... sets: [string, string][]\n  // [button0, display0]: [string, string], // button, display\n  // [button1, display1]: [string, string], // button, display\n) {\n  const [button0, display0] = sets.shift() as [string, string]\n  let query = expectElmCount(display0, 1)\n  let buttonQuery = expectElmCount(button0, 1)\n  const display0Element = query[0] as HTMLElement\n  const ip0 = display0Element.innerText\n  testCounterSelectedElements(\n    buttonQuery as any as HTMLElement[],\n    query as any as HTMLElement[],\n    {elementCountExpected: 1},\n    button0,\n    display0,\n  )\n  \n  let increase = 2\n  sets.forEach(([button1, display1]) => {    \n    query = expectElmCount(display1, 1)\n    buttonQuery = expectElmCount(button1, 1)\n    let display1Element = query[0] as HTMLElement\n    let ip1Check = display1Element.innerText\n    const value = (Number(ip0) + increase).toString()\n    expect(ip1Check).toBe(value, () => `Expected second increase provider to be increased to ${ip0} but got ${ip1Check}`)\n   \n    testCounterSelectedElements(\n      buttonQuery as any as HTMLElement[],\n      query as any as HTMLElement[],\n      {elementCountExpected: 1},\n      button0,\n      display0,\n    )\n  \n    display1Element = query[0] as HTMLElement\n    ip1Check = display1Element.innerText\n    const secondIncrease = increase + 2\n    expect(ip1Check).toBe((Number(ip0) + secondIncrease).toString(), () => `Expected ${display1} innerText to be ${Number(ip0) + secondIncrease} but instead it is ${ip1Check}`)\n\n    increase = increase + 2\n  })\n}\n\nfunction testCounterSelectedElements(\n  counterButtons: HTMLElement[],\n  counterDisplays: HTMLElement[],\n  {elementCountExpected} = {\n    elementCountExpected: 1\n  },\n  counterButtonId: string,\n  counterDisplayId: string,\n) {\n  expect(counterButtons.length).toBe(elementCountExpected, () => `Expected ${counterButtonId} to be ${elementCountExpected} elements but is instead ${counterButtons.length}`)\n  expect(counterDisplays.length).toBe(elementCountExpected, ()=> `Expected ${counterDisplayId} to be ${elementCountExpected} elements but is instead ${counterDisplays.length}`)\n\n  counterButtons.forEach((increaseCounter, index) => {\n    const counterDisplay = counterDisplays[index]\n    let counterValue = Number(counterDisplay?.innerText)\n    increaseCounter.click()\n\n    let oldCounterValue = counterValue + 1\n    counterValue = Number(counterDisplay?.innerText)\n    expect(oldCounterValue).toBe(counterValue, () => `Counter test 1 of 2 expected ${counterDisplayId} to be value ${oldCounterValue} but it is ${counterValue}`)\n    increaseCounter.click()\n\n    counterValue = Number(counterDisplay?.innerText)\n    ++oldCounterValue\n    expect(oldCounterValue).toBe(counterValue, () => `Counter test 2 of 2 expected ${counterDisplayId} to increase value to ${oldCounterValue} but it is ${counterValue}`)\n  })\n\n}\n\n/** increases counter by two */\nexport function testCounterElements(\n  counterButtonId: string,\n  counterDisplayId: string,\n  {elementCountExpected} = {\n    elementCountExpected: 1\n  }\n) {\n  const increaseCounters = document.querySelectorAll(counterButtonId) as unknown as HTMLElement[]\n  const counterDisplays = document.querySelectorAll(counterDisplayId) as unknown as HTMLElement[]\n\n  return testCounterSelectedElements(\n    increaseCounters, counterDisplays, {elementCountExpected},\n    counterButtonId,\n    counterDisplayId,\n  )\n}\n","import { byId, click, elmCount, html, htmlById, queryOneInnerHTML } from \"./elmSelectors\"\nimport { describe, execute, expect, it } from \"./expect\"\nimport { expectElmCount, expectHTML, expectMatchedHtml, testCounterElements, testDuelCounterElements } from \"./expect.html\"\n\nexport async function runTests() {\n  const slowCount = html('#🍄-slowChangeCount')\n  // tests can be run multiple times. Only the first time will this expect below work\n  const firstRun = slowCount === '0'\n\n  it('no template tags', () => {\n    const templateTags = document.getElementsByTagName('template')\n    expect(templateTags.length).toBe(0, 'Expected no templates to be on document')\n  })\n  \n  it('elements exists', () => {\n    expect(byId('h1-app')).toBeDefined()\n    const counterInput = byId('set-main-counter-input') as HTMLInputElement\n    expect(counterInput).toBeDefined()\n    const toggleTest = byId('toggle-test')\n    expect(toggleTest).toBeDefined()\n    expect(toggleTest.innerText).toBe('toggle test')\n    \n    counterInput.value = '0'\n    ;(counterInput as any).onkeyup({target: counterInput})\n  })\n\n  describe('content', () => {    \n    it('basic', () => {\n      expectMatchedHtml('#content-subject-pipe-display0', '#content-subject-pipe-display1')\n      expectMatchedHtml('#content-combineLatest-pipe-display0', '#content-combineLatest-pipe-display1')\n    })\n\n    it('html', () => {\n      expectMatchedHtml('#content-combineLatest-pipeHtml-display0', '#content-combineLatest-pipeHtml-display1')\n    })\n  })\n\n  it('toggle test', () => {\n    const toggleTest = byId('toggle-test')\n    toggleTest.click()\n    expect(toggleTest.innerText).toBe('toggle test true')\n    toggleTest.click()\n    expect(toggleTest.innerText).toBe('toggle test')\n    \n    const propsTextarea = byId('props-debug-textarea') as HTMLTextAreaElement\n    expect(propsTextarea.value.replace(/\\s/g,'')).toBe(`{\"test\":33,\"x\":\"y\"}`)\n  })\n\n  describe('counters', () => {    \n    it('basics', () => {\n      const beforeRenderCount = Number(html('#counters_render_count'))\n      const beforeInnerRenderCount = Number(html('#inner_counters_render_count'))\n\n      expectElmCount('#conditional-counter', 0)\n\n      testCounterElements('#❤️-increase-counter', '#❤️-counter-display')\n\n      expect(html('#counters_render_count')).toBe( (beforeRenderCount + 2).toString() )\n      // the parent changed a value passed to child as a prop\n      expect(html('#inner_counters_render_count')).toBe( (beforeInnerRenderCount + 2).toString() )\n\n      testCounterElements('#❤️-inner-counter', '#❤️-inner-display')\n\n      expect(html('#counters_render_count')).toBe( (beforeRenderCount + 4).toString() )\n      // the child changed a value passed from parent as a prop\n      expect(html('#inner_counters_render_count')).toBe( (beforeInnerRenderCount + 4).toString() )\n\n      testCounterElements('#standalone-counter', '#standalone-display')\n\n      expect(html('#counters_render_count')).toBe( (beforeRenderCount + (firstRun ? 6 : 8)).toString() )\n      // the child was not rendered again because props did not change so value should be less\n      expect(html('#inner_counters_render_count')).toBe( (beforeInnerRenderCount + 4).toString() )\n\n      expectElmCount('#conditional-counter', 1)\n      testCounterElements('#conditional-counter', '#conditional-display')\n      \n      // test again after higher elements have had reruns\n      testCounterElements('#❤️-inner-counter', '#❤️-inner-display')\n\n      if(firstRun) {\n        expect(html('#🪈-pipedSubject')).toBe('')\n        expect(html('#🪈-pipedSubject-2')).toBe('')\n      }\n      \n      click('#🥦-subject-increase-counter')\n\n      expect(html('#🪈-pipedSubject')).toBe( html('#🥦-subject-counter-display') )\n      expect(html('#🪈-pipedSubject-2')).toBe( html('#🥦-subject-counter-display') )\n    })\n  })\n\n  describe('props', () => {    \n    it('test duels', () => {\n      testDuelCounterElements(\n        ['#propsDebug-🥩-0-button', '#propsDebug-🥩-0-display'],\n        ['#propsDebug-🥩-1-button', '#propsDebug-🥩-1-display'],\n      )\n  \n      testDuelCounterElements(\n        ['#propsDebug-🥩-1-button', '#propsDebug-🥩-1-display'],\n        ['#propsOneLevelFunUpdate-🥩-button', '#propsOneLevelFunUpdate-🥩-display'],\n      )\n    })\n\n    it('letProp', () => {\n      // local and outside currently match\n      expectMatchedHtml('#propsDebug-🥩-0-display', '#propsDebug-🥩-2-display')\n      const propCounter = Number(html('#propsDebug-🥩-0-display'))\n      \n      click('#propsDebug-🥩-2-button')\n\n      // outer should not have changed\n      expect(html('#propsDebug-🥩-0-display')).toBe( propCounter.toString() )\n      expect(html('#propsDebug-🥩-2-display')).toBe( (propCounter + 1).toString() )      \n    })\n\n    it('basics', () => {\n      // the number of times the watch counted a change happens to match that increase counter\n      const funUpdateValue = byId('propsOneLevelFunUpdate-🥩-display').innerHTML\n      const changed = queryOneInnerHTML('#propsDebug-🥩-change-display')\n      \n      // test that watch runs onInit\n      expect(changed).toBe( (Number(funUpdateValue) + 1).toString() )\n  \n      const ownerHTML = byId('propsDebug-🥩-0-display').innerHTML\n      const parentHTML = byId('propsDebug-🥩-1-display').innerHTML\n      const childHTML = byId('propsOneLevelFunUpdate-🥩-display').innerHTML\n  \n      const ownerNum = Number(ownerHTML)\n      const parentNum = Number(parentHTML)\n      const childNum = Number(childHTML)\n  \n      expect(parentNum).toBe(childNum)\n      expect(ownerNum + 2).toBe(parentNum) // testing of setProp() doesn't change owner\n\n      byId('propsDebug-🥩-1-button').click()\n    })\n\n    it('props as functions', () => {\n      const syncCounter = Number( htmlById('sync-prop-number-display') )\n      // const syncCounter = Number( htmlById('sync-prop-child-display') )\n      expectMatchedHtml('#sync-prop-number-display', '#sync-prop-child-display')\n\n      byId('sync-prop-child-button').click()\n\n      expectHTML('#sync-prop-number-display', (syncCounter + 2).toString())\n      testCounterElements('#nothing-prop-counter-button', '#nothing-prop-counter-display')\n      expectHTML('#sync-prop-number-display', (syncCounter + 2).toString())\n      expectMatchedHtml('#sync-prop-counter-display', '#nothing-prop-counter-display')\n      \n    })\n  })\n\n  describe('providers', () => {\n    it('basics', () => {\n      testDuelCounterElements(\n        ['#increase-provider-🍌-0-button', '#increase-provider-🍌-0-display'],\n        ['#increase-provider-🍌-1-button', '#increase-provider-🍌-1-display'],\n      )\n  \n      testDuelCounterElements(\n        ['#increase-provider-upper-🌹-0-button', '#increase-provider-upper-🌹-0-display'],\n        ['#increase-provider-upper-🌹-1-button', '#increase-provider-upper-🌹-1-display'],\n      )\n  \n      testDuelCounterElements(\n        ['#increase-provider-🍀-0-button', '#increase-provider-🍀-0-display'],\n        ['#increase-provider-🍀-1-button', '#increase-provider-🍀-1-display'],\n      )\n    })\n  \n    it('inner outer debug', () => {\n      testDuelCounterElements(\n        ['#increase-prop-🐷-0-button', '#increase-prop-🐷-0-display'],\n        ['#increase-prop-🐷-1-button', '#increase-prop-🐷-1-display'],\n      )\n  \n      // change a counter in the parent element\n      testDuelCounterElements(\n        ['#increase-provider-🍀-0-button', '#increase-provider-🍀-0-display'],\n        ['#increase-provider-🍀-1-button', '#increase-provider-🍀-1-display'],\n      )\n  \n      // now ensure that this inner tag still operates correctly even though parent just rendered but i did not from that change\n      testDuelCounterElements(\n        ['#increase-prop-🐷-0-button', '#increase-prop-🐷-0-display'],\n        ['#increase-prop-🐷-1-button', '#increase-prop-🐷-1-display'],\n      )\n    })\n  })  \n\n  describe('tagSwitching', () => {\n    it('0', () => {\n      expect(elmCount('#select-tag-above')).toBe(1, 'Expected select-tag-above element to be defined')\n      expect(elmCount('#tag-switch-dropdown')).toBe(1, 'Expected one #tag-switch-dropdown')\n      expect(elmCount('#tagSwitch-1-hello')).toBe(2, 'Expected two #tagSwitch-1-hello elements')\n      expect(elmCount('#tagSwitch-2-hello')).toBe(0)\n      expect(elmCount('#tagSwitch-3-hello')).toBe(0)\n    })\n  \n    it('1', () => {\n      const dropdown = byId('tag-switch-dropdown') as HTMLSelectElement\n      dropdown.value = \"1\"\n  \n      ;(dropdown as any).onchange({target:dropdown})\n      expectElmCount('#tagSwitch-1-hello', 5)\n      expect(elmCount('#tagSwitch-2-hello')).toBe(0)\n      expect(elmCount('#tagSwitch-3-hello')).toBe(0)\n      expect(elmCount('#select-tag-above')).toBe(0)\n    })\n  \n    it('2', () => {\n      const dropdown = byId('tag-switch-dropdown') as HTMLSelectElement\n  \n      dropdown.value = \"2\"\n      ;(dropdown as any).onchange({target:dropdown})\n  \n      expectElmCount('#tagSwitch-1-hello', 2)\n      expectElmCount('#tagSwitch-2-hello', 4)\n      expect(elmCount('#tagSwitch-3-hello')).toBe(0)\n      expect(elmCount('#select-tag-above')).toBe(0)\n    })\n  \n    it('3', () => {\n      const dropdown = byId('tag-switch-dropdown') as HTMLSelectElement\n      dropdown.value = \"3\"\n      ;(dropdown as any).onchange({target:dropdown})\n  \n      expect(elmCount('#tagSwitch-1-hello')).toBe(0,'Expected no hello 1s')\n      expect(elmCount('#tagSwitch-2-hello')).toBe(0)\n      expectElmCount('#tagSwitch-3-hello', 7)\n      expect(elmCount('#select-tag-above')).toBe(0)\n    })\n  \n    it('4', () => {  \n      const dropdown = byId('tag-switch-dropdown') as HTMLSelectElement\n      dropdown.value = \"\"\n      ;(dropdown as any).onchange({target:dropdown})\n  \n      expectElmCount('#select-tag-above',1)\n      expectElmCount('#tag-switch-dropdown',1)\n      expectElmCount('#tagSwitch-1-hello',2)\n      expectElmCount('#tagSwitch-2-hello',0)\n      expectElmCount('#tagSwitch-3-hello',0)\n    })\n  })\n\n  it('child tests', () => {\n    testCounterElements('#innerHtmlPropsTest-button', '#innerHtmlPropsTest-display')\n    testCounterElements('#innerHtmlTest-counter-button', '#innerHtmlTest-counter-display')\n    testDuelCounterElements(\n      ['#childTests-button', '#childTests-display'],\n      ['#child-as-prop-test-button', '#child-as-prop-test-display'],\n      ['#innerHtmlPropsTest-childTests-button', '#innerHtmlPropsTest-childTests-display'],\n    )\n\n    testDuelCounterElements(\n      ['#childTests-button', '#childTests-display'],\n      ['#innerHtmlTest-childTests-button', '#innerHtmlTest-childTests-display'],\n    )\n  })\n\n  describe('array testing', () => {\n    it('array basics', () => {\n      expect(elmCount('#array-test-push-item')).toBe(1)\n      const insideCount = elmCount('#score-data-0-1-inside-button')\n      expect(insideCount).toBe(0)\n      expect(elmCount('#score-data-0-1-outside-button')).toBe(0)\n      byId('array-test-push-item').click()\n      expect(elmCount('#score-data-0-1-inside-button')).toBe(1)\n      expect(elmCount('#score-data-0-1-outside-button')).toBe(1)\n      \n      const insideElm = byId('score-data-0-1-inside-button')\n      const insideDisplay = byId('score-data-0-1-inside-display')\n      let indexValue = insideDisplay.innerText\n      const outsideElm = byId('score-data-0-1-outside-button')\n      const outsideDisplay = byId('score-data-0-1-outside-display')\n      const outsideValue = outsideDisplay.innerText\n      expect(indexValue).toBe(outsideValue)\n  \n      insideElm.click()\n      expect(insideDisplay.innerText).toBe(outsideDisplay.innerText)\n      expect(indexValue).toBe((Number(insideDisplay.innerText) - 1).toString())\n      expect(indexValue).toBe((Number(outsideDisplay.innerText) - 1).toString())\n  \n      outsideElm.click()\n      expect(insideDisplay.innerText).toBe(outsideDisplay.innerText)\n      expect(indexValue).toBe((Number(insideDisplay.innerText) - 2).toString())\n      expect(indexValue).toBe((Number(outsideDisplay.innerText) - 2).toString())\n    })\n\n    it('🗑️ deletes', async () => {\n      expect(elmCount('#player-remove-promise-btn-0')).toBe(0)\n      expect(elmCount('#player-edit-btn-0')).toBe(1)\n\n      await (byId('player-edit-btn-0') as any).onclick()\n\n      expect(elmCount('#player-remove-promise-btn-0')).toBe(1)\n\n      await (byId('player-remove-promise-btn-0') as any).onclick()\n      await delay(1000) // animation\n\n      expect(elmCount('#player-remove-promise-btn-0')).toBe(0)\n      expect(elmCount('#player-edit-btn-0')).toBe(0)\n    })\n  })\n\n  it('🪞 mirror testing', () => {\n    expectElmCount('#mirror-counter-display', 2)\n    expectElmCount('#mirror-counter-button', 2)\n    \n    const counter = Number(htmlById('mirror-counter-display'))\n\n    byId('mirror-counter-button').click()\n\n    expect(counter + 1).toBe( Number(htmlById('mirror-counter-display')) )\n    expectElmCount('#mirror-counter-display', 2)\n    expectMatchedHtml('#mirror-counter-display')\n  })  \n\n  it('⌚️ watch tests', () => {\n    const startCount = Number(htmlById('watch-testing-num-display'))\n\n    expectMatchedHtml('#watch-testing-num-display', '#🍄-slowChangeCount')\n    \n    // always starts at \"false\"\n    expect(html('#🦷-truthChange')).toBe('false')\n        \n    if(firstRun) {\n      expect(html('#🍄-watchPropNumSlow')).toBe('')\n      expect(html('#🦷-watchTruth')).toBe('false')\n      expect(html('#🦷-watchTruthAsSub')).toBe('undefined')\n    } else {\n      expect(html('#🍄-watchPropNumSlow')).toBe( slowCount )\n      expect( Number(html('#🦷-watchTruth')) ).toBeGreaterThan( Number(slowCount) )\n      expect(html('#🦷-watchTruthAsSub')).toBe( html('#🦷-truthSubChangeCount') )\n    }\n\n    click('#watch-testing-num-button')\n    \n    expectMatchedHtml('#watch-testing-num-display', '#🍄-slowChangeCount')\n    expectMatchedHtml('#🍄-watchPropNumSlow', '#🍄-slowChangeCount')\n    \n    expect(html('#🍄‍🟫-subjectChangeCount')).toBe( (startCount + 2).toString() )\n    expectMatchedHtml('#🍄‍🟫-subjectChangeCount', '#🍄‍🟫-watchPropNumSubject')\n    \n    const truthStartCount = Number(html('#🦷-truthChangeCount'))\n\n    click('#🦷-truthChange-button')\n\n    let newCount = (truthStartCount + 1).toString()\n    // its been changed to \"true\", that causes a change watch count increase\n    expect(html('#🦷-truthChange')).toBe('true')\n    expect(html('#🦷-watchTruth')).toBe( newCount )\n    expect(html('#🦷-truthChangeCount')).toBe( newCount )\n\n    click('#🦷-truthChange-button')\n\n    newCount = (truthStartCount + 1).toString()\n    // its been changed to back to \"false\", that does NOT cause a change watch count increase\n    expect(html('#🦷-truthChange')).toBe('false')\n    expect(html('#🦷-watchTruth')).toBe(newCount)\n    expect(html('#🦷-truthChangeCount')).toBe( newCount )\n\n    click('#🦷-truthChange-button')\n\n    // its been changed to \"true\", that causes a change watch count increase\n    newCount = (truthStartCount + 2).toString()\n    expect(html('#🦷-truthChange')).toBe('true')\n    expect(html('#🦷-watchTruth')).toBe(newCount)\n    expect(html('#🦷-truthChangeCount')).toBe( newCount )\n\n    click('#🦷-truthChange-button') // reset so tests can pass every time\n    click('#🦷-reset-button') // reset so tests can pass every time\n\n    expect(html('#🦷-watchTruthAsSub')).toBe(html('#🦷-watchTruth'))\n  })\n\n  it('oneRender', () => {\n    expect(html('#oneRender_tag_ts_render_count')).toBe('1')\n\n    testCounterElements('#👍-counter-button', '#👍-counter-display')\n    testCounterElements('#👍👍-counter-button', '#👍👍-counter-display')\n    testCounterElements('#👍👍-counter-button', '#👍👍-counter-subject-display')\n\n    expect(html('#oneRender_tag_ts_render_count')).toBe('1')\n  })\n\n  it('has no templates', () => {\n    expect(document.getElementsByTagName('template').length).toBe(0)\n  })\n\n  try {\n    const start = Date.now() //performance.now()\n    await execute()\n    const time = Date.now() - start // performance.now() - start\n    console.info(`✅ all tests passed in ${time}ms`)\n    return true\n  } catch (error: unknown) {\n    console.error('❌ tests failed: ' + (error as Error).message, error)\n    return false\n  }\n}\n\nfunction delay(time: number) {\n  return new Promise((res) => setTimeout(res, time))\n}\n","import {html, letState, tag} from 'taggedjs'\n\nexport const mouseOverTag = tag(({\n  label, memory,\n}: {\n  label: string\n  memory:{\n    counter: number\n  }\n}) => {\n  let mouseOverEditShow = letState(false)(x => [mouseOverEditShow, mouseOverEditShow = x])\n  let edit = letState(false)(x => [edit, edit = x])\n  return html`\n    <div style=\"background-color:purple;padding:.2em;flex:1\"\n      onmouseover=${() => mouseOverEditShow = true}\n      onmouseout=${() => mouseOverEditShow = false}\n    >\n      mouseover - ${label}:${memory.counter}:${mouseOverEditShow || 'false'}\n      <button onclick=${() => ++memory.counter}>++counter</button>\n      <a style.visibility=${(edit || mouseOverEditShow) ? 'visible' : 'hidden'}\n        onclick=${() => edit = !edit}\n      >⚙️&nbsp;</a>\n    </div>\n  `\n})\n","import { mouseOverTag } from \"./mouseover.tag\"\nimport { renderCountDiv } from \"./renderCount.component\"\nimport { html, tag, Subject, onInit, letState, callbackMaker, state, ValueSubject, callback, subject } from \"taggedjs\"\n\nexport const counters = tag(({\n  appCounterSubject\n}: {\n  appCounterSubject: Subject<number>\n}) => {\n  let counter = letState(0)(x => [counter, counter = x])\n  let propCounter = letState(0)(x => [propCounter, propCounter = x])\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  let initCounter = letState(0)(x => [initCounter, initCounter = x])\n  let memory = state(() => ({counter: 0}))\n  \n  const callbacks = callbackMaker()\n  const callbackTestSub = state(() => new Subject(counter))\n\n  const pipedSubject0 = state(() => new ValueSubject('222'))\n  const pipedSubject1 = Subject.all([pipedSubject0, callbackTestSub]).pipe(callback(x => counter))\n  const pipedSubject2 = subject.all([pipedSubject0, callbackTestSub]).pipe(x => counter)\n\n  onInit(() => {\n    ++initCounter\n    console.info('countersDebug.ts: 👉 i should only ever run once')\n\n    callbackTestSub.subscribe(\n      callbacks(y => counter = y)\n    )\n  })\n\n  // State as a callback only needed so pipedSubject1 has the latest value\n  const increaseCounter = () => {\n    ++counter\n    pipedSubject0.next('333-' + counter)\n  }\n\n  const increasePropCounter = () => ++propCounter\n\n  ++renderCount // for debugging\n\n  const sharedMemory = true\n  const testInnerCounters = true\n  const displayRenderCounters = true\n  const testBasics = true\n\n  return html`<!--counters-->\n    <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n      ${testBasics && html`\n        <div>👉 Subscriptions:${(Subject as any).globalSubCount$}</div>\n        <button onclick=${() => console.info('subs', (Subject as any).globalSubs)}>log subs</button>\n        <div>initCounter:${initCounter}</div>\n    \n        <div>\n          <button id=\"app-counter-subject-button\"\n            onclick=${() => appCounterSubject.set((appCounterSubject.value || 0) + 1)}\n          >🍒 ++app subject</button>\n          <span>\n            🍒 <span id=\"app-counter-subject-button\">${appCounterSubject.value}</span>\n          </span>\n        </div>\n\n        <div>\n          <button id=\"standalone-counter\"\n            onclick=${increaseCounter}\n          >stand alone counter:${counter}</button>\n          <span>\n            🥦 <span id=\"standalone-display\">${counter}</span>\n          </span>\n        </div>\n    \n        ${counter > 1 && html`\n          <div>\n            <button id=\"conditional-counter\"\n              onclick=${increaseCounter}\n            >conditional counter:${counter}</button>\n            <span>\n              🥦 <span id=\"conditional-display\">${counter}</span>\n            </span>\n          </div>\n        `}\n\n        <input id=\"set-main-counter-input\"\n          onkeyup=${e => (counter = Number(e.target.value) || 0)}\n        />\n\n        <div>\n          <button id=\"❤️-increase-counter\"\n            onclick=${increasePropCounter}\n          >❤️ propCounter:${propCounter}</button>\n          <span>\n            ❤️ <span id=\"❤️-counter-display\">${propCounter}</span>\n            </span>\n        </div>\n\n        <div>\n          <button id=\"🥦-subject-increase-counter\"\n            onclick=${() => callbackTestSub.set(counter + 1)}\n          >subject increase:</button>\n          <span>\n            🥦 <span id=\"🥦-subject-counter-display\">${counter}</span>\n            🥦 <span id=\"subject-counter-subject-display\">${callbackTestSub}</span>\n          </span>\n        </div>\n      `}\n    </div>\n\n    <fieldset>\n      <legend>🪈 pipedSubject 1</legend>\n      <div>\n        <small>\n          <span id=\"🪈-pipedSubject\">${pipedSubject1}</span>\n        </small>\n      </div>\n    </fieldset>\n\n    <fieldset>\n      <legend>🪈 pipedSubject 2</legend>\n      <div>\n        <small>\n          <span id=\"🪈-pipedSubject-2\">${pipedSubject2}</span>\n        </small>\n      </div>\n    </fieldset>\n\n    ${sharedMemory && html`\n      <fieldset>\n        <legend>shared memory</legend>\n        <div class.bold.text-blue=${true} style=\"display:flex;flex-wrap:wrap;gap:.5em\">\n          ${mouseOverTag({label: 'a-a-😻', memory})}\n          ${mouseOverTag({label: 'b-b-😻', memory})}\n        </div>\n        memory.counter:😻${memory.counter}\n        <button onclick=${() => ++memory.counter}>increase 😻</button>\n      </fieldset>\n    `}\n    \n    ${testInnerCounters && html`\n      <fieldset>\n        <legend>inner counter</legend>\n        ${innerCounters({propCounter, increasePropCounter})}\n      </fieldset>\n    `}\n    ${displayRenderCounters && renderCountDiv({renderCount, name: 'counters'})}\n  `\n})\n\nconst innerCounters = tag(({\n  propCounter,\n  increasePropCounter,\n}: {\n  propCounter: number,\n  increasePropCounter: () => void\n}) => {\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n\n  ++renderCount // for debugging\n\n  return html`\n    <button id=\"❤️-inner-counter\" onclick=${increasePropCounter}\n    >❤️ propCounter:${propCounter}</button>\n    <span>\n      ❤️ <span id=\"❤️-inner-display\">${propCounter}</span>\n    </span>\n    <div>renderCount:${renderCount}</div>\n    ${renderCountDiv({renderCount, name: 'inner_counters'})}\n  `\n})\n","import { fadeInDown, fadeOutUp } from \"./animations\"\nimport { renderCountDiv } from \"./renderCount.component\"\nimport { letState, html, tag, providers, state, callbackMaker, Subject, onInit } from \"taggedjs\"\n\nexport class TagDebugProvider {\n  tagDebug = 0\n  showDialog = false\n}\n\nconst ProviderFunc = () => ({counter: 0})\n\n\nexport function tagDebugProvider() {\n  const upper = providers.create( upperTagDebugProvider )\n  return {\n    upper,\n    test: 0\n  }\n}\n\nexport function upperTagDebugProvider() {\n  return {\n    name: 'upperTagDebugProvider',\n    test: 0\n  }\n}\n\nexport const providerDebugBase = tag((_x = 'providerDebugBase') => {\n  // providerDebugBase, has provider\n  \n  providers.create(ProviderFunc) // test that an arrow function can be a provider\n  const providerClass: TagDebugProvider = providers.create( TagDebugProvider )\n  const provider = providers.create( tagDebugProvider )\n\n  const test = letState('props debug base')\n  let propCounter = letState(0)(x => [propCounter, propCounter = x])\n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n\n  if(providerClass.showDialog) {\n    (document.getElementById('provider_debug_dialog') as any).showModal()\n  }\n\n  ++renderCount\n\n  return html`\n    <div>\n      <strong>provider.test sugar-daddy-77</strong>:${provider.test}\n    </div>\n    <div>\n      <strong>provider.upper?.test</strong>:${provider.upper?.test || '?'}\n    </div>\n    <div>\n      <strong>providerClass.tagDebug</strong>:${providerClass.tagDebug || '?'}\n    </div>\n\n    <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n      <div>\n        <button id=\"increase-provider-🍌-0-button\"\n          onclick=${() => ++provider.test}\n        >🍌 increase provider.test ${provider.test}</button>\n        <span>\n          🍌 <span id=\"increase-provider-🍌-0-display\">${provider.test}</span>\n        </span>\n      </div>\n      \n      <div>\n        <button id=\"increase-provider-upper-🌹-0-button\" onclick=${() => ++provider.upper.test}\n        >🌹 increase upper.provider.test ${provider.upper.test}</button>\n        <span>\n          🌹 <span id=\"increase-provider-upper-🌹-0-display\">${provider.upper.test}</span>\n        </span>\n      </div>\n      \n      <div>\n        <button id=\"increase-provider-🍀-0-button\" onclick=${() => ++providerClass.tagDebug}\n        >🍀 increase provider class ${providerClass.tagDebug}</button>\n        <span>\n          🍀 <span id=\"increase-provider-🍀-0-display\">${providerClass.tagDebug}</span>\n        </span>\n      </div>\n\n      <div>\n        <button id=\"increase-prop-🐷-0-button\" onclick=${() => ++propCounter}\n        >🐷 increase propCounter ${propCounter}</button>\n        <span>\n          🐷 <span id=\"increase-prop-🐷-0-display\">${propCounter}</span>\n        </span>\n      </div>\n\n      <button onclick=${() => providerClass.showDialog = true}\n      >💬 toggle dialog ${providerClass.showDialog}</button>\n    </div>\n\n    <hr />\n\n    <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n      ${providerDebug({\n        propCounter,\n        propCounterChange: x => {\n          propCounter = x\n        }\n      })}\n    </div>\n\n    <hr />\n    renderCount outer:<span name=\"render_count_outer\">${renderCount}</span>\n    ${renderCountDiv({renderCount, name:'providerDebugBase'})}\n\n    ${dialog(providerClass)}\n  `\n})\n\nconst dialog = tag((providerClass: TagDebugProvider) => html`\n  <dialog id=\"provider_debug_dialog\" style=\"padding:0\"\n    onmousedown=\"var r = this.getBoundingClientRect();(r.top<=event.clientY&&event.clientY<=r.top+r.height&&r.left<=event.clientX&&event.clientX<=r.left+r.width) || this.close()\"\n    ondragstart=\"const {e,dt,t} = {t:this,e:event,dt:event.dataTransfer};const d=t.drag=t.drag||{x:0,y:0};d.initX=d.x;d.startX=event.clientX-t.offsetLeft;d.startY=event.clientY-t.offsetTop;t.ondragover=e.target.ondragover=(e)=>e.preventDefault();dt.effectAllowed='move';dt.dropEffect='move'\"\n    ondrag=\"const {t,e,dt,d}={e:event,dt:event.dataTransfer,d:this.drag}; if(e.clientX===0) return;d.x = d.x + e.offsetX - d.startX; d.y = d.y + e.offsetY - d.startY; this.style.left = d.x + 'px'; this.style.top = d.y+'px';\"\n    ondragend=\"const {t,e,d}={t:this,e:event,d:this.drag};if (d.initX === d.x) {d.x=d.x+e.offsetX-(d.startX-d.x);d.y=d.y+e.offsetY-(d.startY-d.y);this.style.transform=translate3d(d.x+'px', d.y+'px', 0)};this.draggable=false\"\n    onclose=${() => providerClass.showDialog = false}\n  >\n    <div style=\"padding:.25em\" onmousedown=\"this.parentNode.draggable=true\"\n    >dialog title</div>\n    ${providerClass.showDialog ? html`\n      <textarea wrap=\"off\">${JSON.stringify(providerClass, null, 2)}</textarea>\n    ` : 'no dialog'}\n    <div style=\"padding:.25em\">\n      <button type=\"button\" onclick=\"provider_debug_dialog.close()\">🅧 close</button>\n    </div>\n  </dialog>\n`)\n\nconst providerDebug = tag(({\n  propCounter,\n  propCounterChange,\n}: {\n  propCounter: number,\n  propCounterChange: (x: number) => unknown\n}) => {\n  const funcProvider = providers.inject(ProviderFunc) // test that an arrow function can be a provider\n  const provider = providers.inject( tagDebugProvider )\n  const providerClass = providers.inject( TagDebugProvider )\n  const upperProvider = providers.inject( upperTagDebugProvider )\n\n  let showProProps: boolean = letState(false)(x => [showProProps, showProProps = x])\n  let renderCount: number = letState(0)(x => [renderCount, renderCount = x])\n  // let propCounter: number = letState(0)(x => [propCounter, propCounter = x])\n\n  const callbacks = callbackMaker()\n  const callbackTestSub = state(() => new Subject())\n\n  onInit(() => {\n    console.info('providerDebug.ts: 👉 👉 i should only ever run once')\n\n    callbackTestSub.subscribe(x => {\n      callbacks((y) => {\n        provider.test = x as number\n      })()\n    })\n  })\n\n  ++renderCount\n\n  return html`<!--providerDebug.js-->\n    <div>\n      <button id=\"increase-provider-🍌-1-button\" onclick=${() => ++provider.test}\n      >🍌 increase provider.test ${provider.test}</button>\n      <span>\n        🍌 <span id=\"increase-provider-🍌-1-display\">${provider.test}</span>\n      </span>\n    </div>\n    \n    <div>\n      <button id=\"increase-provider-upper-🌹-1-button\" onclick=${() => ++upperProvider.test}\n      >🌹 increase upper.provider.test ${upperProvider.test}</button>\n      <span>\n        🌹<span id=\"increase-provider-upper-🌹-1-display\">${upperProvider.test}</span>\n      </span>\n    </div>\n\n    <div>\n      <button id=\"increase-arrow-provider-⚡️-1-button\" onclick=${() => ++funcProvider.counter}\n      >⚡️ increase upper.provider.test ${funcProvider.counter}</button>\n      <span>\n      ⚡️<span id=\"increase-arrow-provider-⚡️-1-display\">${funcProvider.counter}</span>\n      </span>\n    </div>\n\n    <div>\n      <button id=\"subject-increase-counter\"\n        onclick=${() => callbackTestSub.set(provider.test + 1)}\n      >🍌 subject increase:</button>\n      <span>\n        🍌 <span id=\"subject-counter-display\">${provider.test}</span>\n      </span>\n    </div>\n    \n    <div>\n      <button id=\"increase-provider-🍀-1-button\" onclick=${() => ++providerClass.tagDebug}\n      >🍀 increase provider class ${providerClass.tagDebug}</button>\n      <span>\n        🍀 <span id=\"increase-provider-🍀-1-display\">${providerClass.tagDebug}</span>\n      </span>\n    </div>\n\n    <div>\n      <button id=\"increase-prop-🐷-1-button\" onclick=${() => propCounterChange(++propCounter)}\n      >🐷 increase propCounter ${propCounter}</button>\n      <span>\n        🐷 <span id=\"increase-prop-🐷-1-display\">${propCounter}</span>\n      </span>\n    </div>\n\n    <button onclick=${() => providerClass.showDialog = true}\n      >💬 toggle dialog ${providerClass.showDialog}</button>\n\n    <button onclick=${() => showProProps = !showProProps}\n    >${showProProps ? 'hide' : 'show'} provider as props</button>\n    \n    ${showProProps && html`\n      <div oninit=${fadeInDown} ondestroy=${fadeOutUp}>\n        <hr />\n        <h3>Provider as Props</h3>\n        ${testProviderAsProps(providerClass)}\n      </div>\n    `}\n\n    <div>\n      renderCount inner:${renderCount}\n      ${renderCountDiv({renderCount, name:'providerDebugInner'})}\n    </div>\n  `\n})\n\n\nconst testProviderAsProps = tag((\n  providerClass: TagDebugProvider\n) => {\n  return html`<!--providerDebug.js@TestProviderAsProps-->\n    <textarea wrap=\"off\" rows=\"20\" style=\"width:100%;font-size:0.6em\">${JSON.stringify(providerClass, null, 2)}</textarea>\n  `\n})","import { watch, letState, html, tag } from \"taggedjs\"\n\nexport const watchTesting = tag(() => (\n  stateNum = letState(0)(x => [stateNum, stateNum=x]),\n  stateNumChangeCount = letState(0)(x => [stateNumChangeCount, stateNumChangeCount=x]),\n  _ = watch([stateNum], () => ++stateNumChangeCount),\n  slowChangeCount = letState(0)(x => [slowChangeCount, slowChangeCount=x]),\n  watchPropNumSlow = watch.noInit([stateNum], () => ++slowChangeCount),\n  subjectChangeCount = letState(0)(x => [subjectChangeCount, subjectChangeCount=x]),\n  \n  watchPropNumSubject = watch.asSubject([stateNum], () => {\n    return ++subjectChangeCount\n  }),\n\n  truthChange = letState(false)(x => [truthChange, truthChange=x]),\n  truthChangeCount = letState(0)(x => [truthChangeCount, truthChangeCount=x]),\n  watchTruth = watch.truthy([truthChange], () => ++truthChangeCount),\n  \n  truthSubChangeCount = letState(0)(x => [truthSubChangeCount, truthSubChangeCount=x]),\n  \n  watchTruthAsSub = watch.truthy.asSubject([truthChange], () => {\n    ++truthSubChangeCount\n    return truthChange\n  }).pipe(\n    x => {\n      if(x === undefined) {\n        return 'undefined'\n      }      \n\n      return x ? truthSubChangeCount : truthSubChangeCount\n    }\n  ),\n) => html`\n  stateNum:<span id=\"watch-testing-num-display\">${stateNum}</span>\n  <button id=\"watch-testing-num-button\" type=\"button\"\n    onclick=${() => ++stateNum}\n  >++ stateNum</button>\n  <div>\n    <small>stateNumChangeCount:<span id=\"stateNumChangeCount\">${stateNumChangeCount}</span></small>\n  </div>\n  <fieldset>\n    <legend>🍄 slowChangeCount</legend> \n    <div>\n      <small>\n        <span id=\"🍄-slowChangeCount\">${slowChangeCount}</span>\n      </small>\n    </div>\n    <div>\n      <small>\n        watchPropNumSlow:<span id=\"🍄-watchPropNumSlow\">${watchPropNumSlow}</span>\n      </small>\n    </div>\n  </fieldset>\n\n  <fieldset>\n    <legend>🍄‍🟫 subjectChangeCount</legend>    \n    <div>\n      <small>\n        <span id=\"🍄‍🟫-subjectChangeCount\">${subjectChangeCount}</span>\n      </small>\n    </div>\n    <div>\n      <small>\n        (watchPropNumSubject:<span id=\"🍄‍🟫-watchPropNumSubject\">${watchPropNumSubject}</span>)\n      </small>\n    </div>\n  </fieldset>\n\n  <fieldset>\n    <legend>🦷 truthChange</legend>\n    <div>\n      <small>\n        <span id=\"🦷-truthChange\">${truthChange ? 'true' : 'false'}</span>\n      </small>\n    </div>\n    <fieldset>\n      <legend>simple truth</legend>      \n      <div>\n        <small>\n          watchTruth:<span id=\"🦷-watchTruth\">${watchTruth || 'false'}</span>\n        </small>\n      </div>\n      <div>\n        <small>\n          (truthChangeCount:<span id=\"🦷-truthChangeCount\">${truthChangeCount}</span>)\n        </small>\n      </div>\n    </fieldset>\n    <fieldset>\n      <legend>truth subject</legend>      \n      <div>\n        <small>\n        watchTruthAsSub:<span id=\"🦷-watchTruthAsSub\">${watchTruthAsSub}</span>\n        </small>\n      </div>\n      <div>\n        <small>\n          (truthSubChangeCount:<span id=\"🦷-truthSubChangeCount\">${truthSubChangeCount}</span>)\n        </small>\n      </div>\n    </fieldset>\n\n    <button id=\"🦷-truthChange-button\" type=\"button\"\n      onclick=${() => truthChange = !truthChange}\n    >toggle to ${truthChange ? 'true' : 'false'}</button>\n  </fieldset>`\n)\n","import { html, letState, state, subject, tag, ValueSubject } from \"taggedjs\"\nimport { renderCountDiv } from \"./renderCount.component\"\n\n/** this tag renders only once */\nexport const oneRender = () => tag.oneRender = (\n  counter = new ValueSubject(0),\n  renderCount = letState(0)(x => [renderCount, renderCount = x]), // state can be used but it never updates\n) => {\n  ++renderCount\n  return html`\n    <span>👍<span id=\"👍-counter-display\">${counter}</span></span>\n    <button type=\"button\" id=\"👍-counter-button\"\n      onclick=${() => {\n        ++counter.value\n      }}\n    >++👍</button>\n    ${renderCountDiv({renderCount, name:'oneRender_tag_ts'})}\n    <hr />\n    ${insideMultiRender()}\n  `\n}\n\n/** this tag renders on every event but should not cause parent to re-render */\nconst insideMultiRender = tag(() => (\n  counter = letState(0)(x => [counter, counter = x]),\n  counter$ = subject.value(0),\n  renderCount = letState(0)(x => [renderCount, renderCount = x]), // state can be used but it never updates\n) => {\n  ++renderCount\n  return html`\n  <span>👍👍 sub counter-subject-display:<span id=\"👍👍-counter-subject-display\">${counter$}</span></span>\n  <br />\n  <span>👍👍 sub counter<span id=\"👍👍-counter-display\">${counter}</span></span>\n  <br />\n  <button type=\"button\" id=\"👍👍-counter-button\"\n    onclick=${() => {\n      ++counter\n      counter$.set(counter)\n    }}\n  >++👍👍</button>\n  ${renderCountDiv({renderCount, name:'insideMultiRender'})}\n`\n})\n","import { attributeDebug } from \"./attributeDebug.component\"\nimport { contentDebug } from \"./ContentDebug.component\"\nimport { tableDebug } from \"./tableDebug.component\"\nimport { html, tag, letState, onInit, state, Subject, callbackMaker, onDestroy } from \"taggedjs\"\nimport { tagDebug } from \"./tagJsDebug\"\nimport { tagSwitchDebug } from \"./tagSwitchDebug.component\"\nimport { mirroring } from \"./mirroring.tag\"\nimport { childTests } from \"./childTests\"\nimport { runTests } from \"./tests\"\nimport { renderCountDiv } from \"./renderCount.component\"\nimport { counters } from \"./countersDebug\"\nimport { providerDebugBase } from \"./providerDebug\"\nimport { watchTesting } from \"./watchTesting.tag\"\nimport { oneRender } from \"./oneRender.tag\"\n\nexport const App = tag(() => {\n  let _firstState = letState('app first state')(x => [_firstState, _firstState=x])\n  let toggleValue = letState(false)(x => [toggleValue, toggleValue=x])\n  let appCounter = letState(0)(x => [appCounter, appCounter=x])\n  let renderCount = letState(0)(x => [renderCount, renderCount=x])\n  let testTimeout = letState(null)(x => [testTimeout, testTimeout=x])\n\n  const toggle = () => {\n    toggleValue = !toggleValue\n  }\n\n  // if I am destroyed before my test runs, prevent test from running\n  onDestroy(() => {\n    clearTimeout(testTimeout as any)\n    testTimeout = null\n  })\n\n  function runTesting(manual = true) {\n    const waitFor = 1000\n    testTimeout = setTimeout(async () => {\n      console.debug('🏃 Running tests...')\n      const result = await runTests()\n\n      if(!manual) {\n        return\n      }\n\n      if(result) {\n        alert('✅ all app tests passed')\n        return\n      }\n\n      alert('❌ tests failed. See console for more details')\n\n    }, waitFor) as any // cause delay to be separate from renders\n  }\n\n  ++renderCount\n\n  const callbacks = callbackMaker()\n  const appCounterSubject = state(() => new Subject<number>(appCounter))\n\n  onInit(() => {\n    console.info('1️⃣ app init should only run once')\n    \n    runTesting(false)\n\n    appCounterSubject.subscribe(\n      callbacks(y => appCounter = y)\n    )\n  })\n\n  const content = html`<!--app.js-->\n    <h1 id=\"h1-app\">🏷️ TaggedJs - ${2+2}</h1>\n\n    <button id=\"toggle-test\" onclick=${toggle}>toggle test ${toggleValue}</button>\n    <button onclick=${runTesting}>run test</button>\n\n    <div>\n      <button id=\"app-counter-subject-button\"\n        onclick=${() => appCounterSubject.set(appCounter + 1)}\n      >🍒 ++app subject</button>\n      <span>\n        🍒 <span id=\"app-counter-subject-button\">${appCounter}</span>\n      </span>\n    </div>\n\n    ${renderCountDiv({name:'app', renderCount},)}\n\n    <div id=\"tagDebug-fx-wrap\">\n      <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n        <fieldset id=\"counters\" style=\"flex:2 2 20em\">\n          <legend>counters</legend>\n          ${counters({appCounterSubject})}\n        </fieldset>\n\n        <fieldset id=\"counters\" style=\"flex:2 2 20em\">\n          <legend>⌚️ watch testing</legend>\n          ${watchTesting()}\n        </fieldset>\n\n        <fieldset id=\"provider-debug\" style=\"flex:2 2 20em\">\n          <legend>Provider Debug</legend>\n          ${providerDebugBase(undefined)}\n        </fieldset>\n\n        ${childTests(undefined)}\n\n        <fieldset style=\"flex:2 2 20em\">\n          <legend>Attribute Tests</legend>\n          ${attributeDebug()}\n        </fieldset>\n\n        <fieldset id=\"content-debug\" style=\"flex:2 2 20em\">\n          <legend>Content Debug</legend>\n          ${contentDebug()}\n        </fieldset>\n\n        <fieldset style=\"flex:2 2 20em\">\n          <legend>Tag Switching</legend>\n          ${tagSwitchDebug(undefined)}\n        </fieldset>\n\n        <fieldset style=\"flex:2 2 20em\">\n          <legend>Tag Mirroring</legend>\n          ${mirroring()}\n        </fieldset>\n\n        <fieldset style=\"flex:2 2 20em\">\n          <legend>Table Tests</legend>\n          ${tableDebug()}\n        </fieldset>\n\n        <fieldset style=\"flex:2 2 20em\">\n          <legend>oneRender</legend>\n          ${oneRender()}\n        </fieldset>\n      </div>\n\n      ${tagDebug()}\n    </div>\n  `\n\n  return content\n})\n","import { childTests } from \"./childTests\"\nimport { Subject, callbackMaker, html, onInit, letState, tag, state } from \"taggedjs\"\nimport { arrayTests } from \"./arrayTests\"\nimport { tagSwitchDebug } from \"./tagSwitchDebug.component\"\nimport { mirroring } from \"./mirroring.tag\"\nimport { propsDebugMain } from \"./PropsDebug.component\"\nimport { providerDebugBase } from \"./providerDebug\"\nimport { counters } from \"./countersDebug\"\nimport { tableDebug } from \"./tableDebug.component\"\nimport { contentDebug } from \"./ContentDebug.component\"\nimport { watchTesting } from \"./watchTesting.tag\"\nimport { oneRender } from \"./oneRender.tag\"\nimport { renderCountDiv } from \"./renderCount.component\"\n\ntype viewTypes = 'oneRender' | 'watchTesting' | 'mirroring' | 'content' | 'arrays' | 'counters' | 'tableDebug' | 'props' | 'child' | 'tagSwitchDebug' | 'providerDebug'\nexport const IsolatedApp = tag(() => {\n  const views: viewTypes[] = [\n    'content',\n    // 'counters',\n    // 'watchTesting',\n    'oneRender',\n    // 'props',\n    // 'mirroring',\n    // 'providerDebug',\n    \n    // 'arrays',\n    // 'tagSwitchDebug',\n    \n    // 'child',\n  ]\n  \n  let renderCount = letState(0)(x => [renderCount, renderCount = x])\n  let appCounter = letState(0)(x => [appCounter, appCounter=x])\n  const appCounterSubject = state(() => new Subject(appCounter))\n  const callback = callbackMaker()\n  onInit(() => {\n    console.info('1️⃣ app init should only run once')    \n\n    appCounterSubject.subscribe(\n      callback(x => {\n        appCounter = x\n      })\n    )\n  })\n\n  ++renderCount\n\n  return html`<!--isolatedApp.js-->\n    <h1 id=\"app\">🏷️ TaggedJs - isolated</h1>\n\n    <div>\n      <button id=\"app-counter-subject-button\"\n        onclick=${() => appCounterSubject.set(appCounter + 1)}\n      >🍒 ++app subject</button>\n      <span>\n        🍒 <span id=\"app-counter-subject-button\">${appCounter}</span>\n      </span>\n    </div>\n\n    <div id=\"tagDebug-fx-wrap\">\n      <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n        ${views.includes('oneRender') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>oneRender</legend>\n            ${oneRender()}\n          </fieldset>\n        `}\n\n        ${views.includes('props') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>propsDebugMain</legend>\n            ${propsDebugMain(undefined)}\n          </fieldset>\n        `}\n\n        ${views.includes('watchTesting') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>watchTesting</legend>\n            ${watchTesting()}\n          </fieldset>\n        `}\n\n        ${views.includes('tableDebug') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>tableDebug</legend>\n            ${tableDebug()}\n          </fieldset>\n        `}\n\n        ${views.includes('providerDebug') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>providerDebugBase</legend>\n            ${providerDebugBase(undefined)}\n          </fieldset>\n        `}\n\n        ${views.includes('tagSwitchDebug') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>tagSwitchDebug</legend>\n            ${tagSwitchDebug(undefined)}\n          </fieldset>\n        `}\n\n        ${views.includes('mirroring') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>mirroring</legend>\n            ${mirroring()}\n          </fieldset>\n        `}\n\n        ${views.includes('arrays') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>arrays</legend>\n            ${arrayTests()}\n          </fieldset>\n        `}\n\n        ${views.includes('counters') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>counters</legend>\n            ${counters({appCounterSubject})}\n          </fieldset>\n        `}\n\n        ${views.includes('content') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>content</legend>\n            ${contentDebug()}\n          </fieldset>\n        `}\n\n        ${views.includes('child') && html`\n          <fieldset style=\"flex:2 2 20em\">\n            <legend>Children Tests</legend>\n            ${childTests(undefined)}\n          </fieldset>\n        `}\n\n        ${/*\n          <textarea style=\"font-size:0.6em;min-width:50vw;height:400px\">${ template.string }</textarea>\n          <textarea style=\"font-size:0.6em;min-width:50vw;height:400px\">${ JSON.stringify(template, null, 2) }</textarea>\n          */ false\n        }\n      </div>\n      ${renderCountDiv({renderCount, name:'isolatedApp'})}\n    </div>\n  `\n})\n","import { tagElement } from \"taggedjs\"\nimport { App } from \"./app.tag\"\nimport { IsolatedApp } from \"./isolatedApp\"\n\nexport const app = () => {// app.ts\n  console.info('attaching app to element...')\n  const element = document.getElementsByTagName('app')[0]\n\n  const pathname = window.location.pathname\n  const locationSplit = pathname.split('/').filter(x => x)\n  const location = locationSplit[0]?.toLowerCase()\n  if(location && ['isolated.html','index-static.html'].includes(location)) {\n    const start = Date.now()\n    tagElement(IsolatedApp, element, {test:1})\n    const end = Date.now() - start\n    console.info(`⏱️ isolated render in ${end}ms`)\n    return\n  }\n\n  const start = Date.now()\n  tagElement(App, element, {test:1})\n  const end = Date.now() - start\n  console.info(`⏱️ rendered in ${end}ms`)\n}\n"],"names":["ValueTypes","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","isLikeTags","tagSupport0","tagSupport1","templater0","templater","templater1","tag0","tag","tag1","strings0","strings","strings1","length","every","string","index","values0","values1","valuesLengthsMatch","allVarsMatch","value","compareTo","Function","toString","isLikeValueSets","values","destroyTagMemory","oldTagSupport","global","oldest","destroy","destroyTagSupportPast","context","newest","insertAfter","newNode","referenceNode","parentNode","insertBefore","nextSibling","isSimpleType","includes","destroyArrayTag","tagSupport","counts","stagger","removed","removeChild","lastSupport","placeholderElm","placeholder","getValueType","undefined","type","function","Date","date","tagJsType","tagComponent","isTagArray","tagArray","isSubjectInstance","subject","unknown","isStaticTag","isTagComponent","isTagClass","isSubject","subscribe","Array","x","combineLatest","subjects","output","Subject","subscribeWith","callback","valuesSeen","setValue","subscription","clones","shift","subscriptions","map","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","next","newValue","handler","methodResponse","setHandler","onSubscription","subscribers","_value","constructor","this","set","countSubject","globalSubCount$","unsubscribe","findIndex","sub","splice","removeSubFromArray","add","push","getSubscription","orgCallback","lastValue","count","subs","toPromise","Promise","res","toCallback","pipe","operations","all","args","arg","static","ValueSubject","super","getSupportInCycle","setUse","memory","stateConfig","use","useMe","beforeRender","beforeRedraw","afterRender","beforeDestroy","tagUse","TagError","Error","details","message","errorCode","name","ArrayNoKeyError","StateMismatchError","SyncCallbackError","array","state","config","rearray","stateLength","getStateValue","initState","defaultValue","checkValue","oldState","StateEchoBack","getCallbackValue","JSON","stringify","console","error","wrapper","oldStates","newStates","tagFunction","parentWrap","original","warn","item","syncStates","stateFrom","stateTo","fromValue","getSetMethod","restate","oldValue","initValue","newState","result","watch","currentValues","setupWatch","defaultFinally","init","before","final","previous","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","method","originalState","setTo","oldestState","nowTagSupport","letState","makeStateResult","y","deepClone","makeDeepClone","WeakMap","visited","has","RegExp","clone","isArray","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","getTime","isArrayDeepEqual","keys1","keys","keys2","isObjectDeepEqual","newWatch","providerConfig","providers","ownerSupport","constructMethod","stateDiffMemory","stateDiff","provider","oldStateCount","instance","cm","owner","ownerTagSupport","find","msg","run","handleProviderChanges","appSupport","tagsWithProvider","getTagsWithProvider","renderCount","deleted","renderTagSupport","hasProvider","xProvider","childTags","runBeforeRender","runAfterRender","tagClosed$","runBeforeDestroy","renderTagOnly","newTagSupport","oldRenderCount","lastOwnerSupport","runtimeOwnerSupport","lastState","runBeforeRedraw","beforeWithRender","reSupport","renderWithSupport","oldGlobal","destroyUnlikeTags","renderExistingTag","oldestSupport","newSupport","preRenderCount","providersWithChanges","filter","getAppTagSupport","providersChangeCheck","prevSupport","updateBy","renderUp","ownerTag","selfPropChange","nowProps","props","latestProps","propsConfig","latestCloned","innerCallback","a","b","c","d","e","f","callbackMaker","originalGetter","initMemory","triggerStateUpdate","maybePromise","finally","setCurrentTagSupport","support","currentSupport","onInit","destroyCurrentSupport","onDestroy","destroyCallback","childrenCurrentSupport","children","variablePrefix","escapeVariable","escapeSearch","Tag","arrayValue","html","TemplaterResult","tagged","madeChildIntoSubject","childSubject","madeSubject","kid","kidsToTagArraySubject","tags","runTagCallback","bindTo","myGlobal","callbackResult","bind","then","cloneValueArray","getChildTagsToDestroy","allTags","cTag","processNewTag","TagSupport","swapInsertBefore","document","createTextNode","inputAttribute","element","names","split","style","classList","remove","startRegX","endRegX","isTagVar","search","processAttribute","attrName","child","scope","howToSet","getContextValueByVarString","processNameValueAttr","processScopedNameValueAttr","attrValue","removeAttribute","processNameOnlyAttr","isSpecialAttr","replace","reverse","join","isSpecial","action","newAttrValue","oneRender","isChildOverride","subjectFunction","bindSubjectCallback","fun","isDeadValue","processAttributeSubjectValue","howToSetAttribute","setAttribute","howToSetInputValue","interpolateAttributes","attrNames","getAttributeNames","nodeName","getAttribute","interpolateReplace","processTagResult","subjectTag","processTagResultUpdate","buildBeforeElement","processSubjectComponent","options","label","substring","preClones","myClones","fClone","renderSubjectComponent","processTag","newTagSupportByTemplater","added","setupNewTemplater","tagFakeTemplater","getFakeTemplater","fake","isTag","processTagArray","lastArray","setPlaceholderElm","runtimeInsertBefore","lessLength","subTag","lastTag","newArrayValue","lastArrayValue","destroyItem","valueA","valueB","areLikeValues","last","previousSupport","template","getTemplate","processAddTagArrayItem","fragment","createDocumentFragment","newTempElm","createElement","appendChild","updateBeforeTemplate","lastFirstChild","parent","textNode","castTextValue","processRegularValue","castedValue","oldClone","textContent","processFirstSubjectValue","v","wrap","processFirstRegularValue","compareProps","compare","onDelete","compareOriginal","hasTagSupportChanged","newTemplater","propsChanged","pastCloneProps","castedProps","castedPastProps","subCastedProps","subCompareProps","matched","entries","hasPropChanges","kidsChanged","oldCloneKidValues","lastClonedKidValues","newClonedKidValues","hasKidsChanged","alterProps","newProps","toCall","callbackPropOwner","resetFunctionProps","callWith","cycle","lastestOwner","allMatched","updateExistingTagComponent","oldestTag","oldWrapper","newWrapper","isSameTag","newPropsArray","priorPropConfig","priorPropsArray","argPosition","priorProps","newCallback","syncFunctionProps","newOldest","buildNewTag","oldInsertBefore","updateExistingValue","valueType","displaySubject","hasLastValue","newType","destroySimpleValue","arraySubject","wasArray","isValueTag","checkDestroyPrevious","subjectSup","newestState","prepareUpdateToComponent","isClass","valueSupport","isTagTemplater","handleStillTag","interpolateTemplate","hasAttribute","variableName","existingSubject","subscribeToTemplate","called","onValue","mutatingCallback","afterElmBuild","elm","textarea","match","dynamic","_elm","_name","scanTextAreaValue","diff","onInitDoubleWrap","oninit","onInitWrap","target","elementInitCheck","interpolateContentTemplates","tagComponents","nextClones","subChild","isRenderEndTemplate","nextTagComponent","tagName","interpolateElement","container","interpolatedTemplates","interpolation","content","nextTagComponents","processChildrenAttributes","interpolateString","expression","startsWith","id","interpolateToTemplates","afterInterpolateElement","temporary","firstChild","nextNextSibling","buildClones","prefixSearch","BaseTagSupport","isApp","appElement","hasLiveElements","kidValue","latest","setTagPlaceholder","update","elementContainer","tempDraw","innerHTML","thisTag","updateContext","_string","oldValueFn","newValueFn","prevState","shareTemplaterGlobal","updateContextItem","processNewValue","version","byParent","firstDestroy","destroySubscriptions","subGlobal","mainPromise","promise","destroyClones","async","promises","oldClones","checkCloneRemoval","oldContext","customElm","ondestroy","onDestroyDoubleWrap","onDestroyWrap","elementDestroyCheck","compareClone","tempTag","updateConfig","updateValues","tagCount","innerTagWrap","originalFunction","valuesValue","getTagWrap","tagIndex","route","routeProps","oneRenderFunction","appElements","tagElement","app","appElmIndex","appElm","runWrapper","templateElm","hmr","attributeDebug","selected","isOrange","event","checked","class","contentDebug","vs0","vs1","utils","willPromise","resolve","tableDebug","showCell","renderCountDiv","propsDebugMain","_","propNumber","propsJson","test","syncPropNumber","json","parse","propsDebug","propNumberChange","syncPropDebug","nothingTest","timestamp","year","getFullYear","month","String","getMonth","padStart","day","getDate","hours","getHours","minutes","getMinutes","time","timestampToValues","newDateString","propDateDebug","counter","propNumberChangeCount","myPropNumber","watchResults","__","getSetProp","myProp","letProp","assign","propFnUpdateTest","animateInit","staggerBy","fxName","opacity","wait","animateDestroy","capturePosition","zIndex","toTop","offsetTop","toLeft","offsetLeft","toWidth","clientWidth","offsetWidth","toHeight","clientHeight","offsetHeight","setTimeout","top","left","width","height","position","captureElementPosition","in","fadeInDown","out","fadeOutUp","fxIn","fxOut","input","createFx","arrayTests","players","getNewPlayer","scores","repeat","_v","frame","score","Math","floor","random","playersDisplay","scoreData","playerIndex","player","edit","test0interval","test1interval","intervalTester0","intervalCount","intervalId","intervalId2","renderCounter","currentTime","increase","startInterval","info","setInterval","stopInterval","clearInterval","intervalTester1","toggleInterval","tagDebug","_firstState","showIntervals","tagSwitchDebug","_t","selectedTag","tagOutput","title","tag2","tag3","tagOutput2","ternaryPropTest","arraySwitching","mirroring","tagCounter","innerHtmlTest","_props","innerHtmlPropsTest","test22","childTests","now","childAsPropTest","elmCount","selector","querySelectorAll","click","query","forEach","byId","getElementById","htmlById","onlyTests","tests","tab","describe","oldTests","debug","runTests","it","start","clearTests","err","expect","expected","toBeDefined","toBe","received","customMessage","toBeGreaterThan","amount","expectNum","isNaN","toBeLessThan","expectMatchedHtml","queries","elements","reduce","lastHtml","pop","expectHTML","expectElmCount","found","testDuelCounterElements","sets","button0","display0","buttonQuery","ip0","innerText","testCounterSelectedElements","elementCountExpected","button1","display1","display1Element","ip1Check","Number","secondIncrease","counterButtons","counterDisplays","counterButtonId","counterDisplayId","increaseCounter","counterDisplay","counterValue","oldCounterValue","testCounterElements","slowCount","firstRun","getElementsByTagName","counterInput","toggleTest","onkeyup","beforeRenderCount","beforeInnerRenderCount","propCounter","funUpdateValue","pos","queryOneInnerHTML","ownerHTML","parentHTML","childHTML","ownerNum","parentNum","childNum","syncCounter","dropdown","onchange","insideElm","insideDisplay","indexValue","outsideElm","outsideDisplay","outsideValue","onclick","startCount","truthStartCount","newCount","execute","only","skip","mouseOverTag","mouseOverEditShow","counters","appCounterSubject","initCounter","callbacks","callbackTestSub","pipedSubject0","pipedSubject1","pipedSubject2","increasePropCounter","globalSubs","innerCounters","TagDebugProvider","showDialog","ProviderFunc","tagDebugProvider","upper","upperTagDebugProvider","providerDebugBase","_x","providerClass","showModal","providerDebug","propCounterChange","dialog","funcProvider","upperProvider","showProProps","testProviderAsProps","watchTesting","stateNum","stateNumChangeCount","slowChangeCount","watchPropNumSlow","noInit","subjectChangeCount","watchPropNumSubject","asSubject","truthChange","truthChangeCount","watchTruth","truthy","truthSubChangeCount","watchTruthAsSub","insideMultiRender","counter$","App","toggleValue","appCounter","testTimeout","runTesting","manual","alert","clearTimeout","IsolatedApp","views","locationSplit","window","location","pathname","toLowerCase","end"],"sourceRoot":""}