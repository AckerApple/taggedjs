{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://todo/webpack/bootstrap","webpack://todo/webpack/runtime/define property getters","webpack://todo/webpack/runtime/hasOwnProperty shorthand","webpack://todo/./node_modules/taggedjs/js/tag/cycles/getSupportInCycle.function.js","webpack://todo/./node_modules/taggedjs/js/render/dom/blankHandler.function.js","webpack://todo/./node_modules/taggedjs/js/render/paint.function.js","webpack://todo/./node_modules/taggedjs/js/tag/ValueTypes.enum.js","webpack://todo/./node_modules/taggedjs/js/isInstance.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/getSupportWithState.function.js","webpack://todo/./node_modules/taggedjs/js/state/states.utils.js","webpack://todo/./node_modules/taggedjs/js/state/state.utils.js","webpack://todo/./node_modules/taggedjs/js/state/getStateValue.function.js","webpack://todo/./node_modules/taggedjs/js/state/stateHandlers.js","webpack://todo/./node_modules/taggedjs/js/subject/subject.utils.js","webpack://todo/./node_modules/taggedjs/js/subject/Subject.class.js","webpack://todo/./node_modules/taggedjs/js/subject/combineLatest.function.js","webpack://todo/./node_modules/taggedjs/js/state/tagClosed$.subject.js","webpack://todo/./node_modules/taggedjs/js/state/setUseMemory.object.js","webpack://todo/./node_modules/taggedjs/js/tag/update/getNewGlobal.function.js","webpack://todo/./node_modules/taggedjs/js/tag/processUpdateContext.function.js","webpack://todo/./node_modules/taggedjs/js/render/update/updateSupportBy.function.js","webpack://todo/./node_modules/taggedjs/js/deepFunctions.js","webpack://todo/./node_modules/taggedjs/js/tag/cloneValueArray.function.js","webpack://todo/./node_modules/taggedjs/js/tag/shallowPropMatch.function.js","webpack://todo/./node_modules/taggedjs/js/tag/tagRunner.js","webpack://todo/./node_modules/taggedjs/js/tag/destroyContexts.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/arrays/compareArrayItems.function.js","webpack://todo/./node_modules/taggedjs/js/tag/destroyArrayContext.function.js","webpack://todo/./node_modules/taggedjs/js/tag/destroyHtmlDomMeta.function.js","webpack://todo/./node_modules/taggedjs/js/tag/smartRemoveKids.function.js","webpack://todo/./node_modules/taggedjs/js/render/destroySupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/isLikeTags.function.js","webpack://todo/./node_modules/taggedjs/js/tag/destroySupportByContextItem.function.js","webpack://todo/./node_modules/taggedjs/js/tag/checkTagValueChange.function.js","webpack://todo/./node_modules/taggedjs/js/castTextValue.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/isSpecialAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/specialAttribute.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/howToSetInputValue.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/processNameValueAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/processFunctionAttr.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/processAttributeUpdate.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/processSimpleAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/getSimpleTagVar.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processRegularValue.function.js","webpack://todo/./node_modules/taggedjs/js/tag/checkDestroyPrevious.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/tagValueUpdateHandler.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/domProcessContextItem.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/createAndProcessContextItem.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/arrays/processTagArray.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/getArrayTagJsVar.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/valueToTagJsVar.function.js","webpack://todo/./node_modules/taggedjs/js/render/addOneContext.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/attachDynamicDom.function.js","webpack://todo/./node_modules/taggedjs/js/state/handleProviderChanges.function.js","webpack://todo/./node_modules/taggedjs/js/state/providersChangeCheck.function.js","webpack://todo/./node_modules/taggedjs/js/tag/props/safeRenderSupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/props/alterProp.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/syncPriorPropFunction.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/updateExistingArray.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/updateExistingObject.function.js","webpack://todo/./node_modules/taggedjs/js/render/update/updateExistingTagComponent.function.js","webpack://todo/./node_modules/taggedjs/js/tag/hasSupportChanged.function.js","webpack://todo/./node_modules/taggedjs/js/tag/hasPropChanges.function.js","webpack://todo/./node_modules/taggedjs/js/render/softDestroySupport.function.js","webpack://todo/./node_modules/taggedjs/js/render/executeWrap.function.js","webpack://todo/./node_modules/taggedjs/js/render/runAfterRender.function.js","webpack://todo/./node_modules/taggedjs/js/render/callTag.function.js","webpack://todo/./node_modules/taggedjs/js/state/reState.function.js","webpack://todo/./node_modules/taggedjs/js/render/renderTagOnly.function.js","webpack://todo/./node_modules/taggedjs/js/render/renderWithSupport.function.js","webpack://todo/./node_modules/taggedjs/js/render/renderExistingTag.function.js","webpack://todo/./node_modules/taggedjs/js/render/renderSupport.function.js","webpack://todo/./node_modules/taggedjs/js/render/checkRenderUp.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/getUpTags.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/renderTagArray.function.js","webpack://todo/./node_modules/taggedjs/js/state/syncStates.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/checkToResolvePromise.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/bindSubjectCallback.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/bubbleEvent.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/addSupportEventListener.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/processAttributeCallback.function.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/isNoDisplayValue.function.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/processStandAloneAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/updateNameOnlyAttrValue.function.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/processUpdateAttrContext.function.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/processAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/tag/DomTag.type.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/getTagVarIndex.function.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/createDynamicAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/getTagJsVar.function.js","webpack://todo/./node_modules/taggedjs/js/render/attributes/processTagJsAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/render/dom/processAttributeArray.function.js","webpack://todo/./node_modules/taggedjs/js/render/dom/attachDomElement.function.js","webpack://todo/./node_modules/taggedjs/js/render/dom/attachDomElements.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/parseHTML.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/htmlInterpolationToDomMeta.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/replacePlaceholders.function.js","webpack://todo/./node_modules/taggedjs/js/tag/getStringsId.function.js","webpack://todo/./node_modules/taggedjs/js/tag/domMetaCollector.js","webpack://todo/./node_modules/taggedjs/js/tag/isLastRunMatched.function.js","webpack://todo/./node_modules/taggedjs/js/render/buildBeforeElement.function.js","webpack://todo/./node_modules/taggedjs/js/render/update/processTag.function.js","webpack://todo/./node_modules/taggedjs/js/tag/createHtmlSupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processNewSubjectTag.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processTagInit.function.js","webpack://todo/./node_modules/taggedjs/js/tag/getTemplaterResult.function.js","webpack://todo/./node_modules/taggedjs/js/tag/tag.utils.js","webpack://todo/./node_modules/taggedjs/js/tag/getTagWrap.function.js","webpack://todo/./node_modules/taggedjs/js/render/update/processRenderOnceInit.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/oneRenderToSupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processSubscribeWith.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/processSubscribeAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/subscribeWith.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/handleTagTypeChangeFrom.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/checkStillSubscription.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/subscribe.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/deleteContextSubContext.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/onFirstSubContext.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/getInnerHTML.function.js","webpack://todo/./node_modules/taggedjs/js/tag/output.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/host.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/convertTagToElementManaged.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processFirstSubjectComponent.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processTagResult.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processTagComponentInit.function.js","webpack://todo/./node_modules/taggedjs/js/state/state.function.js","webpack://todo/./node_modules/taggedjs/js/state/onInit.function.js","webpack://todo/./node_modules/taggedjs/js/state/onDestroy.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/tag.function.js","webpack://todo/./node_modules/taggedjs/js/tagJsVars/tagInject.function.js","webpack://todo/./node_modules/taggedjs/js/state/onRender.function.js","webpack://todo/./node_modules/taggedjs/js/tag/props/clonePropsBy.function.js","webpack://todo/./node_modules/taggedjs/js/tag/createSupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/tryUpdateToTag.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/handleStillTag.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/updateToDiffValue.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/forceUpdateExistingValue.function.js","webpack://todo/./node_modules/taggedjs/js/tag/guaranteeInsertBefore.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processUpdateSubscribe.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/setupSubscribe.function.js","webpack://todo/./node_modules/taggedjs/js/subject/ValueSubject.js","webpack://todo/./node_modules/taggedjs/js/state/watch.function.js","webpack://todo/./node_modules/taggedjs/js/state/subject.function.js","webpack://todo/./node_modules/taggedjs/js/errors.js","webpack://todo/./node_modules/taggedjs/js/state/callbackStateUpdate.function.js","webpack://todo/./node_modules/taggedjs/js/state/callback.function.js","webpack://todo/./node_modules/taggedjs/js/state/callbackMaker.function.js","webpack://todo/./node_modules/taggedjs/js/tag/cycles/setContextInCycle.function.js","webpack://todo/./node_modules/taggedjs/js/render/registerNewTagElement.function.js","webpack://todo/./node_modules/taggedjs/js/tag/loadNewBaseSupport.function.js","webpack://todo/./node_modules/taggedjs/js/render/renderTagElement.function.js","webpack://todo/./node_modules/taggedjs/js/tag/tagElement.js","webpack://todo/./node_modules/taggedjs/js/elements/elementFunctions.js","webpack://todo/./node_modules/taggedjs/js/elements/destroyDesignElement.function.js","webpack://todo/./node_modules/taggedjs/js/elements/processDesignElementUpdate.function.js","webpack://todo/./node_modules/taggedjs/js/elements/processChildren.function.js","webpack://todo/./node_modules/taggedjs/js/elements/processElementVarFunction.function.js","webpack://todo/./node_modules/taggedjs/js/elements/processElementVar.function.js","webpack://todo/./node_modules/taggedjs/js/elements/processDesignElementInit.function.js","webpack://todo/./node_modules/taggedjs/js/elements/designElement.function.js","webpack://todo/./node_modules/taggedjs/js/elements/noElement.function.js","webpack://todo/./node_modules/taggedjs/js/elements/index.js","webpack://todo/./src/tags/item.tag.ts","webpack://todo/./src/HashRouter.function.ts","webpack://todo/./src/app.tag.ts","webpack://todo/./src/reducer.ts","webpack://todo/./src/tags/header.tag.ts","webpack://todo/./src/tags/footer.tag.ts","webpack://todo/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { setUseMemory } from '../../state/index.js';\nimport { setContextInCycle } from './setContextInCycle.function.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    setContextInCycle(support.context);\n    return setUseMemory.stateConfig.support = support;\n}\n//# sourceMappingURL=getSupportInCycle.function.js.map","export const blankHandler = function blankHandler() {\n    return undefined;\n};\n//# sourceMappingURL=blankHandler.function.js.map","import { blankHandler } from \"./dom/blankHandler.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(_promise) {\n    /*\n    if(paintRemoveAwaits.length) {\n      paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push( ...paintRemoves )\n      paintRemoves = []\n    }\n  \n    paintRemoveAwaits.push({promise, paintRemoves})\n    paintRemoves = []\n    */\n}\n// let paintRemoveAwaits: {promise: Promise<any>, paintRemoves: PaintCommand[]}[] = []\nexport let paintCommands = [];\n// export let paintRemoves: PaintCommand[] = []\nexport const paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\n/** you must lock before calling this function */\nexport function paint() {\n    if (painting.locks > 0) {\n        // throw new Error('double paint')\n        return;\n    }\n    runCycles();\n}\nfunction runCycles() {\n    ++painting.locks;\n    runPaintCycles();\n    --painting.locks;\n    runAfterCycle();\n}\n/** Deletes happen last */\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    const removes = paintRemoves.length;\n    runPaintRemoves();\n    // paintRemoves = []\n    paintRemoves.splice(0, removes);\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element, caller) {\n    paintRemoves.push([paintRemover, [element, caller]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element, _caller) {\n    const parentNode = element.parentNode;\n    /*\n    if(!element) {\n      console.debug('no element by', _caller)\n    }\n    if(!parentNode) {\n      console.debug('no parentNode by', _caller)\n    }\n    */\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element, _caller) {\n    const parentNode = relative.parentNode;\n    parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler, _caller) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm, _caller);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm, 'paintBeforeElementString');\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n//# sourceMappingURL=paint.function.js.map","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n//# sourceMappingURL=ValueTypes.enum.js.map","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n    // TODO: Start using this instead\n    return value instanceof Function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n//# sourceMappingURL=isInstance.js.map","import { isTagComponent } from '../../isInstance.js';\nexport function findStateSupportUpContext(context) {\n    const stateMeta = context.state;\n    if (stateMeta && stateMeta.newest && stateMeta.newest) {\n        return stateMeta.newest;\n    }\n    if (context.parentContext) {\n        return findStateSupportUpContext(context.parentContext);\n    }\n}\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html.dom(allStrings.allStrings73349[0]) support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const context = component.context;\n    const stateMeta = context.state;\n    if (!stateMeta) {\n        return component;\n    }\n    return stateMeta.newest || component;\n}\n//# sourceMappingURL=getSupportWithState.function.js.map\n// @ts-ignore\nconst allStrings = {allStrings73349:[[]]}","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevContext = prevSupport.context;\n    const stateMeta = prevContext.state;\n    const prevStateMeta = stateMeta.older;\n    // const prevStateMeta = stateMeta.newer as ContextStateSupport\n    // const prevStateMeta = stateMeta.older || stateMeta.newer as ContextStateSupport\n    const prevStates = prevStateMeta.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        oldStates.lastValues = lastValues;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n//# sourceMappingURL=states.utils.js.map","import { runFirstState } from './stateHandlers.js';\nimport { firstStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** To be called before rendering anything with a state */\nexport function initState(context) {\n    setContextInCycle(context);\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    const state = config.state = [];\n    const states = config.states = [];\n    config.statesIndex = 0;\n    const stateMeta = context.state = context.state || {};\n    stateMeta.newer = { state, states };\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n//# sourceMappingURL=state.utils.js.map","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n//# sourceMappingURL=getStateValue.function.js.map","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.state.length];\n    config.state.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    const context = getContextInCycle();\n    if (!context || !context.state) {\n        const msg = 'State requested but TaggedJs is not currently rendering a tag or host';\n        console.error(msg, { config, context });\n        throw new Error(msg);\n    }\n    const newer = context.state.newer;\n    config.state = newer.state;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.state.push(push);\n    return initValue;\n}\n//# sourceMappingURL=stateHandlers.js.map","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n//# sourceMappingURL=subject.utils.js.map","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    value;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n        if (arguments.length > 0) {\n            this.value = value;\n        }\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster.\n     * Once called, unsubscribe occurs.\n     * No subscription to manage UNLESS the callback will never occur THEN subscription needs to be closed with result.unsubscribe() */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        // return this 10-2025 remove\n        return subscription;\n    }\n    pipe(...operations) {\n        const args = [];\n        if ('value' in this) {\n            args.push(this.value);\n        }\n        const subject = new Subject(...args);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    _value;\n    constructor(...args) {\n        super(...args);\n        this._value = args[0];\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n//# sourceMappingURL=Subject.class.js.map","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n//# sourceMappingURL=combineLatest.function.js.map","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n//# sourceMappingURL=tagClosed$.subject.js.map","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        state: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n//# sourceMappingURL=setUseMemory.object.js.map","/** Only used in TagSupport */\nexport function getNewGlobal(contextItem) {\n    // TODO: Not need for basic supports, only tag()\n    contextItem.renderCount = contextItem.renderCount || 0;\n    contextItem.varCounter = 0;\n    // TODO: Not need for basic supports, only tag()\n    contextItem.state = {\n        newer: {\n            state: [],\n            states: [],\n        },\n    };\n    return contextItem.global = {\n        blocked: [],\n    };\n}\n//# sourceMappingURL=getNewGlobal.function.js.map","import { removeContextInCycle, setContextInCycle } from './cycles/setContextInCycle.function.js';\nexport function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    for (const context of contexts) {\n        // const context = contexts[index]\n        processUpdateOneContext(values, context, support);\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\ncontextItem, ownerSupport) {\n    if (contextItem.deleted) {\n        return;\n    }\n    // some values, like style, get rearranged and there value appearance may not match context appearance\n    const valueIndex = contextItem.valueIndex;\n    const newValue = values[valueIndex];\n    // Removed, let the tagJsVars do the checking\n    // Do not continue if the value is just the same\n    /*\n    if(newValue === contextItem.value) {\n      return\n    }\n    */\n    const tagJsVar = contextItem.tagJsVar;\n    setContextInCycle(contextItem);\n    tagJsVar.processUpdate(newValue, contextItem, ownerSupport, values);\n    removeContextInCycle();\n    contextItem.value = newValue;\n}\n//# sourceMappingURL=processUpdateContext.function.js.map","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const contexts = olderSupport.context.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, contexts);\n    --painting.locks;\n    paint();\n}\nfunction updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n//# sourceMappingURL=updateSupportBy.function.js.map","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n//# sourceMappingURL=deepFunctions.js.map","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n//# sourceMappingURL=cloneValueArray.function.js.map","import { isArray } from '../isInstance.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n//# sourceMappingURL=shallowPropMatch.function.js.map","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = support.context.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    // global.deleted = true\n    support.context.destroy$.next();\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n//# sourceMappingURL=tagRunner.js.map","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContexts(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContexts(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.destroy(child, ownerSupport);\n            child.deleted = true;\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = child.state.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = child.contexts;\n        // recurse\n        destroyContexts(subTags, support);\n        global.deleted = true;\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = child.state.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = child.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n//# sourceMappingURL=destroyContexts.function.js.map","import { destroySupport } from '../../../render/destroySupport.function.js';\n/** 1 = destroyed, 2 = value changes, 0 = no change */\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(context) {\n    const global = context.global;\n    destroyArrayItemByGlobal(global, context);\n}\nfunction destroyArrayItemByGlobal(global, context) {\n    if (global && context.state?.oldest) {\n        const support = context.state.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    context.tagJsVar.destroy(context, {});\n}\n//# sourceMappingURL=compareArrayItems.function.js.map","import { destroyArrayItem } from './update/arrays/compareArrayItems.function.js';\nexport function destroyArrayContext(context) {\n    ++context.updateCount;\n    const lastArray = context.lastArray;\n    destroyArray(context, lastArray);\n}\n/** Deletes entire array context not just one */\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n//# sourceMappingURL=destroyArrayContext.function.js.map","import { addPaintRemover } from '../render/paint.function.js';\n/** Destroy dom elements and dom space markers */\nexport function destroyHtmlDomMeta(htmlDomMeta) {\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker, 'destroyMarker');\n    }\n    const dom = clone.domElement;\n    addPaintRemover(dom, 'destroyClone');\n}\n//# sourceMappingURL=destroyHtmlDomMeta.function.js.map","import { destroyArray } from './destroyArrayContext.function.js';\nimport { addPaintRemover } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from './destroyHtmlDomMeta.function.js';\nimport { isPromise } from '../index.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(context, allPromises) {\n    const subContexts = context.contexts;\n    smartRemoveByContext(subContexts, allPromises);\n    destroyContextHtml(context);\n}\nexport function destroyContextHtml(context) {\n    destroyHtmlDomMeta(context.htmlDomMeta);\n}\nfunction smartRemoveByContext(contexts, allPromises) {\n    for (const context of contexts) {\n        if (context.withinOwnerElement) {\n            const tagJsVar = context.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = context.supportOwner;\n                const hostDestroy = tagJsVar.destroy(context, newest);\n                if (isPromise(hostDestroy)) {\n                    allPromises.push(hostDestroy);\n                }\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = context.lastArray;\n        if (lastArray) {\n            destroyArray(context, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = context.simpleValueElm;\n        if (elm) {\n            delete context.simpleValueElm;\n            addPaintRemover(elm, 'smartRemoveByContext');\n            continue;\n        }\n        const subGlobal = context.global;\n        if (subGlobal === undefined) {\n            continue; // context\n        }\n        subGlobal.deleted = true;\n        const oldest = context.state?.oldest;\n        if (oldest) {\n            smartRemoveKids(context, allPromises);\n            continue;\n        }\n    }\n}\n//# sourceMappingURL=smartRemoveKids.function.js.map","import { destroyContexts } from '../tag/destroyContexts.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const context = support.context;\n    global.deleted = true;\n    context.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const subContexts = context.contexts;\n    destroyContexts(subContexts, support);\n    // tag() only destroy\n    if (support.templater.wrapper) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(context, promises);\n    delete context.state;\n    delete context.contexts;\n    delete context.returnValue;\n    delete context.providers;\n    return promises;\n}\n//# sourceMappingURL=destroySupport.function.js.map","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=isLikeTags.function.js.map","import { destroySupport } from '../render/destroySupport.function.js';\nexport function destroySupportByContextItem(context) {\n    ++context.updateCount;\n    const global = context.global;\n    const state = context.state;\n    const lastSupport = state.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    destroySupportContext(context);\n}\nfunction destroySupportContext(context) {\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    delete context.contexts;\n    delete context.state;\n    delete context.global;\n    context.renderCount = 0;\n}\n//# sourceMappingURL=destroySupportByContextItem.function.js.map","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nexport function checkTagValueChange(newValue, contextItem) {\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            return 7; // 'tag-swap'\n        }\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        if (newValue.wrapper?.original === contextItem.value.wrapper?.original) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    // destroySupportByContextItem(contextItem)\n    return 8; // 'no-longer-tag'\n}\n/*\nexport function checkTagValueChangeAndUpdate(\n  newValue: unknown,\n  contextItem: ContextItem,\n) {\n  const checkValue = checkTagValueChange(newValue, contextItem)\n\n  const global = contextItem.global as SupportTagGlobal\n  const lastSupport = contextItem.state?.newest as AnySupport\n  \n  if(checkValue === 7) {\n    destroySupport(lastSupport, global)\n    getNewGlobal(contextItem as SupportContextItem)\n    return 7 // 'tag-swap'\n  }\n  \n  if(checkValue === 8) {\n    destroySupportByContextItem(contextItem)\n    return 8\n  }\n\n  const isValueTag = isStaticTag(newValue)\n  if(isValueTag) {\n    // always cause a redraw of static tags (was false)\n    tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      lastSupport as AnySupport,\n    )\n\n    return 0\n  }\n\n  const isTag = (newValue as any)?.tagJsType\n  if(isTag) {\n    const state = contextItem.state as ContextStateMeta\n    const support = state.newest as AnySupport\n    const ownerSupport = support.ownerSupport as AnySupport\n    const result = tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      ownerSupport,\n    )\n\n    const doNotRedraw = result === true\n\n    if(doNotRedraw) {\n      return 0\n    }\n\n    return 88 // its same tag with new values\n  }\n\n  destroySupportByContextItem(contextItem)\n  return 8\n}\n*/\nexport function checkTagValueChangeAndUpdate(newValue, contextItem) {\n    const global = contextItem.global;\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport);\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const state = contextItem.state;\n        const support = state.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\n//# sourceMappingURL=checkTagValueChange.function.js.map","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n//# sourceMappingURL=castTextValue.function.js.map","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName.toLowerCase()) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n    }\n    return false;\n}\n//# sourceMappingURL=isSpecialAttribute.function.js.map","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            // element.setAttribute(\"autofocus\", 'true')\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value; // style.backgroundGround\n    element.style.setProperty(smallName, value); // style.background-ground\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n    console.log('autofocus fired', element);\n    // setTimeout(() => (element as any).focus(), 1)\n}\n//# sourceMappingURL=specialAttribute.js.map","import { isObject } from \"../../index.js\";\nimport { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    paintContent.push([setNonFunctionInputValue, [element, name, value]]);\n}\nfunction howToSetInputObjectValue(element, name, value) {\n    if (typeof element[name] !== 'object') {\n        element[name] = {};\n    }\n    // Handle object values by setting properties directly\n    for (const key in value) {\n        const subValue = value[key];\n        paintContent.push([setObjectValue, [element, name, key, subValue]]);\n    }\n    if (element[name].setProperty) {\n        for (const key in value) {\n            const subValue = value[key];\n            paintContent.push([setPropertyValue, [element, name, key, subValue]]);\n        }\n    }\n}\nexport function howToSetStandAloneAttr(element, name, _value) {\n    element.setAttribute(name, '');\n}\nexport function setNonFunctionInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used for checked, selected, and so on */\nexport function setBooleanAttribute(element, name, value) {\n    if (value) {\n        element[name] = true;\n    }\n    else {\n        element[name] = false;\n    }\n}\nexport function setSimpleAttribute(element, name, value) {\n    // for checked=true\n    ;\n    element[name] = value;\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\nfunction setPropertyValue(element, name, key, value) {\n    ;\n    element[name].setProperty(key, value);\n}\n/** main processor for things like <div style=${{ maxWidth: '100vw' }}> */\nfunction setObjectValue(element, name, key, value) {\n    ;\n    element[name][key] = value;\n}\n//# sourceMappingURL=howToSetInputValue.function.js.map","import { specialAttribute } from './specialAttribute.js';\nimport { setNonFunctionInputValue } from './howToSetInputValue.function.js';\nimport { processFunctionAttr } from './processFunctionAttr.function.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial) {\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    if (value?.tagJsType) {\n        return processTagJsAttribute(attrName, value, contextItem, support, element);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, contextItem);\n}\nfunction processTagJsAttribute(name, value, contextItem, ownerSupport, element) {\n    value.processInitAttribute(name, value, element, value, contextItem, ownerSupport, setNonFunctionInputValue);\n    contextItem.tagJsVar = value;\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, context) {\n    if (typeof value === 'function') {\n        return processFunctionAttr(value, context, attrName, element, howToSet);\n    }\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n//# sourceMappingURL=processNameValueAttribute.function.js.map","import { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { Subject, valueToTagJsVar } from '../../index.js';\n/** Used for bolts like div.style(() => {{backgroundColor:}}) */\nexport function processFunctionAttr(value, parentContext, // parent context\nattrName, element, howToSet) {\n    const innerValue = value();\n    const tagJsVarOverride = {\n        tagJsType: 'dynamic-attr',\n        matchesInjection: (inject) => {\n            const tagJsVar = subContext.tagJsVar;\n            if (tagJsVar.matchesInjection) {\n                const rtn = tagJsVar.matchesInjection(inject, subContext);\n                return rtn;\n            }\n        },\n        hasValueChanged: (_value, _contextItem, ownerSupport) => {\n            const newValue = value();\n            return subContext.tagJsVar.hasValueChanged(newValue, subContext, ownerSupport);\n        },\n        processInit: blankHandler,\n        processInitAttribute: blankHandler,\n        destroy: (_contextItem, ownerSupport) => {\n            subContext.tagJsVar.destroy(subContext, ownerSupport);\n        },\n        processUpdate: (value, contextItem, ownerSupport, values) => {\n            ++contextItem.updateCount;\n            const newValue = value();\n            // const oldValue = subContext.value\n            // const newTagJsVar = valueToTagJsVar(newValue)\n            subContext.tagJsVar.processUpdate(newValue, // newTagJsVar as any,\n            subContext, ownerSupport, values);\n            subContext.value = newValue;\n        }\n    };\n    const subContext = {\n        updateCount: 0,\n        isAttr: true,\n        element,\n        parentContext,\n        value: innerValue, // used for new value comparing\n        tagJsVar: valueToTagJsVar(innerValue),\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        contexts: [subContext],\n        element,\n        parentContext,\n        value,\n        tagJsVar: tagJsVarOverride,\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    subContext.tagJsVar.processInitAttribute(attrName, innerValue, element, subContext.tagJsVar, subContext, {}, howToSet);\n    return contextItem;\n}\n//# sourceMappingURL=processFunctionAttr.function.js.map","import { valueToTagJsVar } from \"./valueToTagJsVar.function.js\";\nexport function processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet) {\n    const oldTag = contextItem.tagJsVar; // contextItem.tagJsVar as TagJsVar\n    const tagValue = value;\n    const checkResult = oldTag.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n    ownerSupport);\n    if (checkResult > 0) {\n        oldTag.destroy(contextItem, ownerSupport);\n        element.removeAttribute(name);\n        const newTagVar = valueToTagJsVar(value);\n        newTagVar.isAttr = true;\n        newTagVar.processInitAttribute(name, value, element, newTagVar, contextItem, ownerSupport, howToSet);\n        contextItem.tagJsVar = newTagVar;\n        return;\n    }\n}\n//# sourceMappingURL=processAttributeUpdate.function.js.map","import { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { checkSimpleValueChange, deleteSimpleAttribute } from \"./getSimpleTagVar.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\n/** init runner */\nexport function processSimpleAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, contextItem, _ownerSupport, howToSet) {\n    // function swapping\n    tagJsVar.destroy = deleteSimpleAttribute;\n    tagJsVar.hasValueChanged = checkSimpleValueChange;\n    tagJsVar.processUpdate = (value, contextItem, ownerSupport) => {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet);\n    };\n    const isSpecial = isSpecialAttr(name);\n    processNonDynamicAttr(name, value, element, howToSet, isSpecial, contextItem);\n    contextItem.tagJsVar = tagJsVar;\n}\n//# sourceMappingURL=processSimpleAttribute.function.js.map","import { forceUpdateExistingValue } from \"../index.js\";\nimport { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { processSimpleAttribute } from \"./processSimpleAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nexport function deleteSimpleAttribute(contextItem) {\n    const element = contextItem.element;\n    const name = contextItem.attrName;\n    element.removeAttribute(name);\n}\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInitAttribute: processSimpleAttribute,\n        processInit: processSimpleValueInit,\n        destroy: deleteSimpleValue,\n        // TODO: get to using only checkSimpleValueChange\n        hasValueChanged: checkUpdateDeleteSimpleValueChange, // For attributes, this gets switched to checkSimpleValueChange\n        processUpdate: processStringUpdate, // For attributes, this gets switched to processAttributeUpdate\n        // processUpdate: tagValueUpdateHandler, // For attributes, this gets switched to processAttributeUpdate\n    };\n}\nfunction processStringUpdate(newValue, // newValue\ncontextItem, ownerSupport) {\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, insertBefore, _appendTo) {\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processSimpleValueInit']];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(context) {\n    if (!context.simpleValueElm && context.paint) {\n        context.paint[0] = blankHandler;\n        return; // I'm being deleted before my first render even occurred\n    }\n    const elm = context.simpleValueElm;\n    delete context.simpleValueElm;\n    addPaintRemover(elm, 'deleteSimpleValue');\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || newValue === contextItem.value; // !(typeof(newValue) === BasicTypes.object)\n    if (isRegularUpdate) {\n        return 0; // no need to destroy, just update display\n    }\n    return 6; // 'changed-simple-value'\n}\nexport function checkUpdateDeleteSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || !(typeof (newValue) === BasicTypes.object);\n    if (isRegularUpdate) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return 0; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n//# sourceMappingURL=getSimpleTagVar.function.js.map","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processNowRegularValue']];\n    paintCommands.push(paint);\n}\n//# sourceMappingURL=processRegularValue.function.js.map","import { isArray } from '../isInstance.js';\nimport { destroyArrayContext } from './destroyArrayContext.function.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContext(subject);\n        return 9; // 'array'\n    }\n    return 0;\n}\n//# sourceMappingURL=checkDestroyPrevious.function.js.map","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\ncontextItem, ownerSupport) {\n    // ++contextItem.updateCount\n    // TODO: When a tag-conversion occurs we should swap a different processUpdate that only runs the code below\n    const tagJsType = contextItem.tagJsVar.tagJsType;\n    if (tagJsType && ['tag-conversion', 'element'].includes(tagJsType)) {\n        // calls processDesignElementUpdate\n        contextItem.tagJsVar.processUpdate(newValue, contextItem, ownerSupport, []);\n        contextItem.value = newValue;\n        return 0;\n    }\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    ++contextItem.updateCount;\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\n//# sourceMappingURL=tagValueUpdateHandler.function.js.map","import { removeContextInCycle, setContextInCycle } from \"../../tag/cycles/setContextInCycle.function.js\";\nexport function domProcessContextItem(value, support, contextItem, appendTo, insertBefore) {\n    const subject = support.context;\n    subject.locked = 3;\n    contextItem.element = contextItem.element || appendTo;\n    setContextInCycle(contextItem);\n    contextItem.tagJsVar.processInit(value, contextItem, support, insertBefore, appendTo);\n    removeContextInCycle();\n    contextItem.value = value;\n    delete subject.locked;\n}\n//# sourceMappingURL=domProcessContextItem.function.js.map","// taggedjs-no-compile\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { getNewContext } from '../../render/addOneContext.function.js';\n/** Used by arrays and subcontext creators like subscribe. Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, contexts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = getNewContext(value, contexts, true, ownerSupport.context);\n    contextItem.withinOwnerElement = false;\n    contextItem.placeholder = element;\n    if (!appendTo) {\n        contextItem.placeholder = insertBefore;\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n//# sourceMappingURL=createAndProcessContextItem.function.js.map","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from '../tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from '../createAndProcessContextItem.function.js';\nexport function processTagArray(contextItem, value, // arry of Tag classes\nownerSupport, appendTo) {\n    const noLast = contextItem.lastArray === undefined;\n    if (noLast) {\n        contextItem.lastArray = [];\n    }\n    const lastArray = contextItem.lastArray;\n    let runtimeInsertBefore = contextItem.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        contextItem.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, contextItem.lastArray, ownerSupport, runtimeInsertBefore, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\n/** new and old array items processed here */\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\nappendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\nappendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, itemSubject, ownerSupport);\n        return itemSubject;\n    }\n    // NEW REPLACEMENT\n    const contextItem = createAndProcessContextItem(value, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n//# sourceMappingURL=processTagArray.js.map","import { checkArrayValueChange } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/arrays/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroyArrayContext } from '../tag/destroyArrayContext.function.js';\n/** how to process an array */\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInitAttribute: blankHandler,\n        processInit: processArrayInit,\n        processUpdate: processArrayUpdates,\n        hasValueChanged: checkArrayValueChange,\n        destroy: destroyArrayContext,\n    };\n}\nfunction processArrayUpdates(newValue, contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const tagUpdateResponse = tagValueUpdateHandler(newValue, contextItem, ownerSupport);\n    if (tagUpdateResponse === 0) {\n        processTagArray(contextItem, newValue, ownerSupport);\n    }\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, appendTo);\n}\n//# sourceMappingURL=getArrayTagJsVar.function.js.map","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n//# sourceMappingURL=valueToTagJsVar.function.js.map","import { Subject } from '../subject/Subject.class.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\nexport function getNewContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = {\n        updateCount: 0,\n        value,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n        parentContext,\n        // TODO: remove with html.dom(allStrings.allStrings86618[0])\n        // valueIndex: contexts?.length || -1, // when -1 its a raw bolt value\n        // valueIndex: contexts.length\n        valueIndex: parentContext.varCounter,\n    };\n    return contextItem;\n}\n/** auto adds onto parent.contexts */\nexport function addOneContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = getNewContext(value, contexts, withinOwnerElement, parentContext);\n    contexts.push(contextItem);\n    ++parentContext.varCounter;\n    return contextItem;\n}\n//# sourceMappingURL=addOneContext.function.js.map\n// @ts-ignore\nconst allStrings = {allStrings86618:[[]]}","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/addOneContext.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, contexts, support, // owner\nparentContext, depth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, contexts, isWithinOwnerElement, parentContext);\n    contextItem.placeholder = marker;\n    contextItem.element = appendTo;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([\n            paintBefore, [insertBefore, marker, 'attachDynamicDom.attachDynamicDom']\n        ]);\n    }\n    domProcessContextItem(value, support, contextItem, appendTo, insertBefore);\n    return contextItem;\n}\n//# sourceMappingURL=attachDynamicDom.function.js.map","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n//# sourceMappingURL=handleProviderChanges.function.js.map","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const context = support.context;\n    const providers = context.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n//# sourceMappingURL=providersChangeCheck.function.js.map","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n//# sourceMappingURL=safeRenderSupport.function.js.map","import { getSupportInCycle } from '../cycles/getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, currentDepth) {\n    return props.map(function eachCastProp(prop, pos) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, currentDepth, pos);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth, pos // arguments position\n) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth, pos);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, pos, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth, pos);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth, pos);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth, pos) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth, pos // argument position\n) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport, pos) {\n    // restore object to have original function on destroy\n    if (depth <= 0) {\n        return;\n    }\n    const context = newSupport.context;\n    const castedProps = context.value?.props;\n    if (castedProps) {\n        // check for old prop subscription\n        const prop = castedProps[pos][index];\n        if (prop?.subscription) {\n            prop.subscription(); // unsubscribe to prevent this old argument/prop from being called on destroy\n            prop.restore(); // put original value back\n        }\n    }\n    const altPropRestore = () => {\n        newProp[index] = originalValue;\n    };\n    newProp[index].subscription = newSupport.context.destroy$.toCallback(altPropRestore);\n    newProp[index].restore = altPropRestore;\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const ownerContext = ownerSupport.context;\n    const newest = ownerContext.state?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const context = newest.context;\n        const global = context.global;\n        if (context.locked) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        if (!global) {\n            /*\n            context.tagJsVar.processUpdate(\n              context.value,\n              context,\n              ownerSupport,\n              [],\n            )\n      */\n            ownerContext.tagJsVar.processUpdate(ownerContext.value, ownerContext, ownerSupport, []);\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n//# sourceMappingURL=alterProp.function.js.map","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n//# sourceMappingURL=syncPriorPropFunction.function.js.map","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n//# sourceMappingURL=updateExistingArray.function.js.map","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n//# sourceMappingURL=updateExistingObject.function.js.map","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = subject.state.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    if (!global || !subject.state.newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    const newest = subject.state.newest;\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const context = oldSupport.context;\n    const global = context.global;\n    let pIndex = -1;\n    const providers = context.providers = context.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = contextItem.state.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n}\n//# sourceMappingURL=updateExistingTagComponent.function.js.map","import { hasPropChanges } from './hasPropChanges.function.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\n//# sourceMappingURL=hasSupportChanged.function.js.map","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch } from './hasSupportChanged.function.js';\nimport { shallowPropMatch } from './shallowPropMatch.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nimport { hasPropLengthsChanged } from '../render/checkRenderUp.function.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n//# sourceMappingURL=hasPropChanges.function.js.map","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContexts.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const context = lastSupport.context;\n    const global = context.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(context.contexts);\n    softDestroyOne(context);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(child.context);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(context);\n}\nfunction softDestroyOne(context) {\n    context.global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(context, []);\n    delete context.contexts;\n}\n//# sourceMappingURL=softDestroySupport.function.js.map","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // tag returns another function expected to be called\n        if (typeof (tag) === BasicTypes.function && tag.tagJsType === undefined) {\n            tag = tag();\n        }\n    }\n    useSupport.context.returnValue = tag;\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.context.state.newer = { ...config };\n    removeContextInCycle();\n    return useSupport;\n}\n//# sourceMappingURL=executeWrap.function.js.map","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterSupportRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    runAfterRender(support.context);\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n/** run after rendering anything with state */\nexport function runAfterRender(context) {\n    saveState(context);\n    // TODO: prove this is worth having\n    // checkStateMismatch(config, support)\n    clearStateConfig();\n    // setUseMemory.tagClosed$.next(ownerSupport)\n}\nfunction saveState(context) {\n    const config = setUseMemory.stateConfig;\n    const subject = context || config.context;\n    subject.state = subject.state || {};\n    subject.state.newer = { ...config };\n    const support = config.support;\n    subject.state.newest = support;\n}\nexport function clearStateConfig() {\n    const config = setUseMemory.stateConfig;\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.state;\n    delete config.states;\n    removeContextInCycle();\n}\n//# sourceMappingURL=runAfterRender.function.js.map","import { ValueTypes } from '../tag/index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { runAfterSupportRender } from './runAfterRender.function.js';\nexport function callTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    let reSupport;\n    const templater = newSupport.templater;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        context);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, context, prevSupport);\n    }\n    runAfterSupportRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\n//# sourceMappingURL=callTag.function.js.map","import { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { runRestate } from './stateHandlers.js';\nimport { reStatesHandler } from './states.utils.js';\nexport function reState(context) {\n    setContextInCycle(context);\n    const stateMeta = context.state;\n    return reStateByPrev(stateMeta.newer.state);\n}\nexport function reStateByPrev(prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.state = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    return config;\n}\nexport function reStateSupport(newSupport, prevSupport, prevState) {\n    reStateByPrev(prevState);\n    const config = setUseMemory.stateConfig;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\n//# sourceMappingURL=reState.function.js.map","import { initState } from '../state/state.utils.js';\nimport { callTag } from './callTag.function.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { reStateSupport } from '../state/reState.function.js';\nexport function reRenderTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    const stateMeta = context.state;\n    const prevState = stateMeta.older.state;\n    reStateSupport(newSupport, prevSupport, prevState);\n    return callTag(newSupport, prevSupport, context, ownerSupport);\n}\n/** Used during first renders of a support */\nexport function firstTagRender(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    initState(newSupport.context);\n    setSupportInCycle(newSupport);\n    const result = callTag(newSupport, prevSupport, context, ownerSupport);\n    removeContextInCycle();\n    return result;\n}\nexport function getSupportOlderState(support) {\n    const context = support?.context;\n    const stateMeta = context?.state;\n    return stateMeta?.older?.state;\n}\n/*\nexport function getSupportNewerState(support?: AnySupport) {\n  const context = support?.context as SupportContextItem\n  const stateMeta = context?.state\n  return stateMeta?.newer?.state\n}\n*/ \n//# sourceMappingURL=renderTagOnly.function.js.map","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { firstTagRender, getSupportOlderState, reRenderTag } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\ncontext) {\n    let reSupport;\n    delete context.toRender;\n    const olderState = getSupportOlderState(lastSupport);\n    // const olderState = getSupportNewerState(lastSupport)\n    if (olderState) {\n        reSupport = reRenderTag(newSupport, lastSupport, context);\n    }\n    else {\n        reSupport = firstTagRender(newSupport, lastSupport, context);\n    }\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const context = reSupport.context;\n        context.state.oldest = reSupport;\n        context.state.newest = reSupport;\n        // context.state.older = context.state.newer\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && context.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n        // context.state.older = context.state.newer\n        // context.state.newer = context.state.older\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return {\n        support: reSupport,\n        wasLikeTags: isLikeTag\n    };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n//# sourceMappingURL=renderWithSupport.function.js.map","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    if (result.wasLikeTags) {\n        const oldest = subject.state.oldest; // || result.support\n        updateSupportBy(oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject);\n}\n//# sourceMappingURL=renderExistingTag.function.js.map","import { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = 4;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(subject.state.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownContext = ownerSupport.context;\n    const newest = ownContext.state.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\n//# sourceMappingURL=renderSupport.function.js.map","import { deepEqual } from '../deepFunctions.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch } from '../tag/hasSupportChanged.function.js';\nimport { shallowPropMatch } from '../tag/shallowPropMatch.function.js';\nexport function checkRenderUp(templater, support) {\n    const global = support.context.global;\n    if (global && global.deleted) {\n        return false;\n    }\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n//# sourceMappingURL=checkRenderUp.function.js.map","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { checkRenderUp } from \"../../render/checkRenderUp.function.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const global = support.context.global;\n    if (global && global.deleted === true) {\n        return supports;\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    if (newSupport.context.providers) {\n        const proSupports = providersChangeCheck(newSupport);\n        supports.push(...proSupports);\n    }\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n//# sourceMappingURL=getUpTags.function.js.map","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const context = support.context;\n    const global = context.global;\n    if (!global) {\n        context.tagJsVar.processUpdate(context.value, context, support.ownerSupport, []);\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    const stateMeta = context.state;\n    renderSupport(stateMeta.newest);\n}\n//# sourceMappingURL=renderTagArray.function.js.map","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    const stateMeta = support.context.state;\n    const newestStateMeta = newestSupport.context.state;\n    const fromStates = stateMeta.newer.states;\n    const toStates = newestStateMeta.newer.states;\n    return syncStatesArray(fromStates, toStates);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n//# sourceMappingURL=syncStates.function.js.map","/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        subject.locked = 2;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const global = last.context.global;\n        //clearTimeout(timeout)\n        const subject = last.context;\n        delete subject.locked;\n        if (global.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, subject.state.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n//# sourceMappingURL=checkToResolvePromise.function.js.map","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = 1; // prevent another render from re-rendering this tag\n    // ++painting.locks\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.context.state.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    // --painting.locks\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, last) {\n    const global = last.context.global;\n    if (global?.deleted) {\n        return;\n    }\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n//# sourceMappingURL=bindSubjectCallback.function.js.map","export function bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.originalStopPropagation = event.stopPropagation;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n            event.stopPropagation = event.originalStopPropagation;\n            delete event.originalStopPropagation;\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n//# sourceMappingURL=bubbleEvent.function.js.map","import { bubbleEvent } from './bubbleEvent.function.js';\nexport function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    const replaceEventName = getEventReferenceName(eventName);\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const context = support.context;\n    const eventReg = context.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nexport function getEventReferenceName(eventName) {\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    return '_' + eventName;\n}\n//# sourceMappingURL=addSupportEventListener.function.js.map","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n//# sourceMappingURL=processAttributeCallback.function.js.map","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n//# sourceMappingURL=isNoDisplayValue.function.js.map","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { BasicTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { processAttribute } from './processAttribute.function.js';\n// single/stand alone attributes\nexport function processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    const newContexts = [];\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const isSpecial = isSpecialAttr(name); // only object variables are evaluated for is special attr\n            const value = attrValue[name];\n            const howToSet = setNonFunctionInputValue;\n            const subContext = processAttribute(name, value, values, element, ownerSupport, howToSet, contexts, parentContext, isSpecial);\n            if (subContext !== undefined) {\n                if (Array.isArray(subContext)) {\n                    newContexts.push(...subContext);\n                }\n                else {\n                    newContexts.push(subContext);\n                }\n            }\n        }\n        return newContexts;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n//# sourceMappingURL=processStandAloneAttribute.function.js.map","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processStandAloneAttribute } from '../../render/attributes/processStandAloneAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue) || attrValue === '') {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    const standAloneResult = processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext);\n    if (standAloneResult) {\n        contexts.push(...standAloneResult);\n    }\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n//# sourceMappingURL=updateNameOnlyAttrValue.function.js.map","import { processAttributeEmit } from './processAttribute.function.js';\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateNameOnlyAttrValue.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\n/** Currently universally used for all attributes */\nexport function processUpdateAttrContext(value, contextItem, ownerSupport, values) {\n    const attrContextItem = contextItem;\n    const tagValue = value;\n    if (tagValue?.tagJsType) {\n        const oldValue = contextItem.value;\n        // its now a tagVar value but before was not\n        if (!oldValue?.tagJsType) {\n            tagValue.isAttr = true;\n            setContextInCycle(contextItem);\n            tagValue.processInitAttribute(attrContextItem.attrName, value, attrContextItem.element, tagValue, attrContextItem, ownerSupport, setNonFunctionInputValue);\n            removeContextInCycle();\n            attrContextItem.tagJsVar = tagValue;\n            return;\n        }\n        oldValue.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n        ownerSupport);\n        return;\n    }\n    if (attrContextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, attrContextItem.value, attrContextItem.element, // global.element as Element,\n        ownerSupport, attrContextItem.howToSet, [], // Context, but we dont want to alter current\n        attrContextItem.parentContext);\n        attrContextItem.value = value;\n        return;\n    }\n    const element = attrContextItem.element;\n    processAttributeEmit(value, attrContextItem.attrName, attrContextItem, element, ownerSupport, attrContextItem.howToSet, attrContextItem.isSpecial);\n    contextItem.value = value;\n    return;\n}\n//# sourceMappingURL=processUpdateAttrContext.function.js.map","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { processStandAloneAttribute } from './processStandAloneAttribute.function.js';\nimport { processTagJsVarAttribute } from './processTagJsAttribute.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(attrName, value, values, // all the variables inside html``\nelement, support, howToSet, //  = howToSetInputValue\ncontexts, parentContext, isSpecial) {\n    const varIndex = getTagJsVar(attrName);\n    let isNameVar = varIndex >= 0 || (value === undefined && typeof (attrName) !== 'string');\n    let valueInValues = values[varIndex];\n    // value or name from bolt?\n    if (value?.tagJsType) {\n        valueInValues = value; // the value is a tagJsVar\n    }\n    else if (attrName?.tagJsType) {\n        isNameVar = true;\n        valueInValues = attrName; // the name is a tagJsVar\n        value = attrName;\n    }\n    const tagJsVar = valueInValues;\n    if (tagJsVar?.tagJsType) {\n        return processTagJsVarAttribute(value, [], // contexts,\n        parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar);\n    }\n    if (isNameVar) {\n        // old way of setting by html``\n        if (varIndex === -1 && isNameVar) {\n            valueInValues = attrName; // its a name only value attribute\n        }\n        const contextItem = getNewContext(valueInValues, [], // contexts,\n        true, parentContext);\n        contextItem.valueIndex = varIndex;\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.isNameOnly = true;\n        contextItem.howToSet = howToSet;\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // single/stand alone attributes\n        const aloneResult = processStandAloneAttribute(values, valueInValues, element, support, howToSet, contexts, parentContext);\n        if (aloneResult) {\n            contexts.push(...aloneResult);\n        }\n        return contextItem;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, [], // contexts,\n        howToSet, values, support.context);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, [], // contexts,\n        parentContext, howToSet, support, isSpecial, valueVar);\n    }\n    // simple name/value attribute\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, parentContext);\n}\n/** Only used during updates */\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(\n        // subject,\n        newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processTagCallbackFun(\n// subject: AttributeContextItem,\nnewAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    // const tagJsVar = subject.tagJsVar // = valueToTagJsVar(newAttrValue)\n    // tagJsVar.processUpdate = processUpdateAttrContext\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n//# sourceMappingURL=processAttribute.function.js.map","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n//# sourceMappingURL=DomTag.type.js.map","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n//# sourceMappingURL=getTagVarIndex.function.js.map","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/index.js';\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { Subject } from '../../subject/Subject.class.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, contexts, howToSet, //  = howToSetInputValue\nvalues, parentContext) {\n    const startIndex = contexts.length;\n    const createdContexts = [];\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = contexts.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                updateCount: 0,\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n                valueIndex: parentContext.varCounter, // contexts.length,\n                parentContext,\n                destroy$: new Subject(),\n                render$: new Subject(),\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHandler(value, contextItem, newSupport, newValues) {\n                ++contextItem.updateCount;\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            createdContexts.push(contextItem);\n            ++parentContext.varCounter;\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n    return createdContexts;\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, parentContext, howToSet, //  = howToSetInputValue\nsupport, isSpecial, varIndex) {\n    if (typeof (value) === BasicTypes.function) {\n        ++parentContext.varCounter;\n        return processTagCallbackFun(\n        // contextItem,\n        value, support, attrName, element);\n    }\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        element,\n        attrName,\n        howToSet,\n        value,\n        withinOwnerElement: true,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        valueIndex: varIndex,\n        parentContext,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial);\n    contextItem.value = value;\n    return contextItem;\n}\n//# sourceMappingURL=createDynamicAttribute.function.js.map","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n//# sourceMappingURL=getTagJsVar.function.js.map","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** adds onto parent.contexts */\nexport function processTagJsVarAttribute(value, contexts, parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar) {\n    // getOneContext\n    const contextItem = getNewContext(value, contexts || [], true, parentContext);\n    contextItem.element = element;\n    contextItem.valueIndex = varIndex;\n    contextItem.isAttr = true;\n    contextItem.isNameOnly = isNameVar;\n    contextItem.stateOwner = getSupportWithState(support);\n    contextItem.supportOwner = support;\n    setContextInCycle(contextItem);\n    tagJsVar.processInitAttribute(attrName, value, // tagJsVar,\n    element, tagJsVar, contextItem, support, setNonFunctionInputValue);\n    removeContextInCycle();\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = tagJsVar;\n    return contextItem;\n}\n//# sourceMappingURL=processTagJsAttribute.function.js.map","import { howToSetStandAloneAttr, setNonFunctionInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nexport function processAttributeArray(attrs, values, domElement, support, \n// contexts: ContextItem[],\nparentContext) {\n    for (const attr of attrs) {\n        const name = attr[0];\n        const value = attr[1];\n        // const isSpecial2 = !value?.tagJsVar && (typeof(name) === 'string' && isSpecialAttr(name))\n        const isSpecial = attr[2] || false; // isSpecial2\n        let howToSet = attr.length > 1 ? setNonFunctionInputValue : howToSetStandAloneAttr;\n        if (attr[3]) {\n            howToSet = attr[3];\n        }\n        // const contexts = support.context.contexts\n        const contexts = parentContext.contexts;\n        const newContext = processAttribute(name, value, values, domElement, support, howToSet, contexts, parentContext, isSpecial) || undefined;\n        if (typeof newContext === 'object') {\n            contexts.push(newContext);\n            ++parentContext.varCounter;\n        }\n    }\n}\n//# sourceMappingURL=processAttributeArray.function.js.map","import { paintAppends, paintAppend, paintCommands, paintBefore } from \"../paint.function.js\";\nimport { processAttributeArray } from \"./processAttributeArray.function.js\";\nexport function attachDomElement(domElement, node, values, support, parentContext, appendTo, insertBefore) {\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        processAttributeArray(node.at, values, domElement, support, \n        // contexts,\n        parentContext);\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement, 'appendToAttachDomElement']]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement, 'insertBeforeAttachDomElement']]);\n    }\n}\n//# sourceMappingURL=attachDomElement.function.js.map","// taggedjs-no-compile\nimport { paintAppend, paintAppendElementString, paintAppends, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nimport { attachDomElement } from \"./attachDomElement.function.js\";\nimport { Subject } from \"../../subject/Subject.class.js\";\nexport function attachDomElements(nodes, values, support, parentContext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const context = support.context;\n    const contexts = context.contexts;\n    parentContext = context;\n    // const contexts = parentContext.contexts\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    // loop map of elements that need to be put down on document\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const v = node.v;\n        const isNum = !isNaN(v);\n        if (isNum) {\n            // const valueIndex = context.varCounter // contexts.length\n            // const valueIndex = (parentContext as SupportContextItem).varCounter // contexts.length\n            const valueIndex = Number(v); // (parentContext as SupportContextItem).varCounter // contexts.length\n            const realValue = values[valueIndex];\n            const isSkipFun = typeof (realValue) === 'function' && realValue.tagJsType === undefined;\n            if (isSkipFun) {\n                ++parentContext.varCounter;\n                // TODO: I dont think we ever get in here?\n                continue;\n            }\n            const contextItem = attachDynamicDom(realValue, contexts, support, parentContext, depth, appendTo, insertBefore);\n            contextItem.valueIndex = valueIndex;\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        const domElement = newNode.domElement = document.createElement(node.nn);\n        // Create parent context for attributes first\n        const newParentContext = {\n            updateCount: 0,\n            isAttrs: true,\n            element: domElement,\n            parentContext,\n            contexts: [],\n            destroy$: new Subject(),\n            render$: new Subject(),\n            tagJsVar: {\n                tagJsType: 'new-parent-context'\n            },\n            valueIndex: -1,\n            withinOwnerElement: true,\n        };\n        newParentContext.varCounter = 0;\n        // one single html element. This is where attribute processing takes place\n        attachDomElement(domElement, node, values, support, newParentContext, appendTo, insertBefore);\n        // Update parent context with element and attribute contexts\n        newParentContext.element = domElement;\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, newParentContext, \n            // contexts,\n            depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, contexts };\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n//# sourceMappingURL=attachDomElements.function.js.map","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n//# sourceMappingURL=parseHTML.function.js.map","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n//# sourceMappingURL=htmlInterpolationToDomMeta.function.js.map","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n//# sourceMappingURL=replacePlaceholders.function.js.map","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n//# sourceMappingURL=getStringsId.function.js.map","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Merges strings & values with dom meta into a html array tree */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n//# sourceMappingURL=domMetaCollector.js.map","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=isLastRunMatched.function.js.map","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, appendTo, insertBefore) {\n    const subject = support.context;\n    // TODO this is only needed for components and not basic tags\n    subject.state = subject.state || {};\n    const stateMeta = subject.state;\n    stateMeta.oldest = support;\n    stateMeta.newest = support;\n    subject.state.older = subject.state.newer;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, support.context, appendTo, insertBefore);\n    subject.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, parentContext, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const context = support.context;\n    parentContext = context;\n    context.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, parentContext, 0, // depth\n    appendTo, insertBefore);\n    return result;\n}\n/** Extracts variables from support in order to merge strings & values with dom meta into a html array tree */\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\n//# sourceMappingURL=buildBeforeElement.function.js.map","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChangeAndUpdate } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\nimport { blankHandler } from '../dom/blankHandler.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem) {\n    const support = contextItem.state.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInitAttribute: blankHandler,\n        processInit: processTagInit,\n        processUpdate: blankHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: blankHandler,\n        propWatch: 'shallow',\n        key: blankHandler,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    subject.contexts = subject.contexts || [];\n    return support;\n}\n//# sourceMappingURL=processTag.function.js.map","import { clonePropsBy } from './props/clonePropsBy.function.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    const global = context.global;\n    global.blocked = [];\n    // context.state.newer = context.state.newer || { ...setUseMemory.stateConfig }\n    if (!context.state) {\n        context.state = {\n            newer: {\n                state: [],\n                states: [],\n            }\n        };\n    }\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n//# sourceMappingURL=createHtmlSupport.function.js.map","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\nappendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker, 'subMarker']]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement, 'subAppendTo']]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement, 'subInsertBefore']]);\n            }\n        }\n    }\n    return support;\n}\n//# sourceMappingURL=processNewSubjectTag.function.js.map","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.state = {};\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem);\n}\n//# sourceMappingURL=processTagInit.function.js.map","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processInitAttribute: blankHandler,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        },\n        matchesInjection(inject, context) {\n            if (templater.wrapper === inject) {\n                return context;\n            }\n            if (templater.wrapper?.original === inject?.original) {\n                return context;\n            }\n        }\n    };\n    return templater;\n}\n//# sourceMappingURL=getTemplaterResult.function.js.map","export const tags = [];\n//# sourceMappingURL=tag.utils.js.map","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n//# sourceMappingURL=getTagWrap.function.js.map","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { firstTagRender } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    firstTagRender(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, appendTo, insertBefore);\n}\n//# sourceMappingURL=processRenderOnceInit.function.js.map","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n//# sourceMappingURL=oneRenderToSupport.function.js.map","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribeWith(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    const subContext = setupSubscribe(value, contextItem, ownerSupport, insertBefore, appendTo);\n    if (!subContext.hasEmitted) {\n        emitSubContext(value, subContext);\n    }\n    return subContext;\n}\nexport function emitSubContext(value, subContext) {\n    const observables = value.Observables;\n    const observable = observables[0];\n    if (!subContext.hasEmitted) {\n        if ('withDefault' in value) {\n            subContext.subValueHandler(value.withDefault, 0);\n            return;\n        }\n        if ('value' in observable) {\n            subContext.subValueHandler(observable.value, 0);\n            return;\n        }\n        return; // nothing to emit\n    }\n    const emitValue = subContext.lastValues[0].value;\n    subContext.subValueHandler(emitValue, 0);\n}\n//# sourceMappingURL=processSubscribeWith.function.js.map","import { setNonFunctionInputValue } from \"../index.js\";\nimport { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { unsubscribeContext, checkToPaint, setupSubscribeCallbackProcessor } from \"../tag/update/setupSubscribe.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\nexport function processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // same as value\ncontextItem, ownerSupport) {\n    // change how the delete occurs\n    value.destroy = unsubscribeContext;\n    const isSpecial = isSpecialAttr(name);\n    const onOutput = function onSubValue(callbackValue, syncRun) {\n        processNonDynamicAttr(name, callbackValue, element, setNonFunctionInputValue, isSpecial, contextItem);\n        checkToPaint(syncRun);\n    };\n    const subContext = setupSubscribeCallbackProcessor(value.Observables, ownerSupport, onOutput, value, contextItem);\n    contextItem.subContext = subContext;\n    contextItem.value = value;\n    contextItem.tagJsVar = value;\n    value.processUpdate = function processAttributeUpdateWrap(value, contextItem2, ownerSupport) {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, setNonFunctionInputValue);\n    };\n    return { subContext, onOutput };\n}\n//# sourceMappingURL=processSubscribeAttribute.function.js.map","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribeWith.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { processSubscribeWithAttribute } from \"./processSubscribeWithAttribute.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    // const support = getSupportInCycle() as AnySupport\n    // const context = getSupportWithState(support).context\n    /*\n    const context = getContextInCycle() as ContextItem\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        onOutput: blankHandler, // this gets set within setupSubscribe\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeWithAttribute,\n        processInit: processSubscribeWith,\n        hasValueChanged: checkSubscribeValueChanged,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        // states: newer.states,\n        Observables: [Observable],\n    };\n}\n/** checks is a previous tag var was a subscription but now has changed */\nexport function checkSubscribeValueChanged(value, contextItem) {\n    if (!value?.tagJsType) {\n        return 1; // its not a subscription anymore\n    }\n    const newObserves = value.Observables;\n    if (!newObserves) {\n        return 2; // its not a subscription anymore\n    }\n    const oldValue = contextItem.value;\n    const oldObserves = oldValue.Observables;\n    if (!oldObserves || oldObserves.length !== newObserves.length) {\n        return 3; // not the same subscription\n    }\n    const allMatch = newObserves.every((ob, index) => ob === oldObserves[index]);\n    if (!allMatch) {\n        return 4;\n    }\n    return 0; // still the same\n}\n//# sourceMappingURL=subscribeWith.function.js.map","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** used to handle when value was subscribe but now is something else */\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem) {\n    const isDifferent = !newValue || !newValue.tagJsType || newValue.tagJsType !== originalType;\n    if (isDifferent) {\n        const oldTagJsVar = contextItem.tagJsVar;\n        oldTagJsVar.destroy(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, // subSubContext,\n        ownerSupport, 99);\n        return 99;\n    }\n}\n//# sourceMappingURL=handleTagTypeChangeFrom.function.js.map","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { handleTagTypeChangeFrom } from './handleTagTypeChangeFrom.function.js';\nexport function checkStillSubscription(newValue, contextItem, ownerSupport) {\n    const subContext = contextItem.subContext;\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    if (!subContext || !subContext.hasEmitted) {\n        return 0;\n    }\n    subContext.tagJsVar = newValue;\n    subContext.valuesHandler(subContext.lastValues, 0);\n    return 0;\n}\n//# sourceMappingURL=checkStillSubscription.function.js.map","import { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\nimport { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { checkStillSubscription } from \"../tag/update/checkStillSubscription.function.js\";\nimport { Subject } from \"../index.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeAttribute,\n        processInit: setupSubscribe,\n        hasValueChanged: checkSubscribeValueChanged,\n        processUpdate: checkStillSubscription,\n        // processUpdate: processUpdateSubscribe,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states,\n        Observables: [Observable],\n    };\n}\nsubscribe.all = subscribeAll;\nfunction subscribeAll(subjects, callback) {\n    return subscribe(Subject.all(subjects), callback);\n}\n//# sourceMappingURL=subscribe.function.js.map","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteContextSubContext(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subscription = contextItem.subContext;\n    const result = deleteSubContext(subscription, ownerSupport);\n    delete contextItem.subContext;\n    return result;\n}\nexport function deleteSubContext(subContext, ownerSupport) {\n    subContext.deleted = true;\n    const appendMarker = subContext.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker, 'deleteSubContext');\n        delete subContext.appendMarker;\n    }\n    // delete (contextItem as any).destroy\n    if (!subContext.hasEmitted) {\n        return;\n    }\n    const subContextItem = subContext.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.destroy(subContextItem, ownerSupport);\n    return 76;\n}\n//# sourceMappingURL=deleteContextSubContext.function.js.map","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, [], insertBefore);\n}\n//# sourceMappingURL=onFirstSubContext.function.js.map","import { deleteContextSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, contextItem, newSupport) {\n    ++contextItem.updateCount;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        hasValueChanged: () => 0, // not expected to do anything\n        processInitAttribute: blankHandler,\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        destroy: deleteContextSubContext,\n    };\n}\n//# sourceMappingURL=getInnerHTML.function.js.map","import { paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./cycles/getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport.context);\n    };\n}\nexport function syncWrapCallback(args, callback, context) {\n    const stateMeta = context.state;\n    const newerStates = stateMeta.newer.states;\n    const olderStates = stateMeta.older ? stateMeta.older.states : newerStates;\n    const newestOwner = stateMeta.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newerStates, olderStates);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(olderStates, newerStates);\n    // now render the owner\n    paintAfters.push([() => {\n            const newGlobal = newestOwner.context.global;\n            const ignore = newGlobal === undefined || newGlobal.deleted === true;\n            if (ignore) {\n                return; // its not a tag anymore\n            }\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n//# sourceMappingURL=output.function.js.map","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { initState } from \"../state/state.utils.js\";\nimport { reState } from '../state/reState.function.js';\nimport { runAfterRender } from \"../render/runAfterRender.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/handleTagTypeChangeFrom.function.js\";\n/** Use to gain access to element\n * @callback called every render\n */\nexport function host(callback, options = {}) {\n    const baseHost = {\n        tagJsType: ValueTypes.host,\n        processInitAttribute: processHostAttribute,\n        // TODO: maybe a host value can change?\n        hasValueChanged: () => 0,\n        processInit: processHost, // This should be a throw error because only attribute is supported\n        processUpdate: processHostUpdate,\n        destroy: deleteHost,\n        options: { callback, ...options },\n        matchesInjection(inject, context) {\n            const options = inject?.options;\n            if (!options) {\n                return false;\n            }\n            const injectCallback = options?.callback;\n            // Check if the inject target is a host with the same callback\n            if (injectCallback === callback) {\n                return context;\n            }\n            return false;\n        },\n    };\n    const returnFunction = (...args) => {\n        const hostValue = {\n            ...returnFunction,\n            options: { arguments: args, ...options, callback },\n        };\n        return hostValue;\n    };\n    Object.assign(returnFunction, baseHost);\n    // returnFunction.options = { callback }\n    return returnFunction;\n}\n// Attach the functions to the host namespace\n;\nhost.onInit = (callback) => {\n    return host(() => { }, { onInit: callback });\n};\nhost.onDestroy = (callback) => {\n    return host(() => { }, { onDestroy: callback });\n};\nfunction processHostUpdate(newValue, contextItem, ownerSupport) {\n    if (typeof (newValue) === 'function' && !newValue?.tagJsType) {\n        throw new Error('issue on its way');\n    }\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, \n    // tagJsVar,\n    ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const oldTagJsVar = contextItem.tagJsVar;\n    const oldOptions = oldTagJsVar.options;\n    // const element = (contextItem as any as AttributeContextItem).element as HTMLInputElement\n    const newHost = newValue;\n    reState(contextItem);\n    const args = (newHost.options.arguments || oldOptions.arguments || []);\n    contextItem.returnValue = newHost.options.callback(...args);\n    runAfterRender(contextItem);\n}\nfunction processHostAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, // same as value not needed\ncontextItem) {\n    return processHost(tagJsVar, contextItem);\n}\n/* Only runs on host() init */\nfunction processHost(tagJsVar, contextItem) {\n    const element = contextItem.element;\n    const state = contextItem.state = {};\n    initState(contextItem);\n    processHostTagJsVar(element, tagJsVar, contextItem, state);\n    runAfterRender(contextItem);\n}\n/** first time run */\nfunction processHostTagJsVar(element, tagJsVar, contextItem, state) {\n    const args = tagJsVar.options.arguments || [];\n    const returnValue = tagJsVar.options.callback(...args);\n    // Store the return value for tag.inject to access\n    contextItem.returnValue = returnValue;\n    // DEPRECATED\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        // const element = contextItem.element as HTMLInputElement\n        options.onInit(element, tagJsVar, contextItem, state);\n    }\n    return returnValue;\n}\nfunction deleteHost(contextItem) {\n    ++contextItem.updateCount;\n    const attrContext = contextItem;\n    const tagJsVar = attrContext.tagJsVar;\n    const options = tagJsVar.options;\n    if (attrContext.destroy$.subscribers.length) {\n        // TODO: Not sure if this needed\n        setContextInCycle(contextItem);\n        syncWrapCallback([], attrContext.destroy$.next.bind(attrContext.destroy$), contextItem);\n        // TODO: Not sure if this needed\n        removeContextInCycle();\n    }\n    // DEPRECATED\n    // TODO: remove this code and use tag.onDestroy instead\n    if (options.onDestroy) {\n        const element = attrContext.element;\n        const hostDestroy = function processHostDestroy() {\n            setContextInCycle(contextItem);\n            const result = options.onDestroy(element, tagJsVar, attrContext, attrContext.state);\n            removeContextInCycle();\n            return result;\n        };\n        const stateOwner = contextItem.stateOwner;\n        return syncWrapCallback([], hostDestroy, stateOwner.context);\n    }\n}\n//# sourceMappingURL=host.function.js.map","import { Subject } from '../../index.js';\nimport { valueToTagJsVar } from '../../tagJsVars/index.js';\nimport { getOverrideTagVar } from './processFirstSubjectComponent.function.js';\nexport function convertTagToElementManaged(support, ownerSupport, subject) {\n    const context = support.context;\n    const newValue = context.toRender || context.returnValue;\n    // EXAMPLE: ['a','b'].map(x=> tag(() => [div,span]).key(x))\n    /*\n    if(Array.isArray(newValue)) {\n      ;(newValue as any).key = (arrayValue: any) => keyTag(arrayValue, newValue)\n    }\n    */\n    const tagJsVar = valueToTagJsVar(newValue);\n    delete context.global;\n    context.contexts = [];\n    const newContext = {\n        updateCount: 0,\n        value: newValue,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        placeholder: context.placeholder,\n        // not important\n        valueIndex: -1,\n        withinOwnerElement: true,\n        parentContext: context,\n        contexts: context.contexts, // share contexts especially so providers properly crawl my available contexts\n        // contexts: subject.contexts, // share contexts especially so providers properly crawl my available contexts\n    };\n    // context.contexts = [ newContext ] as ContextItem[] & SupportContextItem[]\n    const overrideTagVar = getOverrideTagVar(context, newContext, support, subject);\n    context.tagJsVar = overrideTagVar;\n    // TODO: should we be calling this here?\n    tagJsVar.processInit(newValue, newContext, support, subject.placeholder);\n    return support;\n}\n//# sourceMappingURL=convertTagToElementManaged.function.js.map","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { firstTagRender } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { checkTagValueChange, isPromise, paint } from '../../index.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nimport { castProps } from '../props/alterProp.function.js';\nimport { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { convertTagToElementManaged } from './convertTagToElementManaged.function.js';\nfunction createSupportWithProps(templater, subject, ownerSupport) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const support = firstTagRender(newSupport, subject.state.newest, // existing tag\n    subject);\n    return support;\n}\nexport function processReplacementComponent(templater, subject, ownerSupport) {\n    const support = createSupportWithProps(templater, subject, ownerSupport);\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, ownerSupport, subject);\n    }\n    buildBeforeElement(support, undefined, // element for append child\n    subject.placeholder);\n    return support;\n}\n/** Used when a tag() does not return html.dom(allStrings.allStrings490419[0]) */\nexport function getOverrideTagVar(context, newContext, support, subject) {\n    // support.context = subject as SupportContextItem\n    const overrideTagVar = {\n        tagJsType: 'tag-conversion',\n        // processInitAttribute: newContext.tagJsVar.processInitAttribute,\n        processInitAttribute: blankHandler, // cannot be an attribute ever\n        processInit: (_value, _contextItem, _ownerSupport) => {\n            const renderContent = context.toRender || context.returnValue;\n            return newContext.tagJsVar.processInit(renderContent, newContext, support, subject.placeholder);\n        },\n        processUpdate: (value, context, ownerSupport) => {\n            if (context.locked || context.deleted) {\n                return;\n            }\n            ++context.updateCount;\n            const convertValue = context.toRender || context.returnValue;\n            const oldValue = context.value;\n            const oldType = oldValue.tagJsType;\n            const newType = value?.tagJsType;\n            const hasTypeChanged = newType !== oldType;\n            const hasChanged = checkTagValueChange(value, context);\n            // check to see if the tagConversion itself has changed\n            const changed = hasChanged || hasTypeChanged || overrideTagVar.hasValueChanged(convertValue, context, // aka contextItem,\n            support);\n            if (changed) {\n                overrideTagVar.destroy(context, support);\n                updateToDiffValue(value, context, // newContext\n                ownerSupport, 789);\n                return;\n            }\n            context.locked = 467;\n            context.render$.next(); // cause tag.onRender to fire\n            makeRealUpdate(newContext, value, context, convertValue, support);\n            delete context.locked;\n        },\n        hasValueChanged: (_value, _contextItem) => {\n            const newValue = context.toRender || context.returnValue;\n            const checkResult = newContext.tagJsVar.hasValueChanged(newValue, newContext, support);\n            return checkResult;\n        },\n        destroy: (contextItem, ownerSupport) => {\n            ++context.updateCount;\n            const result = newContext.tagJsVar.destroy(newContext, support);\n            if (isPromise(result)) {\n                return result.then(() => {\n                    const result = afterDestroy(context, ownerSupport);\n                    paint();\n                    return result;\n                });\n            }\n            return afterDestroy(context, ownerSupport);\n        }\n    };\n    return overrideTagVar;\n}\nfunction makeRealUpdate(newContext, value, context, convertValue, support) {\n    const castedProps = castProps(value.props, support, // ownerSupport,\n    0);\n    newContext.value.props = castedProps;\n    const propsConfig = support.propsConfig;\n    if (propsConfig) {\n        propsConfig.castProps = castedProps;\n    }\n    ;\n    newContext.updatesHandler = context.updatesHandler;\n    if (context.updatesHandler) {\n        const updatesHandler = context.updatesHandler;\n        updatesHandler(castedProps);\n    }\n    newContext.tagJsVar.processUpdate(convertValue, newContext, support, []);\n    newContext.value = convertValue;\n}\nfunction afterDestroy(context, _ownerSupport) {\n    delete context.returnValue;\n    delete context.toRender;\n    delete context.global // = {} as any;\n    ;\n    context.contexts = [];\n    ;\n    context.htmlDomMeta = [];\n    delete context.updatesHandler;\n    // context.value.destroy(context, ownerSupport)\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, appendTo) {\n    const support = createSupportWithProps(templater, subject, ownerSupport);\n    // DISCOVER IF tag() did NOT return dom|html\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, ownerSupport, subject);\n    }\n    return processFirstTagResult(support, appendTo);\n}\n//# sourceMappingURL=processFirstSubjectComponent.function.js.map\n// @ts-ignore\nconst allStrings = {allStrings490419:[[]]}","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, appendTo) {\n    const result = buildBeforeElement(support, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n//# sourceMappingURL=processTagResult.function.js.map","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\n_insertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processFirstSubjectComponent(value, contextItem, ownerSupport, appendTo);\n    }\n    return processReplacementComponent(value, contextItem, ownerSupport);\n}\n//# sourceMappingURL=processTagComponentInit.function.js.map","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n//# sourceMappingURL=state.function.js.map","import { tag } from '../index.js';\nimport { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const context = getContextInCycle();\n        if (context.global) {\n            const nowSupport = getSupportInCycle();\n            return checkToResolvePromise(result, nowSupport, { resolvePromise, resolveValue });\n        }\n    });\n    return tag;\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n//# sourceMappingURL=onInit.function.js.map","import { state } from \"./state.function.js\";\nimport { getContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const context = getContextInCycle();\n        context.destroy$.toCallback(callback);\n    });\n    return tag;\n}\n//# sourceMappingURL=onDestroy.function.js.map","// taggedjs-no-compile\nimport { callback, setUseMemory, state } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../tag/checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from '../tag/destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { getContextInCycle, getElement as getTagElement } from '../tag/cycles/setContextInCycle.function.js';\nimport { tagInject } from './tagInject.function.js';\nimport { onInit as tagOnInit } from '../state/onInit.function.js';\nimport { onDestroy as tagOnDestroy } from '../state/onDestroy.function.js';\nimport { onRender as tagOnRender } from '../state/onRender.function.js';\nimport { getInnerHTML as tagGetInnerHTML } from '../index.js';\nlet tagCount = 0;\nconst onClick = makeEventListener('click');\nconst onMouseDown = makeEventListener('mousedown');\nfunction makeEventListener(type) {\n    return function eventListener(toBeCalled) {\n        const wrapped = callback(toBeCalled); // should cause render to occur\n        // run one time\n        state(() => {\n            const element = getTagElement();\n            element.addEventListener(type, wrapped);\n        });\n        return wrapped; // this is what you remove\n    };\n}\nconst tagElement = {\n    get: getTagElement,\n    onclick: onClick,\n    click: onClick,\n    onClick,\n    mousedown: onMouseDown,\n    onmousedown: onMouseDown,\n    onMouseDown: onMouseDown,\n};\ndefineGetSet('onclick', onClick);\ndefineGetSet('click', onClick);\ndefineGetSet('onMouseDown', onMouseDown);\ndefineGetSet('onmousedown', onMouseDown);\ndefineGetSet('mousedown', onMouseDown);\nfunction defineGetSet(name, eventFn) {\n    Object.defineProperty(tag, name, {\n        get() {\n            return eventFn;\n        },\n        set(fn) {\n            return eventFn(fn);\n        },\n    });\n}\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        templater.hasValueChanged = checkTagValueChangeAndUpdate;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    const returnWrap = parentWrap;\n    // used for argument updates\n    returnWrap.updates = (handler) => {\n        const context = getContextInCycle();\n        context.updatesHandler = handler;\n        return true;\n    };\n    returnWrap.getInnerHTML = tagGetInnerHTML;\n    return returnWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n// actually placing of items into tag memory\n;\ntag.element = tagElement;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.inject = tagInject;\ntag.onInit = tagOnInit;\ntag.onDestroy = tagOnDestroy;\ntag.onRender = tagOnRender;\ntag.getInnerHTML = tagGetInnerHTML;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.destroy = destroySupportByContextItem;\n        oneRenderFunction.hasValueChanged = function renderOnceNeverChanges() {\n            return 0;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.hasValueChanged = checkTagValueChangeAndUpdate;\n        renderFunction.destroy = destroySupportByContextItem;\n    },\n});\n//# sourceMappingURL=tag.function.js.map","import { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Inject a parent tag or host into the current context\n * For host functions, returns the value returned by the host callback\n * For tag components, returns the tag instance itself\n */\nexport function tagInject(targetItem) {\n    const context = getContextInCycle();\n    if (!context) {\n        throw new Error('tag.inject can only be called within a tag or host context');\n    }\n    // Search up the context tree for a matching parent\n    let currentContext = context.parentContext;\n    while (currentContext) {\n        // Check if this is an attributes context with child contexts\n        const contexts = currentContext.contexts;\n        if (contexts) {\n            // Search within the attributes contexts\n            for (const attrContext of contexts) {\n                if (attrContext.isAttr && attrContext.tagJsVar?.matchesInjection) {\n                    // Use the matchesInjection method if available\n                    const inContext = attrContext.tagJsVar.matchesInjection(targetItem, attrContext);\n                    if (inContext !== undefined) {\n                        // For host values, return the returnValue from the context\n                        return inContext.returnValue;\n                    }\n                }\n            }\n        }\n        // Check if this context has a tagJsVar with matchesInjection\n        if (currentContext.tagJsVar?.matchesInjection) {\n            if (currentContext.tagJsVar.matchesInjection(targetItem, currentContext)) {\n                // For tag components, return the tag instance\n                return currentContext.returnValue;\n            }\n        }\n        // Move up to the parent context\n        currentContext = currentContext.parentContext;\n    }\n    const message = `Could not find parent context for tag.inject ${targetItem}`;\n    console.error(message, { targetItem, context });\n    throw new Error(message);\n}\n//# sourceMappingURL=tagInject.function.js.map","import { getContextInCycle, removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onRender(callback) {\n    const context = getContextInCycle();\n    const callbackWrap = (isFirst) => {\n        // remember current context (old)\n        // const oldIndex = setUseMemory.stateConfig.statesIndex\n        const lastContext = getContextInCycle();\n        // set to inner context cycle with previous state position\n        setContextInCycle(context);\n        const result = callback();\n        // restore previous cycle\n        removeContextInCycle();\n        setContextInCycle(lastContext);\n        return result;\n    };\n    const subscription = context.render$.subscribe(() => callbackWrap());\n    const result = callbackWrap();\n    tag.onDestroy(() => subscription.unsubscribe());\n    return result;\n}\n//# sourceMappingURL=onRender.function.js.map","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n//# sourceMappingURL=clonePropsBy.function.js.map","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n//# sourceMappingURL=createSupport.function.js.map","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        // its html/dom based tag\n        const support = contextItem.state.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, contextItem.placeholder);\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = newValue;\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    // When last value was not a component\n    if (!contextItem.state.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n//# sourceMappingURL=tryUpdateToTag.function.js.map","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html.dom(allStrings.allStrings76234[0])) or () => html.dom(allStrings.allStrings76234[1])\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html.dom(allStrings.allStrings76234[2])\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = oldSupport.context;\n    const oldest = lastSubject.state.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n//# sourceMappingURL=handleStillTag.function.js.map\n// @ts-ignore\nconst allStrings = {allStrings76234:[[],[],[]]}","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './arrays/processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport);\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) { // TODO: is this check really needed?\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n//# sourceMappingURL=updateToDiffValue.function.js.map","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.hasValueChanged(newValue, contextItem, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === 0) {\n        return ignoreOrDestroyed; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed);\n    return ignoreOrDestroyed;\n}\n//# sourceMappingURL=forceUpdateExistingValue.function.js.map","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n//# sourceMappingURL=guaranteeInsertBefore.function.js.map","import { checkStillSubscription } from './checkStillSubscription.function.js';\nimport { emitSubContext } from './processSubscribeWith.function.js';\nexport function processUpdateSubscribe(newValue, contextItem, ownerSupport) {\n    const resultNum = checkStillSubscription(newValue, // subValue,\n    contextItem, ownerSupport);\n    if (contextItem.hasEmitted !== true) {\n        const Observables = contextItem.value.Observables;\n        if (!Observables) {\n            return;\n        }\n        const Observable = Observables[0];\n        // const subValue = Observable.value\n        if (!('value' in Observable)) {\n            return; // its never emitted\n        }\n    }\n    if (resultNum === 0 && newValue.callback) {\n        const subContext = contextItem.subContext;\n        emitSubContext(newValue, subContext);\n    }\n}\n//# sourceMappingURL=processUpdateSubscribe.function.js.map","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { deleteSubContext } from './deleteContextSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { processUpdateSubscribe } from './processUpdateSubscribe.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nexport function setupSubscribe(value, contextItem, ownerSupport, insertBeforeOriginal, // optional but will always be made\nappendTo) {\n    const observables = value.Observables;\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    let onOutput = function onSubValue(value, syncRun, subContext) {\n        onFirstSubContext(value, subContext, ownerSupport, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = subContext.tagJsVar.onOutput = function subscriptionUpdate(updateValue, syncRun, subContext) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport);\n            aContext.tagJsVar.processUpdate(updateValue, aContext, ownerSupport, [updateValue]);\n            // processUpdateContext(ownerSupport)\n            aContext.value = updateValue;\n            checkToPaint(syncRun);\n        };\n    };\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, (value, syncRun, subContext) => onOutput(value, syncRun, subContext), value, contextItem);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    value.processUpdate = processUpdateSubscribe;\n    value.onOutput = onOutput;\n    return subContext;\n}\n/** After calling this function you need to set `contextItem.subContext = subContext` */\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\nonOutput, tagJsVar, contextItem) {\n    // const component = getSupportWithState(ownerSupport)\n    // onValue mutates so function below calls original and mutation\n    function subValueHandler(value, index) {\n        subContext.lastValues[index] = {\n            value,\n            tagJsVar: valueToTagJsVar(value),\n            oldTagJsVar: subContext.lastValues[index]?.tagJsVar\n        };\n        valuesHandler(subContext.lastValues, index);\n    }\n    function valuesHandler(newValues, index) {\n        const newestParentTagJsVar = subContext.tagJsVar;\n        const callback = newestParentTagJsVar?.callback;\n        if (callback) {\n            setContextInCycle(contextItem);\n            const responseValue = newestParentTagJsVar.callback(...newValues.map(x => x.value));\n            onOutput(responseValue, syncRun, subContext);\n            removeContextInCycle();\n            return;\n        }\n        const newValue = newValues[index].value;\n        onOutput(newValue, syncRun, subContext);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        subValueHandler,\n        valuesHandler,\n        tagJsVar,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => subValueHandler(value, index)));\n        syncRun = false;\n    });\n    tagJsVar.onOutput = onOutput;\n    return subContext;\n}\nexport function unsubscribeContext(contextItem) {\n    const subscription = contextItem.subContext;\n    if (!subscription) {\n        return; // TODO: wonder why this happens, maybe subscription never emits?\n    }\n    const subscriptions = subscription.subscriptions;\n    subscriptions.forEach(sub => sub.unsubscribe());\n    delete contextItem.subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subContext = contextItem.subContext;\n    unsubscribeContext(contextItem);\n    return deleteSubContext(subContext, ownerSupport);\n}\nexport function checkToPaint(syncRun) {\n    if (syncRun) {\n        return;\n    }\n    if (setUseMemory.stateConfig.support) {\n        return;\n    }\n    paint();\n}\n//# sourceMappingURL=setupSubscribe.function.js.map","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n//# sourceMappingURL=ValueSubject.js.map","import { ValueSubject } from '../subject/index.js';\nimport { tag } from '../tag/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback).pastResult;\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup).pastResult;\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const isFun = typeof (currentValues) === 'function';\n    const realValues = isFun ? currentValues() : currentValues;\n    const isFirstRender = previous.values === undefined;\n    let renderCount = 0;\n    if (isFirstRender) {\n        if (typeof (currentValues) === 'function') {\n            tag.onRender(() => {\n                ++renderCount;\n                if (renderCount === 1) {\n                    return; // first run is already performed\n                }\n                const realValues = currentValues();\n                processRealValues(realValues);\n            });\n        }\n    }\n    function processRealValues(realValues) {\n        // First time running watch?\n        if (previous.values === undefined) {\n            if (before && !before(realValues)) {\n                previous.values = realValues;\n                return previous; // do not continue\n            }\n            const castedInit = init || callback;\n            const result = castedInit(realValues, previous.values);\n            previous.pastResult = final(result);\n            previous.values = realValues;\n            return previous;\n        }\n        const allExact = realValues.every((item, index) => item === previous.values[index]);\n        if (allExact) {\n            return previous;\n        }\n        if (before && !before(realValues)) {\n            previous.values = realValues;\n            return previous; // do not continue\n        }\n        const result = callback(realValues, previous.values);\n        previous.pastResult = final(result);\n        previous.values.length = 0;\n        previous.values.push(...realValues);\n        return previous;\n    }\n    return processRealValues(realValues);\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => {\n                return new ValueSubject(undefined);\n            });\n            const oldState = state(() => ({\n                state: setUseMemory.stateConfig.state,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                const handler = (realValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(realValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.state;\n                        const context = firstSupport.context;\n                        const stateMeta = context.state;\n                        const oldestStateSupport = stateMeta.older;\n                        if (oldestStateSupport) {\n                            const oldestState = oldestStateSupport.state;\n                            const newStates = oldState.states;\n                            const oldStates = oldestStateSupport.states;\n                            oldSyncStates(newestState, oldestState, newStates, oldStates);\n                        }\n                    }\n                    subject.next(setTo);\n                };\n                setupWatch(currentValues, handler, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n//# sourceMappingURL=watch.function.js.map","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            state: setUseMemory.stateConfig.state,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            const context = nowSupport.context;\n            const stateMeta = context.state;\n            const newer = stateMeta.newer;\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        state: setUseMemory.stateConfig.state,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        const context = nowSupport.context;\n        const stateMeta = context.state;\n        const newer = stateMeta.newer;\n        if (newer) {\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n        }\n        return x;\n    });\n}\nsubject.all = all;\n//# sourceMappingURL=subject.function.js.map","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n//# sourceMappingURL=errors.js.map","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nimport { findStateSupportUpContext } from '../interpolations/attributes/getSupportWithState.function.js';\nexport default function callbackStateUpdate(context, _oldStates, callback, ...args) {\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    const newestSupport = findStateSupportUpContext(context);\n    // TODO: This if may not be ever doing anything\n    if (!newestSupport) {\n        return maybePromise;\n    }\n    // context.global && \n    if (newestSupport.context.global) {\n        renderSupport(newestSupport); // TODO: remove with html.dom(allStrings.allStrings127712[0])\n    }\n    else {\n        const supContext = newestSupport.context;\n        supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n        []);\n    }\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            if (context.global) {\n                renderSupport(newestSupport); // TODO: remove\n            }\n            else {\n                const supContext = newestSupport.context;\n                supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n                []);\n            }\n        });\n    }\n    return maybePromise;\n}\n//# sourceMappingURL=callbackStateUpdate.function.js.map\n// @ts-ignore\nconst allStrings = {allStrings127712:[[]]}","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { paint } from '../tag/index.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const context = getContextInCycle();\n    const callbackState = state({\n        callback,\n    });\n    // ensure only one trigger instance created and always returned\n    const callbackTrigger = state(() => createTrigger(context, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callbackState));\n    // always update callback to latest in cycle\n    callbackState.callback = callback;\n    return callbackTrigger;\n}\nexport function createTrigger(context, oldState, callbackState) {\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        // ++painting.locks\n        const result = callbackStateUpdate(context, oldStates, callbackState.callback, ...args);\n        // --painting.locks\n        paint();\n        return result;\n    };\n}\n//# sourceMappingURL=callback.function.js.map","import { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport const callbackMaker = () => {\n    const context = getContextInCycle();\n    // const support = getSupportInCycle()\n    // callback as typeof innerCallback\n    if (!context) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(context, oldState, { callback });\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n//# sourceMappingURL=callbackMaker.function.js.map","import { setUseMemory } from '../../state/index.js';\nexport function getContextInCycle() {\n    return setUseMemory.stateConfig.context;\n}\n/** Gets the current element associated with taggedjs document processing */\nexport function getElement() {\n    const context = getContextInCycle();\n    return context.element;\n}\n// const contextCycles: ContextItem[] = []\nexport function setContextInCycle(context) {\n    // contextCycles.push(context)\n    return setUseMemory.stateConfig.context = context;\n}\nexport function removeContextInCycle() {\n    // contextCycles.pop()\n    delete setUseMemory.stateConfig.context;\n}\n//# sourceMappingURL=setContextInCycle.function.js.map","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nimport { processReplacementComponent } from '../tag/update/processFirstSubjectComponent.function.js';\nexport function registerTagElement(support, element, global, // TODO: remove\ntemplater, app, placeholder) {\n    const context = support.context;\n    context.state.oldest = support;\n    context.state.newest = support;\n    // Copy newer to older when resetting\n    context.state.older = context.state.newer;\n    // TODO: WORKING HERE to implement higher level tagElement using mock elements\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        context.contexts = context.contexts || [];\n        const newFragment = document.createDocumentFragment();\n        newFragment.appendChild(placeholder);\n        void processReplacementComponent(support.templater, context, support);\n        return newFragment;\n    }\n    // console.debug(' Building element into tag...', {element, app, support})\n    const result = buildBeforeElement(support, element, undefined);\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    return putDownTagDom(placeholder, result);\n}\nfunction putDownTagDom(placeholder, result) {\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    // console.debug(' Element Tag DOM built ')\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n//# sourceMappingURL=registerNewTagElement.function.js.map","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    // Initialize older/newer with empty state if first render\n    if (!subject.state.oldest) {\n        subject.state.oldest = newSupport;\n        subject.state.older = subject.state.newer;\n    }\n    subject.state.newest = newSupport;\n    return newSupport;\n}\n//# sourceMappingURL=loadNewBaseSupport.function.js.map","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterSupportRender } from './runAfterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reStateSupport } from '../state/reState.function.js';\nexport function renderTagElement(app, global, templater, templater2, element, context, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    context.placeholder = placeholder;\n    const support = runWrapper(templater, placeholder, element, context, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = context.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        context.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const oldest = subject.state.oldest;\n    const newest = subject.state.newest;\n    const isFirstRender = newest === oldest;\n    const newSupport = createSupport(templater, newest, newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        const olderStateContext = subject.state.older;\n        reStateSupport(newSupport, newest, olderStateContext.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n        // removeContextInCycle()\n        return result;\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    // this will call removeContextInCycle()\n    runAfterSupportRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterSupportRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterSupportRender(newSupport);\n    return newSupport;\n}\n//# sourceMappingURL=renderTagElement.function.js.map","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { setSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\nimport { removeContextInCycle } from './cycles/setContextInCycle.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    const newest = subject.state.newest;\n    initState(newest.context);\n    setSupportInCycle(newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            subject.state.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const result = renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n    removeContextInCycle();\n    return result;\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        processInitAttribute: blankHandler,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const context = {\n        updateCount: 0,\n        value: templater,\n        valueIndex: 0,\n        varCounter: 0,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        state: {},\n        // parentContext: undefined as any,\n        tagJsVar,\n    };\n    // sets new global on context\n    getNewGlobal(context);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    context.events = {};\n    loadNewBaseSupport(templater, context, appElement);\n    return context;\n}\n//# sourceMappingURL=tagElement.js.map","import { isFunction, isObject } from '../index.js';\nimport { setBooleanAttribute, setNonFunctionInputValue, setSimpleAttribute } from '../interpolations/attributes/howToSetInputValue.function.js';\nimport { getPushKid } from './designElement.function.js';\nfunction callbackWrapper(item, eventName, callback) {\n    const clone = getPushKid(item, item.elementFunctions);\n    return callbackWrapper2(clone, eventName, callback);\n}\nfunction callbackWrapper2(item, eventName, callback) {\n    function wrapCallback(e) {\n        return wrapCallback.toCallback(e);\n    }\n    wrapCallback.toCallback = callback;\n    item.listeners.push([eventName, wrapCallback]);\n    item.allListeners.push([eventName, wrapCallback]);\n    return item;\n}\nfunction attr(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    clone.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsVar\n    }\n    return clone;\n}\nfunction attr2(item, args) {\n    // const clone = getPushKid(item as any, item.elementFunctions)\n    // clone.attributes.push(args as Attribute)\n    item.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], item); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], item); // the attrValue is a function or TagJsVar\n    }\n    return item;\n}\nexport function elementFunctions(item) {\n    /** Used for all element callbacks */\n    function makeCallback(eventName) {\n        return function (callback) {\n            return callbackWrapper(item, eventName, callback);\n        };\n    }\n    // TODO: This maybe the old way of doing things (see callables)\n    const callables_other = {\n        // ...eventCallables,\n        onClose: makeCallback('onclose'),\n        onDoubleClick: makeCallback('ondblclick'),\n        onClick: makeCallback('click'),\n        // onclick: makeCallback('click'),\n        // click: makeCallback('click'),\n        onBlur: makeCallback('onblur'),\n        onChange: makeCallback('onchange'),\n        // onchange: makeCallback('onchange'),\n        // change: makeCallback('onchange'),\n        onMousedown: makeCallback('onmousedown'),\n        onMouseup: makeCallback('onmouseup'),\n        onKeydown: makeCallback('onkeydown'),\n        onKeyup: makeCallback('onkeyup'),\n        // onkeyup: makeCallback('onkeyup'),\n        // keyup: makeCallback('onkeyup'),\n        /* apply attribute via attr(name: string, value?: any): **/\n        attr: (...args) => attr(item, args),\n        /** Used for setting array index-key value */\n        key: function (arrayValue) {\n            ;\n            this.arrayValue = arrayValue;\n            return this;\n        },\n    };\n    return callables_other;\n}\nfunction setClassValue(element, name, value) {\n    if (isObject(value)) {\n        Object.entries(value).forEach(([name, value]) => {\n            if (value) {\n                element.classList.add(name);\n            }\n            else {\n                element.classList.remove(name);\n            }\n        });\n        return; // howToSetInputObjectValue(element, name, value as Record<string, any>)\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used during updates */\nexport function registerMockAttrContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\nexport function isValueForContext(value) {\n    return Array.isArray(value) || isFunction(value) || value?.tagJsType;\n}\nfunction setupAttr(attrName, howToSet) {\n    return (item, value) => attr2(item, [attrName, value, false, howToSet]);\n}\nfunction makeCallback(eventName) {\n    return (item, callback) => {\n        return callbackWrapper2(item, eventName, callback);\n    };\n}\nconst eventCallables = {\n    onClose: makeCallback('onclose'),\n    onClick: makeCallback('click'),\n    onDoubleClick: makeCallback('ondblclick'),\n    onDblClick: makeCallback('ondblclick'),\n    onBlur: makeCallback('onblur'),\n    onChange: makeCallback('onchange'),\n    onMousedown: makeCallback('onmousedown'),\n    onMouseDown: makeCallback('onmousedown'),\n    onMouseup: makeCallback('onmouseup'),\n    onMouseUp: makeCallback('onmouseup'),\n    onKeyup: makeCallback('onkeyup'),\n    onKeyUp: makeCallback('onkeyup'),\n    onKeydown: makeCallback('onkeydown'),\n    onKeyDown: makeCallback('onkeydown'),\n};\nconst callables = {\n    checked: setupAttr('checked', setBooleanAttribute),\n    selected: setupAttr('selected', setBooleanAttribute),\n    /** element.setAttribute('style', x)  */\n    class: setupAttr('class', setClassValue),\n    ...eventCallables\n};\nexport function loopObjectAttributes(item, object) {\n    const result = Object.entries(object).reduce((all, [name, value]) => {\n        if (name in callables) {\n            return callables[name](item, value);\n        }\n        return attr2(item, [name, value, false, setNonFunctionInputValue]);\n    }, item);\n    return result;\n}\n//# sourceMappingURL=elementFunctions.js.map","import { isPromise } from '../index.js';\nimport { paint, painting } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\nimport { destroyContextHtml } from '../tag/smartRemoveKids.function.js';\nexport function destroyDesignElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            context.deleted = true;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                // destroyContextHtml(context)\n                destroyHtmlDomMeta(htmlDomMeta);\n                // delete context.htmlDomMeta\n                context.htmlDomMeta = [];\n                // context.deleted = true\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n    destroyContextHtml(context);\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    // context.deleted = true\n    delete context.contexts;\n    context.deleted = true;\n}\nexport function destroyDesignByContexts(contexts, ownerSupport, promises) {\n    const context = contexts[0];\n    const result = context.tagJsVar.destroy(context, ownerSupport);\n    context.deleted = true;\n    if (isPromise(result)) {\n        return promises.push(result.then(() => {\n            if (contexts.length > 1) {\n                return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n            }\n        }));\n    }\n    if (context.htmlDomMeta) {\n        destroyContextHtml(context);\n        delete context.htmlDomMeta;\n    }\n    if (contexts.length > 1) {\n        return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n    }\n}\n//# sourceMappingURL=destroyDesignElement.function.js.map","import { updateToDiffValue } from '../tag/update/updateToDiffValue.function.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nexport function processDesignElementUpdate(value, context, ownerSupport) {\n    const skip = context.locked || context.deleted === true;\n    if (skip) {\n        return; // something else is running an event\n    }\n    ++context.updateCount;\n    const hasChanged = checkTagElementValueChange(value, context);\n    if (hasChanged) {\n        destroyDesignElement(context, ownerSupport);\n        // delete context.htmlDomMeta // The next value needs to know its not been deleted\n        context.htmlDomMeta = []; // The next value needs to know its not been deleted\n        // context.deleted = true // its not deleted but changed\n        delete context.deleted; // its not deleted but changed\n        updateToDiffValue(value, context, // newContext,\n        ownerSupport, 789);\n        return;\n    }\n    const contexts = context.contexts;\n    const vContexts = value.contexts || [];\n    const ogListeners = context.tagJsVar.allListeners;\n    const allListeners = value.allListeners;\n    allListeners.forEach((newListener, index) => {\n        // ensure the latest callback is always called. Needed for functions within array maps\n        const wrapCallback = ogListeners[index][1];\n        wrapCallback.toCallback = newListener[1].toCallback;\n    });\n    if (contexts.length !== vContexts.length) {\n        console.info('context mismatch', {\n            value,\n            context,\n            conValues: contexts.map(x => x.value),\n            vContexts,\n            deleted: context.deleted\n        });\n        throw new Error('super issue discovered');\n    }\n    context.locked = 79;\n    contexts.forEach((context, index) => {\n        context.tagJsVar.processUpdate(vContexts[index], // context.value,\n        context, ownerSupport);\n    });\n    delete context.locked;\n}\nexport function checkTagElementValueChange(value, context) {\n    const oldValue = context.value;\n    if (oldValue === value) {\n        return 0; // has not changed\n    }\n    // return 1 // it has changed\n    const notElement = !value || value.tagJsType !== 'element';\n    if (notElement) {\n        return 1;\n    }\n    const newKidLength = value.innerHTML.length;\n    const oldKidLength = context.value.innerHTML.length;\n    const kidLengthChanged = newKidLength !== oldKidLength;\n    if (kidLengthChanged) {\n        return 1;\n    }\n    const newAttrLength = value.attributes.length;\n    const oldAttrLength = context.value.attributes.length;\n    const kidAttrChanged = newAttrLength !== oldAttrLength;\n    if (kidAttrChanged) {\n        return 1;\n    }\n    return 0;\n}\n//# sourceMappingURL=processDesignElementUpdate.function.js.map","import { castTextValue } from '../castTextValue.function.js';\nimport { getNewContext } from '../render/addOneContext.function.js';\nimport { paintCommands } from '../render/paint.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nimport { processElementVarFunction } from './processElementVarFunction.function.js';\nexport function processChildren(innerHTML, parentContext, ownerSupport, element, // appendTo\npaintBy) {\n    innerHTML.forEach(item => {\n        const type = typeof item;\n        switch (type) {\n            case 'string':\n            case 'boolean':\n            case 'number':\n                return handleSimpleInnerValue(item, element, paintBy);\n        }\n        if (item === null || item === undefined) {\n            return handleSimpleInnerValue(item, element, paintBy);\n        }\n        if (item.tagJsType === 'element') {\n            const newElement = processElementVar(item, parentContext, ownerSupport, parentContext.contexts);\n            paintCommands.push([paintBy, [element, newElement]]);\n            const htmlDomMeta = parentContext.htmlDomMeta;\n            htmlDomMeta.push({\n                nn: newElement.tagName,\n                domElement: newElement,\n                // at: newElement.attributes,\n                at: [],\n            });\n            return;\n        }\n        if (type === 'function') {\n            const beforeCount = parentContext.contexts?.length;\n            const result = processElementVarFunction(item, element, parentContext, ownerSupport, paintBy);\n            return result;\n        }\n        return processNonElement(item, parentContext, element, ownerSupport, paintBy);\n    });\n}\n/** used when a child is not another element and requires init processing */\nexport function processNonElement(item, parentContext, element, ownerSupport, paintBy) {\n    const newContext = getNewContext(item, [], // addedContexts\n    true, parentContext);\n    const contexts = parentContext.contexts;\n    contexts.push(newContext);\n    newContext.element = element;\n    newContext.placeholder = document.createTextNode('');\n    paintCommands.push([paintBy, [element, newContext.placeholder]]);\n    setContextInCycle(newContext);\n    newContext.tagJsVar.processInit(item, newContext, // context, // newContext,\n    ownerSupport, newContext.placeholder);\n    removeContextInCycle();\n    return newContext;\n}\nexport function handleSimpleInnerValue(value, element, paintBy) {\n    const castedValue = castTextValue(value);\n    const text = document.createTextNode(castedValue);\n    paintCommands.push([paintBy, [element, text]]);\n    return text;\n}\n//# sourceMappingURL=processChildren.function.js.map","import { isFunction, Subject } from '../index.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processNonElement } from './processChildren.function.js';\nexport function processElementVarFunction(item, element, parentContext, ownerSupport, paintBy) {\n    const subContexts = [];\n    const subContext = {\n        updateCount: 0,\n        parentContext,\n        contexts: subContexts,\n        element: element,\n        value: item,\n        htmlDomMeta: [],\n        tagJsVar: {\n            tagJsType: 'dynamic-text',\n            hasValueChanged: () => 0,\n            processInit: blankHandler,\n            processInitAttribute: blankHandler,\n            destroy: (_c, ownerSupport) => {\n                ++subContext.updateCount;\n                subContexts.forEach(subSub => subSub.tagJsVar.destroy(subSub, ownerSupport));\n            },\n            processUpdate: (value, contextItem, ownerSupport, values) => {\n                ++subContext.updateCount;\n                /*\n                if(typeof(value) !== 'function') {\n                  console.debug('value', {contextItem, value})\n                  throw new Error('issue of no function')\n                }*/\n                setContextInCycle(aSubContext);\n                let newValue = value(aSubContext);\n                const underFunction = subContext.underFunction;\n                delete subContext.underFunction;\n                if (newValue instanceof Function && !newValue.tagJsType) {\n                    if (underFunction && newValue.toString() === underFunction.toString()) {\n                        newValue = aSubContext.value;\n                    }\n                    else {\n                        subContext.underFunction = newValue;\n                        newValue = newValue();\n                    }\n                }\n                const result = aSubContext.tagJsVar.processUpdate(newValue, aSubContext, ownerSupport, values);\n                aSubContext.value = newValue;\n                contextItem.value = value;\n                removeContextInCycle();\n                return result;\n            }\n        },\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    // addedContexts.push(subContext)\n    setContextInCycle(subContext);\n    let trueValue = item();\n    const isAgainFunc = isFunction(trueValue) && !trueValue.tagJsType;\n    if (isAgainFunc) {\n        ;\n        subContext.underFunction = trueValue;\n        trueValue = trueValue(); // function returns function\n    }\n    const aSubContext = processNonElement(trueValue, subContext, // parentContext,\n    element, ownerSupport, paintBy);\n    const contexts = parentContext.contexts;\n    contexts.push(subContext);\n    removeContextInCycle();\n    return aSubContext;\n}\n//# sourceMappingURL=processElementVarFunction.function.js.map","import { isPromise } from '../index.js';\nimport { addSupportEventListener } from '../interpolations/attributes/addSupportEventListener.function.js';\nimport { afterTagCallback } from '../interpolations/attributes/bindSubjectCallback.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nimport { isSpecialAttr } from '../interpolations/attributes/isSpecialAttribute.function.js';\nimport { renderTagUpdateArray } from '../interpolations/attributes/renderTagArray.function.js';\nimport { processAttributeArray } from '../render/dom/processAttributeArray.function.js';\nimport { paint, paintAppend, painting } from '../render/paint.function.js';\nimport { processChildren } from './processChildren.function.js';\n/** The first and recursive processor for elements */\nexport function processElementVar(value, context, ownerSupport, addedContexts) {\n    const element = document.createElement(value.tagName);\n    context.element = element;\n    // mark special attributes\n    value.attributes.forEach(x => {\n        const name = x[0];\n        if (typeof (name) !== 'string') {\n            return;\n        }\n        x[2] = isSpecialAttr(name);\n    });\n    processAttributeArray(value.attributes, [], // values,\n    element, ownerSupport, context);\n    /*\n    value.listeners.forEach((listener, index) =>\n      registerListener(value, index, ownerSupport, listener, element)\n    )*/\n    processChildren(value.innerHTML, context, // parentContext\n    ownerSupport, element, paintAppend);\n    value.listeners.forEach((listener, index) => registerListener(value, index, ownerSupport, listener, element));\n    return element;\n}\nfunction registerListener(value, index, ownerSupport, listener, element) {\n    const wrap = (...args) => {\n        const listenScope = value.listeners[index];\n        const toCall = listenScope[1];\n        const stateSupport = getSupportWithState(ownerSupport);\n        const updateCount = stateSupport.context.updateCount;\n        stateSupport.context.locked = 1;\n        ++painting.locks;\n        const result = toCall(...args);\n        --painting.locks;\n        delete stateSupport.context.locked;\n        const needsRender = updateCount === stateSupport.context.updateCount;\n        if (needsRender) {\n            return afterTagCallback(result, stateSupport);\n        }\n        else {\n            paint();\n        }\n        if (isPromise(result)) {\n            return result.then(() => {\n                const newest = stateSupport.context.state.newest;\n                renderTagUpdateArray([newest]);\n                return 'promise-no-data-ever';\n            });\n        }\n        return 'no-data-ever';\n    };\n    addSupportEventListener(ownerSupport.appSupport, listener[0], // eventName\n    element, wrap);\n}\n//# sourceMappingURL=processElementVar.function.js.map","import { paintBefore, paintCommands } from '../render/paint.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nexport function processDesignElementInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    // prevent children from calling a parent function and causing a mid render\n    context.locked = 34;\n    const element = processElementVar(value, context, ownerSupport, context.contexts);\n    delete context.locked;\n    paintCommands.push([paintBefore, [insertBefore, element, 'designElement.processInit']]);\n    const dom = {\n        nn: value.tagName,\n        domElement: element,\n        at: value.attributes, // TODO: most likely does nothing\n    };\n    context.htmlDomMeta = [dom];\n    return element;\n}\n//# sourceMappingURL=processDesignElementInit.function.js.map","import { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions, isValueForContext, loopObjectAttributes } from './elementFunctions.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processDesignElementInit } from './processDesignElementInit.function.js';\nexport function designElement(tagName) {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler,\n        processInit: processDesignElementInit,\n        destroy: destroyDesignElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName,\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = tagName;\n    return pushKid;\n}\nexport function getPushKid(element, _elmFunctions) {\n    const pushKid = (...args) => {\n        const newElement = { ...pushKid };\n        newElement.attributes = [...pushKid.attributes];\n        newElement.listeners = [...pushKid.listeners];\n        newElement.allListeners = [...pushKid.allListeners];\n        if (args.length > 0 &&\n            typeof args[0] === 'object' &&\n            !Array.isArray(args[0]) &&\n            !args[0].tagJsType // TODO: need better attribute detection\n        ) {\n            loopObjectAttributes(newElement, args[0]);\n            args.splice(0, 1);\n        }\n        newElement.innerHTML = args;\n        // review each child for potential to be context\n        args.forEach(arg => {\n            if (!isValueForContext(arg)) {\n                return;\n            }\n            if (arg.tagJsType === 'element') {\n                newElement.allListeners.push(...arg.allListeners);\n                if (arg.contexts) {\n                    // the argument is an element so push up its contexts into mine\n                    if (!newElement.contexts) {\n                        // newElement.contexts = [...arg.contexts]\n                        newElement.contexts = arg.contexts;\n                    }\n                    else {\n                        newElement.contexts.push(...arg.contexts);\n                    }\n                }\n                return;\n            }\n            registerMockChildContext(arg, newElement);\n        });\n        return newElement;\n    };\n    Object.assign(pushKid, element);\n    Object.assign(pushKid, elementFunctions(pushKid));\n    pushKid.attributes = [...element.attributes];\n    pushKid.listeners = [...element.listeners];\n    pushKid.allListeners = [...element.allListeners];\n    return pushKid;\n}\n/** used during updates */\nfunction registerMockChildContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\n//# sourceMappingURL=designElement.function.js.map","import { paint, paintBefore, painting } from '../render/paint.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions } from './elementFunctions.js';\nimport { destroyDesignByContexts } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processChildren } from './processChildren.function.js';\nimport { getPushKid } from './designElement.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\n/** used when you do NOT have a root element returned for your function */\nexport const noElement = noElementMaker();\nexport function noElementMaker() {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler, // its never an attribute\n        processInit: processNoElmInit,\n        destroy: destroyNoElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName: 'no-element',\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = 'no-element';\n    return pushKid;\n}\nfunction processNoElmInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    processChildren(value.innerHTML, context, ownerSupport, insertBefore, paintBefore);\n}\nfunction destroyNoElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                destroyHtmlDomMeta(htmlDomMeta);\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n}\n//# sourceMappingURL=noElement.function.js.map","import { designElement } from './designElement.function.js';\nexport { noElement } from './noElement.function.js';\nexport const button = designElement('button');\nexport const select = designElement('select');\nexport const option = designElement('option');\nexport const input = designElement('input');\nexport const textarea = designElement('textarea');\n// HEAD & SUPPORT ELEMENTS\nexport const htmlDoc = designElement('html'); // TODO: get this named to html\nexport const head = designElement('head');\nexport const title = designElement('title');\nexport const meta = designElement('meta');\nexport const link = designElement('link');\nexport const style = designElement('style');\nexport const body = designElement('body');\nexport const noscript = designElement('noscript');\n// BLOCK ELEMENTS\nexport const hr = designElement('hr');\nexport const h1 = designElement('h1');\nexport const h2 = designElement('h2');\nexport const h3 = designElement('h3');\nexport const h4 = designElement('h4');\nexport const h5 = designElement('h5');\nexport const h6 = designElement('h6');\nexport const ol = designElement('ol');\nexport const ul = designElement('ul');\nexport const li = designElement('li');\nexport const div = designElement('div');\nexport const main = designElement('main');\nexport const section = designElement('section');\nexport const header = designElement('header');\nexport const footer = designElement('footer');\nexport const fieldset = designElement('fieldset');\nexport const legend = designElement('legend');\nexport const dialog = designElement('dialog');\nexport const pre = designElement('pre');\n// TABLE ELEMENTS\nexport const table = designElement('table');\nexport const tr = designElement('tr');\nexport const td = designElement('td');\nexport const th = designElement('th');\nexport const thead = designElement('thead');\nexport const tbody = designElement('tbody');\nexport const tfoot = designElement('tfoot');\n// INLINE ELEMENTS\nexport const a = designElement('a');\nexport const br = designElement('br');\nexport const label = designElement('label');\nexport const p = designElement('p');\nexport const small = designElement('small');\nexport const span = designElement('span');\nexport const strong = designElement('strong');\nexport const b = designElement('b');\nexport const sup = designElement('sup');\n//# sourceMappingURL=index.js.map","import { li, div, input, label, button, tag } from 'taggedjs';\n// Performance boost to not render if props non-mutating props did not change\nexport const Item = tag((todo, dispatch, index) => {\n    Item.updates(x => [todo, dispatch, index] = x);\n    let editing = false;\n    return li({\n        'class.completed': _ => todo.completed,\n        'class.editing': _ => editing\n    }, _ => !editing ?\n        div({ class: \"view\" }, input({\n            class: \"toggle\",\n            type: \"checkbox\",\n            checked: _ => todo.completed,\n            onChange: () => dispatch.toggleItem(todo, index)\n        }), label({\n            'data-testid': \"todo-item-label\",\n            onDblClick: () => {\n                editing = !editing;\n            }\n        }, _ => todo.title), button({\n            class: \"destroy\",\n            onClick: () => dispatch.removeItemByIndex(index)\n        }))\n        :\n            div({ class: \"input-container\" }, input({\n                id: \"edit-todo-input\",\n                type: \"text\",\n                autoFocus: true,\n                class: \"edit\",\n                value: _ => todo.title,\n                onBlur: () => editing = false,\n                onKeyDown: e => handleKey(e, title => {\n                    handleUpdate(title, todo, index, dispatch);\n                    editing = false;\n                })\n            }), label({ class: \"visually-hidden\", htmlFor: \"todo-input\" }, 'Edit Todo Input')));\n});\nfunction handleUpdate(title, todo, index, dispatch) {\n    if (title.length === 0) {\n        dispatch.removeItem(todo.id);\n        return;\n    }\n    dispatch.updateToByIndex(todo, { title }, index);\n}\nexport function handleKey(e, onValid) {\n    if (e.key === \"Enter\") {\n        const value = e.target.value.trim();\n        onValid(value);\n        return true;\n    }\n}\n;\n","import { callback, onDestroy, state } from \"taggedjs\";\nconst getHash = () => window.location.hash.substring(1) || '/';\nconst HashRouter = () => {\n    const memory = { route: getHash() };\n    const onHashChange = callback(() => memory.route = getHash());\n    window.addEventListener('hashchange', onHashChange);\n    return { memory, onHashChange };\n};\nexport const useHashRouter = () => {\n    const { memory, onHashChange } = state(() => HashRouter());\n    onDestroy(() => window.removeEventListener('hashchange', onHashChange));\n    return memory;\n};\n","import { Header } from './tags/header.tag';\nimport { Footer } from './tags/footer.tag';\nimport { todoReducer } from './reducer';\nimport { a, div, input, label, main, noElement, section, tag, ul } from 'taggedjs';\nimport { useHashRouter } from './HashRouter.function';\nimport { Item } from './tags/item.tag';\nexport const todos = [];\nconst dispatch = todoReducer(todos);\nexport const app = () => {\n    const router = useHashRouter();\n    return noElement(_ => router.route === '/info' ? infoTag() : todosTag(router.route), div({ style: 'text-align:center;' }, a({ href: \"#/info\" }, 'info'), '   ', a({ href: \"#/\" }, 'todo app')));\n};\nconst infoTag = () => div({ style: \"margin:2rem;padding:2rem;background-color:white;\" }, ' A work in progress to demonstrate the capabilities of TaggedJs');\nconst todosTag = tag((route) => {\n    let isActiveRoute = route === \"/active\";\n    let isCompletedRoute = route === \"/completed\";\n    const getVisibleTodos = () => {\n        if (isActiveRoute)\n            return todos.filter(todo => !todo.completed);\n        if (isCompletedRoute)\n            return todos.filter(todo => todo.completed);\n        return todos;\n    };\n    const getActiveTodoCount = () => todos.filter((todo) => !todo.completed).length;\n    todosTag.updates(x => {\n        [route] = x;\n        isActiveRoute = route === \"/active\";\n        isCompletedRoute = route === \"/completed\";\n        visibleTodos = getVisibleTodos();\n        activeTodoCount = getActiveTodoCount();\n    });\n    let activeTodoCount = getActiveTodoCount();\n    let visibleTodos = getVisibleTodos();\n    return section({ class: \"todoapp\" }, Header(dispatch), \n    // div('todoCount:', _=> todos.length),\n    main({ class: \"main\" }, _ => todos.length > 0 &&\n        div({ class: \"toggle-all-container\" }, input({\n            id: \"toggle-all\",\n            class: \"toggle-all\",\n            type: \"checkbox\",\n            checked: _ => activeTodoCount < 1,\n            onChange: e => dispatch.toggleAll(e.target.checked),\n        }), label({ class: \"toggle-all-label\", for: \"toggle-all\" }, 'Toggle All Input')), ul({ class: \"todo-list show-priority\" }, _ => visibleTodos.map((todo, index) => Item(todo, dispatch, index).key(todo.id)))), _ => Footer(todos.length, dispatch.removeCompleted, route, activeTodoCount));\n});\n","function uuid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        var r = (Math.random() * 16) | 0, v = c === \"x\" ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nexport function todoReducer(todos) {\n    function addItem(title) {\n        todos.push({ id: uuid(), title, completed: false });\n        return todos;\n    }\n    function removeItem(id) {\n        return todos.filter((t) => t.id !== id);\n    }\n    function removeItemByIndex(index) {\n        todos.splice(index, 1);\n        return todos;\n    }\n    function toggleItem(todo, index) {\n        return updateToByIndex(todo, { completed: !todo.completed }, index);\n    }\n    function removeAll() {\n        todos = [];\n        return todos;\n    }\n    function toggleAll(completed) {\n        for (let index = todos.length - 1; index >= 0; --index) {\n            todos[index] = {\n                ...todos[index],\n                completed,\n            };\n        }\n        return todos;\n    }\n    function removeCompleted() {\n        for (let index = todos.length - 1; index >= 0; --index) {\n            if (todos[index].completed) {\n                todos.splice(index, 1);\n            }\n        }\n        return todos;\n    }\n    function updateToByIndex(todo, partial, index) {\n        todos[index] = { ...todo, ...partial };\n        return todos;\n    }\n    return {\n        addItem,\n        removeItem,\n        toggleItem,\n        removeAll,\n        toggleAll,\n        removeCompleted,\n        removeItemByIndex,\n        completeItem: function completeItem(todo, index) {\n            return updateToByIndex(todo, { completed: true }, index);\n        },\n        updateItemByIndex: function updateItemByIndex(todo, index) {\n            todos[index] = { ...todo };\n            return todos;\n        },\n        updateToByIndex,\n    };\n}\n;\n","import { header, h1, input } from 'taggedjs';\nimport { handleKey } from './item.tag';\nexport const Header = (dispatch) => header({ class: \"header\", 'data-testid': \"header\" }, h1('src todos'), input({\n    autoFocus: true,\n    class: \"new-todo\",\n    placeholder: \"What needs to be done?\",\n    onKeydown: e => {\n        const enter = handleKey(e, title => dispatch.addItem(title));\n        if (enter) {\n            e.target.value = \"\";\n        }\n    }\n}));\n","/* TODO: Not sure this file is even in use */\nimport { footer, p, div, span, ul, li, a, button } from 'taggedjs';\n// Performance boost to not render if props non-mutating props did not change\nexport const Footer = (todosCount, removeCompleted, route, activeTodoCount) => {\n    return footer({ class: \"footer\", 'data-testid': \"footer\" }, p('Double-click to edit a todo'), div(span({ class: \"todo-count\" }, _ => activeTodoCount, ' item', _ => activeTodoCount > 1 && \"s\", ' left!'), ul({ class: \"filters\" }, li(a({ class: _ => route === \"/\" ? \"selected\" : \"\", href: \"#/\" }, 'All')), li(a({ class: _ => route === \"/active\" ? \"selected\" : \"\", href: \"#/active\" }, 'Active')), li(a({ class: _ => route === \"/completed\" ? \"selected\" : \"\", href: \"#/completed\" }, 'Completed'))), _ => (todosCount - activeTodoCount) > 0 &&\n        button({\n            class: \"clear-completed\",\n            onClick: () => removeCompleted()\n        }, 'Clear completed')));\n};\n","import { tagElement } from \"taggedjs\";\nimport { app } from './app.tag';\nexport default function run() {\n    tagElement(app, document.getElementsByTagName('app')[0]);\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","stateConfig","support","setSupportInCycle","setContextInCycle","context","paintCommands","paintRemoves","paintAppends","paintAfters","painting","locks","removeLocks","setContent","text","textNode","textContent","paint","removes","length","content","runPaintRemoves","splice","runPaintCycles","nowPaintAfters","runAfterCycle","addPaintRemover","element","caller","push","paintRemover","_caller","parentNode","removeChild","paintBefore","relative","insertBefore","paintAppend","appendChild","contentCleaner","document","createElement","toPlainTextElm","innerHTML","createTextNode","paintBeforeText","callback","textElm","paintBeforeElementString","paintAppendElementString","empty","BasicTypes","ImmutableTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","isStaticTag","value","tagJsType","isTagComponent","tagType","isPromise","isFunction","then","function","object","isArray","Array","findStateSupportUpContext","stateMeta","state","newest","parentContext","getSupportWithState","component","ownerSupport","returnArgs","args","firstStatesHandler","setter","config","states","statesIndex","reStatesHandler","oldStates","prevSupport","older","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","newer","StateEchoBack","getStateValue","defaultValue","checkValue","getCallbackValue","runRestate","restate","msg","console","error","Error","initValue","original","getSubscription","subject","subscribers","countSubject","Subject","globalSubCount$","next","subscription","unsubscribe","subscriptions","index","findIndex","sub","removeSubFromArray","valSub","add","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","shift","newValue","methodResponse","setHandler","x","onSubscription","isSubject","subscribeWith","constructor","this","arguments","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","switched","map","arg","isSubjectInstance","subjects","output","valuesSeen","values","setValue","item","clones","combineLatest","static","tagClosed$","undefined","getNewGlobal","contextItem","renderCount","varCounter","global","blocked","processUpdateOneContext","deleted","valueIndex","tagJsVar","processUpdate","removeContextInCycle","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","processUpdateContext","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","cloneValueArray","cloneTagJsValue","shallowPropMatch","props","pastCloneProps","len","pastProp","obEntries","entries","subItem","objectItemMatches","name","pastValue","runBeforeDestroy","providers","provider","children","destroy$","destroyContexts","childTags","child","lastArray","childValue","destroy","iSubs","forEach","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","from","compareArrayItems","removed","newLength","at","lessLength","prevContext","destroyArrayItem","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","oldest","destroySupport","destroyArrayItemByGlobal","destroyArrayContext","updateCount","destroyArray","destroyHtmlDomMeta","htmlDomMeta","destroyClone","marker","domElement","smartRemoveKids","allPromises","withinOwnerElement","supportOwner","hostDestroy","elm","simpleValueElm","subGlobal","smartRemoveByContext","destroyContextHtml","promises","wrapper","returnValue","isLikeTags","newSupport","oldSupport","isLike","isLikeBaseTags","_innerHTML","outerHTML","templater0","templater1","newTag","oldTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","every","string","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","destroySupportByContextItem","destroySupportContext","checkTagValueChangeAndUpdate","lastSupport","tryUpdateToTag","isTag","castTextValue","isSpecialAttr","attrName","startsWith","specialAction","toLowerCase","isSpecialAction","specialAttribute","specialName","autofocus","autoselect","names","split","paintStyle","classListAdd","classListRemove","processSpecialClass","smallName","style","setProperty","classList","remove","select","focus","log","howToSetInputObjectValue","subValue","setObjectValue","setPropertyValue","howToSetStandAloneAttr","_value","setAttribute","setNonFunctionInputValue","setSimpleAttribute","setBooleanAttribute","removeAttribute","processDynamicNameValueAttribute","howToSet","isSpecial","processInitAttribute","processTagJsAttribute","processNonDynamicAttr","innerValue","tagJsVarOverride","matchesInjection","inject","subContext","hasValueChanged","_contextItem","processInit","isAttr","valueToTagJsVar","render$","processFunctionAttr","processAttributeUpdate","tagValue","newTagVar","processSimpleAttribute","_ownerSupport","deleteSimpleAttribute","checkSimpleValueChange","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkUpdateDeleteSimpleValueChange","processStringUpdate","forceUpdateExistingValue","_appendTo","castedValue","placeholder","oldClone","processUpdateRegularValue","checkArrayValueChange","tagValueUpdateHandler","domProcessContextItem","appendTo","locked","createAndProcessContextItem","getNewContext","processTagArray","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","array","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","getArrayTagVar","processArrayInit","processArrayUpdates","_insertBefore","getBasicTagVar","attachDynamicDom","depth","addOneContext","handleProviderChanges","appSupport","tagsWithProvider","memory","cSubject","getTagsWithProvider","mapToSupport","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","castProps","currentDepth","pos","checkProp","alterProp","owner","already","mem","wrap","toCall","callWith","ownerContext","noCycle","callbackResult","apply","run","callbackPropOwner","assign","getPropWrap","deepCompareDepth","isSkipPropValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","castedProps","restore","altPropRestore","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","updateExistingTagComponent","oldWrapper","newWrapper","isSameTag","skipComparing","swapTags","hasChanged","newTemplater","latestProps","propsConfig","latest","propsChanged","propWatch","hasLenChanged","hasPropLengthsChanged","PropWatches","NONE","SHALLOW","IMMUTABLE","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","compareProps","onePropCompare","deepPropChangeCompare","hasPropChanges","hasSupportChanged","renderSupport","newProps","syncFunctionProps","lastPropsConfig","syncSupports","DEEP","shallowCompareDepth","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","executeWrap","useSupport","originalFunction","stateless","runAfterSupportRender","runAfterRender","saveState","clearStateConfig","callTag","reSupport","createSupport","reStateByPrev","prevState","reStateSupport","reRenderTag","firstTagRender","renderWithSupport","toRender","olderState","getSupportOlderState","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","processTag","inlineHtml","pop","checkRenderUp","selfPropChange","nowProps","hasPropsToOwnerChanged","getUpTags","supports","isComponent","continueUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","syncStatesArray","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","checkToResolvePromise","last","resolvePromise","resolveValue","newestSupport","newestStateMeta","thenResolveBy","bindSubjectCallback","subjectFunction","bindTo","afterTagCallback","runTagCallback","tagFunction","noData","promiseNoData","bubbleEvent","event","replaceEventName","target","stopped","originalStopPropagation","stopPropagation","defaultPrevented","addSupportEventListener","eventName","appElement","getEventReferenceName","eventReg","events","listener","addEventListener","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","attrValue","processStandAloneAttribute","newContexts","processAttribute","processUpdateAttrContext","attrContextItem","oldValue","isNameOnly","standAloneResult","updateNameOnlyAttrValue","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","variablePrefix","variableSuffix","placeholderRegex","getTagVarIndex","search","createDynamicArrayAttribute","startIndex","createdContexts","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","join","newValues","getTagJsVar","attrPart","varIndex","isNameVar","valueInValues","stateOwner","oldTagJsVar","processTagJsVarAttribute","aloneResult","valueVar","createDynamicAttribute","special","paintContentPush","processAttributeArray","attrs","attr","newContext","attachDomElement","node","attachDomElements","nodes","v","isNaN","Number","realValue","newNode","nn","attachDomText","newParentContext","isAttrs","ch","tc","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","attributes","attrMatch","parseAttrString","pushTo","postProcessTagsInComments","inputString","filter","notEmptyStringMapper","part","notEmpty","noValue","lowerName","fixedName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","replacePlaceholders","valueCount","currentTail","loopTail","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","mapped","lengthMapper","lastRuns","getDomMeta","stringId","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","template","interpolation","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachHtmlDomMeta","ph","newSupportByTemplater","createHtmlSupport","processNewSubjectTag","processTagInit","getTemplaterResult","getCastedProps","preCastedProps","lastCastProps","processRenderOnceInit","oneRenderToSupport","emitSubContext","observable","Observables","hasEmitted","subValueHandler","withDefault","emitValue","_tagJsVar","unsubscribeContext","onOutput","callbackValue","syncRun","checkToPaint","setupSubscribeCallbackProcessor","contextItem2","newObserves","oldObserves","ob","handleTagTypeChangeFrom","originalType","updateToDiffValue","checkStillSubscription","valuesHandler","Observable","deleteContextSubContext","deleteSubContext","appendMarker","subContextItem","onFirstSubContext","handleInnerHTML","oldProcessInit","processInnerHTML","insertBeforeOriginal","guaranteeInsertBefore","checkInnerHTML","getInnerHTML","syncWrapCallback","newerStates","olderStates","newestOwner","c","newGlobal","options","baseHost","processHostAttribute","processHost","processHostUpdate","deleteHost","injectCallback","returnFunction","oldOptions","newHost","onInit","processHostTagJsVar","attrContext","onDestroy","convertTagToElementManaged","overrideTagVar","renderContent","convertValue","oldType","newType","hasTypeChanged","checkTagValueChange","updatesHandler","makeRealUpdate","afterDestroy","getOverrideTagVar","createSupportWithProps","newPropsConfig","processReplacementComponent","processFirstSubjectComponent","processFirstTagResult","processTagComponentInit","tagCount","onClick","makeEventListener","onMouseDown","type","toBeCalled","wrapped","tagElement","onclick","click","mousedown","onmousedown","defineGetSet","eventFn","fn","parentWrap","innerTagWrap","getTagWrap","setUse","ValueTypes","tagIndex","returnWrap","updates","onDelete","compareOriginal","use","deepPropWatch","route","_routeProps","targetItem","currentContext","inContext","message","onRender","callbackWrap","isFirst","lastContext","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","shallowMapper","deepMapper","getBaseSupport","baseSupport","upgradeBaseToSupport","clonePropsBy","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","ignoreOrDestroyed","before","processNowRegularValue","resultNum","observables","updateValue","aContext","newestParentTagJsVar","responseValue","ValueSubject","super","defaultFinally","setupWatch","currentValues","init","final","pastResult","realValues","isFirstRender","processRealValues","defineOnMethod","getWatch","attachTo","watch","setup","oldWatch","firstSupport","oldState","method","previousValues","nowSupport","setTo","newestState","oldestStateSupport","initialValue","newWatch","oldestState","TagError","details","errorCode","SyncCallbackError","callbackStateUpdate","_oldStates","maybePromise","supContext","finally","callbackState","callbackTrigger","getElement","registerTagElement","newFragment","createDocumentFragment","isApp","appElements","domItem","putOneDomDown","putDownTagDom","loadNewBaseSupport","renderTagElement","templater2","isAppFunction","executeStateWrap","runWrapper","removeEventListener","toAwait","taggedJs","warn","appElmIndex","appElm","debug","getNewSubject","callbackWrapper2","wrapCallback","e","listeners","allListeners","attr2","isValueForContext","registerMockAttrContext","elementFunctions","makeCallback","getPushKid","callbackWrapper","callables_other","onClose","onDoubleClick","onBlur","onChange","onMousedown","onMouseup","onKeydown","onKeyup","mockElm","setupAttr","eventCallables","onDblClick","onMouseUp","onKeyUp","onKeyDown","callables","checked","selected","class","destroyDesignElement","destroyDesignByContexts","processDesignElementUpdate","checkTagElementValueChange","vContexts","ogListeners","newListener","info","conValues","processChildren","paintBy","handleSimpleInnerValue","subContexts","_c","subSub","aSubContext","underFunction","Function","trueValue","processNonElement","processElementVarFunction","newElement","processElementVar","addedContexts","stateSupport","registerListener","processDesignElementInit","designElement","pushKid","_elmFunctions","registerMockChildContext","noElement","processNoElmInit","destroyNoElement","noElementMaker","input","h1","ul","li","div","main","section","header","footer","a","label","p","span","Item","todo","dispatch","editing","completed","id","autoFocus","title","handleKey","removeItem","updateToByIndex","handleUpdate","htmlFor","toggleItem","removeItemByIndex","onValid","getHash","window","location","hash","substring","useHashRouter","onHashChange","HashRouter","todos","partial","addItem","r","Math","random","t","removeAll","toggleAll","removeCompleted","completeItem","updateItemByIndex","todoReducer","router","infoTag","todosTag","href","isActiveRoute","isCompletedRoute","getVisibleTodos","getActiveTodoCount","visibleTodos","activeTodoCount","enter","Header","for","todosCount","Footer","getElementsByTagName"],"sourceRoot":""}