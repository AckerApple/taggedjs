{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://todo/webpack/bootstrap","webpack://todo/webpack/runtime/define property getters","webpack://todo/webpack/runtime/hasOwnProperty shorthand","webpack://todo/./node_modules/taggedjs/js/tag/ValueTypes.enum.js","webpack://todo/./node_modules/taggedjs/js/isInstance.js","webpack://todo/./node_modules/taggedjs/js/subject/subject.utils.js","webpack://todo/./node_modules/taggedjs/js/subject/Subject.class.js","webpack://todo/./node_modules/taggedjs/js/subject/combineLatest.function.js","webpack://todo/./node_modules/taggedjs/js/subject/ValueSubject.js","webpack://todo/./node_modules/taggedjs/js/state/stateHandlers.js","webpack://todo/./node_modules/taggedjs/js/state/state.utils.js","webpack://todo/./node_modules/taggedjs/js/state/getStateValue.function.js","webpack://todo/./node_modules/taggedjs/js/state/letState.function.js","webpack://todo/./node_modules/taggedjs/js/state/setUse.function.js","webpack://todo/./node_modules/taggedjs/js/state/state.function.js","webpack://todo/./node_modules/taggedjs/js/state/syncStates.function.js","webpack://todo/./node_modules/taggedjs/js/state/watch.function.js","webpack://todo/./node_modules/taggedjs/js/state/subject.function.js","webpack://todo/./node_modules/taggedjs/js/errors.js","webpack://todo/./node_modules/taggedjs/js/deepFunctions.js","webpack://todo/./node_modules/taggedjs/js/tag/isLikeTags.function.js","webpack://todo/./node_modules/taggedjs/js/tag/cloneValueArray.function.js","webpack://todo/./node_modules/taggedjs/js/tag/TemplaterResult.class.js","webpack://todo/./node_modules/taggedjs/js/tag/tag.utils.js","webpack://todo/./node_modules/taggedjs/js/alterProp.function.js","webpack://todo/./node_modules/taggedjs/js/tag/paint.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/howToSetInputValue.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/specialAttribute.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/elementInitCheck.js","webpack://todo/./node_modules/taggedjs/js/state/handleProviderChanges.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/getUpTags.function.js","webpack://todo/./node_modules/taggedjs/js/tag/render/renderSupport.function.js","webpack://todo/./node_modules/taggedjs/js/state/providersChangeCheck.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/renderTagArray.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/bindSubjectCallback.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/processNameValueAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/addSupportEventListener.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/processAttributeCallback.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/isSpecialAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/attributes/processAttribute.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/attachDomElements.function.js","webpack://todo/./node_modules/taggedjs/js/tag/buildBeforeElement.function.js","webpack://todo/./node_modules/taggedjs/js/tag/domMetaCollector.js","webpack://todo/./node_modules/taggedjs/js/tag/getStringsId.function.js","webpack://todo/./node_modules/taggedjs/js/tag/isLastRunMatched.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/htmlInterpolationToDomMeta.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/restorePlaceholders.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processTag.function.js","webpack://todo/./node_modules/taggedjs/js/tag/Support.class.js","webpack://todo/./node_modules/taggedjs/js/updateBeforeTemplate.function.js","webpack://todo/./node_modules/taggedjs/js/tag/processUpdateAttrContext.function.js","webpack://todo/./node_modules/taggedjs/js/tag/processUpdateContext.function.js","webpack://todo/./node_modules/taggedjs/js/tag/updateSupportBy.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/updateExistingValue.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/getNewGlobal.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/updateExistingTagComponent.function.js","webpack://todo/./node_modules/taggedjs/js/tag/hasSupportChanged.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processRegularValue.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processNewValue.function.js","webpack://todo/./node_modules/taggedjs/js/tag/tagRunner.js","webpack://todo/./node_modules/taggedjs/js/tag/getChildTagsToDestroy.function.js","webpack://todo/./node_modules/taggedjs/js/tag/smartRemoveKids.function.js","webpack://todo/./node_modules/taggedjs/js/tag/elementDestroyCheck.function.js","webpack://todo/./node_modules/taggedjs/js/tag/destroySupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processTagArray.js","webpack://todo/./node_modules/taggedjs/js/tag/checkDestroyPrevious.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processFirstSubjectValue.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processFirstSubjectComponent.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/processTagResult.function.js","webpack://todo/./node_modules/taggedjs/js/tag/update/oneRenderToSupport.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/subscribeToTemplate.function.js","webpack://todo/./node_modules/taggedjs/js/interpolations/processSubscriptionUpdate.function.js","webpack://todo/./node_modules/taggedjs/js/tag/executeWrap.function.js","webpack://todo/./node_modules/taggedjs/js/tag/getTagWrap.function.js","webpack://todo/./node_modules/taggedjs/js/tag/tag.js","webpack://todo/./node_modules/taggedjs/js/tag/key.js","webpack://todo/./node_modules/taggedjs/js/tag/clonePropsBy.function.js","webpack://todo/./node_modules/taggedjs/js/tag/render/renderTagOnly.function.js","webpack://todo/./node_modules/taggedjs/js/tag/render/softDestroySupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/render/renderWithSupport.function.js","webpack://todo/./node_modules/taggedjs/js/tag/render/renderExistingTag.function.js","webpack://todo/./node_modules/taggedjs/js/state/callbackMaker.function.js","webpack://todo/./node_modules/taggedjs/js/state/callbackStateUpdate.function.js","webpack://todo/./node_modules/taggedjs/js/tag/getSupportInCycle.function.js","webpack://todo/./node_modules/taggedjs/js/tag/Tag.class.js","webpack://todo/./node_modules/taggedjs/js/interpolations/optimizers/replacePlaceholders.function.js","webpack://todo/./node_modules/taggedjs/js/tag/html.js","webpack://todo/./node_modules/taggedjs/js/tag/tagElement.js","webpack://todo/./node_modules/taggedjs/js/index.js","webpack://todo/./src/tags/item.tag.ts","webpack://todo/./src/tags/header.tag.ts","webpack://todo/./src/tags/footer.tag.ts","webpack://todo/./src/HashRouter.function.ts","webpack://todo/./node_modules/taggedjs/js/state/onDestroy.js","webpack://todo/./src/app.tag.ts","webpack://todo/./src/reducer.ts","webpack://todo/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: ['html'], // html'' aka StringTag | DomTag\n    dom: ['dom'], // compiled version of html''\n    templater: ['templater'],\n    tagComponent: ['tagComponent'],\n    tagArray: ['tagArray'],\n    subject: ['subject'],\n    tagJsSubject: ['tagJsSubject'],\n    renderOnce: ['renderOnce'],\n    stateRender: ['stateRender'],\n    version,\n};\n//# sourceMappingURL=ValueTypes.enum.js.map","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\nexport function isStaticTag(value) {\n    switch (value?.tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n//# sourceMappingURL=isInstance.js.map","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n//# sourceMappingURL=subject.utils.js.map","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, _subscription) => {\n            subscription.unsubscribe();\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n//# sourceMappingURL=Subject.class.js.map","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n//# sourceMappingURL=combineLatest.function.js.map","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n//# sourceMappingURL=ValueSubject.js.map","import { setUseMemory } from './setUse.function.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    config.array.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n//# sourceMappingURL=stateHandlers.js.map","import { firstLetState, reLetState } from './letState.function.js';\nimport { runFirstState, runRestate } from './stateHandlers.js';\nimport { setUseMemory } from './setUse.function.js';\nexport function afterRender(support) {\n    const config = setUseMemory.stateConfig;\n    // TODO: only needed in development\n    /*\n    const rearray = config.rearray as unknown as State[]\n    if(rearray.length && rearray.length !== config.array.length) {\n      const message = `States lengths have changed ${rearray.length} !== ${config.array.length}. State tracking requires the same amount of function calls every render. Typically this errors is thrown when a state like function call occurs only for certain conditions or when a function is intended to be wrapped with a tag() call`\n      const wrapper = support.templater?.wrapper as Wrapper\n      const details = {\n        oldStates: config.array,\n        newStates: config.rearray,\n        tagFunction: wrapper.parentWrap.original,\n      }\n      const error = new StateMismatchError(message,details)\n      console.warn(message,details)\n      throw error\n    }\n    */\n    delete config.support;\n    support.state = config.array;\n    config.array = [];\n}\nexport function initState(support, config) {\n    config.handlers.handler = runFirstState;\n    config.handlers.letHandler = firstLetState;\n    config.rearray = [];\n    config.support = support;\n}\nexport function reState(support, config) {\n    const state = support.state;\n    config.rearray = state;\n    config.handlers.handler = runRestate;\n    config.handlers.letHandler = reLetState;\n    config.support = support;\n}\nexport class StateEchoBack {\n}\n// sends a fake value and then sets back to received value\nexport function getCallbackValue(callback) {\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [value] = oldState;\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n//# sourceMappingURL=state.utils.js.map","import { getCallbackValue } from './state.utils.js';\nconst badLetState = 'letState function incorrectly used. Second item in array is not setting expected value.\\n\\n' +\n    'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n    'For \"const\" state use `const name = state(default)()`\\n\\n' +\n    'Problem state:\\n';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    // state()\n    if (!callback) {\n        return state.defaultValue;\n    }\n    // letState()\n    const [value, checkValue] = getCallbackValue(callback);\n    // TODO: not needed in production, needed in development\n    /*\n    if(checkValue !== StateEchoBack) {\n      const message = badLetState + (callback ? callback.toString() : JSON.stringify(state)) +'\\n'\n      console.error(message, {state, callback, value, checkValue})\n      throw new Error(message)\n    }\n    */\n    return value;\n}\n//# sourceMappingURL=getStateValue.function.js.map","import { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from './setUse.function.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function letState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.letHandler(defaultValue);\n}\nexport function firstLetState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    const initValue = typeof (defaultValue) === BasicTypes.function ? defaultValue() : defaultValue;\n    const push = {\n        get: function getPushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return makeStateResult(initValue, push);\n}\nexport function reLetState() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    let oldValue = getStateValue(restate);\n    const push = {\n        get: function getLetState() {\n            return getStateValue(push);\n        },\n        defaultValue: restate.defaultValue,\n    };\n    config.array.push(push);\n    return makeStateResult(oldValue, push);\n}\nfunction makeStateResult(initValue, push) {\n    return function msr(y) {\n        push.callback = y;\n        return initValue;\n    };\n}\n//# sourceMappingURL=letState.function.js.map","import { firstLetState } from './letState.function.js';\nimport { runFirstState } from './stateHandlers.js';\nexport const setUseMemory = {\n    stateConfig: {\n        array: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            letHandler: firstLetState,\n        }\n    },\n};\n//# sourceMappingURL=setUse.function.js.map","import { setUseMemory } from './setUse.function.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n//# sourceMappingURL=state.function.js.map","export function syncStates(stateFrom, stateTo) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const state = stateFrom[index];\n        const fromValue = state.get();\n        const s = stateTo[index];\n        setState(s, fromValue);\n    }\n}\nfunction setState(s, fromValue) {\n    const callback = s.callback;\n    if (callback) {\n        callback(fromValue); // set the value\n    }\n}\n//# sourceMappingURL=syncStates.function.js.map","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered. Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = setUseMemory.stateConfig.array;\n                        syncStates(newestState, firstSupport.state);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n//# sourceMappingURL=watch.function.js.map","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(value, onSubscription) {\n    const oldestState = state(function subjectState() {\n        return setUseMemory.stateConfig.array;\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectState() {\n        const subject = new Subject(value, onSubscription).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return setUseMemory.stateConfig.array;\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => setUseMemory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        syncStates(nowSupport.state, oldestState);\n        return x;\n    });\n}\nsubject.all = all;\n//# sourceMappingURL=subject.function.js.map","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n//# sourceMappingURL=errors.js.map","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n//# sourceMappingURL=deepFunctions.js.map","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag; // || (support1 as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    if (tag0.tagJsType === ValueTypes.dom) {\n        return isLikeDomTags(tag0, tag1);\n    }\n    const like = isLikeStringTags(tag0, tag1, support0, support1);\n    return like;\n}\n// used when compiler was used\nexport function isLikeDomTags(tag0, tag1) {\n    const domMeta0 = tag0.dom;\n    const domMeta1 = tag1.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(tag0, tag1, support0, // new\nsupport1) {\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    // strings1[index] === string // slower\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.templater.values || tag0.values;\n    const values1 = support1.templater.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=isLikeTags.function.js.map","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n//# sourceMappingURL=cloneValueArray.function.js.map","import { ValueTypes } from './ValueTypes.enum.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        propWatch,\n        props,\n        tagJsType: ValueTypes.templater,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n//# sourceMappingURL=TemplaterResult.class.js.map","export const tags = [];\n//# sourceMappingURL=tag.utils.js.map","import { isInlineHtml, renderInlineHtml } from './tag/render/renderSupport.function.js';\nimport { renderExistingReadyTag } from './tag/render/renderExistingTag.function.js';\nimport { getSupportInCycle } from './tag/getSupportInCycle.function.js';\nimport { deepCompareDepth } from './tag/hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nimport { setUseMemory } from './state/index.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(prop => alterProp(prop, newSupport.ownerSupport, newSupport, depth));\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        return getPropWrap(value, ownerSupport);\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        for (let index = value.length - 1; index >= 0; --index) {\n            const subValue = value[index];\n            value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1);\n            if (typeof (subValue) === BasicTypes.function) {\n                if (subValue.mem) {\n                    continue;\n                }\n                afterCheckProp(depth + 1, index, subValue, value, newSupport);\n            }\n        }\n        return value;\n    }\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1);\n        if (value[name] === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return wrap.toCall(...args);\n    }; // what gets called can switch over parent state changes\n    // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n    wrap.toCall = function toCallRunner(...args) {\n        return callbackPropOwner(wrap.mem, args, ownerSupport);\n    };\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    const callbackResult = toCall(...callWith);\n    const run = function propCallbackProcessor() {\n        const global = newest.subject.global;\n        // are we in a rendering cycle? then its being called by alterProps\n        if (noCycle === false) {\n            const allMatched = global.locked === true;\n            if (allMatched) {\n                return callbackResult; // owner did not change\n            }\n        }\n        /*\n        const oldest = global.oldest\n        const wasInstant = oldest === newest && global.renderCount === 0\n        if(wasInstant) {\n          return // prop was called immediately\n        }\n        */\n        safeRenderSupport(newest, ownerSupport);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\nexport function safeRenderSupport(newest, ownerSupport) {\n    const subject = newest.subject;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        const result = renderInlineHtml(ownerSupport, newest);\n        // TODO: below maybe never true\n        /*\n        const global = subject.global as TagGlobal\n        if(global) {\n          delete global.locked\n        }\n        */\n        return result;\n    }\n    const global = subject.global;\n    global.locked = true;\n    renderExistingReadyTag(global.newest, newest, ownerSupport, subject);\n    delete global.locked;\n}\n//# sourceMappingURL=alterProp.function.js.map","export let paintRemoves = [];\nexport let paintContent = [];\nexport let setContent = [];\nexport let paintAppends = [];\nexport let paintInsertBefores = [];\nexport let paintAfters = [];\nexport const painting = {\n    locks: 0\n};\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    ++painting.locks;\n    for (const toRemove of paintRemoves) {\n        const parentNode = toRemove.parentNode;\n        parentNode.removeChild(toRemove);\n    }\n    for (const content of paintContent) {\n        content();\n    }\n    for (const [text, textNode] of setContent) {\n        textNode.textContent = text;\n    }\n    for (const now of paintAppends) {\n        now.relative.appendChild(now.element);\n    }\n    for (const { element, relative } of paintInsertBefores) {\n        relative.parentNode.insertBefore(element, relative);\n    }\n    for (const now of paintAfters) {\n        now();\n    }\n    paintRemoves = [];\n    paintContent = [];\n    paintAppends = [];\n    paintInsertBefores = [];\n    paintAfters = [];\n    setContent = [];\n    --painting.locks;\n}\n//# sourceMappingURL=paint.function.js.map","import { paintContent } from \"../../tag/paint.function.js\";\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push(() => {\n        if (value === undefined || value === false || value === null) {\n            element.removeAttribute(name);\n            return;\n        }\n        element.setAttribute(name, value);\n    });\n}\n//# sourceMappingURL=howToSetInputValue.function.js.map","import { paintAfters, paintContent } from \"../../tag/paint.function.js\";\nimport { elementInitCheck } from \"./elementInitCheck.js\";\nconst style = 'style';\nconst classS = 'class';\n// const styleStart = style + '.'\n// const classStart = classS + '.'\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'oninit':\n            paintAfters.push(() => elementInitCheck(element, { added: 0, removed: 0 }));\n            return;\n        case 'autofocus':\n            paintAfters.push(() => element.focus());\n            return;\n        case 'autoselect':\n            paintAfters.push(() => element.select());\n            return;\n        case 'style':\n            const names = name.split('.');\n            // names.shift() // remove 'style'\n            paintContent.push(() => element.style[names[1]] = value); // attribute changes should come first\n            return;\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push(() => element.classList.add(name));\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push(() => element.classList.remove(name));\n    }\n}\n//# sourceMappingURL=specialAttribute.js.map","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n//# sourceMappingURL=elementInitCheck.js.map","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const global = support.subject.global;\n    memory.push({\n        support,\n        renderCount: global.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cGlobal = child.subject.global;\n        memory.push({\n            support: child,\n            renderCount: cGlobal.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n//# sourceMappingURL=handleProviderChanges.function.js.map","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../tag/render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as Support\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(ownerSupport, newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n//# sourceMappingURL=getUpTags.function.js.map","import { deepEqual } from '../../deepFunctions.js';\nimport { renderExistingReadyTag } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../hasSupportChanged.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return renderInlineHtml(ownerSupport, support);\n    }\n    global.locked = true;\n    const subject = support.subject;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    delete global.locked;\n    const tag = renderExistingReadyTag(global.newest, support, ownerSupport, subject);\n    return tag;\n}\nexport function renderInlineHtml(ownerSupport, support) {\n    const ownGlobal = ownerSupport.subject.global;\n    if (!ownGlobal || ownGlobal.deleted === true) {\n        return support;\n    }\n    // ??? new change\n    const newest = ownGlobal.newest || ownerSupport;\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(ownerSupport, templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (ownerSupport && selfPropChange) {\n        return true;\n    }\n    return false;\n}\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    /*\n    const noLength = nowProps && nowLen === 0 && latestLen === 0\n  \n    if(noLength) {\n      return false\n    }\n    */\n    return nowLen !== latestLen;\n}\n//# sourceMappingURL=renderSupport.function.js.map","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(x => x.support));\n    }\n    return prosWithChanges;\n}\n//# sourceMappingURL=providersChangeCheck.function.js.map","import { paint, painting } from '../../tag/paint.function.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.subject.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    // renderSupport(support)\n    renderSupport(global.newest);\n}\n//# sourceMappingURL=renderTagArray.function.js.map","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise, isTagComponent } from '../../isInstance.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    const global = support.subject.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function (element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as Support // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    subjectFunction.support = support;\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, bindTo, args) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const global = component.subject.global; // tag.subject.global as TagGlobal\n    global.locked = true; // prevent another render from re-rendering this tag\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    return afterTagCallback(callbackResult, component);\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.subject.global; // tag.subject.global as SupportTagGlobal\n    delete global.locked;\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (isPromise(callbackResult)) {\n        const global0 = last.subject.global;\n        global0.locked = true;\n        return callbackResult.then(() => {\n            if (global.deleted === true) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            const global1 = last.subject.global;\n            delete global1.locked;\n            const tagsToUpdate = getUpTags(last);\n            renderTagUpdateArray(tagsToUpdate);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    for (const block of blocked) {\n        const lastResult = renderSupport(block);\n        global.newest = lastResult;\n    }\n    global.blocked = [];\n    return global.newest;\n}\n//# sourceMappingURL=bindSubjectCallback.function.js.map","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial) {\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n//# sourceMappingURL=processNameValueAttribute.function.js.map","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.subject.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n//# sourceMappingURL=addSupportEventListener.function.js.map","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n//# sourceMappingURL=processAttributeCallback.function.js.map","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction) {\n        return true;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit':\n            return 'oninit';\n    }\n    return false;\n}\n//# sourceMappingURL=isSpecialAttribute.function.js.map","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { isFunction, isObject, isSubjectInstance } from '../../isInstance.js';\nimport { bindSubjectCallback } from './bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../tag/paint.function.js';\nimport { processDynamicNameValueAttribute, processNonDynamicAttr } from './processNameValueAttribute.function.js';\nimport { addOneContext, checkSimpleValueChange } from '../../tag/index.js';\nimport { processAttributeFunction } from './processAttributeCallback.function.js';\nimport { isSpecialAttr } from './isSpecialAttribute.function.js';\n/** Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, attrName, element, support, howToSet, //  = howToSetInputValue\ncontext, value, isSpecial) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context);\n        return;\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        const contextItem = {\n            isAttr: true,\n            element,\n            attrName: attrName,\n            checkValueChange: checkSimpleValueChange,\n            withinOwnerElement: true,\n        };\n        context.push(contextItem);\n        const isSubject = isSubjectInstance(contextItem.value);\n        if (isSubject) {\n            return processNameValueAttributeAttrSubject(attrName, contextItem, element, support, howToSet, isSpecial);\n        }\n        processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial);\n        contextItem.value = value;\n        return;\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial);\n}\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context);\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, value, isSpecialAttr(name));\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n/** Processor for flat attributes and object attributes */\nfunction processNameValueAttributeAttrSubject(attrName, result, element, support, howToSet, isSpecial) {\n    if (isSpecial) {\n        paintContent.push(function paintContent() {\n            element.removeAttribute(attrName);\n        });\n    }\n    const contextValueSubject = result.value;\n    if (isSubjectInstance(contextValueSubject)) {\n        const callback = function processAttrCallback(newAttrValue) {\n            processAttributeEmit(newAttrValue, attrName, result, element, support, howToSet, isSpecial);\n        };\n        //  Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        const global = result.global;\n        const subs = global.subscriptions = global.subscriptions || [];\n        subs.push(sub);\n    }\n    processAttributeEmit(result.value, attrName, result, element, support, howToSet, isSpecial);\n    return;\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support) {\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    if (isSpecial) {\n        specialAttribute(attrName, newAttrValue, element, isSpecial);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push(function paintContentPush() {\n                element.removeAttribute(attrName);\n            });\n            return;\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject) {\n    const wrapper = support.templater.wrapper;\n    const parentWrap = wrapper?.parentWrap;\n    const tagJsType = wrapper?.tagJsType || parentWrap?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    const prevFun = subject.value;\n    if (prevFun && prevFun.tagFunction && prevFun.support) {\n        prevFun.tagFunction = newAttrValue;\n        prevFun.support = support;\n        return prevFun;\n    }\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\nexport function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n//# sourceMappingURL=processAttribute.function.js.map","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nimport { howToSetInputValue } from \"../attributes/howToSetInputValue.function.js\";\nimport { paintAppends, paintInsertBefores } from \"../../tag/paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { addOneContext } from \"../../tag/index.js\";\nimport { isSubjectInstance } from \"../../isInstance.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\n// ??? TODO: This could be done within exchangeParsedForValues to reduce loops\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nowner, insertBefore, subs = []) {\n    const x = document.createElement('div');\n    const dom = [];\n    for (const node of nodes) {\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            attachDynamicDom(values, context, owner, support, subs, counts, depth);\n            continue;\n        }\n        if (node.nn === 'text') {\n            const textNode = newNode;\n            const string = textNode.tc = node.tc;\n            x.innerHTML = string;\n            const domElement = textNode.domElement = document.createTextNode(x.innerText);\n            domElement.id = `tp_${context.length}_${values.length}`;\n            if (owner) {\n                paintAppends.push({\n                    element: domElement,\n                    relative: owner,\n                });\n            }\n            else {\n                paintInsertBefores.push({\n                    element: domElement,\n                    relative: insertBefore,\n                });\n            }\n            continue;\n        }\n        const domElement = newNode.domElement = document.createElement(node.nn);\n        // attributes that may effect style, come first\n        if (node.at) {\n            node.at.map(attr => processAttribute(values, attr[0], // name\n            domElement, support, howToSetInputValue, context, attr[1], // value\n            attr[2]));\n        }\n        if (owner) {\n            paintAppends.push({\n                element: domElement,\n                relative: owner,\n            });\n        }\n        else {\n            paintInsertBefores.push({\n                element: domElement,\n                relative: insertBefore,\n            });\n        }\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore, subs).dom;\n        }\n    }\n    return { subs, dom, context };\n}\nfunction attachDynamicDom(values, context, owner, support, subs, counts, // used for animation stagger computing\ndepth) {\n    const subVal = values[context.length];\n    const marker = document.createTextNode(empty);\n    marker.id = `dvp_${context.length}_${values.length}`;\n    const contextItem = addOneContext(subVal, context, depth > 0);\n    contextItem.placeholder = marker;\n    if (owner) {\n        paintAppends.push({\n            relative: owner,\n            element: marker,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            element: marker,\n            relative: support.subject.placeholder,\n        });\n    }\n    if (isSubjectInstance(subVal)) {\n        subs.push({\n            insertBefore: marker,\n            appendTo: owner,\n            subject: subVal,\n            support, // ownerSupport,\n            counts,\n            contextItem,\n        });\n        return;\n    }\n    const global = support.subject.global;\n    global.locked = true;\n    processFirstSubjectValue(subVal, contextItem, support, counts, `rvp_${context.length}_${values.length}`, owner);\n    const global2 = support.subject.global;\n    delete global2.locked;\n    contextItem.value = subVal;\n    return;\n}\n//# sourceMappingURL=attachDomElements.function.js.map","import { attachDomElements } from '../interpolations/optimizers/attachDomElements.function.js';\nimport { checkSimpleValueChange } from './index.js';\nimport { getDomMeta } from './domMetaCollector.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, element, insertBefore, options) {\n    const global = support.subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = getHtmlDomMeta(support, options, element, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction getHtmlDomMeta(support, options = {\n    counts: { added: 0, removed: 0 },\n}, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const context = [];\n    const global = support.subject.global;\n    global.context = context;\n    const result = attachDomElements(domMeta, values, support, options.counts, context, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag; // || templater\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    return getDomMeta(thisTag.strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n//# sourceMappingURL=buildBeforeElement.function.js.map","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { restorePlaceholders } from '../interpolations/optimizers/restorePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    // Restore any sanitized placeholders in text nodes\n    restorePlaceholders(map);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n//# sourceMappingURL=domMetaCollector.js.map","export function getStringsId(strings) {\n    const array = strings.map(x => x.length);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\n//# sourceMappingURL=getStringsId.function.js.map","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=isLastRunMatched.function.js.map","import { variablePrefix, variableSuffix } from \"../../tag/Tag.class.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nconst ondoubleclick = 'ondoubleclick';\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst fragReplacer = /(^:tagvar\\d+:|:tagvar\\d+:$)/g;\nconst safeVar = '__safeTagVar';\nconst regexAttr = /([:_a-zA-Z0-9\\-\\.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9\\-]+)((?:\\s+[a-zA-Z_:][\\w:.\\-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\nexport function htmlInterpolationToDomMeta(strings, values) {\n    htmlInterpolationToPlaceholders(strings, values);\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = sanitizePlaceholders(strings);\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction sanitizePlaceholders(fragments) {\n    return fragments.map(fragment => fragment.replace(fragReplacer, (match, index) => safeVar + index));\n}\nfunction addPlaceholders(strings, values) {\n    const results = strings.map((fragment, index) => {\n        if (index < values.length) {\n            return fragment + variablePrefix + index + variableSuffix;\n        }\n        return fragment;\n    });\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                textVarMatches.forEach(textContent => {\n                    if (textContent.startsWith(variablePrefix)) {\n                        textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                });\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n            const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n            let attrValue = attrChoice;\n            if (attrName === undefined) {\n                continue;\n            }\n            const notEmpty = attrMatch[2] !== '';\n            const noValue = attrValue === undefined && notEmpty;\n            const lowerName = attrName.toLowerCase();\n            const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n            if (noValue) {\n                const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n                if (standAloneVar) {\n                    const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                    valuePositions.push(['at', valueName]);\n                    attributes.push([valueName]); // the name itself is dynamic\n                    continue;\n                }\n                const startMatched = attrMatch[0].startsWith(attrName);\n                const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n                if (standAloneAttr) {\n                    attributes.push([fixedName]);\n                    continue;\n                }\n                const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                attrValue = valueName;\n            }\n            if (!notEmpty) {\n                attrValue = attrMatch[2];\n            }\n            const attrSet = [fixedName, attrValue];\n            const isSpecial = isSpecialAttr(fixedName);\n            if (isSpecial) {\n                attrSet.push(isSpecial);\n            }\n            attributes.push(attrSet);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            textVarMatches.forEach(textContent => {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                return pushTextTo(currentElement, elements, textContent);\n            });\n        }\n    }\n    return elements;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(part => part !== '');\n    return filteredParts;\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postprocessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction postprocessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\n//# sourceMappingURL=htmlInterpolationToDomMeta.function.js.map","import { variableSuffix, variablePrefix } from \"../../tag/Tag.class.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nexport const safeVar = '__safeTagVar';\nexport function restorePlaceholders(elements) {\n    elements.forEach(traverseAndRestore);\n}\nconst safeReplacer = /__safeTagVar(\\d+)/g;\nfunction traverseAndRestore(element) {\n    if (element.at) {\n        element.at = element.at ? element.at.map(attr => {\n            if (attr.length === 1) {\n                return attr;\n            }\n            const [, value] = attr;\n            if (typeof value === ImmutableTypes.string && value.startsWith(safeVar)) {\n                const index = parseInt(value.replace(safeVar, ''), 10);\n                attr[1] = variablePrefix + index + variableSuffix;\n            }\n            return attr;\n        }) : [];\n    }\n    if (element.ch) {\n        const children = element.ch;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.nn === 'text') {\n                if (typeof child.tc !== ImmutableTypes.string) {\n                    return;\n                }\n                child.tc = child.tc.replace(safeReplacer, (_match, index) => variablePrefix + index + variableSuffix);\n            }\n            traverseAndRestore(child);\n        }\n        // Remove empty children array\n        if (children.length === 0) {\n            delete element.ch;\n        }\n    }\n}\n//# sourceMappingURL=restorePlaceholders.function.js.map","import { getHtmlSupport } from '../Support.class.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { paintAppends } from '../paint.function.js';\nimport { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { checkTagValueChange } from '../checkDestroyPrevious.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\nsubject) {\n    const global = subject.global;\n    const support = global.newest;\n    support.ownerSupport = ownerSupport;\n    subject.checkValueChange = checkTagValueChange;\n    const ph = subject.placeholder;\n    const result = buildBeforeElement(support, undefined, ph, { counts: { added: 0, removed: 0 } });\n    for (const sub of result.subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n    };\n    return fake;\n}\n/** Create Support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = getHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.context = [];\n    return support;\n}\nexport function processNewTag(templater, ownerSupport, // owner\nsubject, // could be tag via result.tag\nappendTo) {\n    subject.checkValueChange = checkTagValueChange;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, appendTo, undefined, { counts: { added: 0, removed: 0 } });\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            paintAppends.push({\n                element: dom.marker,\n                relative: appendTo, // ph.parentNode as Element,\n            });\n        }\n        if (dom.domElement) {\n            paintAppends.push({\n                element: dom.domElement,\n                relative: appendTo, // ph.parentNode as Element,\n            });\n        }\n    }\n    let index = -1;\n    const length = result.subs.length - 1;\n    //++painting.locks\n    while (index++ < length) {\n        const sub = result.subs[index];\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\n//# sourceMappingURL=processTag.function.js.map","import { clonePropsBy } from './clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, subject, castedProps) {\n    const baseSupport = {\n        templater,\n        subject,\n        castedProps,\n        state: [], // TODO: this is not needed for every type of  tag\n        appSupport: undefined,\n    };\n    baseSupport.appSupport = baseSupport;\n    const global = subject.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    const props = templater.props; // natural props\n    if (props) {\n        baseSupport.propsConfig = clonePropsBy(baseSupport, props, castedProps);\n    }\n    return baseSupport;\n}\nexport function getSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\nexport function getHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n//# sourceMappingURL=Support.class.js.map","import { paintInsertBefores } from './tag/paint.function.js';\nimport { empty } from './tag/ValueTypes.enum.js';\n// Function to update the value of x\nexport function updateBeforeTemplate(value, // value should be casted before calling here\nlastFirstChild) {\n    const textNode = document.createTextNode(value); // never innerHTML\n    paintInsertBefores.push({\n        element: textNode,\n        relative: lastFirstChild,\n    });\n    return textNode;\n}\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n//# sourceMappingURL=updateBeforeTemplate.function.js.map","import { processAttributeEmit, updateNameOnlyAttrValue } from '../interpolations/attributes/processAttribute.function.js';\nexport function processUpdateAttrContext(values, value, contextItem, ownerSupport) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, []);\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial);\n    contextItem.value = value;\n    return;\n}\n//# sourceMappingURL=processUpdateAttrContext.function.js.map","import { updateExistingValue } from './update/updateExistingValue.function.js';\nimport { isSubjectInstance } from '../isInstance.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nexport function processUpdateContext(support, context) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    while (index < len) {\n        processUpdateOneContext(values, index, context, support);\n        ++index;\n    }\n    return context;\n}\n/** returns boolean of did render */\nexport function processUpdateOneContext(values, index, context, ownerSupport) {\n    const value = values[index];\n    // is something already there?\n    const contextItem = context[index];\n    if (isSubjectInstance(value)) {\n        return; // emits on its own\n    }\n    if (contextItem.isAttr) {\n        // Do not continue if the value is just the same\n        if (value === contextItem.value) {\n            return;\n        }\n        processUpdateAttrContext(values, value, contextItem, ownerSupport);\n        contextItem.value = value;\n    }\n    // listeners will evaluate updated values to possibly update display(s)\n    updateExistingValue(contextItem, value, ownerSupport);\n    contextItem.value = value;\n}\n//# sourceMappingURL=processUpdateContext.function.js.map","import { paint, painting } from './paint.function.js';\nimport { processUpdateContext } from './processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.subject.global;\n    const context = global.context;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const tempTag = (newerSupport.templater.tag || newerSupport.templater);\n    const values = newerSupport.templater.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n//# sourceMappingURL=updateSupportBy.function.js.map","import { getFakeTemplater, newSupportByTemplater, processTag } from './processTag.function.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function.js';\nimport { getSupport } from '../Support.class.js';\nimport { BasicTypes, ValueTypes } from '../ValueTypes.enum.js';\nimport { updateSupportBy } from '../updateSupportBy.function.js';\nimport { isArray, isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processTagArray } from './processTagArray.js';\nexport function updateExistingValue(contextItem, // InterpolateSubject,\nvalue, ownerSupport) {\n    // Do not continue if the value is just the same\n    if (value === contextItem.value) {\n        return;\n    }\n    const wasDestroyed = contextItem.checkValueChange(value, contextItem);\n    if (wasDestroyed === -1) {\n        return; // do nothing\n    }\n    // handle already seen tag components\n    const tagJsType = value && value.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        const isComp = isTagComponent(value);\n        if (isComp) {\n            contextItem.global = contextItem.global || getNewGlobal();\n            prepareUpdateToComponent(value, contextItem, ownerSupport);\n            return;\n        }\n    }\n    const global = contextItem.global;\n    if (global) {\n        // was component but no longer\n        const support = global.newest;\n        if (support) {\n            if (typeof (value) === BasicTypes.function) {\n                return;\n            }\n            handleStillTag(support, contextItem, value, ownerSupport);\n            if (!global.locked) {\n                ++global.renderCount;\n            }\n            return;\n        }\n    }\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.templater:\n                processTag(ownerSupport, contextItem);\n                return;\n            case ValueTypes.tag:\n            case ValueTypes.dom:\n                const tag = value;\n                let templater = tag.templater;\n                if (!templater) {\n                    templater = getFakeTemplater();\n                    tag.templater = templater;\n                    templater.tag = tag;\n                }\n                const nowGlobal = contextItem.global = (contextItem.global || getNewGlobal());\n                nowGlobal.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n                processTag(ownerSupport, contextItem);\n                return;\n        }\n    }\n    if (isArray(value)) {\n        processTagArray(contextItem, value, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        contextItem.value = value; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (wasDestroyed) {\n        processNowRegularValue(value, contextItem);\n    }\n}\nfunction handleStillTag(lastSupport, subject, value, ownerSupport) {\n    const templater = value.templater || value;\n    const valueSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = lastSupport.subject;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        processReplacementComponent(templater, contextItem, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    const support = getSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n//# sourceMappingURL=updateExistingValue.function.js.map","export function getNewGlobal() {\n    return {\n        /** Indicator of re-rending. Saves from double rending something already rendered */\n        renderCount: 0,\n    };\n}\n//# sourceMappingURL=getNewGlobal.function.js.map","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { renderSupport } from '../render/renderSupport.function.js';\nimport { castProps, isSkipPropValue } from '../../alterProp.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { BasicTypes, ValueTypes } from '../ValueTypes.enum.js';\nimport { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { PropWatches } from '../tag.js';\nimport { isArray } from '../../isInstance.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject) {\n    const global = subject.global;\n    const lastSupport = global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = support.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = support.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(lastSupport, support);\n    }\n    else if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.parentWrap.original;\n        const newFunction = newWrapper.parentWrap.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(lastSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, support, lastSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (global.locked) {\n        global.blocked.push(support);\n        return;\n    }\n    renderSupport(support);\n    return;\n}\nexport function syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const global = lastSupport.subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, depth + 1, maxDepth);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nfunction syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    // prevent infinite recursion\n    if (depth === maxDepth) {\n        return prop;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        for (let index = prop.length - 1; index >= 0; --index) {\n            const x = prop[index];\n            prop[index] = syncPriorPropFunction(priorProp[index], x, newSupport, ownerSupport, depth + 1, index);\n        }\n        return prop;\n    }\n    if (priorProp === undefined) {\n        return prop;\n    }\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const result = syncPriorPropFunction(priorProp[name], subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (prop[name] === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.subject.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\nfunction syncSupports(templater, support, lastSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = lastSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return lastSupport; // its the same tag component  \n}\nfunction swapTags(subject, templater, ownerSupport) {\n    const global = subject.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, 0);\n    subject.global = getNewGlobal();\n    const newSupport = processReplacementComponent(templater, subject, ownerSupport, { added: 0, removed: 0 });\n    return newSupport;\n}\n//# sourceMappingURL=updateExistingTagComponent.function.js.map","import { deepEqual } from '../deepFunctions.js';\nimport { isArray } from '../isInstance.js';\nimport { hasPropLengthsChanged } from './render/renderSupport.function.js';\nimport { PropWatches } from './tag.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function hasSupportChanged(lastSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = lastSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, lastSupport.templater.propWatch);\n    return propsChanged;\n}\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nfunction hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, () => {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n//# sourceMappingURL=hasSupportChanged.function.js.map","import { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { setContent } from '../paint.function.js';\nimport { checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    setContent.push([castedValue, oldClone]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, subject) {\n    subject.checkValueChange = checkSimpleValueChange;\n    const before = subject.placeholder;\n    const castedValue = castTextValue(value);\n    // Processing of regular values\n    subject.simpleValueElm = updateBeforeTemplate(castedValue, before);\n}\n//# sourceMappingURL=processRegularValue.function.js.map","import { getTemplaterResult } from '../TemplaterResult.class.js';\nimport { getSupport } from '../Support.class.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { checkTagValueChange } from '../checkDestroyPrevious.function.js';\nimport { PropWatches } from '../tag.js';\nexport function processNewArrayValue(value, ownerSupport, contextItem) {\n    const tagJsType = value.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.templater:\n                const templater = value;\n                const tag = templater.tag;\n                processNewTag(tag, ownerSupport, contextItem);\n                break;\n            case ValueTypes.tag:\n            case ValueTypes.dom:\n                processNewTag(value, ownerSupport, contextItem);\n                break;\n        }\n    }\n    return contextItem;\n}\nfunction processNewTag(value, ownerSupport, contextItem) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const tag = value;\n    let templater = tag.templater;\n    // TODO: Can this ever happen?\n    if (!templater) {\n        templater = getTemplaterResult(PropWatches.DEEP);\n        templater.tag = tag;\n        tag.templater = templater;\n    }\n    const global = contextItem.global = getNewGlobal(); // contextItem.global as SupportTagGlobal\n    const newest = global.newest = getSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    global.oldest = newest;\n    return contextItem;\n}\n//# sourceMappingURL=processNewValue.function.js.map","import { setUseMemory } from '../state/index.js';\nimport { Subject } from '../subject/index.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { afterRender } from '../state/state.utils.js';\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nsetUseMemory.tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n// Life cycle 2\nexport function runAfterRender(support, ownerSupport) {\n    afterRender(support);\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(support) {\n    // TODO: We don't need to remove from parents if parent is being destroyed\n    // remove me from my parents\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.subject.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=tagRunner.js.map","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nexport function getChildTagsToDestroy(childTags) {\n    for (const child of childTags) {\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            getChildTagsToDestroy(lastArray);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(iSub => iSub.unsubscribe());\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support);\n        }\n        const subTags = global.context;\n        getChildTagsToDestroy(subTags);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.context;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\n//# sourceMappingURL=getChildTagsToDestroy.function.js.map","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { elementDestroyCheck } from './elementDestroyCheck.function.js';\nimport { paint, paintRemoves } from './paint.function.js';\nimport { isPromise } from '../isInstance.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(support, promises, stagger) {\n    const startStagger = stagger;\n    const subject = support.subject;\n    const thisGlobal = subject.global;\n    const htmlDomMeta = thisGlobal.htmlDomMeta;\n    const context = thisGlobal.context;\n    thisGlobal.deleted = true;\n    for (const subject of context) {\n        if (subject.withinOwnerElement) {\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintRemoves.push(elm);\n            continue;\n        }\n        const global = subject.global;\n        if (global === undefined) {\n            continue; // subject\n        }\n        if (global.deleted === true) {\n            continue;\n        }\n        global.deleted = true;\n        const oldest = global.oldest;\n        if (oldest) {\n            // recurse\n            stagger = stagger + smartRemoveKids(oldest, promises, stagger);\n            continue;\n        }\n    }\n    destroyClones(htmlDomMeta, startStagger, promises);\n    return stagger;\n}\nfunction destroyClones(oldClones, stagger, promises) {\n    // check subjects that may have clones attached to them\n    const newPromises = oldClones.map(clone => {\n        const marker = clone.marker;\n        if (marker) {\n            paintRemoves.push(marker);\n        }\n        const dom = clone.domElement;\n        if (!dom) {\n            return;\n        }\n        return checkCloneRemoval(dom, stagger);\n    }).filter(x => x); // only return promises\n    if (newPromises.length) {\n        promises.push(Promise.all(newPromises));\n        return stagger;\n    }\n    return stagger;\n}\n/** Reviews elements for the presences of ondestroy */\nfunction checkCloneRemoval(clone, stagger) {\n    const customElm = clone;\n    if (customElm.ondestroy) {\n        const promise = elementDestroyCheck(customElm, stagger);\n        if (isPromise(promise)) {\n            return promise.then(() => {\n                paintRemoves.push(clone);\n                paint();\n            });\n        }\n    }\n    paintRemoves.push(clone);\n}\n//# sourceMappingURL=smartRemoveKids.function.js.map","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    const event = {\n        target: nextSibling,\n        stagger\n    };\n    return onDestroy(event);\n}\n//# sourceMappingURL=elementDestroyCheck.function.js.map","import { runBeforeDestroy } from './tagRunner.js';\nimport { getChildTagsToDestroy } from './getChildTagsToDestroy.function.js';\nimport { smartRemoveKids } from './smartRemoveKids.function.js';\nexport function destroySupport(support, stagger) {\n    const global = support.subject.global;\n    global.deleted = true;\n    const context = global.context;\n    getChildTagsToDestroy(context);\n    if (global.destroy$) {\n        global.destroy$.next();\n        runBeforeDestroy(support);\n    }\n    // first paint\n    const promises = [];\n    stagger = smartRemoveKids(support, promises, stagger);\n    if (promises.length) {\n        return Promise.all(promises).then(() => stagger);\n    }\n    return stagger;\n}\n//# sourceMappingURL=destroySupport.function.js.map","// taggedjs-no-compile\nimport { paintAppends, paintInsertBefores, paintRemoves } from '../paint.function.js';\nimport { processFirstSubjectValue } from './processFirstSubjectValue.function.js';\nimport { checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nimport { updateExistingValue } from './updateExistingValue.function.js';\nimport { processNewArrayValue } from './processNewValue.function.js';\nimport { destroySupport } from '../destroySupport.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    if (!subject.lastArray) {\n        subject.lastArray = [];\n    }\n    let lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = subject.lastArray = lastArray.filter(function lastArrayFilter(item, index) {\n        const newRemoved = reviewLastArrayItem(item, value, index, lastArray, removed, counts);\n        removed = removed + newRemoved;\n        return newRemoved === 0;\n    });\n    // const eAppendTo = existed ? undefined : appendTo\n    const eAppendTo = appendTo; // existed ? undefined : appendTo\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, filteredLast, ownerSupport, runtimeInsertBefore, counts, eAppendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    return processAddTagArrayItem(item, runtimeInsertBefore, // thisInsert as any,\n    ownerSupport, counts, lastArray, appendTo);\n}\nfunction reviewPreviousArrayItem(item, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        updateExistingValue(itemSubject, item, ownerSupport);\n        return itemSubject;\n    }\n    const result = processAddTagArrayItem(item, runtimeInsertBefore, // thisInsert as any,\n    ownerSupport, counts, lastArray, appendTo);\n    return result;\n}\nfunction processAddTagArrayItem(value, before, // used during updates\nownerSupport, counts, lastArray, appendTo) {\n    const itemSubject = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        withinOwnerElement: false, // TODO: we need to pass down depth so we can answer this truthfully\n    };\n    counts.added = counts.added + 1; // index\n    const subPlaceholder = document.createTextNode('');\n    itemSubject.placeholder = subPlaceholder;\n    if (!appendTo) {\n        paintInsertBefores.push({\n            element: subPlaceholder,\n            relative: before,\n        });\n    }\n    processNewArrayValue(value, ownerSupport, itemSubject);\n    processFirstSubjectValue(value, itemSubject, ownerSupport, // support,\n    counts, `rvp_${lastArray.length}_array`, appendTo);\n    // after processing\n    itemSubject.value = value;\n    // Added to previous array\n    lastArray.push(itemSubject);\n    if (appendTo) {\n        paintAppends.push({\n            element: subPlaceholder,\n            relative: appendTo,\n        });\n    }\n    return itemSubject;\n}\nexport function destroyArrayItem(item, counts) {\n    const global = item.global;\n    const support = global.newest;\n    global.deleted = true;\n    if (support) {\n        destroySupport(support, counts.removed);\n    }\n    else {\n        const element = item.simpleValueElm;\n        delete item.simpleValueElm;\n        paintRemoves.push(element);\n    }\n    ++counts.removed;\n}\nfunction reviewLastArrayItem(subTag, value, index, lastArray, removed, counts) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    if (lessLength) {\n        destroyArrayItem(lastArray[index], counts);\n        ++removed;\n        return 1;\n    }\n    /*\n    const nowValue = getArrayValueByItem(subTag)\n    const lastArrayValue = lastArray.array[index].arrayValue\n    */\n    // check for html``.key()\n    /*\n    const keySet = 'arrayValue' in tag\n    if (!keySet) {\n      const details = {\n        array: value.map(item => item.values || item),\n        vdom: (tag as any)?.support.templater.tag.dom,\n        tag,\n        lastArray: lastArray.array[index]\n      }\n      const message = 'Found Tag in array without key value, during array update. Be sure to use \"html`...`.key(unique)\" OR import TaggedJs \"key\" \"key(unique).html = CustomTag(props)\"'\n      console.error(message, details)\n      const err = new ArrayNoKeyError(message, details)\n      throw err\n    }\n    */\n    /*\n    const destroyItem = nowValue !== lastArrayValue\n    if(destroyItem) {\n      destroyArrayItem(lastArray.array, index, counts)\n      ++removed\n      return 1\n    }\n    */\n    return 0;\n}\nfunction getArrayValueByItem(item) {\n    return item?.arrayValue || item;\n}\n//# sourceMappingURL=processTagArray.js.map","import { isArray, isStaticTag } from '../isInstance.js';\nimport { destroyArrayItem } from './update/processTagArray.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { paintRemoves } from './paint.function.js';\nimport { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { processUpdateRegularValue } from './update/processRegularValue.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        const lastArray = subject.lastArray;\n        destroyArray(subject, lastArray);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArray(subject, lastArray) {\n    const counts = { added: 0, removed: 0 };\n    delete subject.lastArray;\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index], counts);\n    }\n}\nexport function checkSimpleValueChange(newValue, subject) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, subject);\n        return -1; // no need to destroy, just update display\n    }\n    const elm = subject.simpleValueElm;\n    delete subject.simpleValueElm;\n    paintRemoves.push(elm);\n    return 6; // 'changed-simple-value'\n}\nexport function checkTagValueChange(newValue, subject) {\n    const global = subject.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, 0);\n            subject.global = getNewGlobal();\n            return 7; // 'tag-swap'\n        }\n        return false;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        return false; // its still a tag component\n    }\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, 0);\n    delete subject.global;\n    return 8; // 'no-longer-tag'\n}\n//# sourceMappingURL=checkDestroyPrevious.function.js.map","import { checkArrayValueChange, checkSimpleValueChange, checkTagValueChange } from '../checkDestroyPrevious.function.js';\nimport { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { newSupportByTemplater, processNewTag, processTag, tagFakeTemplater } from './processTag.function.js';\nimport { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { oneRenderToSupport } from './oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { isArray, isSubjectInstance } from '../../isInstance.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processTagArray } from './processTagArray.js';\nexport function processFirstSubjectValue(value, subject, // could be tag via result.tag\nownerSupport, // owning support\ncounts, // {added:0, removed:0}\nvalueId, appendTo) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.templater:\n                subject.checkValueChange = checkTagValueChange;\n                if (appendTo) {\n                    return processNewTag(value, ownerSupport, subject, appendTo);\n                }\n                return processTag(ownerSupport, subject);\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n                subject.checkValueChange = checkTagValueChange;\n                const tag = value;\n                let templater = tag.templater;\n                if (!templater) {\n                    templater = tagFakeTemplater(tag); // TODO: most likely a not needed performance hit\n                }\n                const global = subject.global = getNewGlobal();\n                if (appendTo) {\n                    return processNewTag(templater, ownerSupport, subject, appendTo);\n                }\n                global.newest = newSupportByTemplater(templater, ownerSupport, subject);\n                subject.checkValueChange = checkTagValueChange;\n                return processTag(ownerSupport, subject);\n            case ValueTypes.stateRender:\n            case ValueTypes.tagComponent:\n                subject.global = getNewGlobal();\n                subject.checkValueChange = checkTagValueChange;\n                if (appendTo) {\n                    const processResult = processFirstSubjectComponent(value, subject, ownerSupport, counts, appendTo);\n                    ++subject.global.renderCount;\n                    return processResult;\n                }\n                const processResult = processReplacementComponent(value, subject, ownerSupport, counts);\n                ++subject.global.renderCount;\n                return processResult;\n            case ValueTypes.renderOnce:\n                subject.global = getNewGlobal();\n                const support = oneRenderToSupport(value, subject, ownerSupport);\n                renderTagOnly(support, undefined, // support,\n                subject, ownerSupport);\n                const result = processNewTag(support.templater, ownerSupport, subject, appendTo);\n                ++subject.global.renderCount;\n                subject.checkValueChange = checkTagValueChange;\n                return result;\n        }\n    }\n    if (isArray(value)) {\n        processTagArray(subject, value, ownerSupport, counts, appendTo);\n        subject.checkValueChange = checkArrayValueChange;\n        return;\n    }\n    if (isSubjectInstance(value)) {\n        return; // will be subscribed to for value\n    }\n    processFirstRegularValue(value, subject, subject.placeholder, valueId);\n}\nfunction processFirstRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore, // <template end interpolate /> (will be removed)\nvalueId) {\n    const castedValue = castTextValue(value);\n    const clone = updateBeforeTemplate(castedValue, insertBefore);\n    clone.id = valueId;\n    subject.simpleValueElm = clone;\n    subject.checkValueChange = checkSimpleValueChange;\n}\n//# sourceMappingURL=processFirstSubjectValue.function.js.map","import { processFirstTagResult, processReplaceTagResult } from './processTagResult.function.js';\nimport { getSupport } from '../Support.class.js';\nimport { renderWithSupport } from '../render/renderWithSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag\n    subject, ownerSupport);\n    processReplaceTagResult(support, counts, subject);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag   \n    subject, ownerSupport);\n    processFirstTagResult(support, counts, appendTo);\n    return support;\n}\n//# sourceMappingURL=processFirstSubjectComponent.function.js.map","import { paintAppends } from '../paint.function.js';\nimport { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { checkTagValueChange } from '../index.js';\nexport function processReplaceTagResult(support, counts, contextItem) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const ph = contextItem.placeholder;\n    const result = buildBeforeElement(support, undefined, ph, { counts });\n    const subs = result.subs;\n    for (const sub of subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\nexport function processFirstTagResult(support, counts, appendTo) {\n    let appendIndex = paintAppends.length;\n    const result = buildBeforeElement(support, appendTo, undefined, { counts });\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.domElement,\n                relative: appendTo,\n            });\n        }\n        if (dom.marker) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.marker,\n                relative: appendTo,\n            });\n        }\n    }\n    const subs = result.subs;\n    for (const sub of subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\n//# sourceMappingURL=processTagResult.function.js.map","import { getTemplaterResult } from '../TemplaterResult.class.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nimport { PropWatches } from '../tag.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || (wrapper());\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.parentWrap = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.parentWrap.original = wrapper;\n    return support;\n}\n//# sourceMappingURL=oneRenderToSupport.function.js.map","import { processFirstSubjectValue } from '../tag/update/processFirstSubjectValue.function.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nimport { paint } from '../tag/paint.function.js';\nimport { processSubUpdate } from './processSubscriptionUpdate.function.js';\nexport function subscribeToTemplate({ subject, support, counts, contextItem, appendTo, }) {\n    let onValue = function onSubValue(value) {\n        processFirstSubjectValue(value, contextItem, support, { ...counts }, `rvp_-1_${support.templater.tag?.values.length}`, syncRun ? appendTo : undefined);\n        if (!syncRun && !setUseMemory.stateConfig.support) {\n            paint();\n        }\n        // from now on just run update\n        onValue = function subscriptionUpdate(value) {\n            processSubUpdate(value, contextItem, support);\n        };\n    };\n    const callback = function subValueProcessor(value) {\n        onValue(value);\n    };\n    let syncRun = true;\n    const sub = subject.subscribe(callback);\n    contextItem.subject = subject;\n    syncRun = false;\n    const global = support.subject.global;\n    const subs = global.subscriptions = global.subscriptions || [];\n    subs.push(sub);\n}\n//# sourceMappingURL=subscribeToTemplate.function.js.map","import { updateExistingValue } from '../tag/update/updateExistingValue.function.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nimport { paint } from '../tag/paint.function.js';\nexport function processSubUpdate(value, contextItem, support) {\n    if (value === contextItem.value) {\n        return; // same value emitted\n    }\n    updateExistingValue(contextItem, value, support);\n    if (!setUseMemory.stateConfig.support) {\n        paint();\n    }\n    return;\n}\n//# sourceMappingURL=processSubscriptionUpdate.function.js.map","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    const nowState = setUseMemory.stateConfig.array;\n    useSupport.state = nowState;\n    return useSupport;\n}\n//# sourceMappingURL=executeWrap.function.js.map","import { getSupport } from './Support.class.js';\nimport { castProps } from '../alterProp.function.js';\nimport { syncFunctionProps } from './update/updateExistingTagComponent.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { PropWatches } from './tag.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = getSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as Support,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n//# sourceMappingURL=getTagWrap.function.js.map","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from './TemplaterResult.class.js';\nimport { tags } from './tag.utils.js';\nimport { getTagWrap } from './getTagWrap.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { key } from './key.js';\nlet tagCount = 0;\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = (function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        if (!innerTagWrap.parentWrap) {\n            innerTagWrap.parentWrap = parentWrap;\n        }\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }) // we override the function provided and pretend original is what's returned\n    ;\n    parentWrap.original = tagComponent;\n    // parentWrap.compareTo = (tagComponent as any).toString()\n    const tag = tagComponent;\n    parentWrap.original = tag;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Used to create a tag component that renders once and has no addition rendering cycles */\ntag.renderOnce = function () {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n};\n/** Used to create variable scoping when calling a function that lives within a prop container function */\ntag.state = function () {\n    throw new Error('Do not call tag.state as a function but instead set it as: `(props) => tag.state = (state) => html`` `');\n};\n// TODO???: Is tag.route and tag.app in use?\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.route = function (routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.key = key;\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.app = function (routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.deepPropWatch = tag;\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n    },\n});\nObject.defineProperty(tag, 'state', {\n    set(renderFunction) {\n        ;\n        renderFunction.parentWrap = {\n            original: {\n                setUse: setUseMemory,\n                tags,\n            }\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n    },\n});\n//# sourceMappingURL=tag.js.map","/** Used to give unique value to an array of tag content. Should not be an object */\nexport function key(arrayValue) {\n    return {\n        set html(newValue) {\n            newValue.arrayValue = arrayValue;\n        }\n    };\n}\n//# sourceMappingURL=key.js.map","import { ValueTypes } from './ValueTypes.enum.js';\nimport { cloneTagJsValue } from './cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { PropWatches } from './tag.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(x => cloneTagJsValue(x, shallowCompareDepth)),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(props => cloneTagJsValue(props, deepCompareDepth)),\n        castProps,\n    };\n}\n//# sourceMappingURL=clonePropsBy.function.js.map","import { getSupport } from '../Support.class.js';\nimport { runAfterRender } from '../tagRunner.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { executeWrap } from '../executeWrap.function.js';\nimport { initState, reState } from '../../state/state.utils.js';\nimport { setUseMemory } from '../../state/setUse.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    const global = subject.global;\n    const oldRenderCount = global.renderCount;\n    beforeWithRender(newSupport, prevSupport?.state);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        const useSupport = getSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as Support,\n        subject);\n        reSupport = executeWrap(templater, result, useSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    /* AFTER */\n    runAfterRender(newSupport, ownerSupport);\n    global.newest = reSupport;\n    // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n    if (global.renderCount > oldRenderCount + 1) {\n        return global.newest;\n    }\n    return reSupport;\n}\nfunction beforeWithRender(support, // new\nprevState) {\n    if (prevState) {\n        const lastState = prevState;\n        support.state = lastState;\n        reState(support, setUseMemory.stateConfig);\n        return;\n    }\n    // first time render\n    initState(support, setUseMemory.stateConfig);\n}\n//# sourceMappingURL=renderTagOnly.function.js.map","import { getChildTagsToSoftDestroy } from '../getChildTagsToDestroy.function.js';\nimport { smartRemoveKids } from '../smartRemoveKids.function.js';\nimport { getNewGlobal } from '../update/getNewGlobal.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const global = lastSupport.subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.context);\n    softDestroyOne(lastSupport);\n    for (const child of tags) {\n        softDestroyOne(child);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(sub => sub.unsubscribe());\n    }\n    lastSupport.subject.global = getNewGlobal();\n}\nfunction softDestroyOne(child) {\n    const global = child.subject.global;\n    if (global.deleted === true) {\n        return;\n    }\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(child, [], 0);\n}\n//# sourceMappingURL=softDestroySupport.function.js.map","import { isLikeTags } from '../isLikeTags.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { moveProviders } from '../update/updateExistingTagComponent.function.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.subject.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        const global = subject.global;\n        if (tag && global.renderCount > 1) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n//# sourceMappingURL=renderWithSupport.function.js.map","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from '../update/processTag.function.js';\nimport { updateSupportBy } from '../updateSupportBy.function.js';\nexport function renderExistingReadyTag(lastSupport, newSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const global = subject.global;\n    const { support, wasLikeTags } = renderWithSupport(newSupport, lastSupport, subject, ownerSupport);\n    if (wasLikeTags) {\n        updateSupportBy(global.oldest, support);\n        // updateSupportValuesBy(oldest, support)\n        // paint()\n        return support;\n    }\n    processTag(ownerSupport, subject);\n    return support;\n}\n//# sourceMappingURL=renderExistingTag.function.js.map","import { setUseMemory } from './setUse.function.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport callbackStateUpdate from './callbackStateUpdate.function.js';\nlet innerCallback = (callback) => (a, b, c, d, e, f) => {\n    throw new SyncCallbackError('Callback function was called immediately in sync and must instead be call async');\n};\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig.array;\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nconst syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig.array, callback);\n}\nfunction createTrigger(support, oldState, toCallback) {\n    return function trigger(...args) {\n        const global = support.subject.global;\n        const callbackMaker = global.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, toCallback, oldState, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n//# sourceMappingURL=callbackMaker.function.js.map","import { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { syncStates } from './syncStates.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, callback, oldState, ...args) {\n    const global = support.subject.global;\n    support = global.newest; // || support\n    const state = support.state;\n    // ensure that the oldest has the latest values first\n    syncStates(state, oldState);\n    // run the callback\n    const maybePromise = callback(...args);\n    // send the oldest state changes into the newest\n    syncStates(oldState, state);\n    renderSupport(support);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            syncStates(oldState, state);\n            renderSupport(support);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n//# sourceMappingURL=callbackStateUpdate.function.js.map","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\n//# sourceMappingURL=getSupportInCycle.function.js.map","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        strings: strings,\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    return tag;\n}\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    return tag;\n}\n//# sourceMappingURL=Tag.class.js.map","// taggedjs-no-compile\nimport { variableSuffix, variablePrefix } from \"../../tag/Tag.class.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nconst placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nconst at = 'at'; // short for attribute\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, ...[{\n                    nn: 'text',\n                    v: wIndex\n                }]);\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    return attributes.map(attrSet => {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [{ tagJsVar: index }];\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [key, { tagJsVar: index }, isSpecial];\n            }\n        }\n        return attrSet;\n    });\n}\n//# sourceMappingURL=replacePlaceholders.function.js.map","import { getStringTag, getDomTag } from './Tag.class.js';\nimport { PropWatches } from './tag.js';\nimport { getTemplaterResult } from './TemplaterResult.class.js';\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n//# sourceMappingURL=html.js.map","import { getBaseSupport } from './Support.class.js';\nimport { subscribeToTemplate } from '../interpolations/subscribeToTemplate.function.js';\nimport { buildBeforeElement } from './buildBeforeElement.function.js';\nimport { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { checkTagValueChange, PropWatches } from './index.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { runAfterRender } from './tagRunner.js';\nconst appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        destroySupport(appElements[appElmIndex].support, 0);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    // todo: props should be an array\n    templater.props = [props];\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest, setUseMemory.stateConfig);\n    let templater2 = app(props);\n    if (typeof templater2 !== BasicTypes.function) {\n        if (!isTagComponent(templater2)) {\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const placeholder = document.createTextNode('');\n    const support = runWrapper(templater, placeholder, element, subject);\n    global.isApp = true;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        destroySupport(support, 0); // never return anything here\n        paint();\n    };\n    let tags = [];\n    ++painting.locks;\n    const result = buildBeforeElement(support, element);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const parentWrap = wrap.parentWrap;\n        const original = wrap.original || parentWrap.original;\n        setUse = original.setUse;\n        tags = app.original.tags;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    for (const sub of result.subs) {\n        subscribeToTemplate(sub);\n    }\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    ++global.renderCount;\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nfunction getNewSubject(templater, appElement) {\n    const global = getNewGlobal();\n    global.events = {};\n    const subject = {\n        value: templater,\n        global,\n        checkValueChange: checkTagValueChange,\n        withinOwnerElement: false, // i am the highest owner\n    };\n    const newSupport = getBaseSupport(templater, subject);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return subject;\n}\nexport function runWrapper(templater, placeholder, appElement, subject) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const newSupport = global.newest;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater.wrapper || { original: templater };\n        const nowSupport = executeWrap(templater, result, newSupport);\n        runAfterRender(newSupport, nowSupport);\n        return nowSupport;\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport, nowSupport);\n    return nowSupport;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n//# sourceMappingURL=tagElement.js.map","export * from './tag/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport * from './state/index.js';\nexport * from './subject/index.js';\nexport * from './interpolations/index.js';\nexport * from './tag/Support.class.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './interpolations/attributes/ElementTargetEvent.interface.js';\nimport { renderTagOnly } from './tag/render/renderTagOnly.function.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nexport { key } from './tag/key.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './tag/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n//# sourceMappingURL=index.js.map","import { html, letState, tag } from \"taggedjs\";\n// Performance boost to not render if props non-mutating props did not change\nexport const Item = tag.immutableProps((todo, dispatch, index) => (editing = letState(false)(x => [editing, editing = x])) => {\n    return html.dom(allStrings.allStrings139406[0], todo.completed, editing, !editing ? html.dom(allStrings.allStrings139406[1], todo.completed && 'checked', () => dispatch.toggleItem(todo, index), () => editing = !editing, todo.title, () => dispatch.removeItemByIndex(index)) : html.dom(allStrings.allStrings139406[2], todo.title, () => editing = false, e => handleKey(e, title => {\n        handleUpdate(title, todo, index, dispatch);\n        editing = false;\n    })));\n});\nfunction handleUpdate(title, todo, index, dispatch) {\n    if (title.length === 0) {\n        dispatch.removeItem(todo.id);\n        return;\n    }\n    dispatch.updateToByIndex(todo, { title }, index);\n}\nexport function handleKey(e, onValid) {\n    if (e.key === \"Enter\") {\n        const value = e.target.value.trim();\n        onValid(value);\n        return true;\n    }\n}\n;\n// @ts-ignore\nconst allStrings = { allStrings139406: [[{ \"nn\": \"li\", \"at\": [[\"class.completed\", { \"tagJsVar\": 0 }, \"class\"], [\"class.editing\", { \"tagJsVar\": 1 }, \"class\"]], \"ch\": [{ \"nn\": \"text\", \"v\": 2 }] }], [{ \"nn\": \"div\", \"at\": [[\"class\", \"view\"]], \"ch\": [{ \"nn\": \"input\", \"at\": [[\"class\", \"toggle\"], [\"type\", \"checkbox\"], [{ \"tagJsVar\": 0 }], [\"change\", { \"tagJsVar\": 1 }, null]] }, { \"nn\": \"label\", \"at\": [[\"data-testid\", \"todo-item-label\"], [\"dblclick\", { \"tagJsVar\": 2 }, null]], \"ch\": [{ \"nn\": \"text\", \"v\": 3 }] }, { \"nn\": \"button\", \"at\": [[\"class\", \"destroy\"], [\"click\", { \"tagJsVar\": 4 }, null]] }] }], [{ \"nn\": \"div\", \"at\": [[\"class\", \"input-container\"]], \"ch\": [{ \"nn\": \"input\", \"at\": [[\"id\", \"edit-todo-input\"], [\"type\", \"text\"], [\"autofocus\"], [\"class\", \"edit\"], [\"value\", { \"tagJsVar\": 0 }, null], [\"blur\", { \"tagJsVar\": 1 }, null], [\"keydown\", { \"tagJsVar\": 2 }, null]] }, { \"nn\": \"label\", \"at\": [[\"class\", \"visually-hidden\"], [\"htmlfor\", \"todo-input\"]], \"ch\": [{ \"nn\": \"text\", \"tc\": \"Edit Todo Input\" }] }] }]] };\n","import { html, tag } from 'taggedjs';\nimport { handleKey } from './item.tag';\nexport const Header = (dispatch) => tag.renderOnce = () => html.dom(allStrings.allStrings42493[0], e => {\n    const enter = handleKey(e, title => dispatch.addItem(title));\n    if (enter) {\n        e.target.value = \"\";\n    }\n});\n// @ts-ignore\nconst allStrings = { allStrings42493: [[{ \"nn\": \"header\", \"at\": [[\"class\", \"header\"], [\"data-testid\", \"header\"]], \"ch\": [{ \"nn\": \"h1\", \"ch\": [{ \"nn\": \"text\", \"tc\": \"todos\" }] }, { \"nn\": \"input\", \"at\": [[\"autofocus\"], [\"class\", \"new-todo\"], [\"placeholder\", \"What needs to be done?\"], [\"keydown\", { \"tagJsVar\": 0 }, null]] }] }]] };\n","import { tag, html } from 'taggedjs';\n// Performance boost to not render if props non-mutating props did not change\nexport const Footer = tag.immutableProps((todosCount, removeCompleted, route, activeTodoCount) => html.dom(allStrings.allStrings73580[0], activeTodoCount, activeTodoCount > 1 && \"s\", route === \"/\", route === \"/active\", route === \"/completed\", (todosCount - activeTodoCount) > 0 && html.dom(allStrings.allStrings73580[1], () => removeCompleted())));\n// @ts-ignore\nconst allStrings = { allStrings73580: [[{ \"nn\": \"footer\", \"at\": [[\"class\", \"footer\"], [\"data-testid\", \"footer\"]], \"ch\": [{ \"nn\": \"div\", \"ch\": [{ \"nn\": \"span\", \"at\": [[\"class\", \"todo-count\"]], \"ch\": [{ \"nn\": \"text\", \"v\": 0 }, { \"nn\": \"text\", \"tc\": \" item\" }, { \"nn\": \"text\", \"v\": 1 }, { \"nn\": \"text\", \"tc\": \" left!\" }] }, { \"nn\": \"ul\", \"at\": [[\"class\", \"filters\"]], \"ch\": [{ \"nn\": \"li\", \"ch\": [{ \"nn\": \"a\", \"at\": [[\"class.selected\", { \"tagJsVar\": 2 }, \"class\"], [\"href\", \"#/\"]], \"ch\": [{ \"nn\": \"text\", \"tc\": \"All\" }] }] }, { \"nn\": \"li\", \"ch\": [{ \"nn\": \"a\", \"at\": [[\"class.selected\", { \"tagJsVar\": 3 }, \"class\"], [\"href\", \"#/active\"]], \"ch\": [{ \"nn\": \"text\", \"tc\": \"Active\" }] }] }, { \"nn\": \"li\", \"ch\": [{ \"nn\": \"a\", \"at\": [[\"class.selected\", { \"tagJsVar\": 4 }, \"class\"], [\"href\", \"#/completed\"]], \"ch\": [{ \"nn\": \"text\", \"tc\": \"Completed\" }] }] }] }, { \"nn\": \"text\", \"v\": 5 }] }] }], [{ \"nn\": \"button\", \"at\": [[\"class\", \"clear-completed\"], [\"click\", { \"tagJsVar\": 0 }, null]], \"ch\": [{ \"nn\": \"text\", \"tc\": \"Clear completed\" }] }]] };\n","import { callback, onDestroy, state } from \"taggedjs\";\nconst getHash = () => window.location.hash.substring(1) || '/';\nconst HashRouter = () => {\n    const memory = { route: getHash() };\n    const onHashChange = callback(() => memory.route = getHash());\n    window.addEventListener('hashchange', onHashChange);\n    return { memory, onHashChange };\n};\nexport const useHashRouter = () => {\n    const { memory, onHashChange } = state(() => HashRouter());\n    onDestroy(() => window.removeEventListener('hashchange', onHashChange));\n    return memory;\n};\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.subject.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n//# sourceMappingURL=onDestroy.js.map","import { Header } from './tags/header.tag';\nimport { Footer } from './tags/footer.tag';\nimport { todoReducer } from './reducer';\nimport { html } from 'taggedjs';\nimport { useHashRouter } from './HashRouter.function';\nimport { Item } from './tags/item.tag';\nexport const todos = [];\nconst dispatch = todoReducer(todos);\nexport const app = () => {\n    const route = useHashRouter().route;\n    const activeTodoCount = todos.filter((todo) => !todo.completed).length;\n    const visibleTodos = todos.filter((todo) => {\n        if (route === \"/active\")\n            return !todo.completed;\n        if (route === \"/completed\")\n            return todo.completed;\n        return true;\n    });\n    const todoCount = todos.length;\n    return html.dom(allStrings.allStrings115711[0], Header(dispatch), todoCount > 0 && html.dom(allStrings.allStrings115711[1], activeTodoCount < 1, e => dispatch.toggleAll(e.target.checked), visibleTodos.map((todo, index) => Item(todo, dispatch, index).key(todo.id)), Footer(todoCount, dispatch.removeCompleted, route, activeTodoCount)));\n};\n// @ts-ignore\nconst allStrings = { allStrings115711: [[{ \"nn\": \"section\", \"at\": [[\"class\", \"todoapp\"]], \"ch\": [{ \"nn\": \"text\", \"v\": 0 }, { \"nn\": \"text\", \"tc\": \"\\n      \" }, { \"nn\": \"text\", \"v\": 1 }] }], [{ \"nn\": \"main\", \"at\": [[\"class\", \"main\"]], \"ch\": [{ \"nn\": \"div\", \"at\": [[\"class\", \"toggle-all-container\"]], \"ch\": [{ \"nn\": \"input\", \"at\": [[\"id\", \"toggle-all\"], [\"class\", \"toggle-all\"], [\"type\", \"checkbox\"], [\"checked\", { \"tagJsVar\": 0 }, null], [\"change\", { \"tagJsVar\": 1 }, null]] }, { \"nn\": \"label\", \"at\": [[\"class\", \"toggle-all-label\"], [\"for\", \"toggle-all\"]], \"ch\": [{ \"nn\": \"text\", \"tc\": \"Toggle All Input\" }] }] }, { \"nn\": \"ul\", \"at\": [[\"class\", \"todo-list show-priority\"]], \"ch\": [{ \"nn\": \"text\", \"v\": 2 }] }] }, { \"nn\": \"text\", \"v\": 3 }, { \"nn\": \"text\", \"tc\": \"\\n      \" }]] };\n","function uuid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        var r = (Math.random() * 16) | 0, v = c === \"x\" ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nexport function todoReducer(todos) {\n    function addItem(title) {\n        todos.push({ id: uuid(), title, completed: false });\n        return todos;\n    }\n    function removeItem(id) {\n        return todos.filter((t) => t.id !== id);\n    }\n    function removeItemByIndex(index) {\n        todos.splice(index, 1);\n        return todos;\n    }\n    function toggleItem(todo, index) {\n        return updateToByIndex(todo, { completed: !todo.completed }, index);\n    }\n    function removeAll() {\n        todos = [];\n        return todos;\n    }\n    function toggleAll(completed) {\n        for (let index = todos.length - 1; index >= 0; --index) {\n            todos[index] = {\n                ...todos[index],\n                completed,\n            };\n        }\n        return todos;\n    }\n    function removeCompleted() {\n        for (let index = todos.length - 1; index >= 0; --index) {\n            if (todos[index].completed) {\n                todos.splice(index, 1);\n            }\n        }\n        return todos;\n    }\n    function updateToByIndex(todo, partial, index) {\n        todos[index] = { ...todo, ...partial };\n        return todos;\n    }\n    return {\n        addItem,\n        removeItem,\n        toggleItem,\n        removeAll,\n        toggleAll,\n        removeCompleted,\n        removeItemByIndex,\n        completeItem: function completeItem(todo, index) {\n            return updateToByIndex(todo, { completed: true }, index);\n        },\n        updateItemByIndex: function updateItemByIndex(todo, index) {\n            todos[index] = { ...todo };\n            return todos;\n        },\n        updateToByIndex,\n    };\n}\n;\n","import { tagElement } from \"taggedjs\";\nimport { app } from './app.tag';\nexport default function run() {\n    tagElement(app, document.getElementsByTagName('app')[0]);\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","empty","BasicTypes","ImmutableTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","subject","tagJsSubject","renderOnce","stateRender","version","Date","now","isStaticTag","value","tagJsType","isTagComponent","tagType","isSubjectInstance","isObject","subscribe","function","isPromise","isFunction","then","object","isArray","Array","getSubscription","callback","subscribers","countSubject","Subject","globalSubCount$","next","subscription","unsubscribe","subscriptions","index","findIndex","sub","splice","removeSubFromArray","valSub","add","push","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","shift","newValue","length","handler","methodResponse","setHandler","x","onSubscription","isSubject","subscribeWith","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","_subscription","pipe","operations","setMethods","all","args","subjects","output","valuesSeen","values","setValue","item","clones","map","combineLatest","arg","static","ValueSubject","super","runRestate","config","stateConfig","restate","rearray","array","defaultValue","runFirstState","initValue","original","getStateValue","initState","support","handlers","letHandler","firstLetState","StateEchoBack","state","checkValue","oldState","getCallbackValue","makeStateResult","reLetState","oldValue","y","syncStates","stateFrom","stateTo","fromValue","setState","s","defaultFinally","setupWatch","currentValues","init","before","final","previous","pastResult","undefined","previousValues","result","every","defineOnMethod","getWatch","attachTo","watch","setup","oldWatch","firstSupport","method","nowSupport","setTo","oldestState","newWatch","_value","TagError","Error","details","message","errorCode","name","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","isLikeTags","support0","support1","templater0","templater1","tag0","tag1","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","string","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","cloneValueArray","cloneTagJsValue","getTemplaterResult","propWatch","props","arrayValue","tags","castProps","newSupport","depth","ownerSupport","checkProp","alterProp","already","mem","wrap","toCall","callWith","global","newest","noCycle","callbackResult","run","locked","isInline","isInlineHtml","renderInlineHtml","renderExistingReadyTag","safeRenderSupport","tagClosed$","callbackPropOwner","assign","getPropWrap","deepCompareDepth","isSkipPropValue","subValue","afterCheckProp","getset","getOwnPropertyDescriptor","originalValue","newProp","destroy$","paintRemoves","paintContent","setContent","paintAppends","paintInsertBefores","paintAfters","painting","locks","paint","toRemove","parentNode","removeChild","content","text","textNode","textContent","relative","appendChild","element","insertBefore","howToSetInputValue","setAttribute","removeAttribute","specialAttribute","specialName","nextSibling","counts","onInitDoubleWrap","oninit","added","onInitWrap","tagFunction","onInit","target","stagger","elementInitCheck","removed","focus","select","names","split","style","classList","remove","processSpecialClass","handleProviderChanges","appSupport","provider","tagsWithProvider","memory","renderCount","childTags","children","child","cGlobal","getTagsWithProvider","getUpTags","supports","inlineHtml","isComponent","continueUp","selfPropChange","nowProps","propsConfig","latestProps","latest","hasPropLengthsChanged","PropWatches","IMMUTABLE","immutablePropMatch","SHALLOW","shallowPropMatch","hasPropsToOwnerChanged","checkRenderUp","proSupports","providers","prosWithChanges","hasChange","owner","providersChangeCheck","renderTagUpdateArray","forEach","mapTagUpdate","noData","promiseNoData","bindSubjectCallback","subjectFunction","deleted","bindTo","component","apply","eventHandlerSupport","last","checkAfterCallbackPromise","renderCallbackSupport","afterTagCallback","runTagCallback","processNonDynamicAttr","attrName","howToSet","isSpecial","addSupportEventListener","eventName","elm","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","processAttributeFunction","newAttrValue","fun","isSpecialAttr","startsWith","specialAction","isSpecialAction","processAttribute","context","nameVar","getTagJsVar","contextItem","addOneContext","isAttr","isNameOnly","processNameOnlyAttrValue","valueVar","checkValueChange","checkSimpleValueChange","withinOwnerElement","contextValueSubject","processAttributeEmit","processNameValueAttributeAttrSubject","processTagCallbackFun","processDynamicNameValueAttribute","attrValue","isNoDisplayValue","wrapper","parentWrap","processAttributeSubjectValue","callbackFun","prevFun","attrPart","tagJsVar","attachDomElements","nodes","document","createElement","node","newNode","v","isNaN","attachDynamicDom","nn","tc","innerHTML","domElement","createTextNode","innerText","id","at","attr","ch","subVal","marker","placeholder","appendTo","processFirstSubjectValue","buildBeforeElement","options","oldest","domMeta","thisTag","stringId","Number","join","getStringsId","lastRun","lastRuns","matches","isLastRunMatched","domMetaMap","htmlInterpolationToPlaceholders","htmlString","html","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","regexTagOrg","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","splitByTagVar","variablePrefix","variableSuffix","pushTextTo","pop","attributes","attrMatch","regexAttr","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","search","attrSet","parseHTML","htmlInterpolationToDomMeta","replacePlaceholders","traverseAndRestore","template","interpolation","getDomMeta","loadDomMeta","getHtmlDomMeta","htmlDomMeta","processTag","checkTagValueChange","subscribeToTemplate","getFakeTemplater","newSupportByTemplater","castedProps","getHtmlSupport","processNewTag","updateBeforeTemplate","lastFirstChild","castTextValue","processUpdateAttrContext","updateNameOnlyAttrValue","processUpdateOneContext","updateExistingValue","updateSupportBy","olderSupport","newerSupport","tempTag","updateSupportValuesBy","len","processUpdateContext","wasDestroyed","processReplacementComponent","getSupport","lastSupport","oldWrapper","newWrapper","isSameTag","skipComparing","oldestSupport","destroySupport","swapTags","hasChanged","newTemplater","pastCloneProps","propsChanged","hasLenChanged","NONE","castedPastProps","allFunctionsMatch","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","hasPropChanges","hasSupportChanged","newProps","syncFunctionProps","lastPropsConfig","syncSupports","DEEP","shallowCompareDepth","blocked","updateExistingTagComponent","prepareUpdateToComponent","valueSupport","newGlobal","handleStillTag","processTagArray","castedValue","simpleValueElm","processNowRegularValue","runAfterRender","afterRender","runBeforeDestroy","getChildTagsToDestroy","lastArray","iSubs","iSub","getChildTagsToSoftDestroy","subTags","smartRemoveKids","promises","startStagger","thisGlobal","destroyArray","oldClones","newPromises","customElm","ondestroy","promise","onDestroyWrap","onDestroy","elementDestroyCheck","checkCloneRemoval","filter","destroyClones","runtimeInsertBefore","filteredLast","newRemoved","subTag","newLength","lessLength","destroyArrayItem","reviewLastArrayItem","eAppendTo","reviewArrayItem","itemSubject","couldBeSame","processAddTagArrayItem","reviewPreviousArrayItem","subPlaceholder","processNewArrayValue","checkArrayValueChange","oldClone","processUpdateRegularValue","isTag","valueId","tagFakeTemplater","processResult","newPropsConfig","getCastedProps","renderWithSupport","appendIndex","processFirstTagResult","processFirstSubjectComponent","oneRenderToSupport","renderTagOnly","processFirstRegularValue","onValue","syncRun","processSubUpdate","processReplaceTagResult","newPropsArray","priorPropsArray","newArray","syncPriorPropFunction","priorProp","hasSetter","executeWrap","useSupport","originalFunction","nowState","preCastedProps","lastCastProps","tagCount","innerTagWrap","getTagWrap","setUse","tagIndex","pastProp","obEntries","subItem","objectItemMatches","route","routeProps","app","routeTag","deepPropWatch","immutableProps","watchProps","oneRenderFunction","renderFunction","onDelete","compareOriginal","pastValue","getBaseSupport","baseSupport","clonePropsBy","prevSupport","oldRenderCount","prevState","lastState","reState","beforeWithRender","reSupport","softDestroySupport","softDestroyOne","lastTemplater","lastTag","isLikeTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","lastOwnerSupport","wasLikeTags","ownGlobal","syncError","createTrigger","maybePromise","finally","callbackStateUpdate","ondoubleclick","fragFindAny","fragReplacer","safeVar","results","fragment","diff","balanceArrayByArrays","addPlaceholders","inputString","part","pushTo","postprocessTagsInComments","placeholderRegex","valueCount","currentTail","loopTail","attrs","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","safeReplacer","_match","stringTag","getStringTag","getDomTag","appElements","tagElement","appElmIndex","appElm","console","warn","templater2","getNewSubject","runWrapper","isApp","destroy","removeEventListener","newFragment","createDocumentFragment","domItem","putOneDomDown","Item","todo","dispatch","editing","allStrings","allStrings139406","completed","title","e","handleKey","removeItem","updateToByIndex","handleUpdate","toggleItem","removeItemByIndex","onValid","allStrings42493","Footer","todosCount","removeCompleted","activeTodoCount","allStrings73580","getHash","window","location","hash","substring","HashRouter","onHashChange","useHashRouter","todos","partial","addItem","c","r","Math","random","t","removeAll","toggleAll","completeItem","updateItemByIndex","todoReducer","visibleTodos","todoCount","allStrings115711","Header","checked","getElementsByTagName"],"sourceRoot":""}