{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContext.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/render/afterRender.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/tag/update/deleteSubContext.function.ts","webpack://taggedjs/./ts/tag/update/checkSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribe.function.ts","webpack://taggedjs/./ts/subject/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/state/subscribeWith.function.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/restorePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/render/registerNewTagElement.function.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(subject) {\n    ;\n    subject.renderCount = subject.renderCount || 0;\n    // ;(subject as SupportContextItem).renderCount = 0\n    return subject.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    // subject: 'subject',\n    // tagJsSubject: 'tagJsSubject',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","import { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push(() => howToSetFirstInputValue(element, name, value));\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles init, destroy, autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName, support, counts) {\n    switch (specialName) {\n        // case 'oninit' as any:\n        case 'init': {\n            const stagger = counts.added;\n            // run delayed after elements placed down\n            paintAfters.push(function paintSpecialAttribute() {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                value(event); // call init/oninit\n            });\n            return;\n        }\n        case 'destroy': {\n            const stagger = ++counts.removed;\n            const global = support.subject.global;\n            global.destroys = global.destroys || [];\n            global.destroys.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                return value(event); // call destroy/ondestroy\n            });\n            return;\n        }\n        case 'autofocus':\n            paintAfters.push(() => element.focus());\n            return;\n        case 'autoselect':\n            paintAfters.push(() => element.select());\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push(() => element.style[names[1]] = value); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push(() => element.classList.add(name));\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push(() => element.classList.remove(name));\n    }\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, subject, castedProps) {\n    const baseSupport = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    // baseSupport.appSupport = baseSupport\n    const global = subject.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.subject.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.subject.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContext(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContext(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.delete(child, ownerSupport);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.context;\n        // recurse\n        destroyContext(subTags, support);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.context;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nimport { destroySupport } from '../../render/destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed, counts) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext, counts);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, counts, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, counts, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext, counts);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item, counts) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n    ++counts.removed;\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n    }\n    else {\n        const element = item.simpleValueElm;\n        delete item.simpleValueElm;\n        paintCommands.push({\n            processor: paintRemover,\n            args: [element],\n        });\n    }\n}\n","import { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContextItem(subject);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArrayContextItem(subject) {\n    const lastArray = subject.lastArray;\n    destroyArray(subject, lastArray);\n}\nexport function destroyArray(subject, lastArray) {\n    const counts = { added: 0, removed: 0 };\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index], counts);\n    }\n    delete subject.lastArray;\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { paint, paintCommands, painting, paintRemover } from '../render/paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.context;\n    // already set\n    // global.deleted = true\n    const destroys = global.destroys;\n    if (destroys) {\n        return processContextDestroys(destroys, global, allPromises);\n    }\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\nconst promises = [];\nfunction destroyCall(destroy) {\n    const maybePromise = destroy();\n    const isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        promises.push(maybePromise);\n    }\n}\n// Elements that have a destroy or ondestroy attribute\nfunction processContextDestroys(destroys, global, allPromises) {\n    promises.length = 0;\n    destroys.forEach(destroyCall);\n    if (promises.length) {\n        const lastPromise = Promise.all(promises)\n            .then(() => {\n            ++painting.locks;\n            // continue to remove\n            smartRemoveByContext(global.context, allPromises);\n            destroyClones(global);\n            --painting.locks;\n            paint();\n        });\n        // run destroy animations\n        allPromises.push(lastPromise);\n        return;\n    }\n    ++painting.locks;\n    smartRemoveByContext(global.context, allPromises);\n    destroyClones(global);\n    --painting.locks;\n    paint();\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.withinOwnerElement) {\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintCommands.push({\n                processor: paintRemover,\n                args: [elm],\n            });\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    htmlDomMeta.forEach(destroyClone);\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        paintCommands.push({\n            processor: paintRemover,\n            args: [marker],\n        });\n    }\n    const dom = clone.domElement;\n    if (!dom) {\n        return;\n    }\n    paintCommands.push({\n        processor: paintRemover,\n        args: [dom],\n    });\n}\n","import { destroyContext } from '../tag/destroyContext.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.subject;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.context;\n    destroyContext(context, support);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag; // || (support1 as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (tag0.tagJsType) {\n        case ValueTypes.dom: {\n            if (tag1?.tagJsType !== ValueTypes.dom) {\n                return false; // tag0 is not even same type\n            }\n            return isLikeDomTags(tag0, tag1);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(tag0, tag1, support0, support1);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${tag0.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(tag0, tag1) {\n    const domMeta0 = tag0.dom;\n    const domMeta1 = tag1.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(tag0, tag1, support0, // new\nsupport1) {\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.templater.values || tag0.values;\n    const values1 = support1.templater.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","import { BasicTypes } from \"../index.js\";\nimport { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintRemover } from \"../render/paint.function.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInit: processSimpleValueInit,\n        checkValueChange: checkSimpleValueChange,\n        delete: deleteSimpleValue,\n    };\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    // value = value.value\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = {\n        processor: paintBeforeText,\n        args: [insertBefore, castedValue, (x) => {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }],\n    };\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(contextItem) {\n    const elm = contextItem.simpleValueElm;\n    delete contextItem.simpleValueElm;\n    delete contextItem.tagJsVar;\n    paintCommands.push({\n        processor: paintRemover,\n        args: [elm],\n    });\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return -1; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text\n        contextItem.paint.args[1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    setContent.push([castedValue, oldClone]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = {\n        processor: paintBeforeText,\n        args: [before, castedValue, (x) => {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }],\n    };\n    paintCommands.push(paint);\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.subject;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const context = [];\n    const global = support.subject.global;\n    global.context = context;\n    const result = attachDomElements(domMeta, values, support, counts, context, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingReadyTag } from '../../render/renderExistingTag.function.js';\nimport { getSupportInCycle } from '../getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(function eachCastProp(prop) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, depth);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const global = newest.subject.global;\n        if (!global || global.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest, ownerSupport);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\nexport function safeRenderSupport(newest, ownerSupport) {\n    const subject = newest.subject;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        const result = renderInlineHtml(ownerSupport, newest);\n        return result;\n    }\n    const global = subject.global;\n    global.locked = true;\n    renderExistingReadyTag(global.newest, newest, ownerSupport, subject);\n    delete global.locked;\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.subject.global.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nexport function initState(support, config) {\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.support = support;\n}\nexport function reState(newSupport, prevSupport, config, prevState) {\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    config.support = useSupport;\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { processFirstTagResult, processReplaceTagResult } from './processTagResult.function.js';\nimport { renderWithSupport } from '../../render/renderWithSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag\n    subject, ownerSupport);\n    processReplaceTagResult(support, counts, subject);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag   \n    subject, ownerSupport);\n    processFirstTagResult(support, counts, appendTo);\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processReplaceTagResult(support, counts, contextItem) {\n    const ph = contextItem.placeholder;\n    buildBeforeElement(support, counts, undefined, // element for append child\n    ph);\n    return support;\n}\nexport function processFirstTagResult(support, counts, appendTo) {\n    let appendIndex = paintAppends.length;\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.splice(appendIndex++, 0, {\n                args: [appendTo, dom.domElement],\n                processor: paintAppend,\n            });\n        }\n        if (dom.marker) {\n            paintAppends.splice(appendIndex++, 0, {\n                args: [appendTo, dom.marker],\n                processor: paintAppend,\n            });\n        }\n    }\n    return support;\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, { added: 0, removed: 0 });\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.checkValueChange(newValue, contextItem);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed);\n}\n","import { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\nownerSupport, contextItem) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\nexport function prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        processReplacementComponent(templater, contextItem, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { processReplacementComponent } from '../../tag/update/processFirstSubjectComponent.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject) {\n    const global = subject.global;\n    const lastSupport = global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = support.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = support.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(lastSupport, support);\n    }\n    else if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(lastSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, support, lastSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (global.locked) {\n        global.blocked.push(support);\n        return;\n    }\n    renderSupport(support);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = lastSupport.subject;\n    const global = subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.subject.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, lastSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = lastSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return lastSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(subject, templater, // new tag\nownerSupport) {\n    const global = subject.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(subject);\n    const newSupport = processReplacementComponent(templater, subject, ownerSupport, { added: 0, removed: 0 });\n    return newSupport;\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(lastSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = lastSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, lastSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","import { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nexport function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    const tagJsVar = valueToTagJsVar(value);\n    contextItem.tagJsVar = tagJsVar;\n    return tagJsVar.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nimport { tagValueUpdateHandler } from \"../../tag/update/tagValueUpdateHandler.function.js\";\nexport function domProcessContextItem(value, support, contextItem, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    contextItem.handler = tagValueUpdateHandler;\n    const global = support.subject.global;\n    global.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    const global2 = support.subject.global;\n    delete global2.locked;\n    contextItem.value = value;\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = {\n        value,\n        withinOwnerElement: false,\n        placeholder: element,\n    };\n    counts.added = counts.added + 1; // index  \n    if (!appendTo) {\n        paintCommands.push({\n            processor: paintBefore,\n            args: [insertBefore, element],\n        });\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push({\n            processor: paintAppend,\n            args: [appendTo, element],\n        });\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed, counts);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, ownerSupport, itemSubject);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n","import { checkArrayValueChange, destroyArrayContextItem } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/processTagArray.js';\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInit: processArrayInit,\n        checkValueChange: checkArrayValueChange,\n        delete: destroyArrayContextItem,\n    };\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, counts, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","import { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\nexport function processUpdateContext(support, context) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    while (index < len) {\n        processUpdateOneContext(values, index, context, support);\n        ++index;\n    }\n    return context;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport) {\n    const value = values[index];\n    // is something already there?\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (value === contextItem.value) {\n        return;\n    }\n    const handler = contextItem.handler;\n    handler(value, ownerSupport, contextItem, values);\n    contextItem.value = value;\n    contextItem.tagJsVar = valueToTagJsVar(value);\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.subject.global;\n    const context = global.context;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { getFakeTemplater, newSupportByTemplater, processTag } from '../../render/update/processTag.function.js';\nimport { BasicTypes, ValueTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { prepareUpdateToComponent } from './tagValueUpdateHandler.function.js';\nconst fooCounts = { added: 0, removed: 0 };\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const tagJsType = newValue.tagJsType;\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    switch (tagJsType) {\n        case ValueTypes.templater:\n            processTag(ownerSupport, contextItem, fooCounts);\n            return true;\n        // when value was not a Tag before\n        case ValueTypes.tag:\n        case ValueTypes.dom: {\n            updateToTag(newValue, contextItem, ownerSupport);\n            return true;\n        }\n        case ValueTypes.subscribe: {\n            ;\n            newValue.processInit(newValue, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n            contextItem.placeholder);\n            return true;\n        }\n    }\n    return false;\n}\nfunction updateToTag(value, contextItem, ownerSupport) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = getFakeTemplater();\n        tag.templater = templater;\n        templater.tag = tag;\n    }\n    const nowGlobal = (contextItem.global ? contextItem.global : getNewGlobal(contextItem));\n    nowGlobal.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    processTag(ownerSupport, contextItem, fooCounts);\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(lastSupport, subject, value, ownerSupport) {\n    const templater = value.templater || value;\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = lastSupport.subject;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nexport function checkTagValueChange(newValue, contextItem) {\n    const global = contextItem.global;\n    if (!global) {\n        return 663; // its not a tag this time\n    }\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        return 77; // always cause a redraw of static tags (was false)\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return -1;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destroySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\nsubject, // could be tag via result.tag\ncounts) {\n    const global = subject.global;\n    const support = global.newest;\n    support.ownerSupport = ownerSupport;\n    const ph = subject.placeholder;\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.context = [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push({\n                    args: [appendTo, dom.marker],\n                    processor: paintAppend,\n                });\n            }\n            else {\n                paintCommands.push({\n                    processor: paintBefore,\n                    args: [insertBefore, dom.marker],\n                });\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push({\n                    args: [appendTo, dom.domElement],\n                    processor: paintAppend,\n                });\n            }\n            else {\n                paintCommands.push({\n                    processor: paintBefore,\n                    args: [insertBefore, dom.domElement],\n                });\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem, counts);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from '../tag/checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.subject;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n","import { executeWrap } from './executeWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    runBeforeRender(newSupport, prevSupport);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    return reSupport;\n}\nfunction runBeforeRender(newSupport, prevSupport) {\n    const prevState = prevSupport?.state;\n    const config = setUseMemory.stateConfig;\n    if (prevState) {\n        reState(newSupport, prevSupport, setUseMemory.stateConfig, prevState);\n        return;\n    }\n    initState(newSupport, config);\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem, ownerSupport);\n    const result = processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    return result;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../tag/checkTagValueChange.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.delete = destroySupportByContextItem;\n        oneRenderFunction.checkValueChange = function renderOnceNeverChanges() {\n            return -1;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.checkValueChange = checkTagValueChange;\n        renderFunction.delete = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from '../render/renderSupport.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContext.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.subject;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.context);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.subject.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.subject.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nconst fooCounts = { added: 0, removed: 0 };\n// TODO: This function is being called for 1st time renders WHEN renderCount === 1\nexport function renderExistingReadyTag(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const global = subject.global;\n    const { support, wasLikeTags } = renderWithSupport(newSupport, lastSupport, // renderCount <= 0 ? undefined : lastSupport\n    subject, ownerSupport);\n    if (wasLikeTags) {\n        updateSupportBy(global.oldest, support);\n        return support;\n    }\n    processTag(ownerSupport, subject, fooCounts);\n    return support;\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { renderExistingReadyTag } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../tag/hasSupportChanged.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(ownerSupport, support);\n        return result;\n    }\n    global.locked = true;\n    const subject = support.subject;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingReadyTag(global.newest, support, ownerSupport, subject);\n    delete global.locked;\n    return tag;\n}\nexport function renderInlineHtml(ownerSupport, support) {\n    const ownGlobal = ownerSupport.subject.global;\n    if (!ownGlobal || ownGlobal.deleted === true) {\n        return support;\n    }\n    // ??? new change\n    const newest = ownGlobal.newest || ownerSupport;\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(ownerSupport, templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (ownerSupport && selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    /*\n    const noLength = nowProps && nowLen === 0 && latestLen === 0\n  \n    if(noLength) {\n      return false\n    }\n    */\n    return nowLen !== latestLen;\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.subject;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.subject;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(ownerSupport, newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.subject.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    const global = support.subject.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function (element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    const component = getSupportWithState(support);\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    const states = component.states; // ?.[0]\n    subjectFunction.states = states;\n    // subjectFunction.states = [...states]\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, states, bindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.subject;\n    const global = subject.global; // tag.subject.global as TagGlobal\n    global.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete global.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.subject.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (isPromise(callbackResult)) {\n        const global0 = last.subject.global;\n        global0.locked = true;\n        return callbackResult.then(() => {\n            if (global.deleted === true) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            const global1 = last.subject.global;\n            delete global1.locked;\n            const tagsToUpdate = getUpTags(last);\n            renderTagUpdateArray(tagsToUpdate);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    for (const block of blocked) {\n        const lastResult = renderSupport(block);\n        global.newest = lastResult;\n    }\n    global.blocked = [];\n    return global.newest;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from '../../render/attributes/processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nconst actions = ['init', 'destroy']; // oninit ondestroy\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        if (isSpecial && actions.includes(attrName)) {\n            specialAttribute(attrName, value, element, attrName, support, counts);\n            return;\n        }\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial, support, counts);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.subject.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return true;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit': // when read in compile process\n        case 'init': // when read in realtime\n            return 'oninit';\n        case 'ondestroy': // when read in compile process\n        case 'destroy': // when read in realtime\n            return 'destroy';\n    }\n    return false;\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateAttribute.function.js';\nconst emptyCounts = { added: 0, removed: 0 };\nexport function processUpdateAttrContext(value, ownerSupport, contextItem, values) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        emptyCounts);\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, emptyCounts);\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { isNoDisplayValue, processNameOnlyAttrValue } from '../../render/attributes/processAttribute.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction, isObject } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processDynamicNameValueAttribute, processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { addOneContext } from '../index.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, attrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        // how to process value updates\n        contextItem.handler = processUpdateAttrContext;\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        const contextItem = {\n            isAttr: true,\n            element,\n            attrName: attrName,\n            withinOwnerElement: true,\n        };\n        context.push(contextItem);\n        contextItem.handler = processUpdateAttrContext;\n        processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n        contextItem.value = value;\n        return;\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n/** Processor for flat attributes and object attributes */\n/*\nfunction processNameValueAttributeAttrSubject(\n  attrName: string,\n  contextItem: ContextItem,\n  element: Element,\n  support: AnySupport,\n  howToSet: HowToSet,\n  isSpecial: SpecialDefinition,\n  counts: TagCounts,\n) {\n  if(isSpecial) {\n    paintContent.push(function paintContent() {\n      element.removeAttribute(attrName)\n    })\n  }\n\n  const contextValueSubject = contextItem.value\n  if(isSubjectInstance(contextValueSubject)) {\n    contextItem.handler = blankHandler\n\n    const callback = function processAttrCallback(newAttrValue: any) {\n      processAttributeEmit(\n        newAttrValue,\n        attrName,\n        contextItem,\n        element,\n        support,\n        howToSet,\n        isSpecial,\n        counts,\n      )\n    }\n  \n    //  Subscribe. Above callback called immediately since its a ValueSubject()\n    const sub = contextValueSubject.subscribe(callback as any)\n    \n    // Record subscription for later unsubscribe when element destroyed\n    const global = contextItem.global as TagGlobal\n    const subs = global.subscriptions = global.subscriptions || []\n    subs.push(sub)\n  }\n\n  processAttributeEmit(\n    contextItem.value,\n    attrName,\n    contextItem,\n    element,\n    support,\n    howToSet,\n    isSpecial,\n    counts,\n  )\n\n  return\n}\n*/\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special, // string name of special\n        support, counts);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push(function paintContentPush() {\n                element.removeAttribute(attrName);\n            });\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\nexport function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push({\n            processor: paintAppend,\n            args: [appendTo, marker],\n        });\n    }\n    else {\n        paintCommands.push({\n            processor: paintBefore,\n            args: [insertBefore, marker],\n        });\n    }\n    domProcessContextItem(value, support, contextItem, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { howToSetFirstInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { paintAppend, paintAppendElementString, paintAppends, paintBefore, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nexport const blankHandler = function () {\n    return undefined;\n};\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push({\n            args: [appendTo, insertBefore],\n            processor: paintAppend,\n        });\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, context, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        for (const attr of node.at) {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            processAttribute(values, name, domElement, support, howToSetFirstInputValue, context, isSpecial, counts, value);\n        }\n    }\n    if (appendTo) {\n        paintAppends.push({\n            args: [appendTo, domElement],\n            processor: paintAppend,\n        });\n    }\n    else {\n        paintCommands.push({\n            processor: paintBefore,\n            args: [insertBefore, domElement],\n        });\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push({\n            processor: paintAppendElementString,\n            args: [owner, string, (elm) => textNode.domElement = elm],\n        });\n    }\n    else {\n        paintCommands.push({\n            processor: paintBeforeElementString,\n            args: [insertBefore, string, (elm) => textNode.domElement = elm]\n        });\n    }\n}\n","import { blankHandler } from \"./dom/attachDomElements.function.js\";\nexport let paintCommands = [];\nexport let paintContent = [];\nexport let setContent = [];\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0\n};\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    for (const content of paintContent) {\n        content();\n    }\n    for (const [text, textNode] of setContent) {\n        textNode.textContent = text;\n    }\n    for (const now of paintAppends) {\n        now.processor(...now.args);\n    }\n    for (const item of paintCommands) {\n        item.processor(...item.args);\n    }\n    paintReset();\n    for (const now of paintAfters) {\n        now();\n    }\n    paintAfters = [];\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n    setContent = [];\n}\nexport function paintRemover(element) {\n    const parentNode = element.parentNode;\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element) {\n    relative.parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst someDiv = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    someDiv.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(someDiv.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    someDiv.innerHTML = text;\n    const textElm = document.createTextNode(someDiv.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    someDiv.innerHTML = text;\n    const textElm = document.createTextNode(someDiv.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nexport function deleteSubContext(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.deleted = true;\n    delete contextItem.subContext;\n    const appendMarker = subscription.appendMarker;\n    if (appendMarker) {\n        paintCommands.push({\n            processor: paintRemover,\n            args: [appendMarker],\n        });\n        delete subscription.appendMarker;\n    }\n    delete contextItem.delete;\n    contextItem.handler = tagValueUpdateHandler;\n    if (!subscription.hasEmitted) {\n        return;\n    }\n    const subContextItem = subscription.contextItem;\n    const tagJsVar = subContextItem.tagJsVar;\n    tagJsVar.delete(subContextItem, ownerSupport);\n    return 77;\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nexport function checkSubContext(newValue, ownerSupport, contextItem) {\n    if (!newValue || !newValue.tagJsType || newValue.tagJsType !== ValueTypes.subscribe) {\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.delete(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, ownerSupport, 99);\n        return 99;\n    }\n    const subscription = contextItem.subContext;\n    if (!subscription.hasEmitted) {\n        return -1;\n    }\n    subscription.callback = newValue.callback;\n    subscription.valueHandler(subscription.lastValue);\n    return -1;\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore) {\n    subContext.hasEmitted = true;\n    subContext.contextItem = createAndProcessContextItem(value, ownerSupport, counts, insertBefore);\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push({\n            processor: paintAppend,\n            args: [appendTo, insertBefore]\n        });\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { deleteSubContext } from './deleteSubContext.function.js';\nimport { checkSubContext } from './checkSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nexport function setupSubscribe(observable, contextItem, ownerSupport, counts, callback, appendTo, insertBeforeOriginal) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = setupSubscribeCallbackProcessor(observable, ownerSupport, counts, insertBefore, callback);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    contextItem.handler = checkSubContext;\n    return subContext;\n}\nexport function setupSubscribeCallbackProcessor(observable, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore, callback) {\n    const component = getSupportWithState(ownerSupport);\n    let onValue = function onSubValue(value) {\n        onFirstSubContext(value, subContext, ownerSupport, counts, insertBefore);\n        // from now on just run update\n        onValue = function subscriptionUpdate(value) {\n            forceUpdateExistingValue(subContext.contextItem, value, ownerSupport);\n            if (!syncRun && !setUseMemory.stateConfig.support) {\n                paint();\n            }\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    function valueHandler(value) {\n        subContext.lastValue = value;\n        const newComponent = component.subject.global.newest;\n        syncSupports(newComponent, component);\n        if (subContext.callback) {\n            value = subContext.callback(value);\n        }\n        onValue(value);\n    }\n    let syncRun = true;\n    const subContext = {\n        valueHandler,\n        callback,\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    subContext.subscription = observable.subscribe(valueHandler);\n    syncRun = false;\n    return subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.subscription.unsubscribe();\n    return deleteSubContext(contextItem, ownerSupport);\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    return setupSubscribe(value.Observable, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSubscribeWith(value, contextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    const observable = value.Observable;\n    const subscription = setupSubscribe(observable, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n    if (!subscription.hasEmitted) {\n        subscription.valueHandler((observable.value || value.withDefault));\n    }\n    return subscription;\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo) {\n    setupSubscribe(value, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { state } from '../state/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                // Notify all subscribers\n                subscribers.forEach(callback => callback(newValue));\n            }\n        },\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.subject.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from '../subject/signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.subject.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const ownGlobal = owner.ownerSupport.subject.global;\n            const ownerProviders = ownGlobal.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const global = support.subject.global;\n                const providers = global.providers = global.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.subject.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.subject.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    // OLDEST UPDATE NEWEST: send the oldest state changes into the newest\n    //syncStatesArray(oldStates, newestSupport.states)\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            // syncStatesArray(oldStates, newestSupport.states)\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.subject.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        delete: deleteAndUnsubscribe,\n        checkValueChange: function subscribeDoNothing() {\n            console.log('weird to be here');\n            return -1;\n        },\n        Observable,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n    };\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribeWith,\n        delete: deleteAndUnsubscribe,\n        checkValueChange: function subscribeDoNothing() {\n            console.log('weird to be here subscribeWith');\n            return -1;\n        },\n        Observable,\n        callback,\n        withDefault,\n        states: getSupportWithState(getSupportInCycle()).states,\n    };\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem, counts);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it expects innerHTML */\n        setInnerHTML: function setInnerHTML(innerHTML) {\n            innerHTML.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n        },\n    });\n    return tag;\n}\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nfunction processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    counts, // {added:0, removed:0}\n    appendTo, insertBefore);\n    contextItem.handler = (value, newSupport, contextItem) => {\n        forceUpdateExistingValue(contextItem, value?.outerHTML || value, newSupport);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.checkValueChange = function outerCheckValueChange(newValue, contextItem) {\n        return checkOuterTagValueChange(newValue, contextItem);\n    };\n}\nfunction checkOuterTagValueChange(newValue, contextItem) {\n    return checkTagValueChange(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem);\n}\n/** When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it expects innerHTML */\n        setInnerHTML: function setInnerHTML(innerHTML) {\n            innerHTML.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            innerHTML.outerHTML = tag;\n            innerHTML.processInit = processOuterDomTagInit;\n        },\n    });\n    return tag;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/getDomTag.function.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix)) {\n                        textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n            const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n            let attrValue = attrChoice;\n            if (attrName === undefined) {\n                continue;\n            }\n            const notEmpty = attrMatch[2] !== '';\n            const noValue = attrValue === undefined && notEmpty;\n            const lowerName = attrName.toLowerCase();\n            const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n            if (noValue) {\n                const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n                if (standAloneVar) {\n                    const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                    valuePositions.push(['at', valueName]);\n                    attributes.push([valueName]); // the name itself is dynamic\n                    continue;\n                }\n                const startMatched = attrMatch[0].startsWith(attrName);\n                const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n                if (standAloneAttr) {\n                    attributes.push([fixedName]);\n                    continue;\n                }\n                const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                attrValue = valueName;\n            }\n            if (!notEmpty) {\n                attrValue = attrMatch[2];\n            }\n            const attrSet = [fixedName, attrValue];\n            const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n            if (isSpecial) {\n                attrSet.push(isSpecial);\n            }\n            attributes.push(attrSet);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postprocessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\nfunction postprocessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/getDomTag.function.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nconst fragReplacer = /(^:tagvar\\d+:|:tagvar\\d+:$)/g;\nconst safeVar = '__safeTagVar';\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    htmlInterpolationToPlaceholders(strings, values);\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = sanitizePlaceholders(strings);\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction sanitizePlaceholders(fragments) {\n    return fragments.map(santizeFragment);\n}\nfunction santizeFragment(fragment) {\n    return fragment.replace(fragReplacer, (match, index) => safeVar + index);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        if (index < values.length) {\n            results.push(fragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(fragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { variableSuffix, variablePrefix } from \"../../tag/getDomTag.function.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nconst placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, ...[{\n                    nn: 'text',\n                    v: wIndex\n                }]);\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/getDomTag.function.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nexport const safeVar = '__safeTagVar';\nexport function restorePlaceholders(elements) {\n    elements.forEach(traverseAndRestore);\n}\nconst safeReplacer = /__safeTagVar(\\d+)/g;\nfunction traverseAndRestore(element) {\n    if (element.at) {\n        element.at = element.at ? element.at.map(attr => {\n            if (attr.length === 1) {\n                return attr;\n            }\n            const [, value] = attr;\n            if (typeof value === ImmutableTypes.string && value.startsWith(safeVar)) {\n                const index = parseInt(value.replace(safeVar, ''), 10);\n                attr[1] = variablePrefix + index + variableSuffix;\n            }\n            return attr;\n        }) : [];\n    }\n    if (element.ch) {\n        const children = element.ch;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.nn === 'text') {\n                if (typeof child.tc !== ImmutableTypes.string) {\n                    return;\n                }\n                child.tc = child.tc.replace(safeReplacer, (_match, index) => variablePrefix + index + variableSuffix);\n            }\n            traverseAndRestore(child);\n        }\n        // Remove empty children array\n        if (children.length === 0) {\n            delete element.ch;\n        }\n    }\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { restorePlaceholders } from '../interpolations/optimizers/restorePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    // Restore any sanitized placeholders in text nodes\n    restorePlaceholders(map);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { getStringTag, getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nexport function registerTagElement(support, element, global, templater, app, placeholder) {\n    console.debug(' Building element into tag...', { element, app });\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    console.debug(' Element Tag DOM built ');\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { setUseMemory } from '../index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterRender } from '../render/afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reState } from '../state/state.utils.js';\nexport function renderTagElement(app, global, templater, templater2, element, subject, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        setUseMemory.stateConfig, oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.subject.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest, setUseMemory.stateConfig);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    return renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n}\nfunction getNewSubject(templater, appElement) {\n    const subject = {\n        value: templater,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        tagJsVar: {\n            tagJsType: 'templater',\n            checkValueChange: checkTagValueChange,\n            delete: destroySupportByContextItem,\n            processInit: function appDoNothing() {\n                console.log('do nothing app function');\n            }\n        }\n    };\n    const global = getNewGlobal(subject);\n    // for click events and such read at a higher level\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\n","import { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/alterProp.function.js\";\n/** Used to call a function that belongs to a calling tag */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        const ownerGlobal = ownerSupport.subject.global;\n        const newestOwner = ownerGlobal.newest;\n        // sync the new states to the old before the old does any processing\n        syncStatesArray(newestOwner.states, ownerSupport.states);\n        const c = callback(...args); // call the latest callback\n        // sync the old states to the new\n        syncStatesArray(ownerSupport.states, newestOwner.states);\n        // now render the owner\n        const newestOwnerOwner = newestOwner.ownerSupport;\n        safeRenderSupport(newestOwner, newestOwnerOwner.subject.global.newest);\n        return c;\n    };\n}\n","import { deleteSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, newSupport, contextItem) {\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    contextItem.subContext = {};\n    contextItem.handler = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, counts, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, counts, // {added:0, removed:0}\ninsertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, counts, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        processInit: processInnerHTML,\n        delete: deleteSubContext,\n        checkValueChange: () => console.log('weird innerHTML check'),\n    };\n}\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './interpolations/attributes/ElementTargetEvent.interface.js';\nimport { renderTagOnly } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","subject","renderCount","global","RouteQuery","_name","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","subscribe","signal","renderOnce","stateRender","version","Date","now","howToSetInputValue","element","name","value","paintContent","push","howToSetFirstInputValue","undefined","setAttribute","removeAttribute","specialAttribute","specialName","support","counts","stagger","added","paintAfters","target","removed","destroys","focus","select","names","split","style","shift","classList","add","remove","processSpecialClass","Error","isSimpleType","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","isObject","function","isPromise","isFunction","then","object","isArray","Array","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","length","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","cloneValueArray","values","map","cloneTagJsValue","shallowMapper","x","shallowCompareDepth","deepMapper","props","deepCompareDepth","combineLatest","subjects","output","Subject","subscribeWith","callback","valuesSeen","setValue","index","item","subscription","clones","subscriptions","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","splice","removeSubFromArray","valSub","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","handler","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","args","arg","static","Subjective","_value","super","defineValueOn","getBaseSupport","castedProps","baseSupport","appSupport","blocked","destroy$","upgradeBaseToSupport","propsConfig","castProps","propWatch","PropWatches","IMMUTABLE","latest","SHALLOW","clonePropsBy","createHtmlSupport","ownerSupport","runBeforeDestroy","providers","provider","children","destroyContext","childTags","child","lastArray","childValue","delete","newest","iSubs","forEach","unsubscribeFrom","context","getChildTagsToSoftDestroy","tags","subTags","from","compareArrayItems","newLength","at","lessLength","prevContext","destroyArrayItem","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","destroySupport","oldest","simpleValueElm","paintCommands","processor","paintRemover","destroyArrayItemByGlobal","checkArrayValueChange","destroyArrayContextItem","destroyArray","smartRemoveKids","allPromises","promises","destroyCall","lastPromise","painting","locks","smartRemoveByContext","destroyClones","paint","processContextDestroys","destroy","maybePromise","withinOwnerElement","elm","subGlobal","deleted","htmlDomMeta","destroyClone","marker","domElement","isLikeTags","support0","support1","templater0","templater1","tag0","tag1","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","every","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","castTextValue","getSimpleTagVar","processInit","processSimpleValueInit","checkValueChange","checkSimpleValueChange","deleteSimpleValue","contextItem","appendTo","insertBefore","castedValue","placeholder","paintBeforeText","tagJsVar","oldClone","setContent","processUpdateRegularValue","buildBeforeElement","domMeta","thisTag","getDomMeta","loadDomMeta","attachDomElements","attachHtmlDomMeta","addOneContext","newSupport","depth","checkProp","alterProp","owner","already","mem","wrap","toCall","callWith","noCycle","getSupportInCycle","callbackResult","apply","run","locked","safeRenderSupport","setUseMemory","tagClosed$","callbackPropOwner","original","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","isInlineHtml","renderInlineHtml","renderExistingReadyTag","getSupportWithState","component","returnArgs","firstStatesHandler","setter","config","stateConfig","states","statesIndex","reStatesHandler","oldStates","prevSupport","lastValues","_args","initState","handlers","runFirstState","statesHandler","rearray","stateArray","reState","prevState","runRestate","StateEchoBack","getStateValue","state","defaultValue","checkValue","getCallbackValue","restate","initValue","executeWrap","useSupport","originalFunction","stateless","createSupport","getCastedProps","lastSupport","DEEP","preCastedProps","lastPropsConfig","lastCastProps","syncFunctionProps","processReplacementComponent","newPropsConfig","renderWithSupport","processReplaceTagResult","processFirstSubjectComponent","appendIndex","paintAppends","paintAppend","processFirstTagResult","updateToDiffValue","ignoreOrDestroyed","tryUpdateToTag","processTagArray","getArrayTagVar","before","processNowRegularValue","forceUpdateExistingValue","tagValueUpdateHandler","prepareUpdateToComponent","oldWrapper","wrapper","newWrapper","isSameTag","skipComparing","oldestSupport","swapTags","hasChanged","newTemplater","latestProps","pastCloneProps","propsChanged","hasPropChanges","hasSupportChanged","newProps","syncSupports","updateExistingTagComponent","processFirstSubjectValue","valueToTagJsVar","domProcessContextItem","createAndProcessContextItem","document","createTextNode","paintBefore","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","array","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","processArrayInit","getBasicTagVar","processUpdateOneContext","updateSupportBy","olderSupport","newerSupport","newTemplate","tempTag","updateSupportValuesBy","len","processUpdateContext","fooCounts","valueSupport","handleStillTag","processTag","getFakeTemplater","nowGlobal","newSupportByTemplater","updateToTag","checkTagValueChange","isTag","destroySupportByContextItem","processTagInit","processNewSubjectTag","getTemplaterResult","oneRenderToSupport","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","checkStateMismatch","tagFunction","newStates","error","console","hint","throwStateMismatch","runAfterRender","renderTagOnly","runBeforeRender","reSupport","processRenderOnceInit","processTagComponentInit","tagCount","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","pastProp","obEntries","subItem","objectItemMatches","use","deepPropWatch","route","_routeProps","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","pastValue","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","cGlobal","lastTemplater","lastTag","isLikeTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","lastOwnerSupport","wasLikeTags","inlineHtml","pop","ownGlobal","checkRenderUp","selfPropChange","nowProps","hasPropsToOwnerChanged","handleProviderChanges","tagsWithProvider","memory","cSubject","getTagsWithProvider","mapToSupport","getUpTags","supports","isComponent","continueUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","noData","promiseNoData","bindSubjectCallback","subjectFunction","bindTo","eventHandlerSupport","last","checkAfterCallbackPromise","renderCallbackSupport","afterTagCallback","runTagCallback","actions","processNonDynamicAttr","attrName","howToSet","isSpecial","addSupportEventListener","eventName","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","parentNode","processAttributeFunction","newAttrValue","fun","isSpecialAttr","startsWith","specialAction","isSpecialAction","emptyCounts","processUpdateAttrContext","isNameOnly","attrValue","isNoDisplayValue","processNameOnlyAttrValue","updateNameOnlyAttrValue","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","processAttribute","nameVar","getTagJsVar","isAttr","valueVar","processDynamicNameValueAttribute","special","attrPart","attachDynamicDom","blankHandler","nodes","node","v","isNaN","newNode","nn","attachDomText","attachDomElement","ch","createElement","attr","textNode","tc","paintAppendElementString","paintBeforeElementString","content","text","textContent","removeChild","relative","appendChild","someDiv","toPlainTextElm","innerHTML","textElm","syncStatesArray","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","deleteSubContext","subContext","appendMarker","hasEmitted","subContextItem","checkSubContext","valueHandler","onFirstSubContext","guaranteeInsertBefore","setupSubscribe","observable","insertBeforeOriginal","onValue","syncRun","newComponent","newestSupport","setupSubscribeCallbackProcessor","deleteAndUnsubscribe","processSubscribe","Observable","processSubscribeWith","withDefault","processSignal","initialValue","Signal","Set","unsub","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","defaultFinally","init","final","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","cm","inject","ownerProviders","find","msg","warn","syncError","createTrigger","finally","callbackStateUpdate","callbackMaker","onInit","onDestroy","log","processDomTagInit","tagFakeTemplater","variablePrefix","variableSuffix","getDomTag","setInnerHTML","html","outerHTML","_innerHTML","oldProcessInit","processOuterDomTagInit","checkOuterTagValueChange","getStringTag","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","textVarMatches","splitByTagVar","pushTextTo","attributes","attrMatch","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","search","attrSet","pushTo","postprocessTagsInComments","inputString","filter","notEmptyStringMapper","part","fragReplacer","safeVar","htmlInterpolationToPlaceholders","results","fragment","diff","balanceArrayByArrays","addPlaceholders","santizeFragment","placeholderRegex","replacePlaceholders","valueCount","currentTail","loopTail","attrs","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","mapped","safeReplacer","traverseAndRestore","_match","lengthMapper","lastRuns","stringId","Number","join","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","htmlInterpolationToDomMeta","template","interpolation","stringTag","putOneDomDown","newFragment","loadNewBaseSupport","renderTagElement","templater2","isAppFunction","isFirstRender","executeStateWrap","runWrapper","isApp","removeEventListener","toAwait","debug","appElements","createDocumentFragment","domItem","registerTagElement","tagElement","appElmIndex","appElm","getNewSubject","newestOwner","c","handleInnerHTML","realValue","processInnerHTML","checkInnerHTML","getInnerHTML","hmr"],"sourceRoot":""}