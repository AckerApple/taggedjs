{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/cycles/getSupportInCycle.function.ts","webpack://taggedjs/./ts/render/dom/blankHandler.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/shallowPropMatch.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContexts.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processFunctionAttr.function.ts","webpack://taggedjs/./ts/tagJsVars/processAttributeUpdate.function.ts","webpack://taggedjs/./ts/tagJsVars/processSimpleAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/render/addOneContext.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/arrays/processTagArray.ts","webpack://taggedjs/./ts/tag/update/arrays/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/destroyArrayContext.function.ts","webpack://taggedjs/./ts/tag/destroyHtmlDomMeta.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/destroySupportByContextItem.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/render/runAfterRender.function.ts","webpack://taggedjs/./ts/render/callTag.function.ts","webpack://taggedjs/./ts/state/reState.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/render/checkRenderUp.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bubbleEvent.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/render/attributes/processStandAloneAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateNameOnlyAttrValue.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/render/attributes/processTagJsAttribute.function.ts","webpack://taggedjs/./ts/render/dom/processAttributeArray.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElement.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribeWith.function.ts","webpack://taggedjs/./ts/tagJsVars/processSubscribeAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/processSubscribeWithAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribeWith.function.ts","webpack://taggedjs/./ts/tag/update/handleTagTypeChangeFrom.function.ts","webpack://taggedjs/./ts/tag/update/checkStillSubscription.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/tag/update/deleteContextSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/tagJsVars/pipe.function.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/host.function.ts","webpack://taggedjs/./ts/tag/update/getOverrideTagVar.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/convertTagToElementManaged.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/onInit.function.ts","webpack://taggedjs/./ts/state/onDestroy.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tagJsVars/tagInject.function.ts","webpack://taggedjs/./ts/state/onRender.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/processUpdateSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSignal.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/cycles/setContextInCycle.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/processOuterDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/elements/attributeCallables.ts","webpack://taggedjs/./ts/elements/elementFunctions.ts","webpack://taggedjs/./ts/elements/destroyDesignElement.function.ts","webpack://taggedjs/./ts/elements/processDesignElementUpdate.function.ts","webpack://taggedjs/./ts/elements/processChildren.function.ts","webpack://taggedjs/./ts/elements/processElementVarFunction.function.ts","webpack://taggedjs/./ts/elements/processElementVar.function.ts","webpack://taggedjs/./ts/elements/processDesignElementInit.function.ts","webpack://taggedjs/./ts/elements/htmlTag.function.ts","webpack://taggedjs/./ts/elements/noElement.function.ts","webpack://taggedjs/./ts/elements/index.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/** Only used in TagSupport */\nexport function getNewGlobal(contextItem) {\n    // TODO: Not need for basic supports, only tag()\n    contextItem.renderCount = contextItem.renderCount || 0;\n    contextItem.varCounter = 0;\n    // TODO: Not need for basic supports, only tag()\n    contextItem.state = {\n        newer: {\n            state: [],\n            states: [],\n        },\n    };\n    return contextItem.global = {\n        blocked: [],\n    };\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","import { setUseMemory } from '../../state/index.js';\nimport { setContextInCycle } from './setContextInCycle.function.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    setContextInCycle(support.context);\n    return setUseMemory.stateConfig.support = support;\n}\n","export const blankHandler = function blankHandler() {\n    return undefined;\n};\n","import { blankHandler } from \"./dom/blankHandler.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(_promise) {\n    /*\n    if(paintRemoveAwaits.length) {\n      paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push( ...paintRemoves )\n      paintRemoves = []\n    }\n  \n    paintRemoveAwaits.push({promise, paintRemoves})\n    paintRemoves = []\n    */\n}\n// let paintRemoveAwaits: {promise: Promise<any>, paintRemoves: PaintCommand[]}[] = []\nexport let paintCommands = [];\n// export let paintRemoves: PaintCommand[] = []\nexport const paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\n/** you must lock before calling this function */\nexport function paint() {\n    if (painting.locks > 0) {\n        // throw new Error('double paint')\n        return;\n    }\n    runCycles();\n}\nfunction runCycles() {\n    ++painting.locks;\n    runPaintCycles();\n    --painting.locks;\n    runAfterCycle();\n}\n/** Deletes happen last */\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    const removes = paintRemoves.length;\n    runPaintRemoves();\n    // paintRemoves = []\n    paintRemoves.splice(0, removes);\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element, caller) {\n    paintRemoves.push([paintRemover, [element, caller]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element, _caller) {\n    const parentNode = element.parentNode;\n    /*\n    if(!element) {\n      console.debug('no element by', _caller)\n    }\n    if(!parentNode) {\n      console.debug('no parentNode by', _caller)\n    }\n    */\n    parentNode.removeChild(element);\n}\n/** insertBefore. For parent.appendChild() see paintAppend */\nexport function paintBefore(relative, element, _caller) {\n    const parentNode = relative.parentNode;\n    parentNode.insertBefore(element, relative);\n}\n/** parent.appendChild(). For insertBefore see paintBefore */\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler, _caller) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm, _caller);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm, 'paintBeforeElementString');\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n    // TODO: Start using this instead\n    return value instanceof Function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function findStateSupportUpContext(context) {\n    const stateMeta = context.state;\n    if (stateMeta && stateMeta.newest && stateMeta.newest) {\n        return stateMeta.newest;\n    }\n    if (context.parentContext) {\n        return findStateSupportUpContext(context.parentContext);\n    }\n}\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const context = component.context;\n    const stateMeta = context.state;\n    if (!stateMeta) {\n        return component;\n    }\n    return stateMeta.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevContext = prevSupport.context;\n    const stateMeta = prevContext.state;\n    const prevStateMeta = stateMeta.older;\n    // const prevStateMeta = stateMeta.newer as ContextStateSupport\n    // const prevStateMeta = stateMeta.older || stateMeta.newer as ContextStateSupport\n    const prevStates = prevStateMeta.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        oldStates.lastValues = lastValues;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState } from './stateHandlers.js';\nimport { firstStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** To be called before rendering anything with a state */\nexport function initState(context) {\n    setContextInCycle(context);\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    const state = config.state = [];\n    const states = config.states = [];\n    config.statesIndex = 0;\n    const stateMeta = context.state = context.state || {};\n    stateMeta.newer = { state, states };\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.state.length];\n    config.state.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    const context = getContextInCycle();\n    if (!context || !context.state) {\n        const msg = 'State requested but TaggedJs is not currently rendering a tag or host';\n        console.error(msg, { config, context });\n        throw new Error(msg);\n    }\n    const newer = context.state.newer;\n    config.state = newer.state;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.state.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    value;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n        if (arguments.length > 0) {\n            this.value = value;\n        }\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster.\n     * Once called, unsubscribe occurs.\n     * No subscription to manage UNLESS the callback will never occur THEN subscription needs to be closed with result.unsubscribe() */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        // return this 10-2025 remove\n        return subscription;\n    }\n    pipe(...operations) {\n        const args = [];\n        if ('value' in this) {\n            args.push(this.value);\n        }\n        const subject = new Subject(...args);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    _value;\n    constructor(...args) {\n        super(...args);\n        this._value = args[0];\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        state: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","import { removeContextInCycle, setContextInCycle } from './cycles/setContextInCycle.function.js';\nexport function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    for (const context of contexts) {\n        // const context = contexts[index]\n        processUpdateOneContext(values, context, support);\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\ncontextItem, ownerSupport) {\n    if (contextItem.deleted) {\n        return;\n    }\n    // some values, like style, get rearranged and there value appearance may not match context appearance\n    const valueIndex = contextItem.valueIndex;\n    const newValue = values[valueIndex];\n    // Removed, let the tagJsVars do the checking\n    // Do not continue if the value is just the same\n    /*\n    if(newValue === contextItem.value) {\n      return\n    }\n    */\n    const tagJsVar = contextItem.tagJsVar;\n    setContextInCycle(contextItem);\n    tagJsVar.processUpdate(newValue, contextItem, ownerSupport, values);\n    removeContextInCycle();\n    contextItem.value = newValue;\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const contexts = olderSupport.context.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, contexts);\n    --painting.locks;\n    paint();\n}\nfunction updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { isArray } from '../isInstance.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = support.context.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    // global.deleted = true\n    support.context.destroy$.next();\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContexts(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContexts(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.destroy(child, ownerSupport);\n            child.deleted = true;\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = child.state.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = child.contexts;\n        // recurse\n        destroyContexts(subTags, support);\n        global.deleted = true;\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = child.state.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = child.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\ncontextItem, ownerSupport) {\n    const tagJsType = contextItem.tagJsVar.tagJsType;\n    const processUpdate = tagJsType && ['tag-conversion', 'element'].includes(tagJsType);\n    if (processUpdate) {\n        // calls processDesignElementUpdate\n        contextItem.tagJsVar.processUpdate(newValue, contextItem, ownerSupport, []);\n        contextItem.value = newValue;\n        return 0;\n    }\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    ++contextItem.updateCount;\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\n","import { removeContextInCycle, setContextInCycle } from \"../../tag/cycles/setContextInCycle.function.js\";\nexport function domProcessContextItem(value, support, contextItem, appendTo, insertBefore) {\n    const subject = support.context;\n    subject.locked = 3;\n    contextItem.element = contextItem.element || appendTo;\n    setContextInCycle(contextItem);\n    contextItem.tagJsVar.processInit(value, contextItem, support, insertBefore, appendTo);\n    removeContextInCycle();\n    contextItem.value = value;\n    delete subject.locked;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n        case 'autoSelect':\n            return 'autoselect';\n        case 'autofocus':\n        case 'autoFocus':\n            return 'autofocus';\n    }\n    return false;\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            // element.setAttribute(\"autofocus\", 'true')\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value; // style.backgroundGround\n    element.style.setProperty(smallName, value); // style.background-ground\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\n","import { isObject } from \"../../index.js\";\nimport { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    paintContent.push([setNonFunctionInputValue, [element, name, value]]);\n}\nfunction howToSetInputObjectValue(element, name, value) {\n    if (typeof element[name] !== 'object') {\n        element[name] = {};\n    }\n    // Handle object values by setting properties directly\n    for (const key in value) {\n        const subValue = value[key];\n        paintContent.push([setObjectValue, [element, name, key, subValue]]);\n    }\n    if (element[name].setProperty) {\n        for (const key in value) {\n            const subValue = value[key];\n            paintContent.push([setPropertyValue, [element, name, key, subValue]]);\n        }\n    }\n}\nexport function howToSetStandAloneAttr(element, name, _value) {\n    element.setAttribute(name, '');\n}\nexport function setNonFunctionInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used for checked, selected, and so on */\nexport function setBooleanAttribute(element, name, value) {\n    if (value) {\n        element[name] = true;\n    }\n    else {\n        element[name] = false;\n    }\n}\nexport function setSimpleAttribute(element, name, value) {\n    // for checked=true\n    ;\n    element[name] = value;\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\nfunction setPropertyValue(element, name, key, value) {\n    ;\n    element[name].setProperty(key, value);\n}\n/** main processor for things like <div style=${{ maxWidth: '100vw' }}> */\nfunction setObjectValue(element, name, key, value) {\n    ;\n    element[name][key] = value;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { setNonFunctionInputValue } from './howToSetInputValue.function.js';\nimport { processFunctionAttr } from './processFunctionAttr.function.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial) {\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    if (value?.tagJsType) {\n        return processTagJsAttribute(attrName, value, contextItem, support, element);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, contextItem);\n}\nfunction processTagJsAttribute(name, value, contextItem, ownerSupport, element) {\n    value.processInitAttribute(name, value, element, value, contextItem, ownerSupport, setNonFunctionInputValue);\n    contextItem.tagJsVar = value;\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, context) {\n    if (typeof value === 'function') {\n        return processFunctionAttr(value, context, attrName, element, howToSet);\n    }\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n","import { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { Subject, valueToTagJsVar } from '../../index.js';\n/** Used for bolts like div.style(() => {{backgroundColor:}}) */\nexport function processFunctionAttr(value, parentContext, // parent context\nattrName, element, howToSet) {\n    const innerValue = value();\n    const tagJsVarOverride = {\n        tagJsType: 'dynamic-attr',\n        matchesInjection: (inject) => {\n            const tagJsVar = subContext.tagJsVar;\n            if (tagJsVar.matchesInjection) {\n                const rtn = tagJsVar.matchesInjection(inject, subContext);\n                return rtn;\n            }\n        },\n        hasValueChanged: (_value, _contextItem, ownerSupport) => {\n            const newValue = value();\n            return subContext.tagJsVar.hasValueChanged(newValue, subContext, ownerSupport);\n        },\n        processInit: blankHandler,\n        processInitAttribute: blankHandler,\n        destroy: (_contextItem, ownerSupport) => {\n            subContext.tagJsVar.destroy(subContext, ownerSupport);\n        },\n        processUpdate: (value, contextItem, ownerSupport, values) => {\n            ++contextItem.updateCount;\n            const newValue = value();\n            // const oldValue = subContext.value\n            // const newTagJsVar = valueToTagJsVar(newValue)\n            subContext.tagJsVar.processUpdate(newValue, // newTagJsVar as any,\n            subContext, ownerSupport, values);\n            subContext.value = newValue;\n        }\n    };\n    const subContext = {\n        updateCount: 0,\n        isAttr: true,\n        element,\n        parentContext,\n        value: innerValue, // used for new value comparing\n        tagJsVar: valueToTagJsVar(innerValue),\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        contexts: [subContext],\n        element,\n        parentContext,\n        value,\n        tagJsVar: tagJsVarOverride,\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    subContext.tagJsVar.processInitAttribute(attrName, innerValue, element, subContext.tagJsVar, subContext, {}, howToSet);\n    return contextItem;\n}\n","import { valueToTagJsVar } from \"./valueToTagJsVar.function.js\";\nexport function processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet) {\n    const oldTag = contextItem.tagJsVar; // contextItem.tagJsVar as TagJsVar\n    const tagValue = value;\n    const checkResult = oldTag.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n    ownerSupport);\n    if (checkResult > 0) {\n        oldTag.destroy(contextItem, ownerSupport);\n        element.removeAttribute(name);\n        const newTagVar = valueToTagJsVar(value);\n        newTagVar.isAttr = true;\n        newTagVar.processInitAttribute(name, value, element, newTagVar, contextItem, ownerSupport, howToSet);\n        contextItem.tagJsVar = newTagVar;\n        return;\n    }\n}\n","import { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { checkSimpleValueChange, deleteSimpleAttribute } from \"./getSimpleTagVar.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\n/** init runner */\nexport function processSimpleAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, contextItem, _ownerSupport, howToSet) {\n    // function swapping\n    tagJsVar.destroy = deleteSimpleAttribute;\n    tagJsVar.hasValueChanged = checkSimpleValueChange;\n    tagJsVar.processUpdate = (value, contextItem, ownerSupport) => {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet);\n    };\n    const isSpecial = isSpecialAttr(name);\n    processNonDynamicAttr(name, value, element, howToSet, isSpecial, contextItem);\n    contextItem.tagJsVar = tagJsVar;\n}\n","import { forceUpdateExistingValue } from \"../index.js\";\nimport { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { processSimpleAttribute } from \"./processSimpleAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nexport function deleteSimpleAttribute(contextItem) {\n    const element = contextItem.element;\n    const name = contextItem.attrName;\n    element.removeAttribute(name);\n}\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInitAttribute: processSimpleAttribute,\n        processInit: processSimpleValueInit,\n        destroy: deleteSimpleValue,\n        // TODO: get to using only checkSimpleValueChange\n        hasValueChanged: checkUpdateDeleteSimpleValueChange, // For attributes, this gets switched to checkSimpleValueChange\n        processUpdate: processStringUpdate, // For attributes, this gets switched to processAttributeUpdate\n        // processUpdate: tagValueUpdateHandler, // For attributes, this gets switched to processAttributeUpdate\n    };\n}\nfunction processStringUpdate(newValue, // newValue\ncontextItem, ownerSupport) {\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, insertBefore, _appendTo) {\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processSimpleValueInit']];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(context) {\n    if (!context.simpleValueElm && context.paint) {\n        context.paint[0] = blankHandler;\n        return; // I'm being deleted before my first render even occurred\n    }\n    const elm = context.simpleValueElm;\n    delete context.simpleValueElm;\n    addPaintRemover(elm, 'deleteSimpleValue');\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || newValue === contextItem.value; // !(typeof(newValue) === BasicTypes.object)\n    if (isRegularUpdate) {\n        return 0; // no need to destroy, just update display\n    }\n    return 6; // 'changed-simple-value'\n}\nexport function checkUpdateDeleteSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || !(typeof (newValue) === BasicTypes.object);\n    if (isRegularUpdate) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return 0; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processNowRegularValue']];\n    paintCommands.push(paint);\n}\n","import { isArray } from '../isInstance.js';\nimport { destroyArrayContext } from './destroyArrayContext.function.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContext(subject);\n        return 9; // 'array'\n    }\n    return 0;\n}\n","import { checkArrayValueChange } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/arrays/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroyArrayContext } from '../tag/destroyArrayContext.function.js';\n/** how to process an array */\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInitAttribute: blankHandler,\n        processInit: processArrayInit,\n        processUpdate: processArrayUpdates,\n        hasValueChanged: checkArrayValueChange,\n        destroy: destroyArrayContext,\n    };\n}\nfunction processArrayUpdates(newValue, contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    if (Array.isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport);\n        return;\n    }\n    const tagUpdateResponse = tagValueUpdateHandler(newValue, contextItem, ownerSupport);\n    if (tagUpdateResponse === 0) {\n        processTagArray(contextItem, newValue, ownerSupport);\n    }\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","import { Subject } from '../subject/Subject.class.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\nexport function getNewContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = {\n        updateCount: 0,\n        value,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n        parentContext,\n        // TODO: remove with html``\n        // valueIndex: contexts?.length || -1, // when -1 its a raw bolt value\n        // valueIndex: contexts.length\n        valueIndex: parentContext.varCounter,\n    };\n    return contextItem;\n}\n/** auto adds onto parent.contexts */\nexport function addOneContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = getNewContext(value, contexts, withinOwnerElement, parentContext);\n    contexts.push(contextItem);\n    ++parentContext.varCounter;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { getNewContext } from '../../render/addOneContext.function.js';\n/** Used by arrays and subcontext creators like subscribe. Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, contexts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = getNewContext(value, contexts, true, ownerSupport.context);\n    contextItem.withinOwnerElement = false;\n    contextItem.placeholder = element;\n    if (!appendTo) {\n        contextItem.placeholder = insertBefore;\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from '../tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from '../createAndProcessContextItem.function.js';\nexport function processTagArray(contextItem, value, // arry of Tag classes\nownerSupport, appendTo) {\n    const noLast = contextItem.lastArray === undefined;\n    if (noLast) {\n        contextItem.lastArray = [];\n    }\n    const lastArray = contextItem.lastArray;\n    let runtimeInsertBefore = contextItem.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        contextItem.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, contextItem.lastArray, ownerSupport, runtimeInsertBefore, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\n/** new and old array items processed here */\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\nappendTo) {\n    const item = castArrayItem(array[index]);\n    const previousContext = lastArray[index];\n    if (previousContext) {\n        return reviewPreviousArrayItem(item, previousContext, lastArray, ownerSupport, index, runtimeInsertBefore, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, context, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\nappendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        if (Array.isArray(value)) {\n            context.tagJsVar.processUpdate(value, context, ownerSupport, []);\n            context.value = value;\n            return context;\n        }\n        tagValueUpdateHandler(value, context, ownerSupport);\n        return context;\n    }\n    // NEW REPLACEMENT\n    const contextItem = createAndProcessContextItem(value, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nexport function castArrayItem(item) {\n    const isBasicFun = typeof item === 'function' && item.tagJsType === undefined;\n    if (isBasicFun) {\n        const fun = item;\n        item = fun();\n    }\n    return item;\n}\n","import { destroySupport } from '../../../render/destroySupport.function.js';\nimport { castArrayItem } from './processTagArray.js';\n/** 1 = destroyed, 2 = value changes, 0 = no change */\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = castArrayItem(value[index]);\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(context) {\n    const global = context.global;\n    destroyArrayItemByGlobal(global, context);\n}\nfunction destroyArrayItemByGlobal(global, context) {\n    if (global && context.state?.oldest) {\n        const support = context.state.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    context.tagJsVar.destroy(context, {});\n}\n","import { destroyArrayItem } from './update/arrays/compareArrayItems.function.js';\nexport function destroyArrayContext(context) {\n    ++context.updateCount;\n    const lastArray = context.lastArray;\n    destroyArray(context, lastArray);\n}\n/** Deletes entire array context not just one */\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { addPaintRemover } from '../render/paint.function.js';\n/** Destroy dom elements and dom space markers */\nexport function destroyHtmlDomMeta(htmlDomMeta) {\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker, 'destroyMarker');\n    }\n    const dom = clone.domElement;\n    addPaintRemover(dom, 'destroyClone');\n}\n","import { destroyArray } from './destroyArrayContext.function.js';\nimport { addPaintRemover } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from './destroyHtmlDomMeta.function.js';\nimport { isPromise } from '../index.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(context, allPromises) {\n    const subContexts = context.contexts;\n    smartRemoveByContext(subContexts, allPromises);\n    destroyContextHtml(context);\n}\nexport function destroyContextHtml(context) {\n    destroyHtmlDomMeta(context.htmlDomMeta);\n}\nfunction smartRemoveByContext(contexts, allPromises) {\n    for (const context of contexts) {\n        if (context.withinOwnerElement) {\n            const tagJsVar = context.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = context.supportOwner;\n                const hostDestroy = tagJsVar.destroy(context, newest);\n                if (isPromise(hostDestroy)) {\n                    allPromises.push(hostDestroy);\n                }\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = context.lastArray;\n        if (lastArray) {\n            destroyArray(context, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = context.simpleValueElm;\n        if (elm) {\n            delete context.simpleValueElm;\n            addPaintRemover(elm, 'smartRemoveByContext');\n            continue;\n        }\n        const subGlobal = context.global;\n        if (subGlobal === undefined) {\n            continue; // context\n        }\n        subGlobal.deleted = true;\n        const oldest = context.state?.oldest;\n        if (oldest) {\n            smartRemoveKids(context, allPromises);\n            continue;\n        }\n    }\n}\n","import { destroyContexts } from '../tag/destroyContexts.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const context = support.context;\n    global.deleted = true;\n    context.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const subContexts = context.contexts;\n    destroyContexts(subContexts, support);\n    // tag() only destroy\n    if (support.templater.wrapper) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(context, promises);\n    delete context.state;\n    delete context.contexts;\n    delete context.returnValue;\n    delete context.providers;\n    return promises;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { destroySupport } from '../render/destroySupport.function.js';\nexport function destroySupportByContextItem(context) {\n    ++context.updateCount;\n    const global = context.global;\n    const state = context.state;\n    const lastSupport = state.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    destroySupportContext(context);\n}\nfunction destroySupportContext(context) {\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    delete context.contexts;\n    delete context.state;\n    delete context.global;\n    context.renderCount = 0;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** When return > 0 then its the same tag */\nexport function checkTagValueChange(newValue, contextItem) {\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            return 7; // 'tag-swap'\n        }\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        if (newValue.wrapper?.original === contextItem.value.wrapper?.original) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    // destroySupportByContextItem(contextItem)\n    return 8; // 'no-longer-tag'\n}\n/*\nexport function checkTagValueChangeAndUpdate(\n  newValue: unknown,\n  contextItem: ContextItem,\n) {\n  const checkValue = checkTagValueChange(newValue, contextItem)\n\n  const global = contextItem.global as SupportTagGlobal\n  const lastSupport = contextItem.state?.newest as AnySupport\n  \n  if(checkValue === 7) {\n    destroySupport(lastSupport, global)\n    getNewGlobal(contextItem as SupportContextItem)\n    return 7 // 'tag-swap'\n  }\n  \n  if(checkValue === 8) {\n    destroySupportByContextItem(contextItem)\n    return 8\n  }\n\n  const isValueTag = isStaticTag(newValue)\n  if(isValueTag) {\n    // always cause a redraw of static tags (was false)\n    tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      lastSupport as AnySupport,\n    )\n\n    return 0\n  }\n\n  const isTag = (newValue as any)?.tagJsType\n  if(isTag) {\n    const state = contextItem.state as ContextStateMeta\n    const support = state.newest as AnySupport\n    const ownerSupport = support.ownerSupport as AnySupport\n    const result = tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      ownerSupport,\n    )\n\n    const doNotRedraw = result === true\n\n    if(doNotRedraw) {\n      return 0\n    }\n\n    return 88 // its same tag with new values\n  }\n\n  destroySupportByContextItem(contextItem)\n  return 8\n}\n*/\nexport function checkTagValueChangeAndUpdate(newValue, contextItem) {\n    const global = contextItem.global;\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport);\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const state = contextItem.state;\n        const support = state.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/addOneContext.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, contexts, support, // owner\nparentContext, depth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, contexts, isWithinOwnerElement, parentContext);\n    contextItem.placeholder = marker;\n    contextItem.element = appendTo;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([\n            paintBefore, [insertBefore, marker, 'attachDynamicDom.attachDynamicDom']\n        ]);\n    }\n    domProcessContextItem(value, support, contextItem, appendTo, insertBefore);\n    return contextItem;\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\n/** Called when one tag changes and we need to find other tags that will need to be rendered */\nexport function providersChangeCheck(support) {\n    const context = support.context;\n    const providers = context.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../cycles/getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, currentDepth) {\n    return props;\n    return props.map(function eachCastProp(prop, pos) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, currentDepth, pos);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth, pos // arguments position\n) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth, pos);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, pos, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth, pos);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth, pos);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth, pos) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth, pos // argument position\n) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport, pos) {\n    // restore object to have original function on destroy\n    if (depth <= 0) {\n        return;\n    }\n    const context = newSupport.context;\n    const castedProps = context.value?.props;\n    if (castedProps) {\n        // check for old prop subscription\n        const prop = castedProps[pos][index];\n        if (prop?.subscription) {\n            prop.subscription(); // unsubscribe to prevent this old argument/prop from being called on destroy\n            prop.restore(); // put original value back\n        }\n    }\n    const altPropRestore = () => {\n        newProp[index] = originalValue;\n    };\n    newProp[index].subscription = newSupport.context.destroy$.toCallback(altPropRestore);\n    newProp[index].restore = altPropRestore;\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const ownerContext = ownerSupport.context;\n    const newest = ownerContext.state?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const context = newest.context;\n        const global = context.global;\n        if (context.locked) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        if (!global) {\n            /*\n            context.tagJsVar.processUpdate(\n              context.value,\n              context,\n              ownerSupport,\n              [],\n            )\n      */\n            ownerContext.tagJsVar.processUpdate(ownerContext.value, ownerContext, ownerSupport, []);\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = subject.state.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    if (!global || !subject.state.newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    const newest = subject.state.newest;\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const context = oldSupport.context;\n    const global = context.global;\n    let pIndex = -1;\n    const providers = context.providers = context.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = contextItem.state.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n}\n","import { hasPropChanges } from './hasPropChanges.function.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContexts.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const context = lastSupport.context;\n    const global = context.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(context.contexts);\n    softDestroyOne(context);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(child.context);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(context);\n}\nfunction softDestroyOne(context) {\n    context.global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(context, []);\n    delete context.contexts;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // tag returns another function expected to be called\n        if (typeof (tag) === BasicTypes.function && tag.tagJsType === undefined) {\n            tag = tag();\n        }\n    }\n    useSupport.context.returnValue = tag;\n    useSupport.returnValue = tag;\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.context.state.newer = { ...config };\n    removeContextInCycle();\n    return useSupport;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterSupportRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    runAfterRender(support.context);\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n/** run after rendering anything with state */\nexport function runAfterRender(context) {\n    saveState(context);\n    // TODO: prove this is worth having\n    // checkStateMismatch(config, support)\n    clearStateConfig();\n    // setUseMemory.tagClosed$.next(ownerSupport)\n}\nfunction saveState(context) {\n    const config = setUseMemory.stateConfig;\n    const subject = context || config.context;\n    subject.state = subject.state || {};\n    subject.state.newer = { ...config };\n    const support = config.support;\n    subject.state.newest = support;\n}\nexport function clearStateConfig() {\n    const config = setUseMemory.stateConfig;\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.state;\n    delete config.states;\n    removeContextInCycle();\n}\n","import { ValueTypes } from '../tag/index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { runAfterSupportRender } from './runAfterRender.function.js';\nexport function callTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    let reSupport;\n    const templater = newSupport.templater;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, context, ownerSupport, newSupport.appSupport);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, context, prevSupport);\n    }\n    runAfterSupportRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\n","import { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { runRestate } from './stateHandlers.js';\nimport { reStatesHandler } from './states.utils.js';\nexport function reState(context) {\n    setContextInCycle(context);\n    const stateMeta = context.state;\n    return reStateByPrev(stateMeta.newer.state);\n}\nexport function reStateByPrev(prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.state = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    return config;\n}\nexport function reStateSupport(newSupport, prevSupport, prevState) {\n    reStateByPrev(prevState);\n    const config = setUseMemory.stateConfig;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\n","import { initState } from '../state/state.utils.js';\nimport { callTag } from './callTag.function.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { reStateSupport } from '../state/reState.function.js';\nexport function reRenderTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    const stateMeta = context.state;\n    const prevState = stateMeta.older.state;\n    reStateSupport(newSupport, prevSupport, prevState);\n    return callTag(newSupport, prevSupport, context, ownerSupport);\n}\n/** Used during first renders of a support */\nexport function firstTagRender(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    initState(newSupport.context);\n    setSupportInCycle(newSupport);\n    const result = callTag(newSupport, prevSupport, context, ownerSupport);\n    removeContextInCycle();\n    return result;\n}\nexport function getSupportOlderState(support) {\n    const context = support?.context;\n    const stateMeta = context?.state;\n    return stateMeta?.older?.state;\n}\n/*\nexport function getSupportNewerState(support?: AnySupport) {\n  const context = support?.context as SupportContextItem\n  const stateMeta = context?.state\n  return stateMeta?.newer?.state\n}\n*/ \n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { firstTagRender, getSupportOlderState, reRenderTag } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\ncontext) {\n    let reSupport;\n    const olderState = getSupportOlderState(lastSupport);\n    // const olderState = getSupportNewerState(lastSupport)\n    if (olderState) {\n        reSupport = reRenderTag(newSupport, lastSupport, context);\n    }\n    else {\n        reSupport = firstTagRender(newSupport, lastSupport, context);\n    }\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const context = reSupport.context;\n        context.state.oldest = reSupport;\n        context.state.newest = reSupport;\n        // context.state.older = context.state.newer\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && context.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n        // context.state.older = context.state.newer\n        // context.state.newer = context.state.older\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return {\n        support: reSupport,\n        wasLikeTags: isLikeTag\n    };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    if (result.wasLikeTags) {\n        const oldest = subject.state.oldest; // || result.support\n        updateSupportBy(oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject);\n}\n","import { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = 4;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(subject.state.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownContext = ownerSupport.context;\n    const newest = ownContext.state.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch } from '../tag/hasSupportChanged.function.js';\nimport { shallowPropMatch } from '../tag/shallowPropMatch.function.js';\nexport function checkRenderUp(templater, support) {\n    const global = support.context.global;\n    if (global && global.deleted) {\n        return false;\n    }\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { checkRenderUp } from \"../../render/checkRenderUp.function.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const global = support.context.global;\n    if (global && global.deleted === true) {\n        return supports;\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const providers = newSupport.context.providers;\n    if (providers) {\n        const proSupports = providersChangeCheck(newSupport);\n        supports.push(...proSupports);\n    }\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const context = support.context;\n    const global = context.global;\n    if (!global) {\n        context.tagJsVar.processUpdate(context.value, context, support.ownerSupport, []);\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    const stateMeta = context.state;\n    renderSupport(stateMeta.newest);\n}\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    const stateMeta = support.context.state;\n    const newestStateMeta = newestSupport.context.state;\n    const fromStates = stateMeta.newer.states;\n    const toStates = newestStateMeta.newer.states;\n    return syncStatesArray(fromStates, toStates);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        subject.locked = 2;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const subject = last.context;\n        const global = subject.global;\n        delete subject.locked;\n        if (subject.deleted === true || global?.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, subject.state.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = 1; // prevent another render from re-rendering this tag\n    // ++painting.locks\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.context.state.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    // --painting.locks\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, last) {\n    const global = last.context.global;\n    if (global?.deleted) {\n        return;\n    }\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","export function bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.originalStopPropagation = event.stopPropagation;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n            event.stopPropagation = event.originalStopPropagation;\n            delete event.originalStopPropagation;\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { bubbleEvent } from './bubbleEvent.function.js';\nexport function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    const replaceEventName = getEventReferenceName(eventName);\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const context = support.context;\n    const eventReg = context.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nexport function getEventReferenceName(eventName) {\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    return '_' + eventName;\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { BasicTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { processAttribute } from './processAttribute.function.js';\n// single/stand alone attributes\nexport function processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    const newContexts = [];\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const isSpecial = isSpecialAttr(name); // only object variables are evaluated for is special attr\n            const value = attrValue[name];\n            const howToSet = setNonFunctionInputValue;\n            const subContext = processAttribute(name, value, values, element, ownerSupport, howToSet, contexts, parentContext, isSpecial);\n            if (subContext !== undefined) {\n                if (Array.isArray(subContext)) {\n                    newContexts.push(...subContext);\n                }\n                else {\n                    newContexts.push(subContext);\n                }\n            }\n        }\n        return newContexts;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processStandAloneAttribute } from '../../render/attributes/processStandAloneAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue) || attrValue === '') {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    const standAloneResult = processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext);\n    if (standAloneResult) {\n        contexts.push(...standAloneResult);\n    }\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateNameOnlyAttrValue.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\n/** Currently universally used for all attributes */\nexport function processUpdateAttrContext(value, contextItem, ownerSupport, values) {\n    const attrContextItem = contextItem;\n    const tagValue = value;\n    if (tagValue?.tagJsType) {\n        const oldValue = contextItem.value;\n        // its now a tagVar value but before was not\n        if (!oldValue?.tagJsType) {\n            tagValue.isAttr = true;\n            setContextInCycle(contextItem);\n            tagValue.processInitAttribute(attrContextItem.attrName, value, attrContextItem.element, tagValue, attrContextItem, ownerSupport, setNonFunctionInputValue);\n            removeContextInCycle();\n            attrContextItem.tagJsVar = tagValue;\n            return;\n        }\n        oldValue.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n        ownerSupport);\n        return;\n    }\n    if (attrContextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, attrContextItem.value, attrContextItem.element, // global.element as Element,\n        ownerSupport, attrContextItem.howToSet, [], // Context, but we dont want to alter current\n        attrContextItem.parentContext);\n        attrContextItem.value = value;\n        return;\n    }\n    const element = attrContextItem.element;\n    processAttributeEmit(value, attrContextItem.attrName, attrContextItem, element, ownerSupport, attrContextItem.howToSet, attrContextItem.isSpecial);\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { processStandAloneAttribute } from './processStandAloneAttribute.function.js';\nimport { processTagJsVarAttribute } from './processTagJsAttribute.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(attrName, value, values, // all the variables inside html``\nelement, support, howToSet, //  = howToSetInputValue\ncontexts, parentContext, isSpecial) {\n    const varIndex = getTagJsVar(attrName);\n    let isNameVar = varIndex >= 0 || (value === undefined && typeof (attrName) !== 'string');\n    let valueInValues = values[varIndex];\n    // value or name from bolt?\n    if (value?.tagJsType) {\n        valueInValues = value; // the value is a tagJsVar\n    }\n    else if (attrName?.tagJsType) {\n        isNameVar = true;\n        valueInValues = attrName; // the name is a tagJsVar\n        value = attrName;\n    }\n    const tagJsVar = valueInValues;\n    if (tagJsVar?.tagJsType) {\n        return processTagJsVarAttribute(value, [], // contexts,\n        parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar);\n    }\n    if (isNameVar) {\n        // old way of setting by html``\n        if (varIndex === -1 && isNameVar) {\n            valueInValues = attrName; // its a name only value attribute\n        }\n        const contextItem = getNewContext(valueInValues, [], // contexts,\n        true, parentContext);\n        contextItem.valueIndex = varIndex;\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.isNameOnly = true;\n        contextItem.howToSet = howToSet;\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // single/stand alone attributes\n        const aloneResult = processStandAloneAttribute(values, valueInValues, element, support, howToSet, contexts, parentContext);\n        if (aloneResult) {\n            contexts.push(...aloneResult);\n        }\n        return contextItem;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, [], // contexts,\n        howToSet, values, support.context);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, [], // contexts,\n        parentContext, howToSet, support, isSpecial, valueVar);\n    }\n    // simple name/value attribute\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, parentContext);\n}\n/** Only used during updates */\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, _subject) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(\n        // subject,\n        newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processTagCallbackFun(\n// subject: AttributeContextItem,\nnewAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    // const tagJsVar = subject.tagJsVar // = valueToTagJsVar(newAttrValue)\n    // tagJsVar.processUpdate = processUpdateAttrContext\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/index.js';\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { Subject } from '../../subject/Subject.class.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, contexts, howToSet, //  = howToSetInputValue\nvalues, parentContext) {\n    const startIndex = contexts.length;\n    const createdContexts = [];\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = contexts.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                updateCount: 0,\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n                valueIndex: parentContext.varCounter, // contexts.length,\n                parentContext,\n                destroy$: new Subject(),\n                render$: new Subject(),\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHandler(value, contextItem, newSupport, newValues) {\n                ++contextItem.updateCount;\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            createdContexts.push(contextItem);\n            ++parentContext.varCounter;\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n    return createdContexts;\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, parentContext, howToSet, //  = howToSetInputValue\nsupport, isSpecial, varIndex) {\n    if (typeof (value) === BasicTypes.function) {\n        ++parentContext.varCounter;\n        return processTagCallbackFun(\n        // contextItem,\n        value, support, attrName, element);\n    }\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        element,\n        attrName,\n        howToSet,\n        value,\n        withinOwnerElement: true,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        valueIndex: varIndex,\n        parentContext,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial);\n    contextItem.value = value;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** adds onto parent.contexts */\nexport function processTagJsVarAttribute(value, contexts, parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar) {\n    // getOneContext\n    const contextItem = getNewContext(value, contexts || [], true, parentContext);\n    contextItem.element = element;\n    contextItem.valueIndex = varIndex;\n    contextItem.isAttr = true;\n    contextItem.isNameOnly = isNameVar;\n    contextItem.stateOwner = getSupportWithState(support);\n    contextItem.supportOwner = support;\n    setContextInCycle(contextItem);\n    tagJsVar.processInitAttribute(attrName, value, // tagJsVar,\n    element, tagJsVar, contextItem, support, setNonFunctionInputValue);\n    removeContextInCycle();\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = tagJsVar;\n    return contextItem;\n}\n","import { howToSetStandAloneAttr, setNonFunctionInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nexport function processAttributeArray(attrs, values, domElement, support, \n// contexts: ContextItem[],\nparentContext) {\n    for (const attr of attrs) {\n        const name = attr[0];\n        const value = attr[1];\n        // const isSpecial2 = !value?.tagJsVar && (typeof(name) === 'string' && isSpecialAttr(name))\n        const isSpecial = attr[2] || false; // isSpecial2\n        let howToSet = attr.length > 1 ? setNonFunctionInputValue : howToSetStandAloneAttr;\n        if (attr[3]) {\n            howToSet = attr[3];\n        }\n        // const contexts = support.context.contexts\n        const contexts = parentContext.contexts;\n        const newContext = processAttribute(name, value, values, domElement, support, howToSet, contexts, parentContext, isSpecial) || undefined;\n        if (typeof newContext === 'object') {\n            contexts.push(newContext);\n            ++parentContext.varCounter;\n        }\n    }\n}\n","import { paintAppends, paintAppend, paintCommands, paintBefore } from \"../paint.function.js\";\nimport { processAttributeArray } from \"./processAttributeArray.function.js\";\nexport function attachDomElement(domElement, node, values, support, parentContext, appendTo, insertBefore) {\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        processAttributeArray(node.at, values, domElement, support, \n        // contexts,\n        parentContext);\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement, 'appendToAttachDomElement']]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement, 'insertBeforeAttachDomElement']]);\n    }\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppendElementString, paintAppends, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nimport { attachDomElement } from \"./attachDomElement.function.js\";\nimport { Subject } from \"../../subject/Subject.class.js\";\nimport { isFunction } from \"../../index.js\";\nexport function attachDomElements(nodes, values, support, parentContext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const context = support.context;\n    const contexts = context.contexts;\n    parentContext = context;\n    // const contexts = parentContext.contexts\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    // loop map of elements that need to be put down on document\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const v = node.v;\n        const isNum = !isNaN(v);\n        if (isNum) {\n            // const valueIndex = context.varCounter // contexts.length\n            // const valueIndex = (parentContext as SupportContextItem).varCounter // contexts.length\n            const valueIndex = Number(v); // (parentContext as SupportContextItem).varCounter // contexts.length\n            const realValue = values[valueIndex];\n            const isSkipFun = isFunction(realValue) && realValue.tagJsType === undefined;\n            if (isSkipFun) {\n                ++parentContext.varCounter;\n                // TODO: I dont think we ever get in here?\n                continue;\n            }\n            const contextItem = attachDynamicDom(realValue, contexts, support, parentContext, depth, appendTo, insertBefore);\n            contextItem.valueIndex = valueIndex;\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        const domElement = newNode.domElement = document.createElement(node.nn);\n        // Create parent context for attributes first\n        const newParentContext = {\n            updateCount: 0,\n            isAttrs: true,\n            element: domElement,\n            parentContext,\n            contexts: [],\n            destroy$: new Subject(),\n            render$: new Subject(),\n            tagJsVar: {\n                tagJsType: 'new-parent-context'\n            },\n            valueIndex: -1,\n            withinOwnerElement: true,\n        };\n        newParentContext.varCounter = 0;\n        // one single html element. This is where attribute processing takes place\n        attachDomElement(domElement, node, values, support, newParentContext, appendTo, insertBefore);\n        // Update parent context with element and attribute contexts\n        newParentContext.element = domElement;\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, newParentContext, \n            // contexts,\n            depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, contexts };\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Merges strings & values with dom meta into a html array tree */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, appendTo, insertBefore) {\n    const subject = support.context;\n    // TODO this is only needed for components and not basic tags\n    subject.state = subject.state || {};\n    const stateMeta = subject.state;\n    stateMeta.oldest = support;\n    stateMeta.newest = support;\n    subject.state.older = subject.state.newer;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, support.context, appendTo, insertBefore);\n    subject.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, parentContext, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const context = support.context;\n    parentContext = context;\n    context.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, parentContext, 0, // depth\n    appendTo, insertBefore);\n    return result;\n}\n/** Extracts variables from support in order to merge strings & values with dom meta into a html array tree */\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChangeAndUpdate } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\nimport { blankHandler } from '../dom/blankHandler.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem) {\n    const support = contextItem.state.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInitAttribute: blankHandler,\n        processInit: processTagInit,\n        processUpdate: blankHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: blankHandler,\n        propWatch: 'shallow',\n        key: blankHandler,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    subject.contexts = subject.contexts || [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\nappendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker, 'subMarker']]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement, 'subAppendTo']]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement, 'subInsertBefore']]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.state = {};\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processInitAttribute: blankHandler,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        },\n        matchesInjection(inject, context) {\n            if (templater.wrapper === inject) {\n                return context;\n            }\n            if (templater.wrapper?.original === inject?.original) {\n                return context;\n            }\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, subject, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { firstTagRender } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    firstTagRender(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, appendTo, insertBefore);\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribeWith(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    const subContext = setupSubscribe(value, contextItem, ownerSupport, insertBefore, appendTo);\n    if (!subContext.hasEmitted) {\n        emitSubContext(value, subContext);\n    }\n    return subContext;\n}\nexport function emitSubContext(value, subContext) {\n    const observables = value.Observables;\n    const observable = observables[0];\n    if (!subContext.hasEmitted) {\n        if ('withDefault' in value) {\n            subContext.subValueHandler(value.withDefault, 0);\n            return;\n        }\n        if ('value' in observable) {\n            subContext.subValueHandler(observable.value, 0);\n            return;\n        }\n        return; // nothing to emit\n    }\n    const emitValue = subContext.lastValues[0].value;\n    subContext.subValueHandler(emitValue, 0);\n}\n","import { setNonFunctionInputValue } from \"../index.js\";\nimport { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { unsubscribeContext, checkToPaint, setupSubscribeCallbackProcessor } from \"../tag/update/setupSubscribe.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\nexport function processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // same as value\ncontextItem, ownerSupport) {\n    // change how the delete occurs\n    value.destroy = unsubscribeContext;\n    const isSpecial = isSpecialAttr(name);\n    const onOutput = function onSubValue(callbackValue, syncRun) {\n        processNonDynamicAttr(name, callbackValue, element, setNonFunctionInputValue, isSpecial, contextItem);\n        checkToPaint(syncRun);\n    };\n    const subContext = setupSubscribeCallbackProcessor(value.Observables, ownerSupport, onOutput, value, contextItem);\n    contextItem.subContext = subContext;\n    contextItem.value = value;\n    contextItem.tagJsVar = value;\n    value.processUpdate = function processAttributeUpdateWrap(value, contextItem2, ownerSupport) {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, setNonFunctionInputValue);\n    };\n    return { subContext, onOutput };\n}\n","import { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nexport function processSubscribeWithAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // its the same as the value\ncontextItem, ownerSupport) {\n    const { subContext } = processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\n    element, value, contextItem, ownerSupport);\n    if (!subContext.hasEmitted) {\n        emitSubScriptionAsIs(value, subContext);\n    }\n}\nexport function emitSubScriptionAsIs(value, subContext) {\n    const tagJsVar = subContext.tagJsVar;\n    const onOutput = tagJsVar.onOutput; // value.onOutput\n    const observables = value.Observables;\n    let obValue = observables[0]?.value || value.withDefault;\n    // subContext.hasEmitted = true\n    // subContext.lastValues[0] = obValue\n    if (value.callback) {\n        obValue = value.callback(obValue);\n    }\n    onOutput(obValue, true, subContext);\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribeWith.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { processSubscribeWithAttribute } from \"./processSubscribeWithAttribute.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    // const support = getSupportInCycle() as AnySupport\n    // const context = getSupportWithState(support).context\n    /*\n    const context = getContextInCycle() as ContextItem\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        onOutput: blankHandler, // this gets set within setupSubscribe\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeWithAttribute,\n        processInit: processSubscribeWith,\n        hasValueChanged: checkSubscribeValueChanged,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        // states: newer.states,\n        Observables: [Observable],\n    };\n}\n/** checks is a previous tag var was a subscription but now has changed */\nexport function checkSubscribeValueChanged(value, contextItem) {\n    if (!value?.tagJsType) {\n        return 1; // its not a subscription anymore\n    }\n    const newObserves = value.Observables;\n    if (!newObserves) {\n        return 2; // its not a subscription anymore\n    }\n    const oldValue = contextItem.value;\n    const oldObserves = oldValue.Observables;\n    if (!oldObserves || oldObserves.length !== newObserves.length) {\n        return 3; // not the same subscription\n    }\n    const allMatch = newObserves.every((ob, index) => ob === oldObserves[index]);\n    if (!allMatch) {\n        return 4;\n    }\n    return 0; // still the same\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** used to handle when value was subscribe but now is something else */\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem) {\n    const isDifferent = !newValue || !newValue.tagJsType || newValue.tagJsType !== originalType;\n    if (isDifferent) {\n        const oldTagJsVar = contextItem.tagJsVar;\n        oldTagJsVar.destroy(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, // subSubContext,\n        ownerSupport, 99);\n        return 99;\n    }\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { handleTagTypeChangeFrom } from './handleTagTypeChangeFrom.function.js';\nexport function checkStillSubscription(newValue, contextItem, ownerSupport) {\n    const subContext = contextItem.subContext;\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    if (!subContext || !subContext.hasEmitted) {\n        return 0;\n    }\n    subContext.tagJsVar = newValue;\n    subContext.valuesHandler(subContext.lastValues, 0);\n    return 0;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\nimport { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { checkStillSubscription } from \"../tag/update/checkStillSubscription.function.js\";\nimport { Subject } from \"../index.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeAttribute,\n        processInit: setupSubscribe,\n        hasValueChanged: checkSubscribeValueChanged,\n        processUpdate: checkStillSubscription,\n        // processUpdate: processUpdateSubscribe,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states,\n        Observables: [Observable],\n    };\n}\nsubscribe.all = subscribeAll;\nfunction subscribeAll(subjects, callback) {\n    return subscribe(Subject.all(subjects), callback);\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteContextSubContext(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subscription = contextItem.subContext;\n    const result = deleteSubContext(subscription, ownerSupport);\n    delete contextItem.subContext;\n    return result;\n}\nexport function deleteSubContext(subContext, ownerSupport) {\n    subContext.deleted = true;\n    const appendMarker = subContext.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker, 'deleteSubContext');\n        delete subContext.appendMarker;\n    }\n    // delete (contextItem as any).destroy\n    if (!subContext.hasEmitted) {\n        return;\n    }\n    const subContextItem = subContext.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.destroy(subContextItem, ownerSupport);\n    return 76;\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, [], insertBefore);\n}\n","import { deleteContextSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, contextItem, newSupport) {\n    ++contextItem.updateCount;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        hasValueChanged: () => 0, // not expected to do anything\n        processInitAttribute: blankHandler,\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        destroy: deleteContextSubContext,\n    };\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    /*\n    const support = getSupportInCycle() as AnySupport\n    const context = getSupportWithState(support).context\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: blankHandler,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInit: processPipe,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states: newer.states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: values,\n    };\n    return setupSubscribe(subValue, contextItem, ownerSupport, undefined, appendTo);\n}\n","import { getContextInCycle, paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\nimport { findStateSupportUpContext } from \"../interpolations/attributes/getSupportWithState.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const context = getContextInCycle();\n    // const support = getSupportWithState(context)\n    // const parentContext = context?.parentContext\n    if (!context) {\n        throw new Error('output must be used in render sync with a parent context');\n    }\n    const support = findStateSupportUpContext(context);\n    // const support = getSupportInCycle() as AnySupport\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    if (callback.wrapped === true) {\n        return callback;\n    }\n    const newCallback = (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport.context);\n    };\n    newCallback.wrapped = true;\n    return newCallback;\n}\nexport function syncWrapCallback(args, callback, context) {\n    const stateMeta = context.state;\n    const newerStates = stateMeta.newer.states;\n    const olderStates = stateMeta.older ? stateMeta.older.states : newerStates;\n    const newestOwner = stateMeta.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newerStates, olderStates);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(olderStates, newerStates);\n    // now render the owner\n    paintAfters.push([() => {\n            const newGlobal = newestOwner.context.global;\n            const ignore = newGlobal === undefined || newGlobal.deleted === true;\n            if (ignore) {\n                ++painting.locks;\n                newestOwner.context.tagJsVar.processUpdate(newestOwner.context.value, newestOwner.context, newestOwner, []);\n                --painting.locks;\n                paint();\n                return; // its not a tag anymore\n            }\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { initState } from \"../state/state.utils.js\";\nimport { reState } from '../state/reState.function.js';\nimport { runAfterRender } from \"../render/runAfterRender.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/handleTagTypeChangeFrom.function.js\";\nimport { isFunction } from \"../index.js\";\n/** Use to gain access to element\n * @callback called every render\n */\nexport function host(callback, options = {}) {\n    const baseHost = {\n        tagJsType: ValueTypes.host,\n        processInitAttribute: processHostAttribute,\n        // TODO: maybe a host value can change?\n        hasValueChanged: () => 0,\n        processInit: processHost, // This should be a throw error because only attribute is supported\n        processUpdate: processHostUpdate,\n        destroy: deleteHost,\n        options: { callback, ...options },\n        matchesInjection(inject, context) {\n            const options = inject?.options;\n            if (!options) {\n                return false;\n            }\n            const injectCallback = options?.callback;\n            // Check if the inject target is a host with the same callback\n            if (injectCallback === callback) {\n                return context;\n            }\n            return false;\n        },\n    };\n    const returnFunction = (...args) => {\n        const hostValue = {\n            ...returnFunction,\n            options: { arguments: args, ...options, callback },\n        };\n        return hostValue;\n    };\n    Object.assign(returnFunction, baseHost);\n    // returnFunction.options = { callback }\n    return returnFunction;\n}\n// Attach the functions to the host namespace\n;\nhost.onInit = (callback) => {\n    return host(() => { }, { onInit: callback });\n};\nhost.onDestroy = (callback) => {\n    return host(() => { }, { onDestroy: callback });\n};\nfunction processHostUpdate(newValue, contextItem, ownerSupport) {\n    if (isFunction(newValue) && !newValue?.tagJsType) {\n        throw new Error('issue on its way');\n    }\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, \n    // tagJsVar,\n    ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const oldTagJsVar = contextItem.tagJsVar;\n    const oldOptions = oldTagJsVar.options;\n    // const element = (contextItem as any as AttributeContextItem).element as HTMLInputElement\n    const newHost = newValue;\n    reState(contextItem);\n    const args = (newHost.options.arguments || oldOptions.arguments || []);\n    contextItem.returnValue = newHost.options.callback(...args);\n    runAfterRender(contextItem);\n}\nfunction processHostAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, // same as value not needed\ncontextItem) {\n    return processHost(tagJsVar, contextItem);\n}\n/* Only runs on host() init */\nfunction processHost(tagJsVar, contextItem) {\n    const element = contextItem.element;\n    const state = contextItem.state = {};\n    initState(contextItem);\n    processHostTagJsVar(element, tagJsVar, contextItem, state);\n    runAfterRender(contextItem);\n}\n/** first time run */\nfunction processHostTagJsVar(element, tagJsVar, contextItem, state) {\n    const args = tagJsVar.options.arguments || [];\n    const returnValue = tagJsVar.options.callback(...args);\n    // Store the return value for tag.inject to access\n    contextItem.returnValue = returnValue;\n    // DEPRECATED\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        // const element = contextItem.element as HTMLInputElement\n        options.onInit(element, tagJsVar, contextItem, state);\n    }\n    return returnValue;\n}\nfunction deleteHost(contextItem) {\n    ++contextItem.updateCount;\n    const attrContext = contextItem;\n    const tagJsVar = attrContext.tagJsVar;\n    const options = tagJsVar.options;\n    if (attrContext.destroy$.subscribers.length) {\n        // TODO: Not sure if this needed\n        setContextInCycle(contextItem);\n        syncWrapCallback([], attrContext.destroy$.next.bind(attrContext.destroy$), contextItem);\n        // TODO: Not sure if this needed\n        removeContextInCycle();\n    }\n    // DEPRECATED\n    // TODO: remove this code and use tag.onDestroy instead\n    if (options.onDestroy) {\n        const element = attrContext.element;\n        const hostDestroy = function processHostDestroy() {\n            setContextInCycle(contextItem);\n            const result = options.onDestroy(element, tagJsVar, attrContext, attrContext.state);\n            removeContextInCycle();\n            return result;\n        };\n        const stateOwner = contextItem.stateOwner;\n        return syncWrapCallback([], hostDestroy, stateOwner.context);\n    }\n}\n","import { isPromise } from '../../index.js';\nimport { paint } from '../../render/index.js';\nimport { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { makeRealUpdate, afterDestroy } from './processFirstSubjectComponent.function.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used when a tag() does not return html`` */\nexport function getOverrideTagVar(context, newContext, support, subject) {\n    // support.context = subject as SupportContextItem\n    const overrideTagVar = {\n        tagJsType: 'tag-conversion',\n        // processInitAttribute: newContext.tagJsVar.processInitAttribute,\n        processInitAttribute: blankHandler, // cannot be an attribute ever\n        processInit: (_value, _contextItem, _ownerSupport) => {\n            const renderContent = context.returnValue;\n            return newContext.tagJsVar.processInit(renderContent, newContext, support, subject.placeholder);\n        },\n        processUpdate: (value, context, ownerSupport) => {\n            if (context.locked || context.deleted) {\n                return;\n            }\n            ++context.updateCount;\n            const oldValue = context.value;\n            const oldType = oldValue.tagJsType;\n            const newType = value?.tagJsType;\n            const hasTypeChanged = newType !== oldType;\n            const hasChanged = checkTagValueChange(value, context);\n            // check to see if the tagConversion itself has changed\n            const changed = hasChanged || hasTypeChanged || overrideTagVar.hasValueChanged(value, context, // aka contextItem,\n            support);\n            if (changed) {\n                overrideTagVar.destroy(context, support);\n                updateToDiffValue(value, context, // newContext\n                ownerSupport, 789);\n                return;\n            }\n            context.locked = 467;\n            context.render$.next(); // cause tag.onRender to fire\n            const convertValue = context.returnValue;\n            makeRealUpdate(newContext, value, context, convertValue, support);\n            delete context.locked;\n        },\n        hasValueChanged: (_value, _context, support) => {\n            const newValue = context.returnValue;\n            const checkResult = newContext.tagJsVar.hasValueChanged(newValue, newContext, support);\n            return checkResult;\n        },\n        destroy: (contextItem, ownerSupport) => {\n            ++context.updateCount;\n            context.deleted = true;\n            delete context.returnValue;\n            const result = newContext.tagJsVar.destroy(newContext, support);\n            if (isPromise(result)) {\n                return result.then(() => {\n                    const result = afterDestroy(context, ownerSupport);\n                    paint();\n                    return result;\n                });\n            }\n            return afterDestroy(context, ownerSupport);\n        }\n    };\n    return overrideTagVar;\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { firstTagRender } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { castProps } from '../props/alterProp.function.js';\nimport { convertTagToElementManaged } from './convertTagToElementManaged.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nfunction createSupportWithProps(templater, subject, ownerSupport) {\n    const newSupport = createSupport(templater, subject, ownerSupport, ownerSupport?.appSupport);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const support = firstTagRender(newSupport, subject.state.newest, // existing tag\n    subject);\n    return support;\n}\nexport function processReplacementComponent(templater, context, ownerSupport) {\n    const support = createSupportWithProps(templater, context, ownerSupport);\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, support.ownerSupport, context);\n    }\n    buildBeforeElement(support, undefined, // element for append child\n    context.placeholder);\n    return support;\n}\nexport function makeRealUpdate(newContext, value, context, convertValue, support) {\n    const castedProps = castProps(value.props, support, // ownerSupport,\n    0);\n    newContext.value.props = castedProps;\n    const propsConfig = support.propsConfig;\n    if (propsConfig) {\n        propsConfig.castProps = castedProps;\n    }\n    ;\n    newContext.updatesHandler = context.updatesHandler;\n    if (context.updatesHandler) {\n        setContextInCycle(context);\n        const updatesHandler = context.updatesHandler;\n        updatesHandler(castedProps); // updates()\n        removeContextInCycle();\n    }\n    newContext.tagJsVar.processUpdate(convertValue, newContext, support, []);\n    newContext.value = convertValue;\n}\nexport function afterDestroy(context, _ownerSupport) {\n    delete context.returnValue;\n    delete context.global // = {} as any;\n    ;\n    context.contexts = [];\n    ;\n    context.htmlDomMeta = [];\n    delete context.updatesHandler;\n    // context.value.destroy(context, ownerSupport)\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, appendTo) {\n    const support = createSupportWithProps(templater, subject, ownerSupport);\n    // DISCOVER IF tag() did NOT return dom|html\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, ownerSupport, subject);\n    }\n    return processFirstTagResult(support, appendTo);\n}\n","import { Subject } from '../../index.js';\nimport { valueToTagJsVar } from '../../tagJsVars/index.js';\nimport { getOverrideTagVar } from './getOverrideTagVar.js';\nexport function convertTagToElementManaged(support, ownerSupport, subject) {\n    const context = support.context;\n    const newValue = support.returnValue; // context.returnValue\n    // EXAMPLE: ['a','b'].map(x=> tag(() => [div,span]).key(x))\n    /*\n    if(Array.isArray(newValue)) {\n      ;(newValue as any).key = (arrayValue: any) => keyTag(arrayValue, newValue)\n    }\n    */\n    const tagJsVar = valueToTagJsVar(newValue);\n    delete context.global;\n    context.contexts = [];\n    const newContext = {\n        updateCount: 0,\n        value: newValue,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        placeholder: context.placeholder,\n        // not important\n        valueIndex: -1,\n        withinOwnerElement: true,\n        parentContext: context,\n        contexts: context.contexts, // share contexts especially so providers properly crawl my available contexts\n        // contexts: subject.contexts, // share contexts especially so providers properly crawl my available contexts\n    };\n    // context.contexts = [ newContext ] as ContextItem[] & SupportContextItem[]\n    const overrideTagVar = getOverrideTagVar(context, newContext, support, subject);\n    context.tagJsVar = overrideTagVar;\n    // TODO: should we be calling this here?\n    tagJsVar.processInit(newValue, newContext, support, subject.placeholder);\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, appendTo) {\n    const result = buildBeforeElement(support, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\n_insertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processFirstSubjectComponent(value, contextItem, ownerSupport, appendTo);\n    }\n    return processReplacementComponent(value, contextItem, ownerSupport);\n}\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { tag } from '../index.js';\nimport { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const context = getContextInCycle();\n        if (context.global) {\n            const nowSupport = getSupportInCycle();\n            return checkToResolvePromise(result, nowSupport, { resolvePromise, resolveValue });\n        }\n    });\n    return tag;\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n","import { state } from \"./state.function.js\";\nimport { getContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const context = getContextInCycle();\n        context.destroy$.toCallback(callback);\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { callback, setUseMemory, state } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../tag/checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from '../tag/destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { getContextInCycle, getElement as getTagElement } from '../tag/cycles/setContextInCycle.function.js';\nimport { tagInject } from './tagInject.function.js';\nimport { onInit as tagOnInit } from '../state/onInit.function.js';\nimport { onDestroy as tagOnDestroy } from '../state/onDestroy.function.js';\nimport { onRender as tagOnRender } from '../state/onRender.function.js';\nimport { getInnerHTML as tagGetInnerHTML } from '../index.js';\nlet tagCount = 0;\nconst onClick = makeEventListener('click');\nconst onMouseDown = makeEventListener('mousedown');\nfunction makeEventListener(type) {\n    return function eventListener(toBeCalled) {\n        const wrapped = callback(toBeCalled); // should cause render to occur\n        // run one time\n        state(() => {\n            const element = getTagElement();\n            element.addEventListener(type, wrapped);\n        });\n        return wrapped; // this is what you remove\n    };\n}\nconst tagElement = {\n    get: getTagElement,\n    onclick: onClick,\n    click: onClick,\n    onClick,\n    mousedown: onMouseDown,\n    onmousedown: onMouseDown,\n    onMouseDown: onMouseDown,\n};\ndefineGetSet('onclick', onClick);\ndefineGetSet('click', onClick);\ndefineGetSet('onMouseDown', onMouseDown);\ndefineGetSet('onmousedown', onMouseDown);\ndefineGetSet('mousedown', onMouseDown);\nfunction defineGetSet(name, eventFn) {\n    Object.defineProperty(tag, name, {\n        get() {\n            return eventFn;\n        },\n        set(fn) {\n            return eventFn(fn);\n        },\n    });\n}\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        templater.hasValueChanged = checkTagValueChangeAndUpdate;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    const returnWrap = parentWrap;\n    // used for argument updates\n    returnWrap.updates = (handler) => {\n        const context = getContextInCycle();\n        context.updatesHandler = handler;\n        return true;\n    };\n    returnWrap.getInnerHTML = tagGetInnerHTML;\n    return returnWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n// actually placing of items into tag memory\n;\ntag.element = tagElement;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.inject = tagInject;\ntag.onInit = tagOnInit;\ntag.onDestroy = tagOnDestroy;\ntag.onRender = tagOnRender;\ntag.getInnerHTML = tagGetInnerHTML;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.destroy = destroySupportByContextItem;\n        oneRenderFunction.hasValueChanged = function renderOnceNeverChanges() {\n            return 0;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.hasValueChanged = checkTagValueChangeAndUpdate;\n        renderFunction.destroy = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch } from './hasSupportChanged.function.js';\nimport { shallowPropMatch } from './shallowPropMatch.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nimport { hasPropLengthsChanged } from '../render/checkRenderUp.function.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Inject a parent tag or host into the current context\n * For host functions, returns the value returned by the host callback\n * For tag components, returns the tag instance itself\n */\nexport function tagInject(targetItem) {\n    const context = getContextInCycle();\n    if (!context) {\n        throw new Error('tag.inject can only be called within a tag or host context');\n    }\n    // Search up the context tree for a matching parent\n    let currentContext = context.parentContext;\n    while (currentContext) {\n        // Check if this is an attributes context with child contexts\n        const contexts = currentContext.contexts;\n        if (contexts) {\n            // Search within the attributes contexts\n            for (const attrContext of contexts) {\n                if (attrContext.isAttr && attrContext.tagJsVar?.matchesInjection) {\n                    // Use the matchesInjection method if available\n                    const inContext = attrContext.tagJsVar.matchesInjection(targetItem, attrContext);\n                    if (inContext !== undefined) {\n                        // For host values, return the returnValue from the context\n                        return inContext.returnValue;\n                    }\n                }\n            }\n        }\n        // Check if this context has a tagJsVar with matchesInjection\n        if (currentContext.tagJsVar?.matchesInjection) {\n            if (currentContext.tagJsVar.matchesInjection(targetItem, currentContext)) {\n                // For tag components, return the tag instance\n                return currentContext.returnValue;\n            }\n        }\n        // Move up to the parent context\n        currentContext = currentContext.parentContext;\n    }\n    const message = `Could not find parent context for tag.inject ${targetItem}`;\n    console.error(message, { targetItem, context });\n    throw new Error(message);\n}\n","import { getContextInCycle, removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onRender(callback) {\n    const context = getContextInCycle();\n    const callbackWrap = (_isFirst) => {\n        // remember current context (old)\n        // const oldIndex = setUseMemory.stateConfig.statesIndex\n        const lastContext = getContextInCycle();\n        // set to inner context cycle with previous state position\n        setContextInCycle(context);\n        const result = callback();\n        // restore previous cycle\n        removeContextInCycle();\n        setContextInCycle(lastContext);\n        return result;\n    };\n    const subscription = context.render$.subscribe(() => callbackWrap());\n    const result = callbackWrap();\n    tag.onDestroy(() => subscription.unsubscribe());\n    return result;\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    const global = context.global;\n    global.blocked = [];\n    // context.state.newer = context.state.newer || { ...setUseMemory.stateConfig }\n    if (!context.state) {\n        context.state = {\n            newer: {\n                state: [],\n                states: [],\n            }\n        };\n    }\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, // when appSupport not defined then this support becomes appSupport\nappSupport, castedProps) {\n    support.appSupport = appSupport || support;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsubject, ownerSupport, // when not\nappSupport, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport || support;\n    support.ownerSupport.appSupport = appSupport || support.ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        // its html/dom based tag\n        const support = contextItem.state.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, contextItem.placeholder);\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = newValue;\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    // When last value was not a component\n    if (!contextItem.state.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, contextItem, ownerSupport, ownerSupport.appSupport);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, subject, ownerSupport, ownerSupport.appSupport);\n    const lastSubject = oldSupport.context;\n    const oldest = lastSubject.state.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './arrays/processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, context, ownerSupport, ignoreOrDestroyed) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    delete context.deleted;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(context, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(context, newValue, ownerSupport);\n        context.oldTagJsVar = context.tagJsVar;\n        context.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        context.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) { // TODO: is this check really needed?\n        processNowRegularValue(newValue, context);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.hasValueChanged(newValue, contextItem, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === 0) {\n        return ignoreOrDestroyed; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed);\n    return ignoreOrDestroyed;\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { checkStillSubscription } from './checkStillSubscription.function.js';\nimport { emitSubContext } from './processSubscribeWith.function.js';\nexport function processUpdateSubscribe(newValue, contextItem, ownerSupport) {\n    const resultNum = checkStillSubscription(newValue, // subValue,\n    contextItem, ownerSupport);\n    if (contextItem.hasEmitted !== true) {\n        const Observables = contextItem.value.Observables;\n        if (!Observables) {\n            return;\n        }\n        const Observable = Observables[0];\n        // const subValue = Observable.value\n        if (!('value' in Observable)) {\n            return; // its never emitted\n        }\n    }\n    if (resultNum === 0 && newValue.callback) {\n        const subContext = contextItem.subContext;\n        emitSubContext(newValue, subContext);\n    }\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { deleteSubContext } from './deleteContextSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { processUpdateSubscribe } from './processUpdateSubscribe.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nexport function setupSubscribe(value, contextItem, ownerSupport, insertBeforeOriginal, // optional but will always be made\nappendTo) {\n    const observables = value.Observables;\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    let onOutput = function onSubValue(value, syncRun, subContext) {\n        onFirstSubContext(value, subContext, ownerSupport, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = subContext.tagJsVar.onOutput = function subscriptionUpdate(updateValue, syncRun, subContext) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport);\n            aContext.tagJsVar.processUpdate(updateValue, aContext, ownerSupport, [updateValue]);\n            // processUpdateContext(ownerSupport)\n            aContext.value = updateValue;\n            checkToPaint(syncRun);\n        };\n    };\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, (value, syncRun, subContext) => onOutput(value, syncRun, subContext), value, contextItem);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    value.processUpdate = processUpdateSubscribe;\n    value.onOutput = onOutput;\n    return subContext;\n}\n/** After calling this function you need to set `contextItem.subContext = subContext` */\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\nonOutput, tagJsVar, contextItem) {\n    // const component = getSupportWithState(ownerSupport)\n    // onValue mutates so function below calls original and mutation\n    function subValueHandler(value, index) {\n        subContext.lastValues[index] = {\n            value,\n            tagJsVar: valueToTagJsVar(value),\n            oldTagJsVar: subContext.lastValues[index]?.tagJsVar\n        };\n        valuesHandler(subContext.lastValues, index);\n    }\n    function valuesHandler(newValues, index) {\n        const newestParentTagJsVar = subContext.tagJsVar;\n        const callback = newestParentTagJsVar?.callback;\n        if (callback) {\n            setContextInCycle(contextItem);\n            const responseValue = newestParentTagJsVar.callback(...newValues.map(x => x.value));\n            onOutput(responseValue, syncRun, subContext);\n            removeContextInCycle();\n            return;\n        }\n        const newValue = newValues[index].value;\n        onOutput(newValue, syncRun, subContext);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        subValueHandler,\n        valuesHandler,\n        tagJsVar,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => subValueHandler(value, index)));\n        syncRun = false;\n    });\n    tagJsVar.onOutput = onOutput;\n    return subContext;\n}\nexport function unsubscribeContext(contextItem) {\n    const subscription = contextItem.subContext;\n    if (!subscription) {\n        return; // TODO: wonder why this happens, maybe subscription never emits?\n    }\n    const subscriptions = subscription.subscriptions;\n    subscriptions.forEach(sub => sub.unsubscribe());\n    delete contextItem.subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subContext = contextItem.subContext;\n    unsubscribeContext(contextItem);\n    return deleteSubContext(subContext, ownerSupport);\n}\nexport function checkToPaint(syncRun) {\n    if (syncRun) {\n        return;\n    }\n    if (setUseMemory.stateConfig.support) {\n        return;\n    }\n    paint();\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nexport function processSignal(value, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: [value],\n    };\n    setupSubscribe(subValue, contextItem, ownerSupport, _insertBefore, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSignal.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { checkSubscribeValueChanged } from '../tagJsVars/subscribeWith.function.js';\nimport { processUpdateSubscribe } from '../tag/update/processUpdateSubscribe.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        tagJsType: ValueTypes.signal,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInitAttribute: blankHandler,\n        processInit: processSignal,\n        processUpdate: processUpdateSubscribe,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        destroy: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { ValueSubject } from '../subject/index.js';\nimport { tag } from '../tag/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback).pastResult;\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup).pastResult;\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const isFun = typeof (currentValues) === 'function';\n    const realValues = isFun ? currentValues() : currentValues;\n    const isFirstRender = previous.values === undefined;\n    let renderCount = 0;\n    if (isFirstRender) {\n        if (typeof (currentValues) === 'function') {\n            tag.onRender(() => {\n                ++renderCount;\n                if (renderCount === 1) {\n                    return; // first run is already performed\n                }\n                const realValues = currentValues();\n                processRealValues(realValues);\n            });\n        }\n    }\n    function processRealValues(realValues) {\n        // First time running watch?\n        if (previous.values === undefined) {\n            if (before && !before(realValues)) {\n                previous.values = realValues;\n                return previous; // do not continue\n            }\n            const castedInit = init || callback;\n            const result = castedInit(realValues, previous.values);\n            previous.pastResult = final(result);\n            previous.values = realValues;\n            return previous;\n        }\n        const allExact = realValues.every((item, index) => item === previous.values[index]);\n        if (allExact) {\n            return previous;\n        }\n        if (before && !before(realValues)) {\n            previous.values = realValues;\n            return previous; // do not continue\n        }\n        const result = callback(realValues, previous.values);\n        previous.pastResult = final(result);\n        previous.values.length = 0;\n        previous.values.push(...realValues);\n        return previous;\n    }\n    return processRealValues(realValues);\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => {\n                return new ValueSubject(undefined);\n            });\n            const oldState = state(() => ({\n                state: setUseMemory.stateConfig.state,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                const handler = (realValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(realValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.state;\n                        const context = firstSupport.context;\n                        const stateMeta = context.state;\n                        const oldestStateSupport = stateMeta.older;\n                        if (oldestStateSupport) {\n                            const oldestState = oldestStateSupport.state;\n                            const newStates = oldState.states;\n                            const oldStates = oldestStateSupport.states;\n                            oldSyncStates(newestState, oldestState, newStates, oldStates);\n                        }\n                    }\n                    subject.next(setTo);\n                };\n                setupWatch(currentValues, handler, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            state: setUseMemory.stateConfig.state,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            const context = nowSupport.context;\n            const stateMeta = context.state;\n            const newer = stateMeta.newer;\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        state: setUseMemory.stateConfig.state,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        const context = nowSupport.context;\n        const stateMeta = context.state;\n        const newer = stateMeta.newer;\n        if (newer) {\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n        }\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.state.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.state.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const context = support.context;\n            // const global = context.global as SupportTagGlobal\n            const providers = context.providers = context.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const context = owner.ownerSupport.context;\n            // const ownGlobal = context.global as SupportTagGlobal\n            const ownerProviders = context.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const context = support.context;\n                const providers = context.providers = context.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { paint } from '../tag/index.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const context = getContextInCycle();\n    const callbackState = state({\n        callback,\n    });\n    // ensure only one trigger instance created and always returned\n    const callbackTrigger = state(() => createTrigger(context, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callbackState));\n    // always update callback to latest in cycle\n    callbackState.callback = callback;\n    return callbackTrigger;\n}\nexport function createTrigger(context, oldState, callbackState) {\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        // ++painting.locks\n        const result = callbackStateUpdate(context, oldStates, callbackState.callback, ...args);\n        // --painting.locks\n        paint();\n        return result;\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nimport { findStateSupportUpContext } from '../interpolations/attributes/getSupportWithState.function.js';\nexport default function callbackStateUpdate(context, _oldStates, callback, ...args) {\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    const newestSupport = findStateSupportUpContext(context);\n    // TODO: This if may not be ever doing anything\n    if (!newestSupport) {\n        return maybePromise;\n    }\n    // context.global && \n    if (newestSupport.context.global) {\n        renderSupport(newestSupport); // TODO: remove with html``\n    }\n    else {\n        const supContext = newestSupport.context;\n        supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n        []);\n    }\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            if (context.global) {\n                renderSupport(newestSupport); // TODO: remove\n            }\n            else {\n                const supContext = newestSupport.context;\n                supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n                []);\n            }\n        });\n    }\n    return maybePromise;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport const callbackMaker = () => {\n    const context = getContextInCycle();\n    // const support = getSupportInCycle()\n    // callback as typeof innerCallback\n    if (!context) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(context, oldState, { callback });\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { setUseMemory } from '../../state/index.js';\nexport function getContextInCycle() {\n    return setUseMemory.stateConfig.context;\n}\n/** Gets the current element associated with taggedjs document processing */\nexport function getElement() {\n    const context = getContextInCycle();\n    return context.element;\n}\n// const contextCycles: ContextItem[] = []\nexport function setContextInCycle(context) {\n    // contextCycles.push(context)\n    return setUseMemory.stateConfig.context = context;\n}\nexport function removeContextInCycle() {\n    // contextCycles.pop()\n    delete setUseMemory.stateConfig.context;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    const stateMeta = contextItem.state = contextItem.state || {};\n    stateMeta.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    insertBefore, appendTo);\n    // contextItem.handler = function outDomTagHanlder(\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate = function outDomTagHanlder(value, contextItem2, newSupport) {\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.hasValueChanged = checkOuterTagValueChange;\n}\nfunction checkOuterTagValueChange(newValue, contextItem) {\n    return checkTagValueChangeAndUpdate(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem);\n}\n/** tag(html``) When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInitAttribute: blankHandler,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            return keyTag(arrayValue, tag);\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\nexport function keyTag(arrayValue, tag) {\n    keyTag(arrayValue, tag);\n    tag.arrayValue = arrayValue;\n    return tag;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInitAttribute: blankHandler,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { getStringTag } from './processOuterDomTagInit.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { setSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\nimport { removeContextInCycle } from './cycles/setContextInCycle.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, // aka appElement\nprops) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    const newest = subject.state.newest;\n    initState(newest.context);\n    setSupportInCycle(newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            subject.state.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const result = renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n    removeContextInCycle();\n    return result;\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        processInitAttribute: blankHandler,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const context = {\n        updateCount: 0,\n        value: templater,\n        valueIndex: 0,\n        varCounter: 0,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        state: {},\n        // parentContext: undefined as any,\n        tagJsVar,\n    };\n    // sets new global on context\n    getNewGlobal(context);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    context.events = {};\n    loadNewBaseSupport(templater, context, appElement);\n    return context;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    // Initialize older/newer with empty state if first render\n    if (!subject.state.oldest) {\n        subject.state.oldest = newSupport;\n        subject.state.older = subject.state.newer;\n    }\n    subject.state.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { processReplacementComponent } from '../tag/update/processFirstSubjectComponent.function.js';\n// Imports used only by the commented-out runWrapper/executeStateWrap functions:\n// import { ContextStateSupport } from '../tag/ContextStateMeta.type.js'\n// import { Wrapper } from '../index.js'\n// import { createSupport } from '../tag/createSupport.function.js'\n// import { runAfterSupportRender } from './runAfterRender.function.js'\n// import { executeWrap } from './executeWrap.function.js'\n// import { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js'\n// import { reStateSupport } from '../state/reState.function.js'\nexport function renderTagElement(app, global, templater, templater2, element, // appElement\ncontext, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    context.placeholder = placeholder;\n    /*\n    const support = runWrapper(\n      templater,\n      placeholder,\n      element,\n      context,\n      isAppFunction,\n    )\n    */\n    global.isApp = true;\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = context.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        context.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    const ownerSupport = {\n        appSupport: {\n            appElement: element,\n            context,\n        },\n        appElement: element\n    };\n    const support = processReplacementComponent(templater, context, ownerSupport);\n    support.appElement = element;\n    // support.appSupport = support\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    /*\n    const newFragment = registerTagElement(\n      support,\n      element,\n      global,\n      templater,\n      app,\n      placeholder,\n    )\n    */\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\n","function isTemplateStringsArray(value) {\n    return (Array.isArray(value) &&\n        Object.prototype.hasOwnProperty.call(value, 'raw'));\n}\nexport function makeAttrCallable(attrName, attr) {\n    return function (item, stringsOrValue, values) {\n        if (isTemplateStringsArray(stringsOrValue)) {\n            const attrValue = stringsOrValue.reduce((all, chunk, index) => all + chunk + (values[index] ?? ''), '');\n            return attr(item, [attrName, attrValue]);\n        }\n        return attr(item, [attrName, stringsOrValue]);\n    };\n}\n","import { isFunction, isObject } from '../index.js';\nimport { setBooleanAttribute, setNonFunctionInputValue, setSimpleAttribute } from '../interpolations/attributes/howToSetInputValue.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { makeAttrCallable } from './attributeCallables.js';\nfunction callbackWrapper(item, eventName, callback) {\n    const clone = getPushKid(item, item.elementFunctions);\n    return callbackWrapper2(clone, eventName, callback);\n}\nfunction callbackWrapper2(item, eventName, callback) {\n    function wrapCallback(e) {\n        return wrapCallback.toCallback(e);\n    }\n    wrapCallback.toCallback = callback;\n    item.listeners.push([eventName, wrapCallback]);\n    item.allListeners.push([eventName, wrapCallback]);\n    return item;\n}\nfunction attr(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    clone.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsVar\n    }\n    return clone;\n}\nconst styleCallable = makeAttrCallable('style', attr);\nconst idCallable = makeAttrCallable('id', attr);\nconst classCallable = makeAttrCallable('class', attr);\nconst hrefCallable = makeAttrCallable('href', attr);\nfunction attr2(item, args) {\n    // const clone = getPushKid(item as any, item.elementFunctions)\n    // clone.attributes.push(args as Attribute)\n    item.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], item); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], item); // the attrValue is a function or TagJsVar\n    }\n    return item;\n}\nexport function elementFunctions(item) {\n    /** Used for all element callbacks */\n    function makeCallback(eventName) {\n        return function (callback) {\n            return callbackWrapper(item, eventName, callback);\n        };\n    }\n    // TODO: This maybe the old way of doing things (see callables)\n    const callables_other = {\n        // ...eventCallables,\n        onClose: makeCallback('onclose'),\n        onDoubleClick: makeCallback('ondblclick'),\n        onClick: makeCallback('click'),\n        // onclick: makeCallback('click'),\n        // click: makeCallback('click'),\n        onBlur: makeCallback('onblur'),\n        onChange: makeCallback('onchange'),\n        // onchange: makeCallback('onchange'),\n        // change: makeCallback('onchange'),\n        onMousedown: makeCallback('onmousedown'),\n        onMouseup: makeCallback('onmouseup'),\n        onKeydown: makeCallback('onkeydown'),\n        onKeyup: makeCallback('onkeyup'),\n        // onkeyup: makeCallback('onkeyup'),\n        // keyup: makeCallback('onkeyup'),\n        /* apply attribute via attr(name: string, value?: any): **/\n        attr: (...args) => attr(item, args),\n        /** Used for setting array index-key value */\n        key: function (arrayValue) {\n            ;\n            this.arrayValue = arrayValue;\n            return this;\n        },\n        /** Use as div.style`border:${border}` or div.style(() => `border:${border}`) */\n        style: ((stringsOrValue, ...values) => {\n            return styleCallable(item, stringsOrValue, values);\n        }),\n        /** Use as div.id`main` or div.id(() => `main-${1}`) */\n        id: ((stringsOrValue, ...values) => {\n            return idCallable(item, stringsOrValue, values);\n        }),\n        /** Use as div.class`primary` or div.class(() => `primary`) */\n        class: ((stringsOrValue, ...values) => {\n            return classCallable(item, stringsOrValue, values);\n        }),\n        /** Use as a.href`/path` or a.href(() => `/path`) */\n        href: ((stringsOrValue, ...values) => {\n            return hrefCallable(item, stringsOrValue, values);\n        }),\n    };\n    return callables_other;\n}\nfunction setClassValue(element, name, value) {\n    if (isObject(value)) {\n        Object.entries(value).forEach(([name, value]) => {\n            if (value) {\n                element.classList.add(name);\n            }\n            else {\n                element.classList.remove(name);\n            }\n        });\n        return; // howToSetInputObjectValue(element, name, value as Record<string, any>)\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used during updates */\nexport function registerMockAttrContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\nexport function isValueForContext(value) {\n    return Array.isArray(value) || isFunction(value) || value?.tagJsType;\n}\nfunction setupAttr(attrName, howToSet) {\n    return (item, value) => attr2(item, [attrName, value, false, howToSet]);\n}\nfunction makeCallback(eventName) {\n    return (item, callback) => {\n        return callbackWrapper2(item, eventName, callback);\n    };\n}\nconst eventCallables = {\n    onClose: makeCallback('onclose'),\n    onClick: makeCallback('click'),\n    onDoubleClick: makeCallback('ondblclick'),\n    onDblClick: makeCallback('ondblclick'),\n    onBlur: makeCallback('onblur'),\n    onChange: makeCallback('onchange'),\n    onMousedown: makeCallback('onmousedown'),\n    onMouseDown: makeCallback('onmousedown'),\n    onMouseup: makeCallback('onmouseup'),\n    onMouseUp: makeCallback('onmouseup'),\n    onKeyup: makeCallback('onkeyup'),\n    onKeyUp: makeCallback('onkeyup'),\n    onKeydown: makeCallback('onkeydown'),\n    onKeyDown: makeCallback('onkeydown'),\n};\nconst callables = {\n    checked: setupAttr('checked', setBooleanAttribute),\n    selected: setupAttr('selected', setBooleanAttribute),\n    /** element.setAttribute('style', x)  */\n    class: setupAttr('class', setClassValue),\n    ...eventCallables\n};\nexport function loopObjectAttributes(item, object) {\n    const result = Object.entries(object).reduce((all, [name, value]) => {\n        if (name in callables) {\n            return callables[name](item, value);\n        }\n        return attr2(item, [name, value, false, setNonFunctionInputValue]);\n    }, item);\n    return result;\n}\n","import { isPromise } from '../index.js';\nimport { paint, painting } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\nimport { destroyContextHtml } from '../tag/smartRemoveKids.function.js';\nexport function destroyDesignElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            context.deleted = true;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                // destroyContextHtml(context)\n                destroyHtmlDomMeta(htmlDomMeta);\n                // delete context.htmlDomMeta\n                context.htmlDomMeta = [];\n                // context.deleted = true\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n    destroyContextHtml(context);\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    // context.deleted = true\n    delete context.contexts;\n    context.deleted = true;\n}\nexport function destroyDesignByContexts(contexts, ownerSupport, promises) {\n    const context = contexts[0];\n    const result = context.tagJsVar.destroy(context, ownerSupport);\n    context.deleted = true;\n    if (isPromise(result)) {\n        return promises.push(result.then(() => {\n            if (contexts.length > 1) {\n                return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n            }\n        }));\n    }\n    if (context.htmlDomMeta) {\n        destroyContextHtml(context);\n        delete context.htmlDomMeta;\n    }\n    if (contexts.length > 1) {\n        return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n    }\n}\n","import { updateToDiffValue } from '../tag/update/updateToDiffValue.function.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nexport function processDesignElementUpdate(value, context, ownerSupport) {\n    const skip = context.locked || context.deleted === true;\n    if (skip) {\n        return; // something else is running an event\n    }\n    ++context.updateCount;\n    const hasChanged = checkTagElementValueChange(value, context);\n    if (hasChanged) {\n        destroyDesignElement(context, ownerSupport);\n        // delete context.htmlDomMeta // The next value needs to know its not been deleted\n        context.htmlDomMeta = []; // The next value needs to know its not been deleted\n        // context.deleted = true // its not deleted but changed\n        delete context.deleted; // its not deleted but changed\n        updateToDiffValue(value, context, // newContext,\n        ownerSupport, 789);\n        return;\n    }\n    const contexts = context.contexts;\n    const vContexts = value.contexts || [];\n    const ogListeners = context.tagJsVar.allListeners;\n    const allListeners = value.allListeners;\n    allListeners.forEach((newListener, index) => {\n        // ensure the latest callback is always called. Needed for functions within array maps\n        const wrapCallback = ogListeners[index][1];\n        wrapCallback.toCallback = newListener[1].toCallback;\n    });\n    if (contexts.length !== vContexts.length) {\n        console.info('context mismatch', {\n            value,\n            context,\n            conValues: contexts.map(x => x.value),\n            vContexts,\n            deleted: context.deleted\n        });\n        throw new Error('super issue discovered');\n    }\n    context.locked = 79;\n    contexts.forEach((context, index) => {\n        context.tagJsVar.processUpdate(vContexts[index], // context.value,\n        context, ownerSupport);\n    });\n    delete context.locked;\n}\nexport function checkTagElementValueChange(value, context) {\n    const oldValue = context.value;\n    if (oldValue === value) {\n        return 0; // has not changed\n    }\n    // return 1 // it has changed\n    const notElement = !value || value.tagJsType !== 'element';\n    if (notElement) {\n        return 1;\n    }\n    const newKidLength = value.innerHTML.length;\n    const oldKidLength = context.value.innerHTML.length;\n    const kidLengthChanged = newKidLength !== oldKidLength;\n    if (kidLengthChanged) {\n        return 1;\n    }\n    const newAttrLength = value.attributes.length;\n    const oldAttrLength = context.value.attributes.length;\n    const kidAttrChanged = newAttrLength !== oldAttrLength;\n    if (kidAttrChanged) {\n        return 1;\n    }\n    return 0;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { getNewContext } from '../render/addOneContext.function.js';\nimport { paintCommands } from '../render/paint.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nimport { processElementVarFunction } from './processElementVarFunction.function.js';\nexport function processChildren(innerHTML, parentContext, ownerSupport, element, // appendTo\npaintBy) {\n    innerHTML.forEach(item => {\n        const type = typeof item;\n        switch (type) {\n            case 'string':\n            case 'boolean':\n            case 'number':\n                return handleSimpleInnerValue(item, element, paintBy);\n            case 'function': {\n                if (item.tagJsType === 'element') {\n                    break; // skip\n                }\n                const result = processElementVarFunction(item, element, parentContext, ownerSupport, paintBy);\n                return result;\n            }\n        }\n        if (item === null || item === undefined) {\n            return handleSimpleInnerValue(item, element, paintBy);\n        }\n        if (item.tagJsType === 'element') {\n            const newElement = processElementVar(item, parentContext, ownerSupport, parentContext.contexts);\n            paintCommands.push([paintBy, [element, newElement]]);\n            const htmlDomMeta = parentContext.htmlDomMeta;\n            htmlDomMeta.push({\n                nn: newElement.tagName,\n                domElement: newElement,\n                // at: newElement.attributes,\n                at: [],\n            });\n            return;\n        }\n        return processNonElement(item, parentContext, element, ownerSupport, paintBy);\n    });\n}\n/** used when a child is not another element and requires init processing */\nexport function processNonElement(item, parentContext, element, ownerSupport, paintBy) {\n    const newContext = getNewContext(item, [], // addedContexts\n    true, parentContext);\n    const contexts = parentContext.contexts;\n    contexts.push(newContext);\n    newContext.element = element;\n    newContext.placeholder = document.createTextNode('');\n    paintCommands.push([paintBy, [element, newContext.placeholder]]);\n    setContextInCycle(newContext);\n    newContext.tagJsVar.processInit(item, newContext, // context, // newContext,\n    ownerSupport, newContext.placeholder);\n    removeContextInCycle();\n    return newContext;\n}\nexport function handleSimpleInnerValue(value, element, paintBy) {\n    const castedValue = castTextValue(value);\n    const text = document.createTextNode(castedValue);\n    paintCommands.push([paintBy, [element, text]]);\n    return text;\n}\n","import { isFunction, Subject } from '../index.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processNonElement } from './processChildren.function.js';\nexport function processElementVarFunction(item, element, parentContext, ownerSupport, paintBy) {\n    const subContexts = [];\n    const subContext = {\n        updateCount: 0,\n        parentContext,\n        contexts: subContexts,\n        element: element,\n        value: item,\n        htmlDomMeta: [],\n        tagJsVar: {\n            tagJsType: 'dynamic-text',\n            hasValueChanged: () => 0,\n            processInit: blankHandler,\n            processInitAttribute: blankHandler,\n            destroy: (_c, ownerSupport) => {\n                ++subContext.updateCount;\n                subContexts.forEach(subSub => subSub.tagJsVar.destroy(subSub, ownerSupport));\n            },\n            processUpdate: (value, contextItem, ownerSupport, values) => {\n                ++subContext.updateCount;\n                setContextInCycle(aSubContext);\n                let newValue = value(aSubContext);\n                const underFunction = subContext.underFunction;\n                delete subContext.underFunction;\n                if (newValue instanceof Function && !newValue.tagJsType) {\n                    if (underFunction && newValue.toString() === underFunction.toString()) {\n                        newValue = aSubContext.value;\n                    }\n                    else {\n                        subContext.underFunction = newValue;\n                        newValue = newValue();\n                    }\n                }\n                const result = aSubContext.tagJsVar.processUpdate(newValue, aSubContext, ownerSupport, values);\n                aSubContext.value = newValue;\n                contextItem.value = value;\n                removeContextInCycle();\n                return result;\n            }\n        },\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    // addedContexts.push(subContext)\n    setContextInCycle(subContext);\n    let trueValue = item();\n    const isAgainFunc = isFunction(trueValue) && !trueValue.tagJsType;\n    if (isAgainFunc) {\n        ;\n        subContext.underFunction = trueValue;\n        trueValue = trueValue(); // function returns function\n    }\n    const aSubContext = processNonElement(trueValue, subContext, // parentContext,\n    element, ownerSupport, paintBy);\n    const contexts = parentContext.contexts;\n    contexts.push(subContext);\n    removeContextInCycle();\n    return aSubContext;\n}\n","import { isPromise } from '../index.js';\nimport { addSupportEventListener } from '../interpolations/attributes/addSupportEventListener.function.js';\nimport { afterTagCallback } from '../interpolations/attributes/bindSubjectCallback.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nimport { isSpecialAttr } from '../interpolations/attributes/isSpecialAttribute.function.js';\nimport { renderTagUpdateArray } from '../interpolations/attributes/renderTagArray.function.js';\nimport { processAttributeArray } from '../render/dom/processAttributeArray.function.js';\nimport { paint, paintAppend, painting } from '../render/paint.function.js';\nimport { processChildren } from './processChildren.function.js';\n/** The first and recursive processor for elements */\nexport function processElementVar(value, context, ownerSupport, _addedContexts) {\n    const element = document.createElement(value.tagName);\n    context.element = element;\n    // mark special attributes\n    value.attributes.forEach(x => {\n        const name = x[0];\n        if (typeof (name) !== 'string') {\n            return;\n        }\n        x[2] = isSpecialAttr(name);\n    });\n    processAttributeArray(value.attributes, [], // values,\n    element, ownerSupport, context);\n    /*\n    value.listeners.forEach((listener, index) =>\n      registerListener(value, index, ownerSupport, listener, element)\n    )*/\n    processChildren(value.innerHTML, context, // parentContext\n    ownerSupport, element, paintAppend);\n    value.listeners.forEach((listener, index) => registerListener(value, index, ownerSupport, listener, element));\n    return element;\n}\nfunction registerListener(value, index, ownerSupport, listener, element) {\n    const wrap = (...args) => {\n        const listenScope = value.listeners[index];\n        const toCall = listenScope[1];\n        const stateSupport = getSupportWithState(ownerSupport);\n        const updateCount = stateSupport.context.updateCount;\n        stateSupport.context.locked = 1;\n        ++painting.locks;\n        const result = toCall(...args);\n        --painting.locks;\n        delete stateSupport.context.locked;\n        const needsRender = updateCount === stateSupport.context.updateCount;\n        if (needsRender) {\n            return afterTagCallback(result, stateSupport);\n        }\n        else {\n            paint();\n        }\n        if (isPromise(result)) {\n            return result.then(() => {\n                const newest = stateSupport.context.state.newest;\n                renderTagUpdateArray([newest]);\n                return 'promise-no-data-ever';\n            });\n        }\n        return 'no-data-ever';\n    };\n    addSupportEventListener(ownerSupport.appSupport, listener[0], // eventName\n    element, wrap);\n}\n","import { paintBefore, paintCommands } from '../render/paint.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nexport function processDesignElementInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    // prevent children from calling a parent function and causing a mid render\n    context.locked = 34;\n    const element = processElementVar(value, context, ownerSupport, context.contexts);\n    delete context.locked;\n    paintCommands.push([paintBefore, [insertBefore, element, 'htmlTag.processInit']]);\n    const dom = {\n        nn: value.tagName,\n        domElement: element,\n        at: value.attributes, // TODO: most likely does nothing\n    };\n    context.htmlDomMeta = [dom];\n    return element;\n}\n","import { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions, isValueForContext, loopObjectAttributes } from './elementFunctions.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processDesignElementInit } from './processDesignElementInit.function.js';\nexport function htmlTag(tagName) {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler,\n        processInit: processDesignElementInit,\n        destroy: destroyDesignElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName,\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = tagName;\n    return pushKid;\n}\nexport function getPushKid(element, _elmFunctions) {\n    const pushKid = (...args) => {\n        const newElement = { ...pushKid };\n        newElement.attributes = [...pushKid.attributes];\n        newElement.listeners = [...pushKid.listeners];\n        newElement.allListeners = [...pushKid.allListeners];\n        if (args.length > 0 &&\n            typeof args[0] === 'object' &&\n            !Array.isArray(args[0]) &&\n            !args[0].tagJsType // TODO: need better attribute detection\n        ) {\n            loopObjectAttributes(newElement, args[0]);\n            args.splice(0, 1);\n        }\n        newElement.innerHTML = args;\n        // review each child for potential to be context\n        args.forEach(arg => {\n            if (!isValueForContext(arg)) {\n                return;\n            }\n            if (arg.tagJsType === 'element') {\n                newElement.allListeners.push(...arg.allListeners);\n                if (arg.contexts) {\n                    // the argument is an element so push up its contexts into mine\n                    if (!newElement.contexts) {\n                        // newElement.contexts = [...arg.contexts]\n                        newElement.contexts = arg.contexts;\n                    }\n                    else {\n                        newElement.contexts.push(...arg.contexts);\n                    }\n                }\n                return;\n            }\n            registerMockChildContext(arg, newElement);\n        });\n        return newElement;\n    };\n    Object.assign(pushKid, element);\n    Object.assign(pushKid, elementFunctions(pushKid));\n    pushKid.attributes = [...element.attributes];\n    pushKid.listeners = [...element.listeners];\n    pushKid.allListeners = [...element.allListeners];\n    return pushKid;\n}\n/** used during updates */\nfunction registerMockChildContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\n","import { paint, paintBefore, painting } from '../render/paint.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions } from './elementFunctions.js';\nimport { destroyDesignByContexts } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processChildren } from './processChildren.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\n/** used when you do NOT have a root element returned for your function */\nexport const noElement = noElementMaker();\nexport function noElementMaker() {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler, // its never an attribute\n        processInit: processNoElmInit,\n        destroy: destroyNoElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName: 'no-element',\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = 'no-element';\n    return pushKid;\n}\nfunction processNoElmInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    processChildren(value.innerHTML, context, ownerSupport, insertBefore, paintBefore);\n}\nfunction destroyNoElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                destroyHtmlDomMeta(htmlDomMeta);\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n}\n","import { htmlTag } from './htmlTag.function.js';\nexport { htmlTag };\nexport { noElement } from './noElement.function.js';\nexport const button = htmlTag('button');\nexport const select = htmlTag('select');\nexport const option = htmlTag('option');\nexport const input = htmlTag('input');\nexport const textarea = htmlTag('textarea');\n// HEAD & SUPPORT ELEMENTS\nexport const htmlDoc = htmlTag('html'); // TODO: get this named to html\nexport const head = htmlTag('head');\nexport const title = htmlTag('title');\nexport const meta = htmlTag('meta');\nexport const link = htmlTag('link');\nexport const style = htmlTag('style');\nexport const body = htmlTag('body');\nexport const noscript = htmlTag('noscript');\n// BLOCK ELEMENTS\nexport const hr = htmlTag('hr');\nexport const h1 = htmlTag('h1');\nexport const h2 = htmlTag('h2');\nexport const h3 = htmlTag('h3');\nexport const h4 = htmlTag('h4');\nexport const h5 = htmlTag('h5');\nexport const h6 = htmlTag('h6');\nexport const ol = htmlTag('ol');\nexport const ul = htmlTag('ul');\nexport const li = htmlTag('li');\nexport const div = htmlTag('div');\nexport const main = htmlTag('main');\nexport const section = htmlTag('section');\nexport const header = htmlTag('header');\nexport const footer = htmlTag('footer');\nexport const fieldset = htmlTag('fieldset');\nexport const legend = htmlTag('legend');\nexport const dialog = htmlTag('dialog');\nexport const pre = htmlTag('pre');\n// TABLE ELEMENTS\nexport const table = htmlTag('table');\nexport const tr = htmlTag('tr');\nexport const td = htmlTag('td');\nexport const th = htmlTag('th');\nexport const thead = htmlTag('thead');\nexport const tbody = htmlTag('tbody');\nexport const tfoot = htmlTag('tfoot');\n// INLINE ELEMENTS\nexport const a = htmlTag('a');\nexport const br = htmlTag('br');\nexport const label = htmlTag('label');\nexport const p = htmlTag('p');\nexport const small = htmlTag('small');\nexport const span = htmlTag('span');\nexport const strong = htmlTag('strong');\nexport const b = htmlTag('b');\nexport const sup = htmlTag('sup');\nexport const nav = htmlTag(\"nav\");\nexport const figure = htmlTag(\"figure\");\nexport const figcaption = htmlTag(\"figcaption\");\nexport const code = htmlTag(\"code\");\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { firstTagRender, reRenderTag } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport * from './deepFunctions.js';\nexport * from './elements/index.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    firstTagRender, reRenderTag, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","varCounter","state","newer","states","global","blocked","RouteQuery","_name","getSupportInCycle","setUseMemory","stateConfig","support","setSupportInCycle","setContextInCycle","context","blankHandler","addPaintRemoveAwait","_promise","paintCommands","paintRemoves","paintContent","paintAppends","paintAfters","painting","locks","removeLocks","setContent","text","textNode","textContent","paint","removes","length","content","runPaintRemoves","splice","runPaintCycles","nowPaintAfters","runAfterCycle","addPaintRemover","element","caller","push","paintRemover","_caller","parentNode","removeChild","paintBefore","relative","insertBefore","paintAppend","appendChild","contentCleaner","document","createElement","toPlainTextElm","innerHTML","createTextNode","paintBeforeText","callback","textElm","paintBeforeElementString","paintAppendElementString","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","isSimpleType","value","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","findStateSupportUpContext","stateMeta","newest","parentContext","getSupportWithState","component","ownerSupport","returnArgs","args","firstStatesHandler","setter","config","statesIndex","reStatesHandler","oldStates","prevSupport","older","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","StateEchoBack","getStateValue","defaultValue","checkValue","getCallbackValue","runRestate","restate","getContextInCycle","msg","console","error","Error","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","values","setValue","x","index","item","subscription","clones","shift","subscriptions","map","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","add","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","arguments","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","undefined","processUpdateOneContext","deleted","valueIndex","tagJsVar","processUpdate","removeContextInCycle","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","processUpdateContext","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","cloneValueArray","cloneTagJsValue","shallowPropMatch","props","pastCloneProps","len","pastProp","obEntries","entries","subItem","objectItemMatches","name","pastValue","runBeforeDestroy","providers","provider","children","destroy$","destroyContexts","childTags","child","lastArray","childValue","destroy","iSubs","forEach","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","from","tagValueUpdateHandler","updateCount","forceUpdateExistingValue","domProcessContextItem","appendTo","locked","processInit","castTextValue","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","specialAttribute","specialName","autofocus","autoselect","names","split","paintStyle","classListAdd","classListRemove","processSpecialClass","smallName","style","setProperty","classList","remove","select","focus","howToSetInputValue","howToSetInputObjectValue","setNonFunctionInputValue","subValue","setObjectValue","setPropertyValue","howToSetStandAloneAttr","setAttribute","setSimpleAttribute","setBooleanAttribute","removeAttribute","processDynamicNameValueAttribute","howToSet","isSpecial","processInitAttribute","processTagJsAttribute","processNonDynamicAttr","innerValue","tagJsVarOverride","matchesInjection","inject","subContext","hasValueChanged","_contextItem","isAttr","valueToTagJsVar","withinOwnerElement","render$","processFunctionAttr","processAttributeUpdate","oldTag","tagValue","newTagVar","processSimpleAttribute","_ownerSupport","deleteSimpleAttribute","checkSimpleValueChange","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkUpdateDeleteSimpleValueChange","processStringUpdate","_appendTo","castedValue","placeholder","simpleValueElm","elm","oldClone","processUpdateRegularValue","checkArrayValueChange","destroyArrayContext","getArrayTagVar","processArrayInit","processArrayUpdates","processTagArray","_insertBefore","getBasicTagVar","getNewContext","createAndProcessContextItem","noLast","runtimeInsertBefore","removed","filteredLast","newRemoved","compareArrayItems","reviewArrayItem","array","castArrayItem","previousContext","couldBeSame","reviewPreviousArrayItem","newLength","at","lessLength","prevContext","destroyArrayItem","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","oldest","destroySupport","destroyArrayItemByGlobal","destroyArray","destroyHtmlDomMeta","htmlDomMeta","destroyClone","marker","domElement","smartRemoveKids","allPromises","supportOwner","hostDestroy","subGlobal","smartRemoveByContext","destroyContextHtml","promises","wrapper","returnValue","isLikeTags","newSupport","oldSupport","isLike","isLikeBaseTags","_innerHTML","outerHTML","templater0","templater1","newTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","every","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","destroySupportByContextItem","destroySupportContext","checkTagValueChange","lastSupport","isTag","checkTagValueChangeAndUpdate","tryUpdateToTag","attachDynamicDom","depth","addOneContext","handleProviderChanges","appSupport","tagsWithProvider","memory","cSubject","getTagsWithProvider","mapToSupport","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","castProps","currentDepth","isSkipPropValue","syncPriorPropFunction","priorProp","mem","oldProp","updateExistingArray","hasSetter","getOwnPropertyDescriptor","updateExistingObject","updateExistingTagComponent","oldWrapper","newWrapper","isSameTag","skipComparing","swapTags","hasChanged","newTemplater","latestProps","propsConfig","latest","propsChanged","hasPropChanges","propWatch","hasSupportChanged","renderSupport","newProps","castedProps","syncFunctionProps","lastPropsConfig","syncSupports","PropWatches","DEEP","deepCompareDepth","shallowCompareDepth","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","executeWrap","useSupport","originalFunction","stateless","runAfterRender","saveState","clearStateConfig","callTag","reSupport","createSupport","runAfterSupportRender","reStateByPrev","prevState","reRenderTag","reStateSupport","firstTagRender","getSupportOlderState","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","processTag","inlineHtml","pop","checkRenderUp","selfPropChange","nowProps","hasPropLengthsChanged","IMMUTABLE","immutablePropMatch","SHALLOW","hasPropsToOwnerChanged","getUpTags","supports","isComponent","continueUp","proSupports","prosWithChanges","hasChange","owner","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","syncStatesArray","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","checkToResolvePromise","callbackResult","last","resolvePromise","resolveValue","newestSupport","newestStateMeta","thenResolveBy","bindSubjectCallback","subjectFunction","bindTo","apply","afterTagCallback","runTagCallback","tagFunction","noData","promiseNoData","bubbleEvent","event","replaceEventName","target","stopped","originalStopPropagation","stopPropagation","defaultPrevented","addSupportEventListener","eventName","appElement","getEventReferenceName","eventReg","events","listener","addEventListener","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","attrValue","processStandAloneAttribute","newContexts","processAttribute","processUpdateAttrContext","attrContextItem","oldValue","isNameOnly","standAloneResult","updateNameOnlyAttrValue","_subject","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","variablePrefix","variableSuffix","placeholderRegex","getTagVarIndex","search","createDynamicArrayAttribute","startIndex","createdContexts","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","join","newValues","getTagJsVar","attrPart","varIndex","isNameVar","valueInValues","stateOwner","oldTagJsVar","processTagJsVarAttribute","aloneResult","valueVar","createDynamicAttribute","special","paintContentPush","processAttributeArray","attrs","attr","newContext","attachDomElement","node","attachDomElements","nodes","v","isNaN","Number","realValue","newNode","nn","attachDomText","newParentContext","isAttrs","ch","tc","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","attributes","attrMatch","parseAttrString","pushTo","postProcessTagsInComments","inputString","filter","notEmptyStringMapper","part","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","replacePlaceholders","valueCount","currentTail","loopTail","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","mapped","lengthMapper","lastRuns","getDomMeta","stringId","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","template","interpolation","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachHtmlDomMeta","ph","tagFakeTemplater","processTagInit","newSupportByTemplater","createHtmlSupport","processNewSubjectTag","getTemplaterResult","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","wrap","processRenderOnceInit","processSubscribeWith","setupSubscribe","hasEmitted","emitSubContext","observable","Observables","subValueHandler","withDefault","emitValue","processSubscribeAttribute","_tagJsVar","unsubscribeContext","onOutput","callbackValue","syncRun","checkToPaint","setupSubscribeCallbackProcessor","contextItem2","processSubscribeWithAttribute","observables","obValue","emitSubScriptionAsIs","Observable","checkSubscribeValueChanged","deleteAndUnsubscribe","newObserves","oldObserves","ob","handleTagTypeChangeFrom","originalType","updateToDiffValue","checkStillSubscription","valuesHandler","deleteContextSubContext","deleteSubContext","appendMarker","subContextItem","onFirstSubContext","handleInnerHTML","oldProcessInit","processInnerHTML","insertBeforeOriginal","guaranteeInsertBefore","checkInnerHTML","getInnerHTML","processPipe","wrapped","newCallback","syncWrapCallback","newerStates","olderStates","newestOwner","c","newGlobal","options","baseHost","processHostAttribute","processHost","processHostUpdate","deleteHost","injectCallback","returnFunction","assign","oldOptions","newHost","onInit","processHostTagJsVar","attrContext","onDestroy","getOverrideTagVar","overrideTagVar","renderContent","oldType","newType","hasTypeChanged","convertValue","updatesHandler","makeRealUpdate","_context","afterDestroy","convertTagToElementManaged","createSupportWithProps","newPropsConfig","processReplacementComponent","processFirstSubjectComponent","processFirstTagResult","processTagComponentInit","tagCount","onClick","makeEventListener","onMouseDown","type","toBeCalled","tagElement","onclick","click","mousedown","onmousedown","defineGetSet","eventFn","fn","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","returnWrap","updates","NONE","castedPastProps","compare","subCastedProps","subCompareProps","matched","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","use","deepPropWatch","route","_routeProps","targetItem","currentContext","inContext","message","onRender","callbackWrap","_isFirst","lastContext","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","shallowMapper","deepMapper","getBaseSupport","baseSupport","upgradeBaseToSupport","clonePropsBy","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","ignoreOrDestroyed","before","processNowRegularValue","processUpdateSubscribe","resultNum","updateValue","aContext","newestParentTagJsVar","responseValue","processSignal","initialValue","Signal","Set","unsub","delete","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","pastResult","defaultFinally","init","final","previous","realValues","isFirstRender","processRealValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","previousValues","nowSupport","setTo","newestState","oldestStateSupport","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","cm","ownerProviders","find","warn","TagError","details","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","callbackState","callbackTrigger","createTrigger","_oldStates","maybePromise","supContext","finally","callbackStateUpdate","callbackMaker","syncError","firstSignal","sig","editors","readers","resignal","Proxy","action","getElement","processDomTagInit","processOuterDomTagInit","checkOuterTagValueChange","getStringTag","keyTag","setHTML","acceptInnerHTML","useTagVar","getDomTag","stringTag","taggedJs","appElements","appElmIndex","appElm","templater2","isApp","debug","loadNewBaseSupport","getNewSubject","isAppFunction","removeEventListener","toAwait","newFragment","createDocumentFragment","renderTagElement","makeAttrCallable","stringsOrValue","chunk","callbackWrapper2","wrapCallback","e","listeners","allListeners","getPushKid","elementFunctions","isValueForContext","registerMockAttrContext","styleCallable","idCallable","classCallable","hrefCallable","attr2","makeCallback","callbackWrapper","onClose","onDoubleClick","onBlur","onChange","onMousedown","onMouseup","onKeydown","onKeyup","id","class","href","mockElm","setupAttr","eventCallables","onDblClick","onMouseUp","onKeyUp","onKeyDown","callables","checked","selected","destroyDesignElement","destroyDesignByContexts","processDesignElementUpdate","checkTagElementValueChange","vContexts","ogListeners","newListener","info","conValues","processChildren","paintBy","handleSimpleInnerValue","subContexts","_c","subSub","aSubContext","underFunction","Function","trueValue","processNonElement","processElementVarFunction","newElement","processElementVar","_addedContexts","toCall","stateSupport","registerListener","processDesignElementInit","htmlTag","pushKid","_elmFunctions","registerMockChildContext","noElement","processNoElmInit","destroyNoElement","noElementMaker","input","htmlDoc","head","title","meta","body","noscript","hr","h1","h2","h3","h4","h5","h6","ol","ul","li","div","main","section","header","footer","fieldset","legend","dialog","pre","table","tr","td","th","thead","tbody","tfoot","a","br","label","p","small","span","strong","b","sup","nav","figure","figcaption","code","hmr"],"sourceRoot":""}