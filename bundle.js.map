{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAU;;;;;;;;;;;;;;;;;;ACAH;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnB6D;AACjB;AAC8B;AACb;AACM;AACpB;AACW;AACW;AACJ;AACJ;AACI;AAC2B;AACjB;AACE;AACF;AAC3E,gCAAgC,sDAAc;AAC9C;AACO;AACP;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+EAA+E;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,uCAAuC;AACvC,6BAA6B,yDAAS;AACtC;AACA;AACA;AACA;AACA,oCAAoC,0EAAe;AACnD;AACA,aAAa;AACb;AACA;AACA,aAAa,2DAAc,YAAY,uDAAU;AACjD,4CAA4C,yDAAS;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,iBAAiB;AACjB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gFAAgB;AACpC;AACA;AACA;AACA;AACA,4BAA4B,2DAAc;AAC1C;AACA,YAAY,4DAAgB;AAC5B;AACA,kDAAkD,uEAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,4BAA4B;AAChG;AACA,aAAa;AACb;AACA;AACA,yEAAyE,4BAA4B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA,KAAK;AACL;AACA,0GAA0G;AAC1G,gCAAgC;AAChC;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,oCAAoC,0EAAe;AACnD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,+EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,gBAAgB;AAC9F;AACA,gBAAgB,gBAAgB,EAAE,uFAAkB;AACpD;AACA;AACA;AACA,SAAS;AACT,QAAQ,2FAAuB;AAC/B;AACA;AACA;AACA,YAAY,yFAAmB,+FAA+F,gBAAgB;AAC9I,YAAY,2FAAuB;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sDAAc;AAC1E,sEAAsE,EAAE,sDAAc,CAAC,EAAE,OAAO;AAChG;AACA;AACA,SAAS;AACT,8BAA8B,sFAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA,2BAA2B,yFAAsB;AACjD;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gFAAgB;AACpB;AACA;;;;;;;;;;;;;;;ACnTO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXuC;AAC8B;AAC9D;AACP;AACA;AACA,mBAAmB,oDAAW;AAC9B;AACA;AACA;AACA,4BAA4B,kFAAa;AACzC;AACA;AACA;;;;;;;;;;;;;;;;;;;ACZqC;AAC0B;AACtB;AACzC;AACO;AACP,sBAAsB,kDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI,kDAAU;AACd;AACA;AACA,QAAQ,4EAAgB;AACxB,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC9CiE;AACd;AAC6B;AAC3B;AAC9C;AACP;AACA;AACA;AACA;AACA,qBAAqB,uDAAU;AAC/B;AACA;AACA;AACA,QAAQ,kEAAW;AACnB,4BAA4B,YAAY,mCAAmC,sBAAsB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC,6BAA6B,kDAAK;AAClC;AACA;AACA;AACA,iBAAiB,gEAAU;AAC3B;AACA;AACA,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA;AACA,oCAAoC,2DAAc;AAClD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,2EAAqB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,kEAAW;AACnB;AACA;AACA;;;;;;;;;;;;;;;;;ACjF4C;AAC0C;AAC/E;AACP;AACA;AACA,YAAY,2DAAc;AAC1B;AACA,mBAAmB,yDAAS;AAC5B;AACA,YAAY,uDAAU,SAAS,2DAAc;AAC7C;AACA;AACA,YAAY,uDAAU;AACtB;AACA;AACA,eAAe,yDAAS;AACxB,KAAK;AACL;;;;;;;;;;;;;;;;ACjBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpGO;AACP,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;;;;;;;;;;;;;;;;;ACfO;AACP;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzB4C;AACrC;AACP,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,qCAAqC;AACrC,yCAAyC;AACzC;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB,yDAAS;AAC7B,gCAAgC;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACpEkC;AAC3B;AACP,eAAe,2CAAG;AAClB;;;;;;;;;;;;;;;ACHA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACJA;AACgE;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,aAAa;AACb;AACA,+BAA+B;AAC/B;AACA,IAAI,4EAAgB;AACpB;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,2BAA2B,4EAAgB;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;;;;;;;;;;;;;;AChBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjB+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4EAAgB;AACxB,sCAAsC;AACtC,KAAK;AACL;;;;;;;;;;;;;;;;ACvB4D;AACrD;AACP;AACA,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC,EAAE,yEAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe,EAAE,yEAAmB;AAChE;AACA;AACA;AACA;AACA,wBAAwB,sDAAsD;AAC9E;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxCgE;AACN;AACkB;AAChB;AAC5D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD,EAAE,yFAA2B;AACpG;AACA;AACA;AACA,IAAI,6EAAqB;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,6EAAqB;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,mBAAmB,uEAAsB;AACzC,0CAA0C,oDAAY,EAAE,sDAAc;AACtE;AACA;;;;;;;;;;;;;;;;;;;;;;;AClC8C;AACQ;AACgB;AACX;AACM;AACK;AAC/D;AACP,+BAA+B,WAAW,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,mCAAmC,sDAAc,aAAa,sDAAc;AAC5E,iBAAiB,UAAU;AAC3B;AACA;AACA,sBAAsB,2DAAc,2BAA2B,uDAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,gBAAgB;AAC/F,aAAa;AACb;AACO;AACP,EAAE,gBAAgB;AAClB;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA;AACA;AACA,QAAQ,kFAAmB;AAC3B,sBAAsB,WAAW;AACjC;AACA,SAAS;AACT;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC;AAClC;AACA,QAAQ,8EAAiB;AACzB;AACA;AACA,WAAW,mEAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;AC9EA;AACO,sGAAsG,WAAW,GAAG;AAC3H,eAAe,GAAG;AACX;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD,KAAK;AACL,aAAa;AACb;;;;;;;;;;;;;;;;;;AChBkD;AACA;AACmB;AACrE,wBAAwB;AACxB,kBAAkB;AAClB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAc;AAC7B;AACA;AACA,yDAAyD;AACzD;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA,+BAA+B,kFAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxH+D;AAC/D,0EAA0E,IAAI;AACvE;AACP;AACA;AACA,+CAA+C,IAAI;AACnD;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,QAAQ,4EAAgB;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,+EAA+E;AAC/E;AACO;AACP;AACA;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrCsD;AACuC;AACnC;AACV;AACzC;AACP,QAAQ,2DAAc;AACtB,+BAA+B,+DAAY;AAC3C;AACA;AACA;AACA,mBAAmB,+DAAY;AAC/B;AACA;AACA,mBAAmB,+DAAY;AAC/B;AACA,QAAQ,2DAAc;AACtB;AACA;AACA;AACA;AACA,QAAQ,uDAAU;AAClB;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA,eAAe,+DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAY;AACzC,wBAAwB,mEAAe;AACvC;AACA;AACA;AACA,wBAAwB,+DAAY;AACpC,gDAAgD,yDAAU;AAC1D;AACA;;;;;;;;;;;;;;;;ACzCuE;AAChE;AACP;AACA;AACA,kDAAkD;AAClD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB,oFAAoB;AACtC,2BAA2B;AAC3B;;;;;;;;;;;;;;;;;;;ACbiC;AAC8B;AACf;AAC2B;AACpE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uIAAuI,MAAM;AAC7I;AACA;AACA,2BAA2B,yDAAU;AACrC;AACA;AACA;AACA,sBAAsB,0CAAM;AAC5B;AACA;AACA;AACA;AACA,oBAAoB,wFAAsB;AAC1C;AACA,IAAI,4EAAgB;AACpB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjC6E;AACS;AAClC;AACiB;AACA;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA,QAAQ,2DAAc;AACtB;AACA;AACA,QAAQ,2DAAc;AACtB;AACA;AACA,QAAQ,uDAAU;AAClB;AACA;AACA,QAAQ,uDAAU;AAClB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAgB;AAC5C;AACA,YAAY,gEAAU;AACtB;AACA;AACA,mBAAmB,iEAAe;AAClC;AACA,YAAY,0FAAuB;AACnC;AACA;AACA,IAAI,kFAAmB;AACvB;;;;;;;;;;;;;;;;;;;;ACrDgD;AACP;AACzC;AACO;AACP;AACA;AACA;AACA;AACA,yBAAyB,yDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,kDAAY;AAClC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzCsD;AACX;AACuB;AACU;AAC5B;AACN;AACnC;AACP;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,uDAAU;AACtB,YAAY,sEAAgB;AAC5B;AACA,+BAA+B,yDAAU,qCAAqC,+DAAY;AAC1F;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4CAA4C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtHO;AACP;AACA,EAAE,uBAAuB;AACzB;AACA;AACA;AACA,iEAAiE;AACjE,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACf8D;AACX;AACc;AACjE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2EAAoB;AACxB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,sBAAsB,8EAAiB;AACvC;AACA;AACA;AACA;AACA,QAAQ,gEAAU;AAClB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/BiE;AAC1D;AACP;AACA,gBAAgB,8EAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZ4C;AACqB;AACjE;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAS;AACvC;AACA;AACA;AACA,gBAAgB,8EAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnC+E;AAC9C;AACkB;AACM;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAc;AAClB;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAe;AACvB;AACA;AACA;AACA,QAAQ,2DAAe;AACvB;AACA,0BAA0B,0CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sEAAgB;AACpB;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7DO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACN2C;AACG;AACkB;AAClB;AAC9C;AACA,cAAc,sDAAiB;AAC/B;AACO;AACP,sCAAsC;AACtC,wDAAM;AACN;AACA;AACA;AACA,wCAAwC;AACxC,KAAK;AACL,CAAC;AACD;AACA;AACA,0BAA0B,2DAAa;AACvC;AACA;AACA,iCAAiC;AACjC;AACA,8CAA8C;AAC9C,KAAK;AACL;AACA;AACA,qBAAqB,oDAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4EAAgB;AACpB;AACA;AACA;AACA;AACA,YAAY,4EAAgB;AAC5B,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDiC;AACU;AACF;AACM;AACF;AACL;AACC;AAChB;AACG;;;;;;;;;;;;;;;;;ACRkB;AACH;AAC3C;AACO;AACP,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxC2C;AAC3C;AACA,IAAI,oDAAM;AACV;AACO;AACP,uBAAuB,oDAAM;AAC7B;AACA;AACA,wDAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACjB0C;AAC3C;AACA,IAAI,oDAAM;AACV;AACO;AACP,uBAAuB,oDAAM;AAC7B;AACA;AACA,oBAAoB;AACpB;AACA;AACA,wDAAM;AACN;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;ACduD;AACQ;AACzD;AACP;AACA,sEAAsE,yDAAS;AAC/E;AACA;AACA;AACA;AACA,yBAAyB,yDAAS;AAClC,KAAK;AACL;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA,oBAAoB;AACpB;AACA;AACA;AACA,6BAA6B,yDAAS;AACtC,YAAY,4EAAgB;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtC6C;AACF;AAC3C,oDAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB,oDAAM;AACzB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6BAA6B,yDAAS;AACtC;AACA;AACA;AACA;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,eAAe,uCAAuC;AACtD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,yDAAS,qBAAqB;AAC/D;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,kDAAkD,kBAAkB,EAAE,YAAY;AAClF,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,wDAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA,CAAC;AACD;AACA,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjF8C;AACH;AAC3C;AACO;AACP,mBAAmB,oDAAM;AACzB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZ2C;AACG;AAC9C;AACO;AACP,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChC+C;AACJ;AAC3C,oDAAM;AACN;AACA;AACA;AACA;AACA,wDAAM;AACN;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA,8DAA8D,gBAAgB,MAAM,oBAAoB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAkB;AACpD;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qCAAqC;AACrC,4EAA4E;AAC5E;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAiD;AAClF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc,uDAAkB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC3F+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,4DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;;;;;;;;;;;;;;;ACrH0C;AACnC,2BAA2B,mDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACb0C;AACnC;AACP,uBAAuB,mDAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtBgC;AACD;AACU;AACR;;;;;;;;;;;;;;;;;ACH1B;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;AC9ByF;AACxD;AACyB;AACqB;AACnC;AACI;AACG;AACG;AAC/C;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0BAA0B,uDAAU,WAAW,2DAAc,WAAW,uDAAU;AAClF;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,8BAA8B,mEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB,iBAAiB;AACjB;AACA;AACA,QAAQ,uDAAU;AAClB,iBAAiB,kBAAkB,+DAAY;AAC/C;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB,+DAAY;AAC/C;AACA;AACA,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0CAAM;AAChC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAU;AACpC,4BAA4B,yDAAS,SAAS;AAC9C;AACA;AACA;AACA;AACA,+BAA+B,yDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,wBAAwB,4FAAc;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvHoD;AACU;AACR;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA,mEAAmE,kBAAkB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,+DAAY;AACpC,qBAAqB,6DAAc;AACnC;AACA;AACA,IAAI,2DAAe;AACnB;AACA;AACA;AACA,IAAI,0DAAc;AAClB;AACA;;;;;;;;;;;;;;;;;;;;;ACrDA,wDAAwD;AACvB;AACG;AACpC;AACO,uBAAuB,6CAAO;AACrC,SAAS,0CAAM;AACf,6BAA6B;AAC7B;AACA,CAAC;AACD;AACO;AACP,IAAI,0CAAM;AACV;AACA;AACO;AACP,IAAI,0CAAM;AACV;AACA;AACA;AACO;AACP,IAAI,0CAAM;AACV;AACA;AACO;AACP,IAAI,0CAAM;AACV;;;;;;;;;;;;;;;ACzBA;AACO;AACP;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdiE;AACjB;AACzC;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAc;AAC9B;AACA,qCAAqC,yDAAU;AAC/C,oBAAoB,2DAAc;AAClC;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzCuE;AACM;AACpB;AACM;AACL;AACP;AAC5C;AACP;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,eAAe,0FAAuB;AACtC;AACA,sBAAsB,sBAAsB;AAC5C,SAAS;AACT;AACA;AACA,2BAA2B,oFAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,uBAAuB,4EAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAU;AAC7C;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAgB;AAC5B,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,uEAAiB;AACpC;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/GgD;AACU;AAC+C;AACrD;AAC+B;AACd;AACE;AACjB;AACuB;AAC1B;AACiC;AACI;AACnC;AAC9C;AACP;AACA,wBAAwB,2DAAc;AACtC,IAAI,oFAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAU;AAClB,QAAQ,iEAAe;AACvB,wBAAwB;AACxB;AACA;AACA,eAAe;AACf;AACA;AACA,QAAQ,2DAAc;AACtB,QAAQ,iEAAU;AAClB;AACA;AACA,QAAQ,uDAAU;AAClB;AACA;AACA;AACA,wBAAwB,uEAAgB;AACxC;AACA;AACA;AACA,QAAQ,iEAAU;AAClB;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA;AACA,sBAAsB,kGAAmB;AACzC;AACA;AACA;AACA;AACA,IAAI,kFAAmB;AACvB;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C,4BAA4B,mEAAe;AAC3C;AACA;AACA;AACA;AACA,6BAA6B,yDAAU;AACvC;AACA;AACA;AACA,+BAA+B,gEAAU;AACzC,QAAQ,2DAAc;AACtB,QAAQ,wEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAU;AACzB;AACA,WAAW,kFAAmB;AAC9B;AACA;AACA;AACA;AACA,QAAQ,0FAAuB;AAC/B;AACA;AACA,sBAAsB,sBAAsB;AAC5C,SAAS;AACT;AACA;AACA,2BAA2B,yDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAW;AACvB;AACA;AACA;AACA,QAAQ,0FAAuB;AAC/B;AACA,sBAAsB,sBAAsB;AAC5C,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI,gGAA0B;AAC9B;AACA;AACA;;;;;;;SCxIA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNsB;AACC;AACE;AACI;AACC;AACE;AACG;AACY;AACK;AACV;AACR;AACY;AACiB;AACE;AACF;AACE;AACvB;AACnC;AACP,cAAc,wEAAmB,+FAAkB;AACnD","sources":["webpack://taggedjs/./ts/ElementTargetEvent.interface.ts","webpack://taggedjs/./ts/Tag.class.ts","webpack://taggedjs/./ts/TagSupport.class.ts","webpack://taggedjs/./ts/TemplaterResult.class.ts","webpack://taggedjs/./ts/afterInterpolateElement.function.ts","webpack://taggedjs/./ts/alterProps.function.ts","webpack://taggedjs/./ts/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/cloneValueArray.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/destroy.support.ts","webpack://taggedjs/./ts/destroyTag.function.ts","webpack://taggedjs/./ts/elementDestroyCheck.function.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/hasTagSupportChanged.function.ts","webpack://taggedjs/./ts/html.ts","webpack://taggedjs/./ts/insertAfter.function.ts","webpack://taggedjs/./ts/interpolations/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/elementInitCheck.ts","webpack://taggedjs/./ts/interpolations/inputAttribute.ts","webpack://taggedjs/./ts/interpolations/interpolateAttributes.ts","webpack://taggedjs/./ts/interpolations/interpolateContentTemplates.ts","webpack://taggedjs/./ts/interpolations/interpolateElement.ts","webpack://taggedjs/./ts/interpolations/interpolateTemplate.ts","webpack://taggedjs/./ts/interpolations/interpolations.ts","webpack://taggedjs/./ts/interpolations/processAttribute.function.ts","webpack://taggedjs/./ts/interpolations/scanTextAreaValue.function.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/isLikeTags.function.ts","webpack://taggedjs/./ts/processNewValue.function.ts","webpack://taggedjs/./ts/processRegularValue.function.ts","webpack://taggedjs/./ts/processSubjectComponent.function.ts","webpack://taggedjs/./ts/processSubjectValue.function.ts","webpack://taggedjs/./ts/processTag.function.ts","webpack://taggedjs/./ts/processTagArray.ts","webpack://taggedjs/./ts/processTagResult.function.ts","webpack://taggedjs/./ts/render.ts","webpack://taggedjs/./ts/renderExistingTag.function.ts","webpack://taggedjs/./ts/renderSubjectComponent.function.ts","webpack://taggedjs/./ts/renderTagSupport.function.ts","webpack://taggedjs/./ts/renderWithSupport.function.ts","webpack://taggedjs/./ts/setTagPlaceholder.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/index.ts","webpack://taggedjs/./ts/state/letState.function.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/provider.utils.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/state/setProp.function.ts","webpack://taggedjs/./ts/state/setUse.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/index.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/tag.ts","webpack://taggedjs/./ts/tagElement.ts","webpack://taggedjs/./ts/tagRunner.ts","webpack://taggedjs/./ts/updateBeforeTemplate.function.ts","webpack://taggedjs/./ts/updateContextItem.function.ts","webpack://taggedjs/./ts/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/updateExistingValue.function.ts","webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/webpack/runtime/make namespace object","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["export {};\n","export const variablePrefix = '__tagvar';\nexport const escapeVariable = '--' + variablePrefix + '--';\nexport const escapeSearch = new RegExp(escapeVariable, 'g');\nexport class Tag {\n    strings;\n    values;\n    isTagClass = true;\n    // present only when an array. Populated by Tag.key()\n    memory = {};\n    templater;\n    constructor(strings, values) {\n        this.strings = strings;\n        this.values = values;\n    }\n    /** Used for array, such as array.map(), calls aka array.map(x => html``.key(x)) */\n    key(arrayValue) {\n        this.memory.arrayValue = arrayValue;\n        return this;\n    }\n}\n","import { escapeVariable, variablePrefix } from './Tag.class';\nimport { deepClone } from './deepFunctions';\nimport { isTagClass, isTagComponent, isTagTemplater } from './isInstance';\nimport { cloneValueArray } from './cloneValueArray.function';\nimport { restoreTagMarker } from './checkDestroyPrevious.function';\nimport { runBeforeDestroy } from './tagRunner';\nimport { getChildTagsToDestroy } from './destroy.support';\nimport { elementDestroyCheck } from './elementDestroyCheck.function';\nimport { updateContextItem } from './updateContextItem.function';\nimport { processNewValue } from './processNewValue.function';\nimport { setTagPlaceholder } from './setTagPlaceholder.function';\nimport { interpolateElement, interpolateString } from './interpolations/interpolateElement';\nimport { subscribeToTemplate } from './interpolations/interpolateTemplate';\nimport { afterInterpolateElement } from './afterInterpolateElement.function';\nimport { renderSubjectComponent } from './renderSubjectComponent.function';\nconst prefixSearch = new RegExp(variablePrefix, 'g');\n/** used only for apps, otherwise use TagSupport */\nexport class BaseTagSupport {\n    templater;\n    subject;\n    isApp = true;\n    appElement; // only seen on this.getAppElement().appElement\n    propsConfig;\n    // stays with current render\n    memory = {\n        state: [],\n    };\n    // travels with all rerenderings\n    global = {\n        context: {}, // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n        providers: [],\n        /** Indicator of re-rending. Saves from double rending something already rendered */\n        renderCount: 0,\n        deleted: false,\n        subscriptions: []\n    };\n    constructor(templater, subject) {\n        this.templater = templater;\n        this.subject = subject;\n        const children = templater.children; // children tags passed in as arguments\n        const kidValue = children.value;\n        const props = templater.props; // natural props\n        const latestCloned = deepClone(props);\n        this.propsConfig = {\n            latest: props,\n            latestCloned, // assume its HTML children and then detect\n            lastClonedKidValues: kidValue.map(kid => {\n                const cloneValues = cloneValueArray(kid.values);\n                return cloneValues;\n            })\n        };\n        // if the latest props are not HTML children, then clone the props for later render cycles to compare\n        if (!isTagTemplater(props) && !isTagClass(props)) {\n            this.propsConfig.latestCloned = deepClone(latestCloned);\n        }\n    }\n}\nexport class TagSupport extends BaseTagSupport {\n    templater;\n    ownerTagSupport;\n    subject;\n    version;\n    isApp = false;\n    hasLiveElements = false;\n    childTags = []; // tags on me\n    clones = []; // elements on document. Needed at destroy process to know what to destroy\n    // may not be needed anymore?\n    strings;\n    values;\n    lastTemplateString = undefined; // used to compare templates for updates\n    constructor(templater, // at runtime rendering of a tag, it needs to be married to a new TagSupport()\n    ownerTagSupport, subject, version = 0) {\n        super(templater, subject);\n        this.templater = templater;\n        this.ownerTagSupport = ownerTagSupport;\n        this.subject = subject;\n        this.version = version;\n    }\n    destroy(options = {\n        stagger: 0,\n        byParent: false, // Only destroy clones of direct children\n    }) {\n        const global = this.global;\n        const subject = this.subject;\n        // put back down the template tag\n        const insertBefore = global.insertBefore;\n        if (insertBefore.nodeName === 'TEMPLATE') {\n            const placeholder = global.placeholder;\n            if (placeholder && !('arrayValue' in this.memory)) {\n                if (!options.byParent) {\n                    restoreTagMarker(this);\n                }\n            }\n        }\n        // the isComponent check maybe able to be removed\n        const isComponent = isTagComponent(this.templater) ? true : false;\n        if (isComponent) {\n            runBeforeDestroy(this, this);\n        }\n        const childTags = options.byParent ? [] : getChildTagsToDestroy(this.childTags);\n        // signify that no further event rendering should take place by making logic think a render occurred during event\n        // signify immediately child has been deleted (looked for during event processing)\n        childTags.forEach(child => {\n            const subGlobal = child.global;\n            delete subGlobal.newest;\n            subGlobal.deleted = true;\n            // delete subGlobal.placeholder\n            // restoreTagMarker(child)\n        });\n        // data reset\n        delete global.placeholder;\n        delete subject.tagSupport;\n        global.context = {};\n        delete global.oldest;\n        delete global.newest;\n        global.deleted = true;\n        this.childTags.length = 0;\n        this.hasLiveElements = false;\n        delete subject.tagSupport;\n        this.destroySubscriptions();\n        let mainPromise;\n        if (this.ownerTagSupport) {\n            this.ownerTagSupport.childTags = this.ownerTagSupport.childTags.filter(child => child !== this);\n        }\n        if (!options.byParent) {\n            const { stagger, promise } = this.destroyClones(options);\n            options.stagger = stagger;\n            if (promise) {\n                mainPromise = promise;\n            }\n        }\n        else {\n            this.destroyClones();\n        }\n        if (mainPromise) {\n            mainPromise = mainPromise.then(async () => {\n                const promises = childTags.map(kid => kid.destroy({ stagger: 0, byParent: true }));\n                return Promise.all(promises);\n            });\n        }\n        else {\n            mainPromise = Promise.all(childTags.map(kid => kid.destroy({ stagger: 0, byParent: true })));\n        }\n        return mainPromise.then(() => options.stagger);\n    }\n    destroySubscriptions() {\n        const global = this.global;\n        global.subscriptions.forEach(cloneSub => cloneSub.unsubscribe());\n        global.subscriptions.length = 0;\n    }\n    destroyClones({ stagger } = {\n        stagger: 0,\n    }) {\n        //const promises = this.clones.reverse().map(\n        const promises = this.clones.map(clone => this.checkCloneRemoval(clone, stagger)).filter(x => x); // only return promises\n        this.clones.length = 0; // tag maybe used for something else\n        if (promises.length) {\n            return { promise: Promise.all(promises), stagger };\n        }\n        return { stagger };\n    }\n    /** Reviews elements for the presences of ondestroy */\n    checkCloneRemoval(clone, stagger) {\n        let promise;\n        const customElm = clone;\n        if (customElm.ondestroy) {\n            promise = elementDestroyCheck(customElm, stagger);\n        }\n        const next = () => {\n            clone.parentNode?.removeChild(clone);\n            const ownerSupport = this.ownerTagSupport;\n            if (ownerSupport) {\n                // Sometimes my clones were first registered to my owner, remove them from owner\n                ownerSupport.clones = ownerSupport.clones.filter(compareClone => compareClone !== clone);\n            }\n        };\n        if (promise instanceof Promise) {\n            return promise.then(next);\n        }\n        else {\n            next();\n        }\n        return promise;\n    }\n    update() {\n        return this.updateContext(this.global.context);\n    }\n    updateBy(tagSupport) {\n        const tempTag = tagSupport.templater.tag;\n        this.updateConfig(tempTag.strings, tempTag.values);\n    }\n    updateConfig(strings, values) {\n        this.strings = strings;\n        this.updateValues(values);\n    }\n    updateValues(values) {\n        this.values = values;\n        return this.updateContext(this.global.context);\n    }\n    updateContext(context) {\n        const thisTag = this.templater.tag;\n        const strings = this.strings || thisTag.strings;\n        const values = this.values || thisTag.values;\n        strings.map((_string, index) => {\n            const variableName = variablePrefix + index;\n            const hasValue = values.length > index;\n            const value = values[index];\n            // is something already there?\n            const exists = variableName in context;\n            if (exists) {\n                return updateContextItem(context, variableName, value);\n            }\n            if (!hasValue) {\n                return;\n            }\n            // 🆕 First time values below\n            context[variableName] = processNewValue(hasValue, value, this);\n        });\n        return context;\n    }\n    /** Function that kicks off actually putting tags down as HTML elements */\n    buildBeforeElement(insertBefore, options = {\n        forceElement: false,\n        counts: { added: 0, removed: 0 },\n    }) {\n        const subject = this.subject;\n        const global = this.global;\n        global.insertBefore = insertBefore;\n        if (!global.placeholder) {\n            setTagPlaceholder(global);\n        }\n        const placeholderElm = global.placeholder;\n        global.oldest = this;\n        global.newest = this;\n        subject.tagSupport = this;\n        this.hasLiveElements = true;\n        // remove old clones\n        if (this.clones.length) {\n            // this.destroyClones()\n            // this.clones.forEach(clone => this.checkCloneRemoval(clone, 0))\n        }\n        global.insertBefore = insertBefore;\n        const context = this.update();\n        const template = this.getTemplate();\n        const isForceElement = options.forceElement;\n        const elementContainer = document.createElement('div');\n        elementContainer.id = 'tag-temp-holder';\n        // render content with a first child that we can know is our first element\n        elementContainer.innerHTML = `<template id=\"temp-template-tag-wrap\">${template.string}</template>`;\n        // Search/replace innerHTML variables but don't interpolate tag components just yet\n        const { tagComponents } = interpolateElement(elementContainer, context, template, this, // ownerSupport,\n        {\n            forceElement: options.forceElement,\n            counts: options.counts\n        });\n        afterInterpolateElement(elementContainer, placeholderElm, this, // ownerSupport\n        context, options);\n        // Any tag components that were found should be processed AFTER the owner processes its elements. Avoid double processing of elements attributes like (oninit)=${}\n        tagComponents.forEach(tagComponent => {\n            subscribeToTemplate(tagComponent.insertBefore, tagComponent.subject, tagComponent.ownerSupport, options.counts, { isForceElement });\n            afterInterpolateElement(elementContainer, tagComponent.insertBefore, tagComponent.ownerSupport, context, options);\n        });\n    }\n    getTemplate() {\n        const thisTag = this.templater.tag;\n        const strings = this.strings || thisTag.strings;\n        const values = this.values || thisTag.values;\n        const string = strings.map((string, index) => {\n            const safeString = string.replace(prefixSearch, escapeVariable);\n            const endString = safeString + (values.length > index ? `{${variablePrefix}${index}}` : '');\n            const trimString = endString.replace(/>\\s*/g, '>').replace(/\\s*</g, '<');\n            return trimString;\n        }).join('');\n        const interpolation = interpolateString(string);\n        this.lastTemplateString = interpolation.string;\n        return {\n            interpolation,\n            string: interpolation.string,\n            strings,\n            values,\n            context: this.global.context || {},\n        };\n    }\n    /** Used during HMR only where static content itself could have been edited */\n    async rebuild() {\n        delete this.strings; // seek the templater strings instead now\n        delete this.values; // seek the templater strings instead now\n        restoreTagMarkers(this);\n        const newSupport = renderSubjectComponent(this.subject, this, this.ownerTagSupport);\n        await this.destroy();\n        newSupport.buildBeforeElement(this.global.insertBefore, {\n            forceElement: true,\n            counts: { added: 0, removed: 0 },\n        });\n        return newSupport;\n    }\n    getAppElement() {\n        let tag = this;\n        while (tag.ownerTagSupport) {\n            tag = tag.ownerTagSupport;\n        }\n        return tag;\n    }\n}\nfunction restoreTagMarkers(support) {\n    restoreTagMarker(support);\n    support.childTags.forEach(childTag => restoreTagMarkers(childTag.global.oldest));\n}\n","export class TemplaterResult {\n    props;\n    children;\n    isTemplater = true;\n    tagged;\n    wrapper;\n    tag;\n    constructor(props, children) {\n        this.props = props;\n        this.children = children;\n    }\n}\n","import { buildClones } from './render';\nimport { afterElmBuild } from './interpolations/interpolateTemplate';\nexport function afterInterpolateElement(container, insertBefore, tagSupport, \n// preClones: Clones,\ncontext, options) {\n    const clones = buildClones(container, insertBefore);\n    if (!clones.length) {\n        return clones;\n    }\n    clones.forEach(clone => afterElmBuild(clone, options, context, tagSupport));\n    tagSupport.clones.push(...clones);\n    return clones;\n}\n","import { isTag } from './isInstance';\nimport { renderTagSupport } from './renderTagSupport.function';\nimport { tagClosed$ } from './tagRunner';\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProps(props, ownerSupport) {\n    const isPropTag = isTag(props);\n    const watchProps = isPropTag ? 0 : props;\n    const newProps = resetFunctionProps(watchProps, ownerSupport);\n    return newProps;\n}\nfunction resetFunctionProps(props, ownerSupport) {\n    if (typeof (props) !== 'object') {\n        return props;\n    }\n    const newProps = props;\n    // BELOW: Do not clone because if first argument is object, the memory ref back is lost\n    // const newProps = {...props} \n    Object.entries(newProps).forEach(([name, value]) => {\n        if (value instanceof Function) {\n            const original = newProps[name].original;\n            if (original) {\n                return; // already previously converted\n            }\n            newProps[name] = (...args) => {\n                return newProps[name].toCall(...args); // what gets called can switch over parent state changes\n            };\n            // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n            newProps[name].toCall = (...args) => {\n                callbackPropOwner(value, args, ownerSupport);\n            };\n            newProps[name].original = value;\n            return;\n        }\n    });\n    return newProps;\n}\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    // signify that a render will be taking place. This prevents breaking state\n    // ownerSupport.childTags.forEach(childTag => ++childTag.global.renderCount)\n    // ++ownerSupport.global.renderCount\n    // if a tag is currently rendering, render after it otherwise render now\n    tagClosed$.toCallback(() => {\n        toCall(...callWith);\n        const lastestOwner = ownerSupport.global.newest;\n        renderTagSupport(lastestOwner, true);\n    });\n}\n","import { isTag, isTagArray, isTagComponent } from './isInstance';\nimport { isLikeTags } from './isLikeTags.function';\nimport { destroyTagMemory, destroyTagSupportPast } from './destroyTag.function';\nimport { insertAfter } from './insertAfter.function';\nexport function checkDestroyPrevious(subject, // existing.value is the old value\nnewValue, insertBefore) {\n    const arraySubject = subject;\n    const wasArray = arraySubject.lastArray;\n    // no longer an array\n    if (wasArray && !isTagArray(newValue)) {\n        const placeholderElm = arraySubject.placeholder;\n        delete arraySubject.lastArray;\n        delete arraySubject.placeholder;\n        insertAfter(insertBefore, placeholderElm);\n        wasArray.forEach(({ tagSupport }) => destroyArrayTag(tagSupport, { added: 0, removed: 0 }));\n        return 'array';\n    }\n    const tagSubject = subject;\n    const lastSupport = tagSubject.tagSupport;\n    // no longer tag or component?\n    if (lastSupport) {\n        const isValueTag = isTag(newValue);\n        const isSubjectTag = isTag(subject.value);\n        if (isSubjectTag && isValueTag) {\n            const newTag = newValue;\n            // its a different tag now\n            if (!isLikeTags(newTag, lastSupport)) {\n                // put template back down\n                restoreTagMarker(lastSupport);\n                destroyTagMemory(lastSupport, tagSubject);\n                return 2;\n            }\n            return false;\n        }\n        const isValueTagComponent = isTagComponent(newValue);\n        if (isValueTagComponent) {\n            return false; // its still a tag component\n        }\n        // put template back down\n        restoreTagMarker(lastSupport);\n        // destroy old component, value is not a component\n        destroyTagMemory(lastSupport, tagSubject);\n        return 'different-tag';\n    }\n    const displaySubject = subject;\n    const hasLastValue = 'lastValue' in displaySubject;\n    const lastValue = displaySubject.lastValue; // TODO: we maybe able to use displaySubject.value and remove concept of lastValue\n    // was simple value but now something bigger\n    if (hasLastValue && lastValue !== newValue) {\n        destroySimpleValue(insertBefore, displaySubject);\n        return 'changed-simple-value';\n    }\n    return false;\n}\nexport function destroyArrayTag(tagSupport, counts) {\n    destroyTagSupportPast(tagSupport);\n    tagSupport.destroy({\n        stagger: counts.removed++,\n    });\n    const insertBefore = tagSupport.global.insertBefore;\n    const parentNode = insertBefore.parentNode;\n    parentNode.removeChild(insertBefore);\n}\nfunction destroySimpleValue(insertBefore, // always a template tag\nsubject) {\n    const clone = subject.clone;\n    const parent = clone.parentNode;\n    // 1 put the template back down\n    parent.insertBefore(insertBefore, clone);\n    parent.removeChild(clone);\n    delete subject.clone;\n    delete subject.lastValue;\n}\nexport function restoreTagMarker(lastSupport) {\n    const insertBefore = lastSupport.global.insertBefore;\n    const global = lastSupport.global;\n    const placeholderElm = global.placeholder;\n    if (placeholderElm) {\n        insertAfter(insertBefore, placeholderElm);\n        delete global.placeholder;\n    }\n}\n","import { deepClone } from './deepFunctions';\nimport { isTagArray, isTagClass, isTagComponent, isTagTemplater } from './isInstance';\nexport function cloneValueArray(values) {\n    return values.map((value) => {\n        const tag = value;\n        if (isTagComponent(value)) {\n            const tagComponent = value;\n            return deepClone(tagComponent.props);\n        }\n        if (isTagClass(tag) || isTagTemplater(tag)) {\n            return cloneValueArray(tag.values);\n        }\n        if (isTagArray(tag)) {\n            return cloneValueArray(tag);\n        }\n        return deepClone(value);\n    });\n}\n","export function deepClone(obj) {\n    return makeDeepClone(obj, new WeakMap());\n}\nfunction makeDeepClone(obj, visited) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj)) {\n        return visited.get(obj);\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Register the cloned object to avoid cyclic references\n    visited.set(obj, clone);\n    // Clone each property or element of the object or array\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], visited);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clone[key] = makeDeepClone(obj[key], visited);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2) {\n    return isDeepEqual(obj1, obj2, new WeakMap());\n}\nfunction isDeepEqual(obj1, obj2, visited) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj1)) {\n        return true;\n    }\n    if (typeof obj1 === 'object' && typeof obj2 === 'object') {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return false;\n        }\n        // Register the cloned object to avoid cyclic references\n        visited.set(obj1, 0);\n        // Check if obj1 and obj2 are both arrays\n        if (Array.isArray(obj1) && Array.isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, visited);\n        }\n        else if (Array.isArray(obj1) || Array.isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        return isObjectDeepEqual(obj1, obj2, visited);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, visited) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, visited) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = fn0 instanceof Function && fn1 instanceof Function;\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","export function getChildTagsToDestroy(childTags, allTags = []) {\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const cTag = childTags[index];\n        allTags.push(cTag);\n        childTags.splice(index, 1);\n        getChildTagsToDestroy(cTag.childTags, allTags);\n    }\n    return allTags;\n}\n","export function destroyTagMemory(oldTagSupport, subject) {\n    // must destroy oldest which is tag with elements on stage\n    const oldest = oldTagSupport.global.oldest;\n    oldest.destroy();\n    destroyTagSupportPast(oldTagSupport);\n    oldTagSupport.global.context = {};\n}\nexport function destroyTagSupportPast(oldTagSupport) {\n    delete oldTagSupport.global.oldest;\n    delete oldTagSupport.global.newest;\n}\n","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    if (!onDestroyDoubleWrap) {\n        return;\n    }\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    if (!onDestroy) {\n        return;\n    }\n    const event = { target: nextSibling, stagger };\n    return onDestroy(event);\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { deepEqual } from \"./deepFunctions\";\nexport function hasTagSupportChanged(oldTagSupport, newTagSupport, newTemplater) {\n    const latestProps = newTemplater.props; // newTagSupport.propsConfig.latest\n    const pastCloneProps = oldTagSupport.propsConfig.latestCloned;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps);\n    // if no changes detected, no need to continue to rendering further tags\n    if (propsChanged) {\n        return propsChanged;\n    }\n    const kidsChanged = hasKidsChanged(oldTagSupport, newTagSupport);\n    // we already know props didn't change and if kids didn't either, than don't render\n    return kidsChanged;\n}\nexport function hasPropChanges(props, // natural props\npastCloneProps) {\n    /*\n    const isCommonEqual = props === undefined && props === compareToProps\n    if(isCommonEqual) {\n      return false\n    }\n    */\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    // check all prop functions match\n    if (typeof (props) === 'object') {\n        if (!pastCloneProps) {\n            return 3;\n        }\n        castedProps = { ...props };\n        castedPastProps = { ...(pastCloneProps || {}) };\n        const allFunctionsMatch = Object.entries(castedProps).every(([key, value]) => {\n            let compare = castedPastProps[key];\n            if (!(value instanceof Function)) {\n                return 4; // this will be checked in deepEqual\n            }\n            if (!(compare instanceof Function)) {\n                return false; // its a function now but was not before\n            }\n            // ensure we are comparing apples to apples as function get wrapped\n            if (compare.original) {\n                compare = compare.original;\n            }\n            const original = value.original;\n            if (original) {\n                value = value.original;\n            }\n            if (value.toString() !== compare.toString()) {\n                return false; // both are function but not the same\n            }\n            delete castedProps[key]; // its a function and not needed to be compared\n            delete castedPastProps[key]; // its a function and not needed to be compared\n            return 5;\n        });\n        if (!allFunctionsMatch) {\n            return 6; // a change has been detected by function comparisons\n        }\n    }\n    const isEqual = deepEqual(castedPastProps, castedProps);\n    return isEqual ? false : 7; // if equal then no changes\n}\nexport function hasKidsChanged(oldTagSupport, newTagSupport) {\n    const oldCloneKidValues = oldTagSupport.propsConfig.lastClonedKidValues;\n    const newClonedKidValues = newTagSupport.propsConfig.lastClonedKidValues;\n    const everySame = oldCloneKidValues.every((set, index) => {\n        const x = newClonedKidValues[index];\n        return set.every((item, index) => item === x[index]);\n    });\n    return everySame ? false : 9;\n}\n","import { Tag } from \"./Tag.class\";\nexport function html(strings, ...values) {\n    return new Tag(strings, values);\n}\n","// Function to insert element after reference element\nexport function insertAfter(newNode, referenceNode) {\n    const parentNode = referenceNode.parentNode;\n    parentNode.insertBefore(newNode, referenceNode.nextSibling);\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { renderTagSupport } from \"../renderTagSupport.function\";\nexport function bindSubjectCallback(value, tagSupport) {\n    // Is this children? No override needed\n    if (value.isChildOverride) {\n        return value;\n    }\n    const subjectFunction = (element, args) => runTagCallback(value, tagSupport, element, args);\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    return subjectFunction;\n}\nexport function runTagCallback(value, tagSupport, bindTo, args) {\n    const renderCount = tagSupport.global.renderCount;\n    const method = value.bind(bindTo);\n    const callbackResult = method(...args);\n    const sameRenderCount = renderCount === tagSupport.global.renderCount;\n    // already rendered OR tag was deleted before event processing\n    if (!sameRenderCount || tagSupport.global.deleted) {\n        if (callbackResult instanceof Promise) {\n            return callbackResult.then(() => {\n                return 'promise-no-data-ever'; // tag was deleted during event processing\n            });\n        }\n        return 'no-data-ever'; // already rendered\n    }\n    renderTagSupport(tagSupport, true);\n    // tagSupport.global.newest = newest\n    if (callbackResult instanceof Promise) {\n        return callbackResult.then(() => {\n            if (tagSupport.global.deleted) {\n                return 'promise-no-data-ever'; // tag was deleted during event processing\n            }\n            const newest = renderTagSupport(tagSupport, true);\n            tagSupport.global.newest = newest;\n            return 'promise-no-data-ever';\n        });\n    }\n    // Caller always expects a Promise\n    return 'no-data-ever';\n}\n","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n","export function inputAttribute(name, value, element) {\n    const names = name.split('.');\n    // style.position = \"absolute\"\n    if (names[0] === 'style') {\n        element.style[names[1]] = value;\n    }\n    // Example: class.width-full = \"true\"\n    if (names[0] === 'class') {\n        names.shift();\n        if (value) {\n            names.forEach(name => element.classList.add(name));\n        }\n        else {\n            names.forEach(name => element.classList.remove(name));\n        }\n        return;\n    }\n}\n","import { processAttribute } from \"./processAttribute.function\";\nfunction howToSetAttribute(element, name, value) {\n    element.setAttribute(name, value);\n}\nfunction howToSetInputValue(element, name, value) {\n    /*\n    if((element as any)[name] === value) {\n      return // its already the value we are setting\n    }\n    */\n    element[name] = value;\n}\nexport function interpolateAttributes(child, scope, ownerSupport) {\n    const attrNames = child.getAttributeNames();\n    let howToSet = howToSetAttribute;\n    attrNames.forEach(attrName => {\n        if (child.nodeName === 'INPUT' && attrName === 'value') {\n            howToSet = howToSetInputValue;\n        }\n        const value = child.getAttribute(attrName);\n        processAttribute(attrName, value, child, scope, ownerSupport, howToSet);\n        howToSet = howToSetAttribute; // put back\n    });\n}\n","import { interpolateTemplate } from \"./interpolateTemplate\";\nexport function interpolateContentTemplates(element, context, tagSupport, options, children) {\n    if (!children || element.tagName === 'TEMPLATE') {\n        return { clones: [], tagComponents: [] }; // done\n    }\n    // counting for animation stagger computing\n    const counts = options.counts;\n    const clones = [];\n    const tagComponents = [];\n    const childArray = new Array(...children);\n    childArray.forEach(child => {\n        const { clones: nextClones, tagComponent } = interpolateTemplate(child, context, tagSupport, counts, options);\n        clones.push(...nextClones);\n        if (tagComponent) {\n            tagComponents.push(tagComponent);\n            return;\n        }\n        if (child.children) {\n            const nextKids = new Array(...child.children);\n            nextKids.forEach((subChild, index) => {\n                // IF <template end /> its a variable to be processed\n                if (isRenderEndTemplate(subChild)) {\n                    const { tagComponent } = interpolateTemplate(subChild, context, tagSupport, counts, options);\n                    if (tagComponent) {\n                        tagComponents.push(tagComponent);\n                    }\n                }\n                const { clones: nextClones, tagComponents: nextTagComponent } = interpolateContentTemplates(subChild, context, tagSupport, options, subChild.children);\n                clones.push(...nextClones);\n                tagComponents.push(...nextTagComponent);\n            });\n        }\n    });\n    return { clones, tagComponents };\n}\nfunction isRenderEndTemplate(child) {\n    const isTemplate = child.tagName === 'TEMPLATE';\n    return isTemplate &&\n        child.getAttribute('interpolate') !== undefined &&\n        child.getAttribute('end') !== undefined;\n}\n","import { interpolateAttributes } from \"./interpolateAttributes\";\nimport { interpolateToTemplates } from \"./interpolations\";\nimport { interpolateContentTemplates } from \"./interpolateContentTemplates\";\nimport { escapeSearch, variablePrefix } from \"../Tag.class\";\n/** Review elements within an element */\nexport function interpolateElement(container, // element containing innerHTML to review interpolations\ncontext, // variables used to evaluate\ninterpolatedTemplates, ownerSupport, options) {\n    const clones = [];\n    const tagComponents = [];\n    const result = interpolatedTemplates.interpolation;\n    const template = container.children[0];\n    const children = template.content.children;\n    if (result.keys.length) {\n        const { clones: nextClones, tagComponents: nextTagComponents } = interpolateContentTemplates(container, context, ownerSupport, options, children);\n        clones.push(...nextClones);\n        tagComponents.push(...nextTagComponents);\n    }\n    interpolateAttributes(container, context, ownerSupport);\n    processChildrenAttributes(children, context, ownerSupport);\n    return { clones, tagComponents };\n}\nfunction processChildrenAttributes(children, context, ownerSupport) {\n    new Array(...children).forEach(child => {\n        interpolateAttributes(child, context, ownerSupport);\n        if (child.children) {\n            processChildrenAttributes(child.children, context, ownerSupport);\n        }\n    });\n}\nexport function interpolateString(string) {\n    const result = interpolateToTemplates(string);\n    result.string = result.string.replace(escapeSearch, variablePrefix);\n    return result;\n}\n","import { variablePrefix } from \"../Tag.class\";\nimport { elementInitCheck } from \"./elementInitCheck\";\nimport { processSubjectValue } from \"../processSubjectValue.function\";\nimport { isTagArray, isTagComponent } from \"../isInstance\";\nimport { scanTextAreaValue } from \"./scanTextAreaValue.function\";\nimport { updateExistingValue } from \"../updateExistingValue.function\";\nexport function interpolateTemplate(insertBefore, // <template end interpolate /> (will be removed)\ncontext, // variable scope of {`__tagvar${index}`:'x'}\nownerSupport, // Tag class\ncounts, // used for animation stagger computing\noptions) {\n    // TODO: THe clones array is useless here\n    const clones = [];\n    if (!insertBefore.hasAttribute('end')) {\n        return { clones }; // only care about <template end>\n    }\n    const variableName = insertBefore.getAttribute('id');\n    if (variableName?.substring(0, variablePrefix.length) !== variablePrefix) {\n        return { clones }; // ignore, not a tagVar\n    }\n    const existingSubject = context[variableName];\n    const isDynamic = isTagComponent(existingSubject.value) || isTagArray(existingSubject.value);\n    // process dynamics later\n    if (isDynamic) {\n        return {\n            clones,\n            tagComponent: {\n                variableName,\n                ownerSupport,\n                subject: existingSubject,\n                insertBefore\n            }\n        };\n    }\n    let isForceElement = options.forceElement;\n    subscribeToTemplate(insertBefore, existingSubject, ownerSupport, counts, { isForceElement });\n    return { clones };\n}\nexport function subscribeToTemplate(insertBefore, subject, ownerSupport, counts, // used for animation stagger computing\n{ isForceElement }) {\n    let called = false;\n    const callback = (value) => {\n        if (called) {\n            updateExistingValue(subject, value, ownerSupport, insertBefore);\n            return;\n        }\n        const templater = value;\n        processSubjectValue(templater, subject, insertBefore, ownerSupport, {\n            counts: { ...counts },\n            forceElement: isForceElement,\n        });\n        if (isForceElement) {\n            isForceElement = false; // only can happen once\n        }\n        called = true;\n    };\n    const sub = subject.subscribe(callback);\n    ownerSupport.global.subscriptions.push(sub);\n}\nexport function afterElmBuild(elm, options, context, ownerSupport) {\n    if (!elm.getAttribute) {\n        return;\n    }\n    const tagName = elm.nodeName; // elm.tagName\n    if (tagName === 'TEXTAREA') {\n        scanTextAreaValue(elm, context, ownerSupport);\n    }\n    let diff = options.counts.added;\n    diff = elementInitCheck(elm, options.counts) - diff;\n    if (elm.children) {\n        new Array(...elm.children).forEach((child, index) => {\n            const subOptions = {\n                ...options,\n                counts: options.counts,\n            };\n            return afterElmBuild(child, subOptions, context, ownerSupport);\n        });\n    }\n}\n","// support arrow functions in attributes\nexport const interpolateReplace = /(?:<[^>]*?(?:(?:\\s+\\w+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)))*\\s*)\\/?>)|({__tagvar[^}]+})/g;\n/** replaces ${x} with <template id=\"x-start\"></template><template id=\"x-end\"></template> */\nexport function interpolateToTemplates(template) {\n    const keys = [];\n    const string = template.replace(interpolateReplace, (match, expression) => {\n        if (match.startsWith('<')) {\n            // If the match is an HTML tag, don't replace\n            return match;\n        }\n        const noBraces = expression.substring(1, expression.length - 1);\n        const id = noBraces;\n        keys.push(id);\n        return `<template interpolate end id=\"${id}\"></template>`;\n    });\n    return { string, keys };\n}\n","import { inputAttribute } from './inputAttribute';\nimport { isSubjectInstance } from '../isInstance';\nimport { bindSubjectCallback } from './bindSubjectCallback.function';\nconst startRegX = /^\\s*{__tagvar/;\nconst endRegX = /}\\s*$/;\nfunction isTagVar(value) {\n    return value && value.search(startRegX) >= 0 && value.search(endRegX) >= 0;\n}\nexport function processAttribute(attrName, value, child, scope, ownerSupport, howToSet) {\n    if (isTagVar(value)) {\n        return processScopedNameValueAttr(attrName, value, child, scope, ownerSupport, howToSet);\n    }\n    if (isTagVar(attrName)) {\n        const contextValueSubject = getContextValueByVarString(scope, attrName);\n        let lastValue;\n        // the above callback gets called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe((value) => {\n            processNameOnlyAttr(value, lastValue, child, ownerSupport, howToSet);\n            lastValue = value;\n        });\n        ownerSupport.global.subscriptions.push(sub); // this is where unsubscribe is picked up\n        child.removeAttribute(attrName);\n        return;\n    }\n    // Non dynamic\n    const isSpecial = isSpecialAttr(attrName);\n    if (isSpecial) {\n        return inputAttribute(attrName, value, child);\n    }\n}\nfunction processScopedNameValueAttr(attrName, value, // {__tagVarN}\nchild, scope, ownerSupport, howToSet) {\n    // get the code inside the brackets like \"variable0\" or \"{variable0}\"\n    const result = getContextValueByVarString(scope, value);\n    return processNameValueAttr(attrName, result, child, ownerSupport, howToSet);\n}\nfunction getContextValueByVarString(scope, value) {\n    const code = value.replace('{', '').split('').reverse().join('').replace('}', '').split('').reverse().join('');\n    return scope[code];\n}\nfunction processNameOnlyAttr(attrValue, lastValue, child, ownerSupport, howToSet) {\n    if (lastValue && lastValue != attrValue) {\n        if (typeof (lastValue) === 'string') {\n            child.removeAttribute(lastValue);\n        }\n        else if (lastValue instanceof Object) {\n            Object.entries(lastValue).forEach(([name]) => child.removeAttribute(name));\n        }\n    }\n    if (typeof (attrValue) === 'string') {\n        if (!attrValue.length) {\n            return;\n        }\n        processNameValueAttr(attrValue, '', child, ownerSupport, howToSet);\n        return;\n    }\n    if (attrValue instanceof Object) {\n        Object.entries(attrValue).forEach(([name, value]) => processNameValueAttr(name, value, child, ownerSupport, howToSet));\n        return;\n    }\n}\nfunction processNameValueAttr(attrName, result, child, ownerSupport, howToSet) {\n    const isSpecial = isSpecialAttr(attrName);\n    // attach as callback?\n    if (result instanceof Function) {\n        const action = function (...args) {\n            const result2 = result(child, args);\n            return result2;\n        };\n        child[attrName].action = action;\n        // child.addEventListener(attrName, action)\n    }\n    // Most every variable comes in here since everything is made a ValueSubject\n    if (isSubjectInstance(result)) {\n        child.removeAttribute(attrName);\n        const callback = (newAttrValue) => {\n            if (newAttrValue instanceof Function) {\n                newAttrValue = bindSubjectCallback(newAttrValue, ownerSupport);\n            }\n            return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = result.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        ownerSupport.global.subscriptions.push(sub);\n        return;\n    }\n    howToSet(child, attrName, result);\n    // child.setAttribute(attrName, result.value)\n    return;\n}\nfunction processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet) {\n    if (newAttrValue instanceof Function) {\n        const fun = function (...args) {\n            return newAttrValue(child, args);\n        };\n        // access to original function\n        fun.tagFunction = newAttrValue;\n        child[attrName] = fun;\n        return;\n    }\n    if (isSpecial) {\n        inputAttribute(attrName, newAttrValue, child);\n        return;\n    }\n    if (newAttrValue) {\n        howToSet(child, attrName, newAttrValue);\n        return;\n    }\n    const isDeadValue = [undefined, false, null].includes(newAttrValue);\n    if (isDeadValue) {\n        child.removeAttribute(attrName);\n        return;\n    }\n    // value is 0\n    howToSet(child, attrName, newAttrValue);\n}\n/** Looking for (class | style) followed by a period */\nfunction isSpecialAttr(attrName) {\n    return attrName.search(/^(class|style)(\\.)/) >= 0;\n}\n","import { processAttribute } from './processAttribute.function';\nconst search = new RegExp('\\\\s*<template interpolate end id=\"__tagvar(\\\\d{1,4})\"([^>]*)></template>(\\\\s*)');\nexport function scanTextAreaValue(textarea, context, ownerSupport) {\n    const value = textarea.value;\n    if (value.search(search) >= 0) {\n        const match = value.match(/__tagvar(\\d{1,4})/);\n        const token = match ? match[0] : '';\n        const dynamic = '{' + token + '}';\n        textarea.value = '';\n        textarea.setAttribute('text-var-value', dynamic);\n        const howToSet = (_elm, _name, value) => textarea.value = value;\n        processAttribute('text-var-value', dynamic, // realValue, // context[token].value,\n        textarea, context, ownerSupport, howToSet);\n    }\n}\n","export function isTagComponent(value) {\n    return value?.wrapper?.original instanceof Function;\n}\nexport function isTag(value) {\n    return isTagTemplater(value) || isTagClass(value);\n}\nexport function isTagTemplater(value) {\n    const templater = value;\n    return templater?.isTemplater === true && templater.wrapper === undefined;\n}\nexport function isTagClass(value) {\n    const templater = value;\n    return templater?.isTagClass === true;\n}\nexport function isSubjectInstance(subject) {\n    return (subject?.isSubject === true || subject?.subscribe) ? true : false; // subject?.isSubject === true || \n}\nexport function isTagArray(value) {\n    return value instanceof Array && value.every(x => isTagClass(x) || isTagTemplater(x));\n}\n","export function isLikeTags(tagSupport0, // new\ntagSupport1) {\n    const templater0 = tagSupport0.templater;\n    const templater1 = tagSupport1.templater;\n    const tag0 = templater0?.tag || tagSupport0;\n    const tag1 = templater1.tag;\n    const strings0 = tag0.strings;\n    const strings1 = tagSupport1.strings || tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index] === string);\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = tagSupport0.values || tag0.values;\n    const values1 = tagSupport1.values || tag1.values;\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = value instanceof Function && compareTo instanceof Function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true; // deepEqual(value, compareTo)\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { ValueSubject } from './subject/ValueSubject';\nimport { isSubjectInstance, isTagClass, isTagComponent, isTagTemplater } from './isInstance';\nimport { TemplaterResult } from './TemplaterResult.class';\nimport { TagSupport } from './TagSupport.class';\nexport function processNewValue(hasValue, value, ownerSupport) {\n    if (isTagComponent(value)) {\n        const tagSubject = new ValueSubject(value);\n        return tagSubject;\n    }\n    if (value instanceof Function) {\n        return new ValueSubject(value);\n    }\n    if (!hasValue) {\n        return new ValueSubject(undefined);\n    }\n    if (isTagTemplater(value)) {\n        const templater = value;\n        const tag = templater.tag;\n        return processNewTag(tag, ownerSupport);\n    }\n    if (isTagClass(value)) {\n        return processNewTag(value, ownerSupport);\n    }\n    // is already a value subject?\n    if (isSubjectInstance(value)) {\n        return value;\n    }\n    return new ValueSubject(value);\n}\nfunction processNewTag(value, ownerSupport) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        const children = new ValueSubject([]);\n        templater = new TemplaterResult(undefined, children);\n        templater.tag = tag;\n        tag.templater = templater;\n    }\n    const subject = new ValueSubject(templater);\n    const tagSupport = subject.tagSupport = new TagSupport(templater, ownerSupport, subject);\n    return subject;\n}\n","import { updateBeforeTemplate } from './updateBeforeTemplate.function';\nexport function processRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.insertBefore = insertBefore;\n    const before = subject.clone || insertBefore; // Either the template is on the doc OR its the first element we last put on doc\n    // matches but also was defined at some point\n    if (subject.lastValue === value && 'lastValue' in subject) {\n        return; // no need to update display, its the same\n    }\n    subject.lastValue = value;\n    // Processing of regular values\n    const clone = updateBeforeTemplate(value, before);\n    subject.clone = clone; // remember single element put down, for future updates\n}\n","import { setUse } from './state';\nimport { processTagResult } from './processTagResult.function';\nimport { TagSupport } from './TagSupport.class';\nimport { renderSubjectComponent } from './renderSubjectComponent.function';\nexport function processSubjectComponent(templater, subject, insertBefore, ownerSupport, options) {\n    // Check if function component is wrapped in a tag() call\n    // TODO: This below check not needed in production mode\n    if (templater.tagged !== true) {\n        const wrapper = templater.wrapper;\n        const original = wrapper.original;\n        let name = original.name || original.constructor?.name;\n        if (name === 'Function') {\n            name = undefined;\n        }\n        const label = name || original.toString().substring(0, 120);\n        const error = new Error(`Not a tag component. Wrap your function with tag(). Example tag(props => html\\`\\`) on component:\\n\\n${label}\\n\\n`);\n        throw error;\n    }\n    const tagSupport = new TagSupport(templater, ownerSupport, subject);\n    let reSupport = subject.tagSupport;\n    const global = tagSupport.global = reSupport?.global || tagSupport.global;\n    global.insertBefore = insertBefore;\n    const providers = setUse.memory.providerConfig;\n    providers.ownerSupport = ownerSupport;\n    const isRender = !reSupport || options.forceElement;\n    if (isRender) {\n        const support = reSupport || tagSupport;\n        reSupport = renderSubjectComponent(subject, support, ownerSupport);\n    }\n    processTagResult(reSupport, subject, // The element set here will be removed from document. Also result.tag will be added in here\n    insertBefore, // <template end interpolate /> (will be removed)\n    options);\n    return reSupport;\n}\n","import { processSubjectComponent } from './processSubjectComponent.function';\nimport { isTagArray, isTagClass, isTagComponent, isTagTemplater } from './isInstance';\nimport { processTagArray } from './processTagArray';\nimport { processRegularValue } from './processRegularValue.function';\nimport { processTag, tagFakeTemplater } from './processTag.function';\nvar ValueTypes;\n(function (ValueTypes) {\n    ValueTypes[\"tag\"] = \"tag\";\n    ValueTypes[\"templater\"] = \"templater\";\n    ValueTypes[\"tagArray\"] = \"tag-array\";\n    ValueTypes[\"tagComponent\"] = \"tag-component\";\n    ValueTypes[\"value\"] = \"value\";\n})(ValueTypes || (ValueTypes = {}));\nfunction getValueType(value) {\n    if (isTagComponent(value)) {\n        return ValueTypes.tagComponent;\n    }\n    if (isTagTemplater(value)) {\n        return ValueTypes.templater;\n    }\n    if (isTagClass(value)) {\n        return ValueTypes.tag;\n    }\n    if (isTagArray(value)) {\n        return ValueTypes.tagArray;\n    }\n    return ValueTypes.value;\n}\n// export type ExistingValue = TemplaterResult | Tag[] | TagSupport | Function | Subject<unknown> | RegularValue | Tag\nexport function processSubjectValue(value, subject, // could be tag via result.tag\ninsertBefore, // <template end interpolate /> (will be removed)\nownerSupport, // owner\noptions) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.templater:\n            processTag(value, insertBefore, ownerSupport, subject);\n            return;\n        case ValueTypes.tag:\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = tagFakeTemplater(tag);\n            }\n            processTag(templater, insertBefore, ownerSupport, subject);\n            return;\n        case ValueTypes.tagArray:\n            return processTagArray(subject, value, insertBefore, ownerSupport, options);\n        case ValueTypes.tagComponent:\n            processSubjectComponent(value, subject, insertBefore, ownerSupport, options);\n            return;\n    }\n    processRegularValue(value, subject, insertBefore);\n}\n","import { TagSupport } from './TagSupport.class';\nimport { ValueSubject } from './subject';\n/** Could be a regular tag or a component. Both are Tag.class */\nexport function processTag(templater, insertBefore, ownerSupport, // owner\nsubject) {\n    let tagSupport = subject.tagSupport;\n    // first time seeing this tag?\n    if (!tagSupport) {\n        tagSupport = new TagSupport(templater, ownerSupport, subject);\n        setupNewTemplater(tagSupport, ownerSupport, subject);\n        ownerSupport.childTags.push(tagSupport);\n    }\n    subject.tagSupport = tagSupport;\n    tagSupport.ownerTagSupport = ownerSupport;\n    tagSupport.buildBeforeElement(insertBefore, {\n        counts: { added: 0, removed: 0 },\n        forceElement: true,\n    });\n}\nexport function setupNewTemplater(tagSupport, ownerSupport, subject) {\n    tagSupport.global.oldest = tagSupport;\n    tagSupport.global.newest = tagSupport;\n    // asking me to render will cause my parent to render\n    tagSupport.ownerTagSupport = ownerSupport;\n    subject.tagSupport = tagSupport;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    return {\n        children: new ValueSubject([]), // no children\n        props: {},\n        isTag: true,\n        isTemplater: false,\n        tagged: false,\n        // wrapper: (() => undefined) as unknown as Wrapper,\n    };\n}\n","import { ValueSubject } from './subject/ValueSubject';\nimport { ArrayNoKeyError } from './errors';\nimport { destroyArrayTag } from './checkDestroyPrevious.function';\nimport { setupNewTemplater, tagFakeTemplater } from './processTag.function';\nimport { TagSupport } from './TagSupport.class';\nimport { isTagClass } from './isInstance';\nexport function processTagArray(subject, value, // arry of Tag classes\ninsertBefore, // <template end interpolate />\nownerSupport, options) {\n    const clones = ownerSupport.clones; // []\n    let lastArray = subject.lastArray = subject.lastArray || [];\n    if (!subject.placeholder) {\n        setPlaceholderElm(insertBefore, subject);\n    }\n    const runtimeInsertBefore = subject.placeholder; // || insertBefore\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    lastArray = subject.lastArray = subject.lastArray.filter((item, index) => {\n        const newLength = value.length - 1;\n        const at = index - removed;\n        const lessLength = newLength < at;\n        const subValue = value[index - removed];\n        const subTag = subValue;\n        // const tag = subTag?.templater.tag as Tag\n        const lastTag = item.tagSupport.templater.tag;\n        const newArrayValue = subTag?.memory.arrayValue;\n        const lastArrayValue = lastTag.memory.arrayValue;\n        const destroyItem = lessLength || !areLikeValues(newArrayValue, lastArrayValue);\n        if (destroyItem) {\n            const last = lastArray[index];\n            const tagSupport = last.tagSupport;\n            destroyArrayTag(tagSupport, options.counts);\n            last.deleted = true;\n            ++removed;\n            ++options.counts.removed;\n            return false;\n        }\n        return true;\n    });\n    value.forEach((item, index) => {\n        const previous = lastArray[index];\n        const previousSupport = previous?.tagSupport;\n        const subTag = item;\n        if (isTagClass(subTag) && !subTag.templater) {\n            tagFakeTemplater(subTag);\n        }\n        const tagSupport = new TagSupport(subTag.templater, ownerSupport, new ValueSubject(undefined));\n        // tagSupport.templater = subTag.templater\n        if (previousSupport) {\n            setupNewTemplater(tagSupport, ownerSupport, previousSupport.subject);\n            const global = previousSupport.global;\n            tagSupport.global = global;\n            global.newest = tagSupport;\n        }\n        // check for html``.key()\n        const keySet = 'arrayValue' in subTag.memory;\n        if (!keySet) {\n            const details = {\n                template: tagSupport.getTemplate().string,\n                array: value,\n                ownerTagContent: ownerSupport.lastTemplateString,\n            };\n            const message = 'Use html`...`.key(item) instead of html`...` to template an Array';\n            console.error(message, details);\n            const err = new ArrayNoKeyError(message, details);\n            throw err;\n        }\n        const couldBeSame = lastArray.length > index;\n        if (couldBeSame) {\n            const prevSupport = previous.tagSupport;\n            const prevGlobal = prevSupport.global;\n            // subTag.tagSupport = subTag.tagSupport || prevSupport\n            const oldest = prevGlobal.oldest;\n            oldest.updateBy(tagSupport);\n            return [];\n        }\n        processAddTagArrayItem(runtimeInsertBefore, tagSupport, index, options, lastArray);\n        ownerSupport.childTags.push(tagSupport);\n    });\n    return clones;\n}\nfunction setPlaceholderElm(insertBefore, subject) {\n    if (insertBefore.nodeName !== 'TEMPLATE') {\n        subject.placeholder = insertBefore;\n        return;\n    }\n    const placeholder = subject.placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n}\nfunction processAddTagArrayItem(before, tagSupport, index, options, lastArray) {\n    const lastValue = {\n        tagSupport, index\n    };\n    // Added to previous array\n    lastArray.push(lastValue);\n    const counts = {\n        added: options.counts.added + index,\n        removed: options.counts.removed,\n    };\n    const newTempElm = document.createElement('template');\n    const parent = before.parentNode;\n    parent.insertBefore(newTempElm, before);\n    tagSupport.buildBeforeElement(newTempElm, // before,\n    { counts, forceElement: options.forceElement });\n}\n/** compare two values. If both values are arrays then the items will be compared */\nfunction areLikeValues(valueA, valueB) {\n    if (valueA === valueB) {\n        return true;\n    }\n    const bothArrays = valueA instanceof Array && valueB instanceof Array;\n    const matchLengths = bothArrays && valueA.length == valueB.length;\n    if (matchLengths) {\n        return valueA.every((item, index) => item == valueB[index]);\n    }\n    return false;\n}\n","export function processTagResult(tagSupport, subject, // used for recording past and current value\ninsertBefore, // <template end interpolate />\n{ counts, forceElement, }) {\n    // *if appears we already have seen\n    const subjectTag = subject;\n    const lastSupport = subjectTag.tagSupport;\n    const prevSupport = lastSupport?.global.oldest || undefined; // || tag.tagSupport.oldest // subjectTag.tag\n    const justUpdate = prevSupport; // && !forceElement\n    if (prevSupport && justUpdate) {\n        return processTagResultUpdate(tagSupport, subjectTag, prevSupport);\n    }\n    tagSupport.buildBeforeElement(insertBefore, {\n        counts,\n        forceElement,\n    });\n}\nfunction processTagResultUpdate(tagSupport, subject, // used for recording past and current value\nprevSupport) {\n    // components\n    if (subject instanceof Function) {\n        const newSupport = subject(prevSupport);\n        prevSupport.updateBy(newSupport);\n        subject.tagSupport = newSupport;\n        return;\n    }\n    prevSupport.updateBy(tagSupport);\n    subject.tagSupport = tagSupport;\n    return;\n}\n","export function buildClones(temporary, insertBefore) {\n    const clones = [];\n    const template = temporary.children[0];\n    let nextSibling = template.content.firstChild;\n    while (nextSibling) {\n        const nextNextSibling = nextSibling.nextSibling;\n        buildSibling(nextSibling, insertBefore);\n        clones.push(nextSibling);\n        nextSibling = nextNextSibling;\n    }\n    return clones;\n}\nfunction buildSibling(nextSibling, insertBefore) {\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(nextSibling, insertBefore);\n}\n","import { providersChangeCheck } from './state/provider.utils';\nimport { isLikeTags } from './isLikeTags.function';\nimport { renderWithSupport } from './renderWithSupport.function';\n/** Returns true when rendering owner is not needed. Returns false when rendering owner should occur */\nexport function renderExistingTag(oldestSupport, // oldest with elements on html\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const lastSupport = subject.tagSupport;\n    const global = lastSupport.global;\n    // share point between renders\n    newSupport.global = global;\n    const preRenderCount = global.renderCount;\n    providersChangeCheck(oldestSupport);\n    // When the providers were checked, a render to myself occurred and I do not need to re-render again\n    const prevSupport = global.newest;\n    if (preRenderCount !== global.renderCount) {\n        oldestSupport.updateBy(prevSupport);\n        return prevSupport; // already rendered during triggered events\n    }\n    const toRedrawTag = prevSupport || lastSupport || global.oldest;\n    const reSupport = renderWithSupport(newSupport, toRedrawTag, subject, \n    // oldestSupport,\n    ownerSupport);\n    const oldest = global.oldest || oldestSupport;\n    reSupport.global.oldest = oldest;\n    if (isLikeTags(prevSupport, reSupport)) {\n        subject.tagSupport = reSupport;\n        oldest.updateBy(reSupport);\n    }\n    return reSupport;\n}\n","import { renderWithSupport } from './renderWithSupport.function';\nexport function renderSubjectComponent(subject, reSupport, ownerSupport) {\n    const preClones = ownerSupport.clones.map(clone => clone);\n    reSupport = renderWithSupport(reSupport, subject.tagSupport, // existing tag\n    subject, ownerSupport);\n    reSupport.global.newest = reSupport;\n    if (ownerSupport.clones.length > preClones.length) {\n        const myClones = ownerSupport.clones.filter(fClone => !preClones.find(clone => clone === fClone));\n        reSupport.clones.push(...myClones);\n    }\n    ownerSupport.childTags.push(reSupport);\n    return reSupport;\n}\n","import { deepEqual } from './deepFunctions';\nimport { renderExistingTag } from './renderExistingTag.function';\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderTagSupport(tagSupport, // must be latest/newest state render\nrenderUp) {\n    const global = tagSupport.global;\n    const templater = tagSupport.templater;\n    // is it just a vanilla tag, not component?\n    if (!templater.wrapper) { // || isTagTemplater(templater) \n        const ownerTag = tagSupport.ownerTagSupport;\n        ++global.renderCount;\n        return renderTagSupport(ownerTag, true);\n    }\n    const subject = tagSupport.subject;\n    let ownerSupport;\n    let selfPropChange = false;\n    const shouldRenderUp = renderUp && tagSupport;\n    if (shouldRenderUp) {\n        ownerSupport = tagSupport.ownerTagSupport;\n        if (ownerSupport) {\n            const nowProps = templater.props;\n            const latestProps = tagSupport.propsConfig.latestCloned;\n            selfPropChange = !deepEqual(nowProps, latestProps);\n        }\n    }\n    const oldest = tagSupport.global.oldest;\n    const tag = renderExistingTag(oldest, tagSupport, ownerSupport, // useTagSupport,\n    subject);\n    const renderOwner = ownerSupport && selfPropChange;\n    if (renderOwner) {\n        const ownerTagSupport = ownerSupport;\n        renderTagSupport(ownerTagSupport, true);\n        return tag;\n    }\n    return tag;\n}\n","import { runAfterRender, runBeforeRedraw, runBeforeRender } from './tagRunner';\nimport { setUse } from './state';\nimport { isLikeTags } from './isLikeTags.function';\nimport { destroyTagMemory } from './destroyTag.function';\nexport function renderWithSupport(tagSupport, // new\nlastSupport, // previous\nsubject, // events & memory\nownerSupport) {\n    const oldRenderCount = tagSupport.global.renderCount;\n    beforeWithRender(tagSupport, ownerSupport, lastSupport);\n    const templater = tagSupport.templater;\n    // NEW TAG CREATED HERE\n    const wrapper = templater.wrapper;\n    const reSupport = wrapper(tagSupport, subject);\n    /* AFTER */\n    runAfterRender(tagSupport, reSupport);\n    // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n    if (reSupport.global.renderCount > oldRenderCount + 1) {\n        return tagSupport.global.newest;\n    }\n    tagSupport.global.newest = reSupport;\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        destroyUnlikeTags(lastSupport, reSupport, subject);\n    }\n    const lastOwnerSupport = lastSupport?.ownerTagSupport;\n    reSupport.ownerTagSupport = (ownerSupport || lastOwnerSupport);\n    return reSupport;\n}\nfunction beforeWithRender(tagSupport, ownerSupport, lastSupport) {\n    const lastOwnerSupport = lastSupport?.ownerTagSupport;\n    const runtimeOwnerSupport = lastOwnerSupport || ownerSupport;\n    if (lastSupport) {\n        const lastState = lastSupport.memory.state;\n        const memory = tagSupport.memory;\n        memory.state = [...lastState];\n        tagSupport.global = lastSupport.global;\n        runBeforeRedraw(tagSupport, lastSupport);\n    }\n    else {\n        // first time render\n        runBeforeRender(tagSupport, runtimeOwnerSupport);\n        // TODO: Logic below most likely could live within providers.ts inside the runBeforeRender function\n        const providers = setUse.memory.providerConfig;\n        providers.ownerSupport = runtimeOwnerSupport;\n    }\n}\nfunction destroyUnlikeTags(lastSupport, // old\nreSupport, // new\nsubject) {\n    const oldGlobal = lastSupport.global;\n    const insertBefore = oldGlobal.insertBefore;\n    destroyTagMemory(lastSupport, subject);\n    // when a tag is destroyed, disconnect the globals\n    reSupport.global = { ...oldGlobal }; // break memory references\n    const global = reSupport.global;\n    global.insertBefore = insertBefore;\n    global.deleted = false;\n    delete global.oldest;\n    delete global.newest;\n    delete subject.tagSupport;\n}\n","export function setTagPlaceholder(global) {\n    const insertBefore = global.insertBefore;\n    const placeholder = global.placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n}\n","import { setUse } from \"./setUse.function\";\nimport { getStateValue } from \"./state.utils\";\nimport { renderTagSupport } from \"../renderTagSupport.function\";\nimport { SyncCallbackError } from \"../errors\";\nlet innerCallback = (callback) => (a, b, c, d, e, f) => {\n    throw new SyncCallbackError('Callback function was called immediately in sync and must instead be call async');\n};\nexport const callbackMaker = () => innerCallback;\nconst originalGetter = innerCallback; // callbackMaker\nsetUse({\n    beforeRender: (tagSupport) => initMemory(tagSupport),\n    beforeRedraw: (tagSupport) => initMemory(tagSupport),\n    afterRender: (_tagSupport) => {\n        innerCallback = originalGetter; // prevent crossing callbacks with another tag\n    },\n});\nfunction updateState(stateFrom, stateTo) {\n    stateFrom.forEach((state, index) => {\n        const fromValue = getStateValue(state);\n        const callback = stateTo[index].callback;\n        if (callback) {\n            callback(fromValue); // set the value\n        }\n        stateTo[index].lastValue = fromValue; // record the value\n    });\n}\nfunction initMemory(tagSupport) {\n    const oldState = setUse.memory.stateConfig.array;\n    innerCallback = (callback) => {\n        const trigger = (...args) => triggerStateUpdate(tagSupport, callback, oldState, ...args);\n        return trigger;\n    };\n}\nfunction triggerStateUpdate(tagSupport, callback, oldState, ...args) {\n    const state = tagSupport.memory.state;\n    // ensure that the oldest has the latest values first\n    updateState(state, oldState);\n    // run the callback\n    const promise = callback(...args);\n    // send the oldest state changes into the newest\n    updateState(oldState, state);\n    renderTagSupport(tagSupport, false);\n    if (promise instanceof Promise) {\n        promise.finally(() => {\n            // send the oldest state changes into the newest\n            updateState(oldState, state);\n            renderTagSupport(tagSupport, false);\n        });\n    }\n}\n","export * from \"./watch.function\";\nexport { setUse } from \"./setUse.function\";\nexport { state } from \"./state.function\";\nexport { letState } from \"./letState.function\";\nexport { setProp } from \"./setProp.function\";\nexport { providers } from \"./providers\";\nexport * from \"./callbackMaker.function\";\nexport * from \"./onInit\";\nexport * from \"./onDestroy\";\n","import { getStateValue } from './state.utils';\nimport { setUse } from './setUse.function';\n/** Used for variables that need to remain the same variable during render passes */\nexport function letState(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    const rearray = config.rearray;\n    let getSetMethod;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return makeStateResult(oldValue, push);\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return makeStateResult(initValue, push);\n}\nfunction makeStateResult(initValue, push) {\n    // return initValue\n    const result = (y) => {\n        push.callback = y || (x => [initValue, initValue = x]);\n        return initValue;\n    };\n    return result;\n}\n","import { setUse } from \"./setUse.function\";\nfunction setCurrentTagSupport(support) {\n    setUse.memory.destroyCurrentSupport = support;\n}\nexport function onDestroy(callback) {\n    const tagSupport = setUse.memory.destroyCurrentSupport;\n    tagSupport.global.destroyCallback = callback;\n}\nsetUse({\n    beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeDestroy: (tagSupport) => {\n        const callback = tagSupport.global.destroyCallback;\n        if (callback) {\n            callback();\n        }\n    }\n});\n","import { setUse } from \"./setUse.function\";\nfunction setCurrentTagSupport(support) {\n    setUse.memory.initCurrentSupport = support;\n}\nexport function onInit(callback) {\n    const tagSupport = setUse.memory.initCurrentSupport;\n    if (!tagSupport.global.init) {\n        tagSupport.global.init = callback;\n        callback(); // fire init\n    }\n}\nsetUse({\n    beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n});\n","import { deepClone, deepEqual } from '../deepFunctions';\nimport { renderTagSupport } from '../renderTagSupport.function';\nexport function providersChangeCheck(tagSupport) {\n    const global = tagSupport.global;\n    const providersWithChanges = global.providers.filter(provider => !deepEqual(provider.instance, provider.clone));\n    // reset clones\n    providersWithChanges.forEach(provider => {\n        const appElement = tagSupport.getAppElement();\n        handleProviderChanges(appElement, provider);\n        provider.clone = deepClone(provider.instance);\n    });\n}\nfunction handleProviderChanges(appElement, provider) {\n    const tagsWithProvider = getTagsWithProvider(appElement, provider);\n    tagsWithProvider.forEach(({ tagSupport, renderCount, provider }) => {\n        if (tagSupport.global.deleted) {\n            return; // i was deleted after another tag processed\n        }\n        const notRendered = renderCount === tagSupport.global.renderCount;\n        if (notRendered) {\n            provider.clone = deepClone(provider.instance);\n            renderTagSupport(tagSupport, false);\n        }\n    });\n}\nfunction getTagsWithProvider(tagSupport, provider, memory = []) {\n    const global = tagSupport.global;\n    const compare = global.providers;\n    const hasProvider = compare.find(xProvider => xProvider.constructMethod === provider.constructMethod);\n    if (hasProvider) {\n        memory.push({\n            tagSupport,\n            renderCount: global.renderCount,\n            provider: hasProvider,\n        });\n    }\n    tagSupport.childTags.forEach(child => getTagsWithProvider(child, provider, memory));\n    return memory;\n}\n","import { deepClone } from '../deepFunctions';\nimport { setUse } from './setUse.function';\nsetUse.memory.providerConfig = {\n    providers: [],\n    ownerSupport: undefined,\n};\nfunction get(constructMethod) {\n    const config = setUse.memory.providerConfig;\n    const providers = config.providers;\n    return providers.find(provider => provider.constructMethod === constructMethod);\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const existing = get(constructMethod);\n        if (existing) {\n            existing.clone = deepClone(existing.instance);\n            return existing.instance;\n        }\n        // Providers with provider requirements just need to use providers.create() and providers.inject()\n        const instance = 'prototype' in constructMethod ? new constructMethod() : constructMethod();\n        const config = setUse.memory.providerConfig;\n        config.providers.push({\n            constructMethod,\n            instance,\n            clone: deepClone(instance)\n        });\n        return instance;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        const oldValue = get(constructor);\n        if (oldValue) {\n            return oldValue.instance;\n        }\n        const config = setUse.memory.providerConfig;\n        let owner = {\n            ownerTagSupport: config.ownerSupport\n        };\n        while (owner.ownerTagSupport) {\n            const ownerProviders = owner.ownerTagSupport.global.providers;\n            const provider = ownerProviders.find(provider => {\n                if (provider.constructMethod === constructor) {\n                    return true;\n                }\n            });\n            if (provider) {\n                provider.clone = deepClone(provider.instance); // keep a copy of the latest before any change occur\n                config.providers.push(provider);\n                return provider.instance;\n            }\n            owner = owner.ownerTagSupport; // cause reloop\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, config.providers);\n        throw new Error(msg);\n    }\n};\nsetUse({\n    beforeRender: (tagSupport, ownerSupport) => {\n        run(tagSupport, ownerSupport);\n    },\n    beforeRedraw: (tagSupport, newTagSupport) => {\n        run(tagSupport, newTagSupport.ownerTagSupport);\n    },\n    afterRender: (tagSupport) => {\n        const config = setUse.memory.providerConfig;\n        tagSupport.global.providers = [...config.providers];\n        config.providers.length = 0;\n    }\n});\nfunction run(tagSupport, ownerSupport) {\n    const config = setUse.memory.providerConfig;\n    config.ownerSupport = ownerSupport;\n    if (tagSupport.global.providers.length) {\n        config.providers.length = 0;\n        config.providers.push(...tagSupport.global.providers);\n    }\n}\n","import { getStateValue } from './state.utils';\nimport { setUse } from './setUse.function';\n/** Used for variables that need to remain the same variable during render passes */\nexport function setProp(getSet) {\n    const config = setUse.memory.stateConfig;\n    const rearray = config.rearray;\n    const [propValue] = getSet(undefined);\n    getSet(propValue); // restore original value instead of undefined\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let watchValue = restate.watch;\n        let oldValue = getStateValue(restate);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSet,\n            lastValue: oldValue,\n            watch: restate.watch,\n        };\n        // has the prop value changed?\n        if (propValue != watchValue) {\n            push.watch = propValue;\n            oldValue = push.lastValue = propValue;\n        }\n        config.array.push(push);\n        getSet(oldValue);\n        return oldValue;\n    }\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSet,\n        lastValue: propValue,\n        watch: propValue,\n    };\n    config.array.push(push);\n    return propValue;\n}\n","const tagUse = [];\nexport function setUse(use) {\n    // must provide defaults\n    const useMe = {\n        beforeRender: use.beforeRender || (() => undefined),\n        beforeRedraw: use.beforeRedraw || (() => undefined),\n        afterRender: use.afterRender || (() => undefined),\n        beforeDestroy: use.beforeDestroy || (() => undefined),\n    };\n    setUse.tagUse.push(useMe);\n}\nsetUse.tagUse = tagUse;\nsetUse.memory = {};\n","import { setUse } from './setUse.function';\nimport { getStateValue } from './state.utils';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    let getSetMethod;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return oldValue;\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n","import { StateMismatchError } from '../errors';\nimport { setUse } from './setUse.function';\nsetUse.memory.stateConfig = {\n    array: [], // state memory on the first render\n    // rearray: [] as State,\n};\nconst beforeRender = (tagSupport) => initState(tagSupport);\nsetUse({\n    beforeRender,\n    beforeRedraw: beforeRender,\n    afterRender: (tagSupport) => {\n        const memory = tagSupport.memory;\n        // const state: State = memory.state\n        const config = setUse.memory.stateConfig;\n        const rearray = config.rearray;\n        if (rearray.length) {\n            if (rearray.length !== config.array.length) {\n                const message = `States lengths has changed ${rearray.length} !== ${config.array.length}. Typically occurs when a function is intended to be wrapped with a tag() call`;\n                const wrapper = tagSupport.templater?.wrapper;\n                const details = {\n                    oldStates: config.array,\n                    newStates: config.rearray,\n                    tagFunction: wrapper.original,\n                };\n                const error = new StateMismatchError(message, details);\n                console.warn(message, details);\n                throw error;\n            }\n        }\n        delete config.rearray; // clean up any previous runs\n        memory.state = config.array; // [...config.array]\n        memory.state.forEach(item => item.lastValue = getStateValue(item)); // set last values\n        config.array = [];\n    }\n});\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [oldValue] = oldState;\n    const [checkValue] = callback(oldValue); // set back to original value\n    if (checkValue !== StateEchoBack) {\n        const message = 'State property not used correctly. Second item in array is not setting value as expected.\\n\\n' +\n            'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n            'For \"const\" state use `const name = state(default)()`\\n\\n' +\n            'Problem state:\\n' + (callback ? callback.toString() : JSON.stringify(state)) + '\\n';\n        console.error(message, { state, callback, oldState, oldValue, checkValue });\n        throw new Error(message);\n    }\n    // state.lastValue = oldValue\n    return oldValue;\n}\nexport class StateEchoBack {\n}\nfunction initState(tagSupport) {\n    const memory = tagSupport.memory;\n    const state = memory.state;\n    const config = setUse.memory.stateConfig;\n    // TODO: This guard may no longer be needed\n    if (config.rearray) {\n        checkStateMismatch(tagSupport, config, state);\n    }\n    config.rearray = [];\n    if (state?.length) {\n        state.forEach(state => getStateValue(state));\n        config.rearray.push(...state);\n    }\n    config.tagSupport = tagSupport;\n}\nfunction checkStateMismatch(tagSupport, config, state) {\n    const wrapper = tagSupport.templater?.wrapper;\n    const wasWrapper = config.tagSupport?.templater.wrapper;\n    const message = 'last state not cleared. Possibly in the middle of rendering one component and another is trying to render';\n    if (!wasWrapper) {\n        return; // its not a component or was not a component before\n    }\n    console.error(message, {\n        config,\n        tagFunction: wrapper.original,\n        wasInMiddleOf: wasWrapper.original,\n        state,\n        expectedClearArray: config.rearray,\n    });\n    throw new StateMismatchError(message, {\n        config,\n        tagFunction: wrapper.original,\n        state,\n        expectedClearArray: config.rearray,\n    });\n}\n","import { letState } from './letState.function';\n/**\n * When an item in watch array changes, callback function will be triggered. Does not trigger on initial watch setup.\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport function watch(currentValues, callback) {\n    let previousValues = letState(undefined)(x => [previousValues, previousValues = x]);\n    // First time running watch?\n    if (previousValues === undefined) {\n        // callback(currentValues, previousValues) // do not call during init\n        previousValues = currentValues;\n        return currentValues;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return currentValues;\n    }\n    callback(currentValues, previousValues);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return currentValues;\n}\n","export class Subject {\n    value;\n    onSubscription;\n    methods = [];\n    isSubject = true;\n    subscribers = [];\n    subscribeWith;\n    // unsubcount = 0 // 🔬 testing\n    constructor(value, onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        SubjectClass.globalSubs.push(subscription); // 🔬 testing\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    set(value) {\n        this.value = value;\n        // Notify all subscribers with the new value\n        this.subscribers.forEach(sub => {\n            // (sub.callback as any).value = value\n            sub.callback(value, sub);\n        });\n    }\n    next = this.set;\n    toPromise() {\n        return new Promise((res, rej) => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    // like toPromise but faster\n    toCallback(callback) {\n        this.subscribe((x, subscription) => {\n            subscription.unsubscribe();\n            callback(x);\n        });\n    }\n    pipe(...operations) {\n        const subject = new Subject();\n        subject.methods = operations;\n        subject.subscribeWith = (x) => this.subscribe(x);\n        return subject;\n    }\n}\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nconst SubjectClass = Subject;\nSubjectClass.globalSubs = []; // 🔬 for testing\nSubjectClass.globalSubCount$ = new Subject(); // for ease of debugging\nSubjectClass.globalSubCount$.set(0);\nfunction getSubscription(subject, callback) {\n    const countSubject = SubjectClass.globalSubCount$;\n    SubjectClass.globalSubCount$.set(countSubject.value + 1);\n    const subscription = () => {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = () => {\n        removeSubFromArray(subject.subscribers, callback); // each will be called when update comes in\n        removeSubFromArray(SubjectClass.globalSubs, callback); // 🔬 testing\n        SubjectClass.globalSubCount$.set(countSubject.value - 1);\n        // any double unsubscribes will be ignored\n        subscription.unsubscribe = () => subscription;\n        // unsubscribe from any combined subjects\n        subscription.subscriptions.forEach(subscription => subscription.unsubscribe());\n        return subscription;\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nfunction runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n        // return newValue = next\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\n","import { Subject } from './Subject.class';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\n","import { Subject } from \"./Subject.class\";\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            if (valuesSeen.length === subjects.length && valuesSeen.every(x => x)) {\n                callback(values, subscription);\n            }\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => subject.subscribe(x => setValue(x, index + 1)));\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","export * from './Subject.class';\nexport * from './ValueSubject';\nexport * from './combineLatest.function';\nexport * from './will.functions';\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { isSubjectInstance, isTagArray, isTagClass, isTagTemplater } from './isInstance';\nimport { setUse } from './state';\nimport { TemplaterResult } from './TemplaterResult.class';\nimport { runTagCallback } from './interpolations/bindSubjectCallback.function';\nimport { deepClone } from './deepFunctions';\nimport { TagSupport } from './TagSupport.class';\nimport { alterProps } from './alterProps.function';\nimport { ValueSubject } from './subject/ValueSubject';\nexport const tags = [];\nlet tagCount = 0;\n/** Wraps a tag component in a state manager and always push children to last argument as an array */\n// export function tag<T>(a: T): T;\nexport function tag(tagComponent) {\n    /** function developer triggers */\n    const result = (function tagWrapper(props, children) {\n        // is the props argument actually children?\n        const isPropTag = isTagClass(props) || isTagTemplater(props) || isTagArray(props);\n        if (isPropTag) {\n            children = props;\n            props = undefined;\n        }\n        const { childSubject, madeSubject } = kidsToTagArraySubject(children);\n        childSubject.isChildSubject = true;\n        const templater = new TemplaterResult(props, childSubject);\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, madeSubject);\n        innerTagWrap.original = tagComponent.lastResult?.original || tagComponent;\n        templater.tagged = true;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }); // we override the function provided and pretend original is what's returned\n    updateResult(result, tagComponent);\n    // group tags together and have hmr pickup\n    updateComponent(tagComponent);\n    tags.push(tagComponent);\n    // fake the return as being (props?, children?) => TemplaterResult\n    return result;\n}\nfunction kidsToTagArraySubject(children) {\n    if (isSubjectInstance(children)) {\n        return { childSubject: children, madeSubject: false };\n    }\n    const kidArray = children;\n    if (isTagArray(kidArray)) {\n        return { childSubject: new ValueSubject(children), madeSubject: true };\n    }\n    const kid = children;\n    if (kid) {\n        kid.memory.arrayValue = 0;\n        return { childSubject: new ValueSubject([kid]), madeSubject: true };\n    }\n    return {\n        childSubject: new ValueSubject([]),\n        madeSubject: true\n    };\n}\nfunction updateResult(result, tagComponent) {\n    result.isTag = true;\n    result.original = tagComponent;\n}\nfunction updateComponent(tagComponent) {\n    tagComponent.tags = tags;\n    tagComponent.setUse = setUse;\n    tagComponent.tagIndex = tagCount++; // needed for things like HMR\n    tagComponent.lastResult = tagComponent;\n}\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nfunction getTagWrap(templater, madeSubject) {\n    // this function gets called by taggedjs\n    const innerTagWrap = function (oldTagSetup, subject) {\n        const global = oldTagSetup.global;\n        ++global.renderCount;\n        const childSubject = templater.children;\n        const lastArray = global.oldest?.templater.children.lastArray;\n        if (lastArray) {\n            childSubject.lastArray = lastArray;\n        }\n        const originalFunction = innerTagWrap.original;\n        let props = templater.props;\n        let castedProps = alterProps(props, oldTagSetup.ownerTagSupport);\n        const clonedProps = deepClone(props); // castedProps\n        // CALL ORIGINAL COMPONENT FUNCTION\n        const tag = originalFunction(castedProps, childSubject);\n        tag.templater = templater;\n        templater.tag = tag;\n        const tagSupport = new TagSupport(templater, oldTagSetup.ownerTagSupport, subject, global.renderCount);\n        tagSupport.global = global;\n        tagSupport.propsConfig = {\n            latest: props,\n            latestCloned: clonedProps,\n            lastClonedKidValues: tagSupport.propsConfig.lastClonedKidValues,\n        };\n        tagSupport.memory = oldTagSetup.memory; // state handover\n        if (madeSubject) {\n            childSubject.value.forEach(kid => {\n                kid.values.forEach((value, index) => {\n                    if (!(value instanceof Function)) {\n                        return;\n                    }\n                    const valuesValue = kid.values[index];\n                    if (valuesValue.isChildOverride) {\n                        return; // already overwritten\n                    }\n                    // all functions need to report to me\n                    kid.values[index] = function (...args) {\n                        const ownerSupport = tagSupport.ownerTagSupport;\n                        runTagCallback(value, // callback\n                        ownerSupport, this, // bindTo\n                        args);\n                    };\n                    valuesValue.isChildOverride = true;\n                });\n            });\n        }\n        return tagSupport;\n    };\n    return innerTagWrap;\n}\n","import { BaseTagSupport } from './TagSupport.class';\nimport { runAfterRender, runBeforeRender } from './tagRunner';\nimport { ValueSubject } from './subject/ValueSubject';\nconst appElements = [];\nexport function tagElement(app, // (...args: unknown[]) => TemplaterResult,\nelement, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        appElements[appElmIndex].tagSupport.destroy();\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    const wrapper = app(props);\n    // have a function setup and call the tagWrapper with (props, {update, async, on})\n    const tagSupport = runWrapper(wrapper);\n    // TODO: is the below needed?\n    tagSupport.appElement = element;\n    tagSupport.isApp = true;\n    tagSupport.global.isApp = true;\n    const templateElm = document.createElement('template');\n    templateElm.setAttribute('id', 'app-tag-' + appElements.length);\n    templateElm.setAttribute('app-tag-detail', appElements.length.toString());\n    element.appendChild(templateElm);\n    element.destroy = async () => {\n        await tagSupport.destroy();\n        const insertBefore = tagSupport.global.insertBefore;\n        const parentNode = insertBefore.parentNode;\n        parentNode.removeChild(insertBefore);\n    };\n    tagSupport.buildBeforeElement(templateElm);\n    tagSupport.global.oldest = tagSupport;\n    tagSupport.global.newest = tagSupport;\n    element.setUse = app.original.setUse;\n    appElements.push({ element, tagSupport });\n    return {\n        tagSupport,\n        tags: app.original.tags,\n    };\n}\nexport function runWrapper(templater) {\n    let newSupport = {};\n    const subject = new ValueSubject(newSupport);\n    newSupport = new BaseTagSupport(templater, subject);\n    subject.set(templater);\n    subject.tagSupport = newSupport;\n    runBeforeRender(newSupport, undefined);\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const tagSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport, tagSupport);\n    return tagSupport;\n}\n","// TODO: This should be more like `new TaggedJs().use({})`\nimport { setUse } from './state';\nimport { Subject } from './subject';\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nexport const tagClosed$ = new Subject(undefined, subscription => {\n    if (!setUse.memory.stateConfig.rearray) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n// Life cycle 1\nexport function runBeforeRender(tagSupport, ownerSupport) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeRender(tagSupport, ownerSupport));\n}\n// Life cycle 2\nexport function runAfterRender(tagSupport, ownerTagSupport) {\n    setUse.tagUse.forEach(tagUse => tagUse.afterRender(tagSupport, ownerTagSupport));\n    tagClosed$.next(ownerTagSupport);\n}\n// Life cycle 3\nexport function runBeforeRedraw(tagSupport, ownerTagSupport) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeRedraw(tagSupport, ownerTagSupport));\n}\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(tagSupport, ownerTagSupport) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeDestroy(tagSupport, ownerTagSupport));\n}\n","// Function to update the value of x\nexport function updateBeforeTemplate(value, lastFirstChild) {\n    const parent = lastFirstChild.parentNode;\n    let castedValue = value;\n    // mimic React skipping to display EXCEPT for true does display on page\n    if ([undefined, false, null].includes(value)) { // || value === true\n        castedValue = '';\n    }\n    // Insert the new value (never use innerHTML here)\n    const textNode = document.createTextNode(castedValue); // never innerHTML\n    parent.insertBefore(textNode, lastFirstChild);\n    /* remove existing nodes */\n    parent.removeChild(lastFirstChild);\n    return textNode;\n}\n","import { isSubjectInstance, isTagComponent } from './isInstance';\nimport { TagSupport } from './TagSupport.class';\nexport function updateContextItem(context, variableName, value) {\n    const subject = context[variableName];\n    const tagSubject = subject;\n    const tagSupport = tagSubject.tagSupport;\n    if (tagSupport) {\n        if (value) {\n            if (isTagComponent(value)) {\n                const templater = value;\n                let newSupport = new TagSupport(templater, tagSupport.ownerTagSupport, subject);\n                if (isTagComponent(tagSupport)) {\n                    shareTemplaterGlobal(tagSupport, newSupport);\n                }\n            }\n        }\n    }\n    if (isSubjectInstance(value)) {\n        return;\n    }\n    // listeners will evaluate updated values to possibly update display(s)\n    subject.set(value);\n    return;\n}\nfunction shareTemplaterGlobal(oldTagSupport, tagSupport) {\n    const oldTemp = oldTagSupport.templater;\n    const oldWrap = oldTemp.wrapper; // tag versus component\n    const oldValueFn = oldWrap.original;\n    const templater = tagSupport.templater;\n    const newWrapper = templater.wrapper;\n    const newValueFn = newWrapper?.original;\n    const fnMatched = oldValueFn === newValueFn;\n    if (fnMatched) {\n        tagSupport.global = oldTagSupport.global;\n        // ??? new mirroring transfer state\n        const newest = oldTagSupport.global.newest;\n        if (newest) {\n            const prevState = newest.memory.state;\n            tagSupport.memory.state = [...prevState];\n        }\n    }\n}\n","import { hasTagSupportChanged } from './hasTagSupportChanged.function';\nimport { processSubjectComponent } from './processSubjectComponent.function';\nimport { destroyTagMemory } from './destroyTag.function';\nimport { renderTagSupport } from './renderTagSupport.function';\nimport { callbackPropOwner } from './alterProps.function';\nimport { isLikeTags } from './isLikeTags.function';\nexport function updateExistingTagComponent(ownerSupport, tagSupport, // lastest\nsubject, insertBefore) {\n    // ??? changed during mirroring\n    // let lastSupport = subject.tagSupport\n    let lastSupport = subject.tagSupport?.global.newest; // || subject.tagSupport\n    let oldestTag = lastSupport.global.oldest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = tagSupport.templater.wrapper;\n    let isSameTag = false;\n    if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = tagSupport.templater;\n    if (!isSameTag) {\n        const oldestSupport = lastSupport.global.oldest;\n        destroyTagMemory(oldestSupport, subject);\n        return processSubjectComponent(templater, subject, insertBefore, ownerSupport, {\n            forceElement: false,\n            counts: { added: 0, removed: 0 },\n        });\n    }\n    else {\n        const hasChanged = hasTagSupportChanged(lastSupport, tagSupport, templater);\n        if (!hasChanged) {\n            // if the new props are an object then implicitly since no change, the old props are an object\n            const newProps = templater.props;\n            if (newProps && typeof (newProps) === 'object') {\n                syncFunctionProps(lastSupport, ownerSupport, newProps);\n            }\n            return lastSupport; // its the same tag component\n        }\n    }\n    const previous = lastSupport.global.newest;\n    const newSupport = renderTagSupport(tagSupport, false);\n    lastSupport = subject.tagSupport;\n    const newOldest = newSupport.global.oldest;\n    const hasOldest = newOldest ? true : false;\n    if (!hasOldest) {\n        return buildNewTag(newSupport, insertBefore, lastSupport, subject);\n    }\n    if (newOldest && templater.children.value.length) {\n        const oldKidsSub = newOldest.templater.children;\n        oldKidsSub.set(templater.children.value);\n    }\n    // detect if both the function is the same and the return is the same\n    const isLikeTag = isSameTag && isLikeTags(previous, newSupport);\n    if (isLikeTag) {\n        subject.tagSupport = newSupport;\n        oldestTag.updateBy(newSupport); // the oldest tag has element references\n        return newSupport;\n    }\n    else {\n        // Although function looked the same it returned a different html result\n        if (isSameTag && lastSupport) {\n            destroyTagMemory(lastSupport, subject);\n            newSupport.global.context = {}; // do not share previous outputs\n        }\n        oldestTag = undefined;\n    }\n    if (!oldestTag) {\n        lastSupport = newSupport;\n        buildNewTag(newSupport, lastSupport.global.insertBefore, lastSupport, subject);\n    }\n    lastSupport.global.newest = newSupport;\n    if (!lastSupport.global.oldest) {\n        throw new Error('333333');\n    }\n    return newSupport;\n}\nfunction buildNewTag(newSupport, oldInsertBefore, oldTagSupport, subject) {\n    newSupport.buildBeforeElement(oldInsertBefore, {\n        forceElement: true,\n        counts: { added: 0, removed: 0 },\n    });\n    newSupport.global.oldest = newSupport;\n    newSupport.global.newest = newSupport;\n    oldTagSupport.global.oldest = newSupport;\n    oldTagSupport.global.newest = newSupport;\n    subject.tagSupport = newSupport;\n    return newSupport;\n}\nfunction syncFunctionProps(lastSupport, ownerSupport, newProps) {\n    lastSupport = lastSupport.global.newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorProps = priorPropConfig.latestCloned;\n    const prevSupport = ownerSupport.global.newest;\n    Object.entries(priorProps).forEach(([name, value]) => {\n        if (!(value instanceof Function)) {\n            return;\n        }\n        // TODO: The code below maybe irrelevant\n        const newCallback = newProps[name];\n        const original = newCallback.original;\n        if (original) {\n            return; // already previously converted\n        }\n        // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n        priorProps[name].toCall = (...args) => {\n            return callbackPropOwner(newCallback, // value, // newOriginal,\n            args, prevSupport);\n        };\n        return;\n    });\n}\n","import { TagSupport } from './TagSupport.class';\nimport { TemplaterResult } from './TemplaterResult.class';\nimport { isSubjectInstance, isTagArray, isTagClass, isTagComponent, isTagTemplater } from './isInstance';\nimport { processTagArray } from './processTagArray';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function';\nimport { processRegularValue } from './processRegularValue.function';\nimport { checkDestroyPrevious } from './checkDestroyPrevious.function';\nimport { ValueSubject } from './subject/ValueSubject';\nimport { processSubjectComponent } from './processSubjectComponent.function';\nimport { isLikeTags } from './isLikeTags.function';\nimport { bindSubjectCallback } from './interpolations/bindSubjectCallback.function';\nimport { setupNewTemplater, getFakeTemplater, processTag } from './processTag.function';\nimport { insertAfter } from './insertAfter.function';\nexport function updateExistingValue(subject, value, ownerSupport, insertBefore) {\n    const subjectTag = subject;\n    const isComponent = isTagComponent(value);\n    checkDestroyPrevious(subject, value, insertBefore);\n    // handle already seen tag components\n    if (isComponent) {\n        return prepareUpdateToComponent(value, subjectTag, insertBefore, ownerSupport);\n    }\n    // was component but no longer\n    const tagSupport = subjectTag.tagSupport;\n    if (tagSupport) {\n        handleStillTag(subject, value, ownerSupport);\n        return subjectTag;\n    }\n    // its another tag array\n    if (isTagArray(value)) {\n        processTagArray(subject, value, insertBefore, // oldInsertBefore as InsertBefore,\n        ownerSupport, { counts: {\n                added: 0,\n                removed: 0,\n            } });\n        return subject;\n    }\n    if (isTagTemplater(value)) {\n        processTag(value, insertBefore, ownerSupport, subjectTag);\n        return subjectTag;\n    }\n    if (isTagClass(value)) {\n        const tag = value;\n        let templater = tag.templater;\n        if (!templater) {\n            templater = getFakeTemplater();\n            tag.templater = templater;\n            templater.tag = tag;\n        }\n        processTag(templater, insertBefore, ownerSupport, subjectTag);\n        return subjectTag;\n    }\n    // we have been given a subject\n    if (isSubjectInstance(value)) {\n        return value;\n    }\n    // now its a function\n    if (value instanceof Function) {\n        const bound = bindSubjectCallback(value, ownerSupport);\n        subject.set(bound);\n        return subject;\n    }\n    // This will cause all other values to render\n    processRegularValue(value, subject, insertBefore);\n    return subjectTag;\n}\nfunction handleStillTag(subject, value, ownerSupport) {\n    const lastSupport = subject.tagSupport;\n    let templater = value;\n    const isClass = isTagClass(value);\n    if (isClass) {\n        const tag = value;\n        templater = tag.templater;\n        if (!templater) {\n            const children = new ValueSubject([]);\n            templater = new TemplaterResult(undefined, children);\n            templater.tag = tag;\n            tag.templater = templater;\n        }\n    }\n    const valueSupport = new TagSupport(templater, ownerSupport, subject);\n    if (isClass) {\n        valueSupport.global = lastSupport.global;\n    }\n    const isSameTag = value && isLikeTags(lastSupport, valueSupport);\n    if (isTagTemplater(value)) {\n        setupNewTemplater(valueSupport, ownerSupport, subject);\n    }\n    if (isSameTag) {\n        lastSupport.updateBy(valueSupport);\n        return;\n    }\n    if (isSameTag) {\n        // const subjectTag = subject as TagSubject\n        const global = lastSupport.global;\n        const insertBefore = global.insertBefore;\n        return processTag(templater, insertBefore, ownerSupport, subject);\n    }\n    return processRegularValue(value, subject, subject.insertBefore);\n}\nfunction prepareUpdateToComponent(templater, subjectTag, insertBefore, ownerSupport) {\n    // When was something before component\n    if (!subjectTag.tagSupport) {\n        processSubjectComponent(templater, subjectTag, insertBefore, // oldInsertBefore as InsertBefore,\n        ownerSupport, {\n            forceElement: true,\n            counts: { added: 0, removed: 0 },\n        });\n        return subjectTag;\n    }\n    const tagSupport = new TagSupport(templater, ownerSupport, subjectTag);\n    // ??? new mirroring\n    const subjectSup = subjectTag.tagSupport;\n    // const prevSupport = (subjectSup.global.newest || subjectSup) as TagSupport\n    const prevSupport = subjectSup.global.newest;\n    if (prevSupport) {\n        const newestState = prevSupport.memory.state;\n        tagSupport.memory.state = [...newestState];\n    }\n    else {\n        const placeholder = subjectSup.global.placeholder;\n        if (placeholder && !insertBefore.parentNode) {\n            insertAfter(insertBefore, placeholder);\n            delete subjectSup.global.placeholder;\n        }\n        // insertBefore = subjectSup.global.placeholder || insertBefore\n        processSubjectComponent(templater, subjectTag, insertBefore, ownerSupport, {\n            forceElement: true,\n            counts: { added: 0, removed: 0 },\n        });\n        return subjectTag;\n    }\n    tagSupport.global = subjectSup.global;\n    subjectTag.tagSupport = tagSupport;\n    updateExistingTagComponent(ownerSupport, tagSupport, // latest value\n    subjectTag, insertBefore);\n    return subjectTag;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * from \"./tag\";\nexport * from \"./html\";\nexport * from \"./errors\";\nexport * from \"./isInstance\";\nexport * from \"./state/index\";\nexport * from \"./subject/index\";\nexport * from \"./TagSupport.class\";\nexport * from \"./ElementTargetEvent.interface\";\nexport * from \"./interpolations/interpolateElement\";\nexport { tagElement } from \"./tagElement\";\nexport { Tag } from \"./Tag.class\";\nexport { runBeforeRender } from \"./tagRunner\";\nexport { renderTagSupport } from \"./renderTagSupport.function\";\nexport { renderWithSupport } from \"./renderWithSupport.function\";\nimport { renderTagSupport } from \"./renderTagSupport.function\";\nimport { renderWithSupport } from \"./renderWithSupport.function\";\nimport { tagElement } from \"./tagElement\";\nexport const hmr = {\n    tagElement, renderWithSupport, renderTagSupport,\n};\n"],"names":[],"sourceRoot":""}