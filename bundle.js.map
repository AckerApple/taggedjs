{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/state/setUse.function.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/letState.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/tag/Tag.class.ts","webpack://taggedjs/./ts/tag/destroyTag.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/getValueType.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/destroy.support.ts","webpack://taggedjs/./ts/tag/TemplaterResult.class.ts","webpack://taggedjs/./ts/tag/kidsToTagArraySubject.function.ts","webpack://taggedjs/./ts/tag/update/TagJsSubject.class.ts","webpack://taggedjs/./ts/tag/update/processNewValue.function.ts","webpack://taggedjs/./ts/interpolations/specialAttribute.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/render/renderSubjectComponent.function.ts","webpack://taggedjs/./ts/alterProp.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/interpolations/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/processAttribute.function.ts","webpack://taggedjs/./ts/interpolations/interpolateAttributes.ts","webpack://taggedjs/./ts/interpolations/interpolations.ts","webpack://taggedjs/./ts/interpolations/scanTextAreaValue.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/updateBeforeTemplate.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/tag/setTagPlaceholder.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingValue.function.ts","webpack://taggedjs/./ts/interpolations/subscribeToTemplate.function.ts","webpack://taggedjs/./ts/interpolations/interpolateTemplate.ts","webpack://taggedjs/./ts/interpolations/elementInitCheck.ts","webpack://taggedjs/./ts/interpolations/interpolateContentTemplates.ts","webpack://taggedjs/./ts/interpolations/interpolateElement.ts","webpack://taggedjs/./ts/interpolations/afterInterpolateElement.function.ts","webpack://taggedjs/./ts/buildClones.function.ts","webpack://taggedjs/./ts/tag/Support.class.ts","webpack://taggedjs/./ts/tag/update/updateContextItem.function.ts","webpack://taggedjs/./ts/tag/elementDestroyCheck.function.ts","webpack://taggedjs/./ts/tag/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/tag/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/tag/render/destroyUnlikeTags.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/tag/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/tag/render/renderSupport.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/children.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/tag.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","export var ValueTypes;\n(function (ValueTypes) {\n    ValueTypes[\"unknown\"] = \"unknown\";\n    ValueTypes[\"tag\"] = \"tag\";\n    ValueTypes[\"templater\"] = \"templater\";\n    ValueTypes[\"tagComponent\"] = \"tag-component\";\n    ValueTypes[\"tagArray\"] = \"tag-array\";\n    ValueTypes[\"subject\"] = \"subject\";\n    ValueTypes[\"tagJsSubject\"] = \"tagJsSubject\";\n    ValueTypes[\"date\"] = \"date\";\n    ValueTypes[\"string\"] = \"string\";\n    ValueTypes[\"boolean\"] = \"boolean\";\n    ValueTypes[\"function\"] = \"function\";\n    ValueTypes[\"undefined\"] = \"undefined\";\n})(ValueTypes || (ValueTypes = {}));\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export class RouteQuery {\n    get(name) {\n        return 'todo';\n    }\n}\n","import { ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isStaticTag(value) {\n    return [\n        ValueTypes.tag,\n        ValueTypes.templater,\n    ].includes(value?.tagJsType);\n}\nexport function isTagTemplater(value) {\n    return value?.tagJsType === ValueTypes.templater;\n}\n// TODO: whats the difference between isTagClass and isTagComponent\nexport function isTagComponent(value) {\n    return value?.tagJsType === ValueTypes.tagComponent;\n}\nexport function isTagClass(value) {\n    return value?.tagJsType === ValueTypes.tag;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return (subject?.isSubject === true || subject?.subscribe) ? true : false; // subject?.isSubject === true || \n}\nexport function isTagArray(value) {\n    return value instanceof Array && value.every(x => [\n        ValueTypes.tag, ValueTypes.templater, ValueTypes.tag, ValueTypes.tagComponent\n    ].includes(x?.tagJsType));\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (let index = valuesSeen.length - 1; index >= 0; --index) {\n                if (!valuesSeen[index]) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => subject.subscribe(x => setValue(x, index + 1)));\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject._value + 1);\n    const subscription = () => {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = () => {\n        removeSubFromArray(subscribers, callback); // each will be called when update comes in\n        // removeSubFromArray(Subject.globalSubs, callback) // 🔬 testing\n        Subject.globalSubCount$.next(countSubject._value - 1);\n        // any double unsubscribes will be ignored\n        subscription.unsubscribe = () => subscription;\n        // unsubscribe from any combined subjects\n        const subscriptions = subscription.subscriptions;\n        for (let index = subscriptions.length - 1; index >= 0; --index) {\n            subscriptions[index].unsubscribe();\n        }\n        return subscription;\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    _value;\n    // this is overwritten by constructor at runtime. However having it helps editors know of its existence\n    set; // `subject.set = x` equal to `subject.next(x)`\n    constructor(value, \n    // private?\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        const subs = [...this.subscribers]; // subs may change as we call callbacks\n        const length = subs.length;\n        for (let index = 0; index < length; ++index) {\n            const sub = subs[index];\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, _subscription) => {\n            subscription.unsubscribe();\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this._value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n    Object.defineProperty(subject, 'set', {\n        // supports subject.set = x\n        set: (value) => subject.next(value),\n        // supports subject.set(x)\n        get: () => (x) => subject.next(x),\n    });\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        defineValueOn(this);\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUse } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUse.memory.stateConfig.support;\n}\n","const tagUse = [];\nexport function setUse(use) {\n    // must provide defaults\n    const useMe = {\n        beforeRender: use.beforeRender || (() => undefined),\n        beforeRedraw: use.beforeRedraw || (() => undefined),\n        afterRender: use.afterRender || (() => undefined),\n        beforeDestroy: use.beforeDestroy || (() => undefined),\n    };\n    setUse.tagUse.push(useMe);\n}\nsetUse.tagUse = tagUse;\nsetUse.memory = {};\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { StateMismatchError } from '../errors.js';\nimport { setUse } from './setUse.function.js';\nsetUse.memory.stateConfig = {\n    array: [], // state memory on the first render\n    // rearray: [] as State,\n};\nconst beforeRender = (support) => initState(support);\nsetUse({\n    beforeRender,\n    beforeRedraw: beforeRender,\n    afterRender: (support) => {\n        const state = support.state;\n        const config = setUse.memory.stateConfig;\n        const rearray = config.rearray;\n        if (rearray.length) {\n            if (rearray.length !== config.array.length) {\n                const message = `States lengths have changed ${rearray.length} !== ${config.array.length}. State tracking requires the same amount of function calls every render. Typically this errors is thrown when a state like function call occurs only for certain conditions or when a function is intended to be wrapped with a tag() call`;\n                const wrapper = support.templater?.wrapper;\n                const details = {\n                    oldStates: config.array,\n                    newStates: config.rearray,\n                    tagFunction: wrapper.parentWrap.original,\n                };\n                const error = new StateMismatchError(message, details);\n                console.warn(message, details);\n                throw error;\n            }\n        }\n        delete config.rearray; // clean up any previous runs\n        delete config.support;\n        state.length = 0;\n        state.push(...config.array);\n        for (let index = state.length - 1; index >= 0; --index) {\n            const item = state[index];\n            item.lastValue = getStateValue(item); // set last values\n        }\n        config.array = [];\n    }\n});\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value, checkValue] = getCallbackValue(callback);\n    if (checkValue !== StateEchoBack) {\n        const message = 'letState function incorrectly used. Second item in array is not setting expected value.\\n\\n' +\n            'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n            'For \"const\" state use `const name = state(default)()`\\n\\n' +\n            'Problem state:\\n' + (callback ? callback.toString() : JSON.stringify(state)) + '\\n';\n        console.error(message, { state, callback, value, checkValue });\n        throw new Error(message);\n    }\n    return value;\n}\nexport class StateEchoBack {\n}\nfunction initState(support) {\n    const state = support.state;\n    const config = setUse.memory.stateConfig;\n    config.rearray = [];\n    const stateLength = state?.length;\n    if (stateLength) {\n        for (let index = 0; index < stateLength; ++index) {\n            getStateValue(state[index]);\n        }\n        config.rearray.push(...state);\n    }\n    config.support = support;\n}\nexport function getCallbackValue(callback) {\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [value] = oldState;\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","export function syncStates(stateFrom, stateTo) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const state = stateFrom[index];\n        const fromValue = state.get();\n        const callback = stateTo[index].callback;\n        if (callback) {\n            callback(fromValue); // set the value\n        }\n        stateTo[index].lastValue = fromValue; // record the value\n    }\n}\n","import { setUse } from './setUse.function.js';\nimport { getStateValue } from './state.utils.js';\nimport { syncStates } from './syncStates.function.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    let getSetMethod;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return oldValue;\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    // the state is actually intended to be a function\n    if (initValue instanceof Function) {\n        const oldState = config.array;\n        const support = config.support;\n        const original = initValue;\n        initValue = ((...args) => {\n            const global = support.subject.global;\n            const newest = global.newest;\n            const newState = newest.state;\n            syncStates(newState, oldState);\n            const result = original(...args);\n            syncStates(oldState, newState);\n            return result;\n        });\n        initValue.original = original;\n    }\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUse } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered. Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before = () => true, final = defaultFinally, } = {}) => {\n    let previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (!before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (!before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = setUse.memory.stateConfig.array;\n                        syncStates(newestState, firstSupport.state);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUse } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(value, onSubscription) {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return state(() => {\n        const subject = new Subject(value, onSubscription).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n}\nsubject._value = (value) => {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return state(() => {\n        const subject = new ValueSubject(value).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        syncStates(nowSupport.state, oldestState);\n        return x;\n    });\n}\nsubject.all = all;\n","import { getStateValue } from './state.utils.js';\nimport { setUse } from './setUse.function.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function letState(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    const rearray = config.rearray;\n    let getSetMethod;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return makeStateResult(oldValue, push);\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return makeStateResult(initValue, push);\n}\nfunction makeStateResult(initValue, push) {\n    // return initValue\n    const result = (y) => {\n        push.callback = y || (x => [initValue, initValue = x]);\n        return initValue;\n    };\n    return result;\n}\n","import { letState } from './letState.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(prop) {\n    return getSetProp => {\n        let myProp = letState(prop)(getSetProp);\n        watch([prop], () => getSetProp(myProp = prop));\n        getSetProp(myProp); // always reset to my value and right await so that the old prop value never slips through\n        return myProp;\n    };\n}\n","export function deepClone(obj) {\n    return makeDeepClone(obj, new WeakMap());\n}\nfunction makeDeepClone(obj, visited) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj)) {\n        return visited.get(obj);\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Register the cloned object to avoid cyclic references\n    visited.set(obj, clone);\n    // Clone each property or element of the object or array\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], visited);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clone[key] = makeDeepClone(obj[key], visited);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2) {\n    return isDeepEqual(obj1, obj2, new WeakMap());\n}\nfunction isDeepEqual(obj1, obj2, visited) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj1)) {\n        return true;\n    }\n    if (typeof obj1 === 'object' && typeof obj2 === 'object') {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        visited.set(obj1, 0);\n        // Check if obj1 and obj2 are both arrays\n        if (Array.isArray(obj1) && Array.isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, visited);\n        }\n        else if (Array.isArray(obj1) || Array.isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        return isObjectDeepEqual(obj1, obj2, visited);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, visited) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, visited) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = fn0 instanceof Function && fn1 instanceof Function;\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { setUse } from './setUse.function.js';\nimport { state } from './state.function.js';\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(() => ({ stateDiff: 0, provider: undefined }));\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            for (let x = stateDiffMemory.stateDiff; x > 0; --x) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const memory = setUse.memory;\n            const stateConfig = memory.stateConfig;\n            const oldStateCount = stateConfig.array.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = 'prototype' in constructMethod ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.array.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                clone: deepClone(instance),\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            support.subject.global.providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        // const compareTo = cm.compareTo = cm.compareTo || cm.toString()\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        // find once, return same every time after\n        return state(() => {\n            const memory = setUse.memory;\n            const cm = constructor;\n            const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n            const support = memory.stateConfig.support;\n            const providers = [];\n            let owner = {\n                ownerSupport: support.ownerSupport\n            };\n            while (owner.ownerSupport) {\n                const ownerProviders = owner.ownerSupport.subject.global.providers;\n                const provider = ownerProviders.find(provider => {\n                    providers.push(provider);\n                    const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                    if (constructorMatch) {\n                        return true;\n                    }\n                });\n                if (provider) {\n                    provider.clone = deepClone(provider.instance); // keep a copy of the latest before any change occur\n                    const support = memory.stateConfig.support;\n                    support.subject.global.providers.push(provider);\n                    provider.children.push(support);\n                    return provider.instance;\n                }\n                owner = owner.ownerSupport; // cause reloop checking next parent\n            }\n            const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n            console.warn(`${msg}. Available providers`, providers);\n            throw new Error(msg);\n        });\n    }\n};\n","export function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag;\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings || support1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    // strings1[index] === string // slower\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.values || tag0.values;\n    const values1 = support1.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = value instanceof Function && compareTo instanceof Function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true; // deepEqual(value, compareTo)\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { setUse } from '../state/index.js';\nimport { Subject } from '../subject/index.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nsetUse.memory.tagClosed$ = new Subject(undefined, subscription => {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n// Life cycle 1\nexport function runBeforeRender(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeRender(support, ownerSupport);\n    }\n}\n// Life cycle 2\nexport function runAfterRender(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].afterRender(support, ownerSupport);\n    }\n    setUse.memory.tagClosed$.next(ownerSupport);\n}\n// Life cycle 3\nexport function runBeforeRedraw(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeRedraw(support, ownerSupport);\n    }\n}\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeDestroy(support, ownerSupport);\n    }\n    support.subject.global.deleted = true;\n    support.hasLiveElements = false;\n    // remove me from my parents\n    if (ownerSupport) {\n        ownerSupport.subject.global.childTags = ownerSupport.subject.global.childTags.filter(child => child !== support.subject.global.oldest);\n        const global = support.subject.global;\n        global.providers.forEach(provider => provider.children.forEach((child, index) => {\n            if (child.subject.global === global) {\n                provider.children.splice(index, 1);\n            }\n        }));\n    }\n}\n","import { runBeforeRedraw, runBeforeRender } from '../tagRunner.js';\nimport { runAfterRender } from '../tagRunner.js';\nexport function renderTagOnly(newSupport, prevSupport, subject, ownerSupport) {\n    const oldRenderCount = subject.global.renderCount;\n    beforeWithRender(newSupport, ownerSupport, prevSupport);\n    const templater = newSupport.templater;\n    // NEW TAG CREATED HERE\n    const wrapper = templater.wrapper;\n    let reSupport = wrapper(newSupport, subject);\n    /* AFTER */\n    runAfterRender(newSupport, ownerSupport);\n    subject.global.newest = reSupport;\n    if (!prevSupport && ownerSupport) {\n        ownerSupport.subject.global.childTags.push(reSupport);\n    }\n    // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n    if (subject.global.renderCount > oldRenderCount + 1) {\n        return subject.global.newest;\n    }\n    return reSupport;\n}\nfunction beforeWithRender(support, // new\nparentSupport, prevSupport) {\n    const lastOwnerSupport = prevSupport?.ownerSupport;\n    const runtimeOwnerSupport = lastOwnerSupport || parentSupport;\n    if (prevSupport) {\n        if (prevSupport !== support) {\n            const lastState = prevSupport.state;\n            support.subject.global = prevSupport.subject.global;\n            support.state.length = 0;\n            support.state.push(...lastState);\n        }\n        return runBeforeRedraw(support, prevSupport);\n    }\n    // first time render\n    return runBeforeRender(support, runtimeOwnerSupport);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nexport const variablePrefix = '__tagvar';\nexport const escapeVariable = '--' + variablePrefix + '--';\nexport const escapeSearch = new RegExp(escapeVariable, 'g');\nexport class Tag {\n    strings;\n    values;\n    tagJsType = ValueTypes.tag;\n    // present only when an array. Populated by Tag.key()\n    memory = {};\n    templater;\n    constructor(strings, values) {\n        this.strings = strings;\n        this.values = values;\n    }\n    /** Used for array, such as array.map(), calls aka array.map(x => html``.key(x)) */\n    key(arrayValue) {\n        this.memory.arrayValue = arrayValue;\n        return this;\n    }\n    children;\n    html(strings, ...values) {\n        this.children = { strings, values };\n        return this;\n    }\n}\n","export function destroyTagMemory(oldSupport) {\n    // must destroy oldest which is tag with elements on stage\n    const oldest = oldSupport.subject.global.oldest;\n    oldest.destroy();\n    oldSupport.subject.global.context = {};\n}\n","import { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { destroyTagMemory } from './destroyTag.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function checkDestroyPrevious(subject, // existing.value is the old value\nnewValue, insertBefore, valueType) {\n    const displaySubject = subject;\n    const hasLastValue = 'lastValue' in displaySubject;\n    const lastValue = displaySubject.lastValue; // TODO: we maybe able to use displaySubject.value and remove concept of lastValue\n    // was simple value but now something bigger\n    if (hasLastValue && lastValue !== newValue) {\n        // below is faster than using getValueType\n        const newType = typeof (newValue);\n        if (isSimpleType(newType) && typeof (lastValue) === newType) {\n            return false;\n        }\n        if (newValue instanceof Function && lastValue instanceof Function) {\n            return false;\n        }\n        destroySimpleValue(displaySubject);\n        return 'changed-simple-value';\n    }\n    const arraySubject = subject;\n    const wasArray = arraySubject.lastArray;\n    // no longer an array\n    if (wasArray && valueType !== ValueTypes.tagArray) {\n        delete arraySubject.lastArray;\n        for (let index = wasArray.array.length - 1; index >= 0; --index) {\n            const { support } = wasArray.array[index];\n            destroyArrayTag(support, { added: 0, removed: 0 });\n        }\n        return 'array';\n    }\n    const tagSubject = subject;\n    const lastSupport = tagSubject.support;\n    // no longer tag or component?\n    if (lastSupport) {\n        const isValueTag = isStaticTag(newValue);\n        const isSubjectTag = isStaticTag(subject._value);\n        const newTag = newValue;\n        if (isSubjectTag && isValueTag) {\n            // its a different tag now\n            if (!isLikeTags(newTag, lastSupport)) {\n                // put template back down\n                destroyTagMemory(lastSupport);\n                return 2;\n            }\n            return false;\n        }\n        if (valueType === ValueTypes.tagComponent) {\n            return false; // its still a tag component\n        }\n        if (newValue && newValue.oneRender) {\n            return false;\n        }\n        // destroy old component, value is not a component\n        destroyTagMemory(lastSupport);\n        // delete lastSupport.global.deleted // ???\n        return 'different-tag';\n    }\n    return false;\n}\nexport function isSimpleType(value) {\n    return ['string', 'number', 'boolean'].includes(value);\n}\nexport function destroyArrayTag(support, counts) {\n    support.destroy({\n        stagger: counts.removed++,\n    });\n}\nfunction destroySimpleValue(subject) {\n    delete subject.lastValue;\n}\n","import { isSimpleType } from './checkDestroyPrevious.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isSubjectInstance, isTagArray } from '../isInstance.js';\nexport function getValueType(value) {\n    if (value === undefined || value === null) {\n        return ValueTypes.undefined;\n    }\n    const type = typeof (value);\n    if (value instanceof Function) {\n        return ValueTypes.function;\n    }\n    if (type === 'object') {\n        if (value instanceof Date) {\n            return ValueTypes.date;\n        }\n        if (isSimpleType(type)) {\n            return type;\n        }\n        const tagJsType = value.tagJsType;\n        if (tagJsType) {\n            const included = [\n                ValueTypes.tagComponent,\n                ValueTypes.templater,\n                ValueTypes.tag,\n            ].includes(tagJsType);\n            if (included) {\n                return tagJsType;\n            }\n        }\n        if (isTagArray(value)) {\n            return ValueTypes.tagArray;\n        }\n        if (isSubjectInstance(value)) {\n            return ValueTypes.subject;\n        }\n    }\n    return ValueTypes.unknown;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getValueType } from './getValueType.function.js';\nexport function cloneValueArray(values) {\n    return values.map((value) => {\n        const tag = value;\n        switch (getValueType(value)) {\n            case ValueTypes.tagComponent:\n                const tagComponent = value;\n                return deepClone(tagComponent.props);\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n            case ValueTypes.tagArray:\n                return cloneValueArray(tag);\n        }\n        return deepClone(value);\n    });\n}\n","export function getChildTagsToDestroy(childTags, allTags = []) {\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const cTag = childTags[index];\n        allTags.push(cTag);\n        childTags.splice(index, 1);\n        getChildTagsToDestroy(cTag.subject.global.childTags, allTags);\n    }\n    return allTags;\n}\n","import { Tag } from './Tag.class.js';\nimport { ValueSubject } from '../subject/index.js';\nimport { kidsToTagArraySubject } from './kidsToTagArraySubject.function.js';\nexport class TemplaterResult {\n    props;\n    tagJsType = 'templater';\n    tagged;\n    wrapper;\n    madeChildIntoSubject;\n    tag;\n    children = new ValueSubject([]);\n    arrayValue; // used for tag components used in arrays\n    constructor(props) {\n        this.props = props;\n    }\n    key(arrayValue) {\n        this.arrayValue = arrayValue;\n        return this;\n    }\n    html(strings, ...values) {\n        const children = new Tag(strings, values);\n        const childSubject = kidsToTagArraySubject(children, this);\n        this.children = childSubject;\n        return this;\n    }\n}\n","import { isSubjectInstance, isTagArray } from '../isInstance.js';\nimport { ValueSubject } from '../subject/ValueSubject.js';\nexport function kidsToTagArraySubject(children, templaterResult) {\n    if (isSubjectInstance(children)) {\n        return children;\n    }\n    const kidArray = children;\n    if (isTagArray(kidArray)) {\n        templaterResult.madeChildIntoSubject = true; // was converted into a subject\n        return new ValueSubject(children);\n    }\n    const kid = children;\n    if (kid) {\n        templaterResult.madeChildIntoSubject = true; // was converted into a subject\n        kid.memory.arrayValue = 0;\n        return new ValueSubject([kid]);\n    }\n    templaterResult.madeChildIntoSubject = true; // was converted into a subject\n    return new ValueSubject([]);\n}\n","import { Subject } from '../../subject/Subject.class.js';\nimport { ValueSubject } from '../../subject/ValueSubject.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nexport class TagJsSubject extends ValueSubject {\n    tagJsType = ValueTypes.tagJsSubject;\n    // travels with all rerenderings\n    global = getNewGlobal();\n    lastRun;\n}\nexport function getNewGlobal() {\n    return {\n        destroy$: new Subject(),\n        context: {}, // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n        providers: [],\n        /** Indicator of re-rending. Saves from double rending something already rendered */\n        renderCount: 0,\n        subscriptions: [],\n        oldest: undefined, // TODO: This needs to addressed\n        blocked: [], // renders that did not occur because an event was processing\n        childTags: [], // tags on me\n        clones: [], // elements on document. Needed at destroy process to know what to destroy\n    };\n}\n","import { TemplaterResult } from '../TemplaterResult.class.js';\nimport { Support } from '../Support.class.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getValueType } from '../getValueType.function.js';\nimport { TagJsSubject, getNewGlobal } from './TagJsSubject.class.js';\nexport function processNewValue(value, ownerSupport) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.tagComponent:\n            return new TagJsSubject(value); // ownerSupport.global.value\n        case ValueTypes.templater:\n            const templater = value;\n            const tag = templater.tag;\n            return processNewTag(tag, ownerSupport);\n        case ValueTypes.tag:\n            return processNewTag(value, ownerSupport);\n        case ValueTypes.subject:\n            value.global = getNewGlobal();\n            return value;\n    }\n    return new TagJsSubject(value);\n}\nfunction processNewTag(value, ownerSupport) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = new TemplaterResult([]);\n        templater.tag = tag;\n        tag.templater = templater;\n    }\n    const subject = new TagJsSubject(templater);\n    subject.support = new Support(templater, ownerSupport, subject);\n    subject.global.oldest = subject.support;\n    ownerSupport.subject.global.childTags.push(subject.support);\n    return subject;\n}\n","export function specialAttribute(name, value, element) {\n    const names = name.split('.');\n    // style.position = \"absolute\"\n    if (names[0] === 'style') {\n        element.style[names[1]] = value;\n    }\n    // Example: class.width-full = \"true\"\n    if (names[0] === 'class') {\n        names.shift();\n        if (value) {\n            for (let index = 0; index < names.length; ++index) {\n                element.classList.add(names[index]);\n            }\n        }\n        else {\n            for (let index = 0; index < names.length; ++index) {\n                element.classList.remove(names[index]);\n            }\n        }\n    }\n}\n","import { deepEqual } from '../deepFunctions.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps) {\n    /*\n    const isCommonEqual = props === undefined && props === compareToProps\n    if(isCommonEqual) {\n      return false\n    }\n    */\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    // check all prop functions match\n    if (typeof (props) === 'object') {\n        if (!pastCloneProps) {\n            return 3;\n        }\n        castedProps = [...props];\n        castedPastProps = [...(pastCloneProps || [])];\n        const allFunctionsMatch = castedProps.every((value, index) => {\n            let compare = castedPastProps[index];\n            if (value && typeof (value) === 'object') {\n                const subCastedProps = { ...value };\n                const subCompareProps = { ...compare || {} };\n                const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n                    delete subCastedProps[key]; // its a function and not needed to be compared\n                    delete subCompareProps[key]; // its a function and not needed to be compared\n                }));\n                return matched;\n            }\n            return compareProps(value, compare, () => {\n                castedProps.splice(index, 1);\n                castedPastProps.splice(index, 1);\n            });\n        });\n        if (!allFunctionsMatch) {\n            return 6; // a change has been detected by function comparisons\n        }\n    }\n    // const isEqual = deepEqual(castedPastProps, castedProps)\n    // return isEqual ? false : 7 // if equal then no changes\n    return false;\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(value instanceof Function)) {\n        return deepEqual(value, compare) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(compareFn instanceof Function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 3; // both are function the same\n    }\n    onDelete();\n    return 5;\n}\n","/** checks if previous support exists on subject or as a last global support. If first render, calls builder. Otherwise calls support.updateBy() */\nexport function processTagResult(support, subject, // used for recording past and current value\ninsertBefore, // <template end interpolate />\n{ counts, }) {\n    // *if appears we already have seen\n    const subjectTag = subject;\n    const lastSupport = subjectTag.support;\n    const prevSupport = lastSupport?.subject.global.oldest || undefined;\n    const justUpdate = prevSupport;\n    if (prevSupport && justUpdate) {\n        return processTagResultUpdate(support, subjectTag, prevSupport);\n    }\n    const fragment = support.buildBeforeElement({ counts });\n    const placeholder = subject.global.placeholder;\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(fragment, placeholder);\n    return support;\n}\nfunction processTagResultUpdate(support, subject, // used for recording past and current value\nprevSupport) {\n    // components\n    if (subject instanceof Function) {\n        const newSupport = subject(prevSupport);\n        prevSupport.updateBy(newSupport);\n        subject.support = newSupport;\n        return newSupport;\n    }\n    prevSupport.updateBy(support);\n    subject.support = support;\n    return support;\n}\n","import { Support } from '../Support.class.js';\nimport { ValueSubject } from '../../subject/index.js';\n/** When first time render, adds to owner childTags */\nexport function processTag(templater, ownerSupport, // owner\nsubject) {\n    let support = subject.support;\n    // first time seeing this tag?\n    if (!support) {\n        support = newSupportByTemplater(templater, ownerSupport, subject);\n    }\n    subject.support = support;\n    support.ownerSupport = ownerSupport;\n    const fragment = support.buildBeforeElement({ counts: { added: 0, removed: 0 } });\n    const placeholder = subject.global.placeholder;\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(fragment, placeholder);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        children: new ValueSubject([]), // no children\n        // props: {} as Props,\n        props: [],\n        isTag: true,\n        tagJsType: 'templater',\n        tagged: false,\n        html: () => fake,\n        key: () => fake,\n    };\n    return fake;\n}\n/** Create Support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = new Support(templater, ownerSupport, subject);\n    setupNewSupport(support, ownerSupport, subject);\n    ownerSupport.subject.global.childTags.push(support);\n    return support;\n}\nexport function setupNewSupport(support, ownerSupport, subject) {\n    support.subject = subject;\n    subject.global.oldest = support;\n    subject.global.newest = support;\n    // asking me to render will cause my parent to render\n    support.ownerSupport = ownerSupport;\n}\n","import { processTagResult } from './processTagResult.function.js';\nimport { Support } from '../Support.class.js';\nimport { renderSubjectComponent } from '../render/renderSubjectComponent.function.js';\nimport { setupNewSupport } from './processTag.function.js';\n/** create new support, connects globals to old support if one, and  */\nexport function processSubjectComponent(templater, subject, insertBefore, ownerSupport, options) {\n    // Check if function component is wrapped in a tag() call\n    // TODO: This below check not needed in production mode\n    if (templater.tagged !== true) {\n        const wrapper = templater.wrapper;\n        const original = wrapper.parentWrap.original;\n        let name = original.name || original.constructor?.name;\n        if (name === 'Function') {\n            name = undefined;\n        }\n        const label = name || original.toString().substring(0, 120);\n        const error = new Error(`Not a tag component. Wrap your function with tag(). Example tag(props => html\\`\\`) on component:\\n\\n${label}\\n\\n`);\n        throw error;\n    }\n    const support = new Support(templater, ownerSupport, subject);\n    let reSupport = subject.support;\n    setupNewSupport(support, ownerSupport, subject);\n    const global = support.subject.global = reSupport?.subject.global || support.subject.global;\n    global.oldest = support;\n    global.insertBefore = insertBefore;\n    const isRender = !reSupport;\n    if (isRender) {\n        const mySupport = reSupport || support;\n        reSupport = renderSubjectComponent(subject, mySupport, ownerSupport);\n    }\n    const newSupport = processTagResult(reSupport, subject, // The element set here will be removed from document. Also result.tag will be added in here\n    insertBefore, // <template end interpolate /> (will be removed)\n    options);\n    // subject.support = newSupport\n    ownerSupport.subject.global.childTags.push(newSupport);\n    return reSupport;\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nexport function renderSubjectComponent(subject, reSupport, ownerSupport) {\n    const ownGlobal = ownerSupport.subject.global;\n    const preClones = ownGlobal.clones.map(clone => clone);\n    reSupport = renderWithSupport(reSupport, subject.support, // existing tag\n    subject, ownerSupport);\n    const reGlobal = reSupport.subject.global;\n    if (ownGlobal.clones.length > preClones.length) {\n        const myClones = ownGlobal.clones.filter(fClone => !preClones.find(clone => clone === fClone));\n        reGlobal.clones.push(...myClones);\n    }\n    return reSupport;\n}\n","import { deepClone, deepEqual } from './deepFunctions.js';\nimport { isStaticTag } from './isInstance.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { setUse } from './state/index.js';\nimport { getSupportInCycle } from './tag/getSupportInCycle.function.js';\nexport function castProps(props, newSupport, stateArray) {\n    return props.map(prop => alterProp(prop, newSupport.ownerSupport, stateArray, newSupport));\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProp(prop, ownerSupport, stateArray, newSupport) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, stateArray, newSupport);\n}\nexport function checkProp(value, ownerSupport, stateArray, newSupport, index, newProp, seen = []) {\n    if (value instanceof Function) {\n        return getPropWrap(value, ownerSupport, stateArray, newSupport, index, newProp);\n    }\n    if (seen.includes(value)) {\n        return value;\n    }\n    seen.push(value);\n    if (typeof (value) !== 'object' || !value) {\n        return value; // no children to crawl through\n    }\n    if (value instanceof Array) {\n        for (let index = value.length - 1; index >= 0; --index) {\n            const subValue = value[index];\n            value[index] = checkProp(subValue, ownerSupport, stateArray, newSupport, index, value, seen);\n            if (subValue instanceof Function) {\n                if (subValue.toCall) {\n                    continue;\n                }\n                afterCheckProp(index, subValue, value, newSupport);\n            }\n        }\n        return value;\n    }\n    for (const name in value) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, stateArray, newSupport, name, value, seen);\n        const hasSetter = Object.getOwnPropertyDescriptor(value, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (result instanceof Function) {\n            if (subValue.toCall) {\n                continue;\n            }\n            afterCheckProp(name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(index, pastValue, newProp, newSupport) {\n    if (pastValue?.toCall) {\n        return; // already been done\n    }\n    // restore object to have original function on destroy\n    newSupport.subject.global.destroy$.toCallback(() => newProp[index] = pastValue);\n}\nexport function getPropWrap(value, ownerSupport, stateArray, newSupport, name, newProp) {\n    const toCall = value.toCall;\n    // already previously converted by a parent?\n    if (toCall) {\n        return value;\n    }\n    const wrap = (...args) => wrap.toCall(...args); // what gets called can switch over parent state changes\n    // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n    wrap.toCall = (...args) => {\n        return callbackPropOwner(wrap.prop, args, ownerSupport);\n    };\n    wrap.original = value;\n    wrap.prop = value;\n    wrap.stateArray = stateArray;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    const newest = ownerSupport.subject.global.newest;\n    const noCycle = getSupportInCycle() === undefined;\n    const result = toCall(...callWith);\n    const run = () => {\n        // are we in a rendering cycle? then its being called by alterProps\n        if (noCycle === false) {\n            // appears a prop function was called sync/immediately so lets see if owner changed state\n            const allMatched = newest.state.every(state => {\n                const lastValue = state.lastValue;\n                const get = state.get();\n                const equal = deepEqual(deepClone(lastValue), get);\n                return equal;\n            });\n            if (allMatched) {\n                return result; // owner did not change\n            }\n        }\n        renderSupport(newest, true);\n        return result;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUse.memory.tagClosed$.toCallback(run);\n    return result;\n}\n","import { hasSupportChanged } from '../hasSupportChanged.function.js';\nimport { processSubjectComponent } from './processSubjectComponent.function.js';\nimport { destroyTagMemory } from '../destroyTag.function.js';\nimport { renderSupport } from '../render/renderSupport.function.js';\nimport { castProps } from '../../alterProp.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { softDestroySupport } from '../render/softDestroySupport.function.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject, insertBefore, renderUp = false) {\n    let lastSupport = subject.global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.parentWrap.original;\n        const newFunction = newWrapper.parentWrap.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        const oldestSupport = subject.global.oldest;\n        destroyTagMemory(oldestSupport);\n        const newSupport = processSubjectComponent(templater, subject, insertBefore, ownerSupport, {\n            counts: { added: 0, removed: 0 },\n        });\n        return newSupport;\n    }\n    else {\n        const hasChanged = hasSupportChanged(lastSupport, support, templater);\n        // everyhing has matched, no display needs updating.\n        if (!hasChanged) {\n            const newProps = templater.props;\n            // update function refs to use latest references\n            const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps);\n            // When new support actually makes call to real function, use these pre casted props\n            support.propsConfig.castProps = castedProps;\n            // update support to think it has different cloned props\n            lastSupport.propsConfig.latestCloned = support.propsConfig.latestCloned;\n            lastSupport.propsConfig.lastClonedKidValues = support.propsConfig.lastClonedKidValues;\n            return lastSupport; // its the same tag component\n        }\n    }\n    const oldest = subject.global.oldest;\n    if (subject.global.locked) {\n        subject.global.blocked.push(support);\n        return support;\n    }\n    const previous = subject.global.newest;\n    const newSupport = renderSupport(support, renderUp);\n    return afterTagRender(subject, oldest, templater, previous, newSupport, isSameTag);\n}\nfunction afterTagRender(subject, oldest, templater, previous, newSupport, isSameTag) {\n    let lastSupport = subject.support;\n    // const oldest = newSupport.global.oldest\n    /*\n    const hasOldest = oldest ? true : false\n    if(!hasOldest) {\n      return buildNewTag(\n        newSupport,\n        insertBefore,\n        lastSupport,\n        subject\n      )\n    }\n    */\n    if (oldest && templater.children._value.length) {\n        const oldKidsSub = oldest.templater.children;\n        oldKidsSub.next(templater.children._value);\n    }\n    // detect if both the function is the same and the return is the same\n    const isLikeTag = isSameTag && isLikeTags(previous, newSupport);\n    if (isLikeTag) {\n        const oldestTag = subject.global.oldest;\n        subject.support = newSupport;\n        oldestTag.updateBy(newSupport);\n        return newSupport;\n    }\n    // Although function looked the same it returned a different html result\n    if (isSameTag && lastSupport) {\n        const preGlobal = previous.subject.global;\n        if (!preGlobal.deleted) {\n            // destroyTagMemory(previous)\n            softDestroySupport(previous);\n        }\n        subject.global.context = {}; // do not share previous outputs\n    }\n    return buildNewTag(newSupport, subject);\n}\nfunction buildNewTag(newSupport, subject) {\n    const fragment = newSupport.buildBeforeElement({\n        counts: { added: 0, removed: 0 },\n    });\n    // ??? new\n    const placeholder = subject.global.placeholder;\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(fragment, placeholder);\n    subject.global.oldest = newSupport;\n    subject.global.newest = newSupport;\n    subject.global.oldest = newSupport;\n    subject.global.newest = newSupport;\n    subject.support = newSupport;\n    newSupport.ownerSupport.subject.global.childTags.push(newSupport);\n    return newSupport;\n}\nfunction syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray) {\n    const newest = lastSupport.subject.global.newest;\n    if (!newest) {\n        const state = ownerSupport.state;\n        newPropsArray.length = 0;\n        const castedProps = castProps(newPropsArray, newSupport, state);\n        newPropsArray.push(...castedProps);\n        newSupport.propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = newPropsArray.length - 1; index >= 0; --index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport);\n        newArray.push(newValue);\n    }\n    newSupport.propsConfig.castProps = newArray;\n    return newArray;\n}\nfunction syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, seen = []) {\n    if (priorProp instanceof Function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.toCall) {\n            priorProp.toCall = prop.toCall;\n            return prop;\n        }\n        const ownerGlobal = ownerSupport.subject.global;\n        const oldOwnerState = ownerGlobal.newest.state;\n        priorProp.prop = prop;\n        priorProp.stateArray = oldOwnerState;\n        return priorProp;\n    }\n    // prevent infinite recursion\n    if (seen.includes(prop)) {\n        return prop;\n    }\n    seen.push(prop);\n    if (typeof (prop) !== 'object' || !prop) {\n        return prop; // no children to crawl through\n    }\n    if (prop instanceof Array) {\n        for (let index = prop.length - 1; index >= 0; --index) {\n            const x = prop[index];\n            prop[index] = syncPriorPropFunction(priorProp[index], x, newSupport, ownerSupport, seen);\n        }\n        return prop;\n    }\n    if (priorProp === undefined) {\n        return prop;\n    }\n    for (const name in prop) {\n        const subValue = prop[name];\n        const result = syncPriorPropFunction(priorProp[name], subValue, newSupport, ownerSupport, seen);\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    global.providers.forEach(provider => {\n        provider.children.forEach((child, index) => {\n            const wasSameGlobals = global.destroy$ === child.subject.global.destroy$;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        });\n    });\n}\n","import { hasPropChanges } from './hasPropChanges.function.js';\nexport function hasSupportChanged(lastSupport, newSupport, newTemplater) {\n    const latestProps = newTemplater.props; // newSupport.propsConfig.latest\n    const pastCloneProps = lastSupport.propsConfig.latestCloned;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps);\n    // if no changes detected, no need to continue to rendering further tags\n    if (propsChanged) {\n        return propsChanged;\n    }\n    const propsChanged2 = hasPropChanges(lastSupport.propsConfig.latestCloned, newSupport.propsConfig.latestCloned);\n    if (propsChanged2) {\n        return propsChanged2;\n    }\n    const kidsChanged = hasKidsChanged(lastSupport, newSupport);\n    // we already know props didn't change and if kids didn't either, than don't render\n    return kidsChanged;\n}\nexport function hasKidsChanged(oldSupport, newSupport) {\n    const oldCloneKidValues = oldSupport.propsConfig.lastClonedKidValues;\n    const newClonedKidValues = newSupport.propsConfig.lastClonedKidValues;\n    const everySame = oldCloneKidValues.every((set, index) => {\n        const x = newClonedKidValues[index];\n        return set.every((item, index) => item === x[index]);\n    });\n    return everySame ? false : 9;\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { setUse } from '../state/setUse.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { updateExistingTagComponent } from '../tag/update/updateExistingTagComponent.function.js';\nconst useLocks = true;\nexport function bindSubjectCallback(value, support) {\n    // Is this children? No override needed\n    if (value.isChildOverride) {\n        return value;\n    }\n    const state = setUse.memory.stateConfig;\n    const subjectFunction = (element, args) => runTagCallback(value, support, element, args);\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, bindTo, args) {\n    const tag = findTagToCallback(support);\n    const method = value.bind(bindTo);\n    tag.subject.global.locked = useLocks; // prevent another render from re-rendering this tag\n    const callbackResult = method(...args);\n    return afterTagCallback(tag, callbackResult);\n}\nfunction afterTagCallback(tag, callbackResult) {\n    delete tag.subject.global.locked;\n    if (tag.subject.global.blocked.length) {\n        let lastResult;\n        tag.subject.global.blocked.forEach(blocked => {\n            const block = blocked;\n            lastResult = updateExistingTagComponent(block.ownerSupport, block, block.subject, block.subject.global.insertBefore, true);\n            tag.subject.global.newest = lastResult;\n            tag.subject.global.blocked.splice(0, 1);\n        });\n        tag.subject.global.blocked.length = 0;\n        // return lastResult\n        return checkAfterCallbackPromise(callbackResult, lastResult, lastResult.subject.global);\n    }\n    const result = renderCallbackSupport(tag.subject.global.newest, callbackResult, tag.subject.global);\n    return result;\n}\nfunction findTagToCallback(support) {\n    // If we are NOT a component than we need to render my owner instead\n    if (support.templater.tagJsType === ValueTypes.templater) {\n        const owner = support.ownerSupport;\n        return findTagToCallback(owner);\n    }\n    return support;\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    if (global.deleted) {\n        return 'no-data-ever'; // || last.global.deleted\n    }\n    renderSupport(last, true);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nfunction checkAfterCallbackPromise(callbackResult, last, global) {\n    if (callbackResult instanceof Promise) {\n        last.subject.global.locked = useLocks;\n        return callbackResult.then(() => {\n            delete last.subject.global.locked;\n            if (global.deleted) {\n                return 'promise-no-data-ever'; // tag was deleted during event processing\n            }\n            delete last.subject.global.locked;\n            renderSupport(global.newest, true);\n            return 'promise-no-data-ever';\n        });\n    }\n    return 'no-data-ever';\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { isSubjectInstance } from '../isInstance.js';\nimport { bindSubjectCallback } from './bindSubjectCallback.function.js';\nconst startRegX = /^\\s*{__tagvar/;\nconst endRegX = /}\\s*$/;\nfunction isTagVar(value) {\n    return value && value.search(startRegX) >= 0 && value.search(endRegX) >= 0;\n}\nexport function processAttribute(attrName, value, // current attribute value by using .getAttribute\nchild, scope, ownerSupport, howToSet) {\n    if (isTagVar(value)) {\n        return processScopedNameValueAttr(attrName, value, child, scope, ownerSupport, howToSet);\n    }\n    if (isTagVar(attrName)) {\n        const contextValueSubject = getContextValueByVarString(scope, attrName);\n        let lastValue;\n        // the above callback gets called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe((value) => {\n            if (value === lastValue) {\n                return; // value did not change\n            }\n            processNameOnlyAttr(value, lastValue, child, ownerSupport, howToSet);\n            lastValue = value;\n        });\n        ownerSupport.subject.global.subscriptions.push(sub); // this is where unsubscribe is picked up\n        child.removeAttribute(attrName);\n        return;\n    }\n    // Non dynamic\n    const isSpecial = isSpecialAttr(attrName);\n    if (isSpecial) {\n        return specialAttribute(attrName, value, child);\n    }\n}\nfunction processScopedNameValueAttr(attrName, value, // {__tagVarN}\nchild, scope, ownerSupport, howToSet) {\n    // get the code inside the brackets like \"variable0\" or \"{variable0}\"\n    const result = getContextValueByVarString(scope, value);\n    return processNameValueAttr(attrName, result, child, ownerSupport, howToSet);\n}\nfunction getContextValueByVarString(scope, value) {\n    const code = value.replace('{', '').split('').reverse().join('').replace('}', '').split('').reverse().join('');\n    return scope[code];\n}\nfunction processNameOnlyAttr(attrValue, lastValue, child, ownerSupport, howToSet) {\n    if (lastValue && lastValue != attrValue) {\n        if (typeof (lastValue) === 'string') {\n            child.removeAttribute(lastValue);\n        }\n        else if (lastValue instanceof Object) {\n            for (const name in lastValue) {\n                child.removeAttribute(name);\n            }\n        }\n    }\n    if (typeof (attrValue) === 'string') {\n        if (!attrValue.length) {\n            return;\n        }\n        processNameValueAttr(attrValue, '', child, ownerSupport, howToSet);\n        return;\n    }\n    if (attrValue instanceof Object) {\n        for (const name in attrValue) {\n            processNameValueAttr(name, attrValue[name], child, ownerSupport, howToSet);\n        }\n    }\n}\nfunction processNameValueAttr(attrName, result, child, ownerSupport, howToSet) {\n    const isSpecial = isSpecialAttr(attrName);\n    if (result instanceof Function) {\n        const action = function (...args) {\n            const result2 = result(child, args);\n            return result2;\n        };\n        child[attrName].action = action;\n    }\n    // Most every variable comes in here since everything is made a ValueSubject\n    if (isSubjectInstance(result)) {\n        child.removeAttribute(attrName);\n        let lastValue;\n        const callback = (newAttrValue) => {\n            // should the function be wrapped so every time its called we re-render?\n            if (newAttrValue instanceof Function) {\n                return callbackFun(ownerSupport, newAttrValue, child, attrName, isSpecial, howToSet);\n            }\n            // TODO: we maybe able to block higher before instance of check\n            if (lastValue === newAttrValue) {\n                return lastValue;\n            }\n            lastValue = newAttrValue;\n            return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = result.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        ownerSupport.subject.global.subscriptions.push(sub);\n        return;\n    }\n    howToSet(child, attrName, result);\n    // child.setAttribute(attrName, result.value)\n    return;\n}\nfunction processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet) {\n    if (newAttrValue instanceof Function) {\n        const fun = function (...args) {\n            return newAttrValue(child, args);\n        };\n        // access to original function\n        fun.tagFunction = newAttrValue;\n        if (attrName === 'ondoubleclick') {\n            attrName = 'ondblclick';\n        }\n        ;\n        child[attrName] = fun;\n        return;\n    }\n    if (isSpecial) {\n        specialAttribute(attrName, newAttrValue, child);\n        return;\n    }\n    if (newAttrValue) {\n        howToSet(child, attrName, newAttrValue);\n        return;\n    }\n    const isDeadValue = [undefined, false, null].includes(newAttrValue);\n    if (isDeadValue) {\n        child.removeAttribute(attrName);\n        return;\n    }\n    // value is 0\n    howToSet(child, attrName, newAttrValue);\n}\n/** Looking for (class | style) followed by a period */\nfunction isSpecialAttr(attrName) {\n    return attrName.search(/^(class|style)(\\.)/) >= 0;\n}\nfunction callbackFun(ownerSupport, newAttrValue, child, attrName, isSpecial, howToSet) {\n    const wrapper = ownerSupport.templater.wrapper;\n    const parentWrap = wrapper?.parentWrap;\n    const oneRender = parentWrap?.oneRender;\n    if (!oneRender) {\n        newAttrValue = bindSubjectCallback(newAttrValue, ownerSupport);\n    }\n    return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n}\n","import { processAttribute } from './processAttribute.function.js';\nfunction howToSetAttribute(element, name, value) {\n    element.setAttribute(name, value);\n}\nfunction howToSetInputValue(element, name, value) {\n    element[name] = value;\n}\nexport function interpolateAttributes(child, scope, ownerSupport) {\n    const attrNames = child.getAttributeNames();\n    let howToSet = howToSetAttribute;\n    for (let index = 0; index < attrNames.length; ++index) {\n        const attrName = attrNames[index];\n        if (child.nodeName === 'INPUT' && attrName === 'value') {\n            howToSet = howToSetInputValue;\n        }\n        const value = child.getAttribute(attrName);\n        processAttribute(attrName, value, child, scope, ownerSupport, howToSet);\n        howToSet = howToSetAttribute; // put back\n    }\n}\n","// support arrow functions in attributes\nexport const interpolateReplace = /(?:<[^>]*?(?:(?:\\s+\\w+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)))*\\s*)\\/?>)|({__tagvar[^}]+})/g;\n/** replaces ${x} with <template id=\"x-start\"></template><template id=\"x-end\"></template> */\nexport function interpolateToTemplates(template) {\n    const keys = [];\n    const string = template.replace(interpolateReplace, (match, expression) => {\n        if (match.startsWith('<')) {\n            // If the match is an HTML tag, don't replace\n            return match;\n        }\n        const noBraces = expression.substring(1, expression.length - 1);\n        const id = noBraces;\n        keys.push(id);\n        return `<template interpolate end id=\"${id}\"></template>`;\n    });\n    return { string, keys };\n}\n","import { processAttribute } from './processAttribute.function.js';\nconst search = new RegExp('\\\\s*<template interpolate end id=\"__tagvar(\\\\d{1,4})\"([^>]*)></template>(\\\\s*)');\nexport function scanTextAreaValue(textarea, context, ownerSupport) {\n    const value = textarea.value;\n    if (value.search(search) >= 0) {\n        const match = value.match(/__tagvar(\\d{1,4})/);\n        const token = match ? match[0] : '';\n        const dynamic = '{' + token + '}';\n        textarea.value = '';\n        textarea.setAttribute('text-var-value', dynamic);\n        const howToSet = (_elm, _name, value) => textarea.value = value;\n        processAttribute('text-var-value', dynamic, // realValue, // context[token].value,\n        textarea, context, ownerSupport, howToSet);\n    }\n}\n","import { ArrayNoKeyError } from '../../errors.js';\nimport { destroyArrayTag } from '../checkDestroyPrevious.function.js';\nimport { newSupportByTemplater, setupNewSupport, tagFakeTemplater } from './processTag.function.js';\nimport { Support } from '../Support.class.js';\nimport { isTagClass } from '../../isInstance.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { TagJsSubject } from './TagJsSubject.class.js';\nexport function processTagArray(subject, value, // arry of Tag classes\ninsertBefore, // <template end interpolate />\nownerSupport, options) {\n    const clones = ownerSupport.subject.global.clones; // []\n    let lastArray = subject.lastArray = subject.lastArray || { array: [] };\n    if (!subject.global.placeholder) {\n        setPlaceholderElm(insertBefore, subject);\n    }\n    const runtimeInsertBefore = subject.global.placeholder;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    lastArray.array = lastArray.array.filter((item, index) => {\n        const newLength = value.length - 1;\n        const at = index - removed;\n        const lessLength = newLength < at;\n        if (lessLength) {\n            destroyArrayItem(lastArray.array, index, options);\n            ++removed;\n            return false;\n        }\n        const subTag = value[index - removed];\n        const tagClass = isTagClass(subTag);\n        let tag = subTag;\n        let templater = subTag.templater;\n        let prevArrayValue;\n        if (tagClass) {\n            prevArrayValue = tag.memory.arrayValue;\n        }\n        else {\n            templater = subTag;\n            tag = templater.tag;\n            prevArrayValue = templater.arrayValue;\n        }\n        // const tag = subTag?.templater.tag as Tag\n        const lastTag = item.support.templater.tag;\n        const lastArrayValue = lastTag.memory.arrayValue;\n        const destroyItem = !areLikeValues(prevArrayValue, lastArrayValue);\n        if (destroyItem) {\n            destroyArrayItem(lastArray.array, index, options);\n            ++removed;\n            return false;\n        }\n        return true;\n    });\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const item = value[index];\n        const previous = lastArray.array[index];\n        const previousSupport = previous?.support;\n        const subTag = item;\n        const tagClass = isTagClass(subTag);\n        const itemSubject = new TagJsSubject(\n        // runtimeInsertBefore,\n        undefined);\n        // itemSubject.lastRun = lastArray.lastRun\n        let templater = subTag.templater;\n        let support;\n        if (tagClass) {\n            if (!templater) {\n                templater = tagFakeTemplater(subTag);\n            }\n            support = new Support(templater, ownerSupport, itemSubject);\n        }\n        else {\n            templater = subTag;\n            support = setupNewTemplater(templater, ownerSupport, itemSubject);\n        }\n        // share global between old and new\n        if (previousSupport) {\n            const prevSubject = previousSupport.subject;\n            const global = prevSubject.global;\n            setupNewSupport(support, ownerSupport, prevSubject);\n            support.subject.global = global;\n            global.newest = support;\n        }\n        else {\n            setupNewSupport(support, ownerSupport, itemSubject);\n        }\n        // check for html``.key()\n        const tag = templater.tag || subTag;\n        const keySet = 'arrayValue' in tag.memory;\n        if (!keySet) {\n            const details = {\n                template: support.getTemplate().string,\n                array: value,\n            };\n            const message = 'Use html`...`.key(item) instead of html`...` to template an Array';\n            console.error(message, details);\n            const err = new ArrayNoKeyError(message, details);\n            throw err;\n        }\n        const couldBeSame = lastArray.array.length > index;\n        if (couldBeSame) {\n            const prevSupport = previous.support;\n            const prevGlobal = prevSupport.subject.global;\n            const oldest = prevGlobal.oldest;\n            oldest.updateBy(support);\n            continue;\n        }\n        processAddTagArrayItem(runtimeInsertBefore, support, index, options, lastArray.array);\n        lastArray.lastRun = support.subject.lastRun;\n        ownerSupport.subject.global.childTags.push(support);\n    }\n    return clones;\n}\nfunction setPlaceholderElm(insertBefore, subject) {\n    const placeholder = subject.global.placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n}\nfunction processAddTagArrayItem(before, support, index, options, lastArray) {\n    const lastValue = {\n        support, index\n    };\n    // Added to previous array\n    lastArray.push(lastValue);\n    const counts = {\n        added: options.counts.added + index,\n        removed: options.counts.removed,\n    };\n    // TODO: may not be needed\n    // const newIb = document.createElement('template')\n    // support.subject.global.insertBefore = newIb\n    // TODO: This might be causing double clones delete issues because all array items share same placeholder\n    support.subject.global.placeholder = before; // newTempElm\n    const fragment = support.buildBeforeElement({ counts });\n    const placeholder = before; // subject.global.placeholder as Text\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(fragment, placeholder);\n}\n/** compare two values. If both values are arrays then the items will be compared */\nfunction areLikeValues(valueA, valueB) {\n    if (valueA === valueB) {\n        return true;\n    }\n    const bothArrays = valueA instanceof Array && valueB instanceof Array;\n    const matchLengths = bothArrays && valueA.length == valueB.length;\n    if (matchLengths) {\n        return valueA.every((item, index) => item === valueB[index]);\n    }\n    return false;\n}\nfunction setupNewTemplater(templater, ownerSupport, itemSubject) {\n    const support = newSupportByTemplater(templater, ownerSupport, itemSubject);\n    renderTagOnly(support, support, itemSubject, ownerSupport);\n    return support;\n}\nfunction destroyArrayItem(lastArray, index, options) {\n    const last = lastArray[index];\n    const support = last.support;\n    destroyArrayTag(support, options.counts);\n    last.deleted = true;\n    ++options.counts.removed;\n}\n","// Function to update the value of x\nexport function updateBeforeTemplate(value, // value should be casted before calling here\nlastFirstChild) {\n    const parent = lastFirstChild.parentNode;\n    // Insert the new value (never use innerHTML here)\n    const textNode = document.createTextNode(value); // never innerHTML\n    parent.insertBefore(textNode, lastFirstChild);\n    /* remove existing nodes */\n    parent.removeChild(lastFirstChild);\n    return textNode;\n}\nexport function castTextValue(value) {\n    // mimic React skipping to display EXCEPT for true does display on page\n    if ([undefined, false, null].includes(value)) { // || value === true\n        return '';\n    }\n    return value;\n}\n","import { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nexport function processRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.global.insertBefore = insertBefore;\n    const before = subject.global.placeholder || insertBefore; // Either the template is on the doc OR its the first element we last put on doc\n    // matches but also was defined at some point\n    if (subject.lastValue === value && 'lastValue' in subject) {\n        return; // no need to update display, its the same\n    }\n    subject.lastValue = value;\n    const castedValue = castTextValue(value);\n    // replace existing string?\n    const oldClone = subject.global.placeholder;\n    if (oldClone) {\n        oldClone.textContent = castedValue;\n        return;\n    }\n    // Processing of regular values\n    const clone = updateBeforeTemplate(castedValue, before);\n    subject.global.placeholder = clone; // remember single element put down, for future updates\n}\nexport function processFirstRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.lastValue = value;\n    const castedValue = castTextValue(value);\n    // Processing of regular values\n    const clone = updateBeforeTemplate(castedValue, insertBefore);\n    subject.global.placeholder = clone; // remember single element put down, for future updates \n}\n","import { TemplaterResult } from '../TemplaterResult.class.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = new TemplaterResult([]);\n    templater.tagJsType = 'oneRender';\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    const wrap = () => {\n        templater.tag = tag || (wrapper());\n        return support;\n    };\n    templater.wrapper = wrap;\n    wrap.parentWrap = wrap;\n    wrap.oneRender = true;\n    wrap.parentWrap.original = wrapper;\n    return support;\n}\n","import { processSubjectComponent } from './processSubjectComponent.function.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processFirstRegularValue } from './processRegularValue.function.js';\nimport { processTag, tagFakeTemplater } from './processTag.function.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { oneRenderToSupport } from './oneRenderToSupport.function.js';\nimport { getValueType } from '../getValueType.function.js';\nexport function processFirstSubjectValue(value, subject, // could be tag via result.tag\ninsertBefore, // <template end interpolate /> (will be removed)\nownerSupport, // owner\noptions) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.templater:\n            processTag(value, ownerSupport, subject);\n            return;\n        case ValueTypes.tag:\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = tagFakeTemplater(tag);\n            }\n            processTag(templater, ownerSupport, subject);\n            return;\n        case ValueTypes.tagArray:\n            return processTagArray(subject, value, insertBefore, ownerSupport, options);\n        case ValueTypes.tagComponent:\n            const newSupport = processSubjectComponent(value, subject, insertBefore, ownerSupport, options);\n            return newSupport;\n        case ValueTypes.function:\n            const v = value;\n            if (v.oneRender) {\n                const support = oneRenderToSupport(v, subject, ownerSupport);\n                renderTagOnly(support, support, subject, ownerSupport);\n                processTag(support.templater, ownerSupport, subject);\n                return;\n            }\n            break;\n    }\n    processFirstRegularValue(value, subject, subject.global.placeholder || insertBefore);\n}\n","export function setTagPlaceholder(global) {\n    const insertBefore = global.insertBefore;\n    return global.placeholder = swapInsertBefore(insertBefore);\n}\nexport function swapInsertBefore(insertBefore) {\n    const placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n    return placeholder;\n}\n","import { Support } from '../Support.class.js';\nimport { TemplaterResult } from '../TemplaterResult.class.js';\nimport { isTagClass, isTagTemplater } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function.js';\nimport { processRegularValue } from './processRegularValue.function.js';\nimport { checkDestroyPrevious } from '../checkDestroyPrevious.function.js';\nimport { processSubjectComponent } from './processSubjectComponent.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { getFakeTemplater, processTag, setupNewSupport } from './processTag.function.js';\nimport { swapInsertBefore } from '../setTagPlaceholder.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getValueType } from '../getValueType.function.js';\nexport function updateExistingValue(subject, value, ownerSupport, insertBefore) {\n    const valueType = getValueType(value);\n    checkDestroyPrevious(subject, value, insertBefore, valueType);\n    // handle already seen tag components\n    if (valueType === ValueTypes.tagComponent) {\n        return prepareUpdateToComponent(value, subject, insertBefore, ownerSupport);\n    }\n    // was component but no longer\n    const support = subject.support;\n    if (support) {\n        if (valueType === ValueTypes.function) {\n            return subject; // its a oneRender tag\n        }\n        handleStillTag(subject, value, ownerSupport);\n        return subject;\n    }\n    switch (valueType) {\n        case ValueTypes.tagArray:\n            processTagArray(subject, value, insertBefore, // oldInsertBefore as InsertBefore,\n            ownerSupport, { counts: {\n                    added: 0,\n                    removed: 0,\n                } });\n            return subject;\n        case ValueTypes.templater:\n            processTag(value, ownerSupport, subject);\n            return subject;\n        case ValueTypes.tag:\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = getFakeTemplater();\n                tag.templater = templater;\n                templater.tag = tag;\n            }\n            processTag(templater, ownerSupport, subject);\n            return subject;\n        case ValueTypes.subject:\n            return value;\n        // now its a useless function (we don't automatically call functions)\n        case ValueTypes.function:\n            if (!subject.global.placeholder) {\n                subject.global.placeholder = swapInsertBefore(insertBefore);\n            }\n            return subject;\n    }\n    // This will cause all other values to render\n    processRegularValue(value, subject, insertBefore);\n    return subject;\n}\nfunction handleStillTag(subject, value, ownerSupport) {\n    const lastSupport = subject.support;\n    let templater = value;\n    const isClass = isTagClass(value);\n    if (isClass) {\n        const tag = value;\n        templater = tag.templater;\n        if (!templater) {\n            templater = new TemplaterResult([]);\n            templater.tag = tag;\n            tag.templater = templater;\n        }\n    }\n    const valueSupport = new Support(templater, ownerSupport, subject);\n    const isSameTag = value && isLikeTags(lastSupport, valueSupport);\n    if (isTagTemplater(value)) {\n        setupNewSupport(valueSupport, ownerSupport, subject);\n    }\n    /*\n    if(valueSupport.templater.wrapper?.parentWrap.original.toString().includes('🌹-1')) {\n      // console.log('isSameTag', isSameTag)\n    }\n    */\n    if (isSameTag) {\n        lastSupport.updateBy(valueSupport);\n        return;\n    }\n    if (isSameTag) {\n        return processTag(templater, ownerSupport, subject);\n    }\n    return processRegularValue(value, subject, subject.global.insertBefore);\n}\nfunction prepareUpdateToComponent(templater, subjectTag, insertBefore, ownerSupport) {\n    // When last value was not a component\n    if (!subjectTag.support) {\n        processSubjectComponent(templater, subjectTag, insertBefore, ownerSupport, {\n            counts: { added: 0, removed: 0 },\n        });\n        return subjectTag;\n    }\n    const support = new Support(templater, ownerSupport, subjectTag);\n    const subjectSup = subjectTag.support;\n    const prevSupport = subjectSup.subject.global.newest;\n    if (prevSupport) {\n        const newestState = prevSupport.state;\n        support.state.length = 0;\n        support.state.push(...newestState);\n    }\n    else {\n        processSubjectComponent(templater, subjectTag, insertBefore, ownerSupport, { counts: { added: 0, removed: 0 } });\n        return subjectTag;\n    }\n    subjectTag.global = subjectSup.subject.global;\n    subjectTag.support = support;\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    subjectTag, insertBefore);\n    return subjectTag;\n}\n","import { processFirstSubjectValue } from '../tag/update/processFirstSubjectValue.function.js';\nimport { updateExistingValue } from '../tag/update/updateExistingValue.function.js';\nimport { swapInsertBefore } from '../tag/setTagPlaceholder.function.js';\nexport function subscribeToTemplate(insertBefore, subject, ownerSupport, counts) {\n    let called = false;\n    const onValue = (value) => {\n        if (called) {\n            updateExistingValue(subject, value, ownerSupport, insertBefore);\n            return;\n        }\n        const templater = value;\n        processFirstSubjectValue(templater, subject, insertBefore, ownerSupport, {\n            counts: { ...counts },\n        });\n        called = true;\n    };\n    // leave no template tag\n    if (!subject.global.placeholder) {\n        subject.global.placeholder = swapInsertBefore(insertBefore);\n    }\n    let mutatingCallback = onValue;\n    const callback = (value) => mutatingCallback(value);\n    const sub = subject.subscribe(callback);\n    ownerSupport.subject.global.subscriptions.push(sub);\n}\n","import { elementInitCheck } from './elementInitCheck.js';\nimport { scanTextAreaValue } from './scanTextAreaValue.function.js';\nimport { subscribeToTemplate } from './subscribeToTemplate.function.js';\nexport function interpolateTemplate(insertBefore, // <template end interpolate /> (will be removed)\ncontext, // variable scope of {`__tagvar${index}`:'x'}\nownerSupport, // Tag class\ncounts) {\n    if (!insertBefore.hasAttribute('end')) {\n        return; // only care about <template end>\n    }\n    const variableName = insertBefore.getAttribute('id');\n    const subject = context[variableName];\n    subject.global.insertBefore = insertBefore;\n    // process dynamics later\n    /*\n    ??? newly removed\n    \n    const isDynamic = isTagComponent(subject._value) || isTagArray(subject.value)\n    if(isDynamic) {\n      return {\n        variableName,\n        ownerSupport,\n        subject,\n        insertBefore\n      }\n    }\n    */\n    subscribeToTemplate(insertBefore, subject, ownerSupport, counts);\n    return;\n}\n/** This is the function that enhances elements such as [class.something] and [style.color] OR it fixes elements that alter innerHTML */\nexport function afterElmBuild(elm, options, context, ownerSupport) {\n    if (!elm.getAttribute) {\n        return;\n    }\n    // Elements that alter innerHTML\n    const tagName = elm.nodeName; // elm.tagName\n    if (tagName === 'TEXTAREA') {\n        scanTextAreaValue(elm, context, ownerSupport);\n    }\n    let diff = options.counts.added;\n    diff = elementInitCheck(elm, options.counts) - diff;\n    const hasFocusFun = elm.focus;\n    if (hasFocusFun) {\n        if (elm.hasAttribute('autofocus')) {\n            elm.focus();\n        }\n        if (elm.hasAttribute('autoselect')) {\n            elm.select();\n        }\n    }\n    const children = elm.children;\n    if (children) {\n        for (let index = children.length - 1; index >= 0; --index) {\n            const child = children[index];\n            const subOptions = {\n                ...options,\n                counts: options.counts,\n            };\n            afterElmBuild(child, subOptions, context, ownerSupport);\n        }\n    }\n}\n","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n","import { interpolateTemplate } from './interpolateTemplate.js';\nexport function interpolateContentTemplates(context, support, options, children) {\n    // counting for animation stagger computing\n    const counts = options.counts;\n    const tagComponents = [];\n    const childLength = children.length;\n    for (let index = childLength - 1; index >= 0; --index) {\n        const child = children[index];\n        // const tagComponent =\n        interpolateTemplate(child, context, support, counts);\n        // clones.push(...nextClones)\n        /*\n        if(tagComponent) {\n          tagComponents.push(tagComponent)\n          continue\n        }\n        */\n        if (child.children) {\n            for (let index = child.children.length - 1; index >= 0; --index) {\n                const subChild = child.children[index];\n                // IF <template end /> its a variable to be processed\n                if (isRenderEndTemplate(subChild)) {\n                    // const tagComponent =\n                    interpolateTemplate(subChild, context, support, counts);\n                    /*\n                    if(tagComponent) {\n                      tagComponents.push(tagComponent)\n                    }\n                    */\n                }\n                const nextTagComponent = interpolateContentTemplates(context, support, options, subChild.children);\n                tagComponents.push(...nextTagComponent);\n            }\n        }\n    }\n    return tagComponents;\n}\nfunction isRenderEndTemplate(child) {\n    const isTemplate = child.tagName === 'TEMPLATE';\n    return isTemplate &&\n        child.getAttribute('interpolate') !== undefined &&\n        child.getAttribute('end') !== undefined;\n}\n","import { interpolateAttributes } from './interpolateAttributes.js';\nimport { interpolateToTemplates } from './interpolations.js';\nimport { interpolateContentTemplates } from './interpolateContentTemplates.js';\nimport { escapeSearch, variablePrefix } from '../tag/Tag.class.js';\n/** Review elements within an element */\nexport function interpolateElement(template, // element containing innerHTML to review interpolations\ncontext, // variables used to evaluate\ninterpolatedTemplates, ownerSupport, options) {\n    const tagComponents = [];\n    const result = interpolatedTemplates.interpolation;\n    // const template = container.children[0] as HTMLTemplateElement\n    const children = template.content.children;\n    if (result.keys.length) {\n        const nextTagComponents = interpolateContentTemplates(context, ownerSupport, options, children);\n        tagComponents.push(...nextTagComponents);\n    }\n    interpolateAttributes(template, context, ownerSupport);\n    processChildrenAttributes(children, context, ownerSupport);\n    return tagComponents;\n}\nfunction processChildrenAttributes(children, context, ownerSupport) {\n    for (let index = children.length - 1; index >= 0; --index) {\n        const child = children[index];\n        interpolateAttributes(child, context, ownerSupport);\n        if (child.children) {\n            processChildrenAttributes(child.children, context, ownerSupport);\n        }\n    }\n}\nexport function interpolateString(string) {\n    const result = interpolateToTemplates(string);\n    result.string = result.string.replace(escapeSearch, variablePrefix);\n    return result;\n}\n","import { buildClones } from '../buildClones.function.js';\nimport { afterElmBuild } from './interpolateTemplate.js';\nexport function afterInterpolateElement(container, template, support, context, options) {\n    const clones = buildClones(container, template);\n    if (!clones.length) {\n        return clones;\n    }\n    const global = support.subject.global;\n    for (let index = clones.length - 1; index >= 0; --index) {\n        const clone = clones[index];\n        afterElmBuild(clone, options, context, support);\n    }\n    global.clones.push(...clones);\n    return clones;\n}\n","export function buildClones(fragment, template) {\n    const clones = [];\n    let nextSibling = template.content.firstChild;\n    while (nextSibling) {\n        const nextNextSibling = nextSibling.nextSibling;\n        fragment.appendChild(nextSibling);\n        clones.push(nextSibling);\n        nextSibling = nextNextSibling;\n    }\n    return clones;\n}\n","import { escapeVariable, variablePrefix } from './Tag.class.js';\nimport { deepClone } from '../deepFunctions.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { cloneValueArray } from './cloneValueArray.function.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { getChildTagsToDestroy } from './destroy.support.js';\nimport { elementDestroyCheck } from './elementDestroyCheck.function.js';\nimport { updateContextItem } from './update/updateContextItem.function.js';\nimport { processNewValue } from './update/processNewValue.function.js';\nimport { interpolateElement, interpolateString } from '../interpolations/interpolateElement.js';\nimport { afterInterpolateElement } from '../interpolations/afterInterpolateElement.function.js';\nimport { subscribeToTemplate } from '../interpolations/subscribeToTemplate.function.js';\nconst prefixSearch = new RegExp(variablePrefix, 'g');\n/** used only for apps, otherwise use Support */\n// TODO: We need to split Support and simple tag support apart\nexport class BaseSupport {\n    templater;\n    subject;\n    isApp = true;\n    appElement; // only seen on this.getAppSupport().appElement\n    strings;\n    values;\n    propsConfig;\n    // stays with current render\n    state = [];\n    hasLiveElements = false;\n    constructor(templater, subject, castedProps) {\n        this.templater = templater;\n        this.subject = subject;\n        const props = templater.props; // natural props\n        this.propsConfig = this.clonePropsBy(props, castedProps);\n    }\n    clonePropsBy(props, castedProps) {\n        const children = this.templater.children; // children tags passed in as arguments\n        const kidValue = children.value;\n        const latestCloned = props.map(props => deepClone(props));\n        return this.propsConfig = {\n            latest: props,\n            latestCloned, // assume its HTML children and then detect\n            castProps: castedProps,\n            lastClonedKidValues: kidValue.map(kid => {\n                const cloneValues = cloneValueArray(kid.values);\n                return cloneValues;\n            })\n        };\n    }\n    /** Function that kicks off actually putting tags down as HTML elements */\n    buildBeforeElement(options = {\n        counts: { added: 0, removed: 0 },\n    }) {\n        const subject = this.subject;\n        const global = this.subject.global;\n        global.oldest = this;\n        global.newest = this;\n        subject.support = this;\n        this.hasLiveElements = true;\n        const context = this.update();\n        const template = this.getTemplate();\n        const elementContainer = document.createDocumentFragment();\n        const tempDraw = document.createElement('template'); // put down a first element we can expect to always be there\n        tempDraw.innerHTML = template.string;\n        // Search/replace innerHTML variables but don't interpolate tag components just yet\n        const tagComponents = interpolateElement(tempDraw, context, template, this, // ownerSupport,\n        {\n            counts: options.counts\n        });\n        afterInterpolateElement(elementContainer, tempDraw, this, // ownerSupport\n        context, options);\n        // Any tag components that were found should be processed AFTER the owner processes its elements. Avoid double processing of elements attributes like (oninit)=${}\n        const length = tagComponents.length;\n        for (let index = 0; index < length; ++index) {\n            const tagComponent = tagComponents[index];\n            subscribeToTemplate(tagComponent.insertBefore, tagComponent.subject, tagComponent.ownerSupport, options.counts);\n            afterInterpolateElement(elementContainer, tempDraw, tagComponent.ownerSupport, context, options);\n        }\n        /*\n        const insertBefore = this.subject.global.insertBefore as Element\n        if(insertBefore.parentNode) {\n          const parentNode = insertBefore.parentNode as ParentNode\n          parentNode.insertBefore(elementContainer, insertBefore)\n        }\n        */\n        return elementContainer;\n    }\n    getTemplate() {\n        const thisTag = this.templater.tag;\n        const strings = this.strings || thisTag.strings;\n        const values = this.values || thisTag.values;\n        const lastRun = this.subject.lastRun;\n        if (lastRun) {\n            if (lastRun.strings.length === strings.length) {\n                const stringsMatch = lastRun.strings.every((string, index) => \n                // string.length === strings[index].length\n                string === strings[index]);\n                if (stringsMatch && lastRun.values.length === values.length) {\n                    return lastRun; // performance savings using the last time this component was rendered\n                }\n            }\n        }\n        const string = strings.map((string, index) => {\n            const safeString = string.replace(prefixSearch, escapeVariable);\n            const endString = safeString + (values.length > index ? `{${variablePrefix}${index}}` : '');\n            // ??? new removed\n            //const trimString = endString.replace(/>\\s*/g,'>').replace(/\\s*</g,'<')\n            //return trimString\n            return endString;\n        }).join('');\n        const interpolation = interpolateString(string);\n        const run = {\n            interpolation,\n            string: interpolation.string,\n            strings,\n            values,\n        };\n        this.subject.lastRun = run;\n        return run;\n    }\n    update() {\n        return this.updateContext(this.subject.global.context);\n    }\n    updateContext(context) {\n        const thisTag = this.templater.tag;\n        const strings = this.strings || thisTag.strings;\n        const values = this.values || thisTag.values;\n        strings.forEach((_string, index) => {\n            const hasValue = values.length > index;\n            if (!hasValue) {\n                return;\n            }\n            const variableName = variablePrefix + index;\n            const value = values[index];\n            // is something already there?\n            const exists = variableName in context;\n            if (exists) {\n                if (this.subject.global.deleted) {\n                    const valueSupport = (value && value.support);\n                    if (valueSupport) {\n                        valueSupport.destroy();\n                        return context; // item was deleted, no need to emit\n                    }\n                }\n                return updateContextItem(context, variableName, value);\n            }\n            // 🆕 First time values below\n            context[variableName] = processNewValue(value, this);\n            // context[variableName].global.insertBefore = this.subject.global.placeholder || this.subject.global.insertBefore\n        });\n        return context;\n    }\n    updateBy(support) {\n        const tempTag = support.templater.tag;\n        this.updateConfig(tempTag.strings, tempTag.values);\n    }\n    updateConfig(strings, values) {\n        this.strings = strings;\n        this.updateValues(values);\n    }\n    updateValues(values) {\n        this.values = values;\n        return this.updateContext(this.subject.global.context);\n    }\n    destroy(options = {\n        stagger: 0,\n    }) {\n        const global = this.subject.global;\n        const childTags = options.byParent ? [] : getChildTagsToDestroy(this.subject.global.childTags); // .toReversed()\n        if (isTagComponent(this.templater)) {\n            global.destroy$.next();\n            runBeforeDestroy(this, this);\n        }\n        this.destroySubscriptions();\n        // signify immediately child has been deleted (looked for during event processing)\n        for (let index = childTags.length - 1; index >= 0; --index) {\n            const child = childTags[index];\n            const subGlobal = child.subject.global;\n            delete subGlobal.newest;\n            subGlobal.deleted = true;\n            if (isTagComponent(child.templater)) {\n                runBeforeDestroy(child, child);\n            }\n            child.destroySubscriptions();\n            resetSupport(this);\n        }\n        resetSupport(this);\n        let mainPromise;\n        const { stagger, promise } = this.destroyClones(options);\n        options.stagger = stagger;\n        if (promise) {\n            mainPromise = promise;\n        }\n        if (mainPromise) {\n            return mainPromise.then(async () => {\n                const promises = childTags.map(kid => kid.destroyClones());\n                return Promise.all(promises);\n            }).then(() => options.stagger);\n        }\n        childTags.forEach(kid => kid.destroyClones());\n        return options.stagger;\n    }\n    destroyClones({ stagger } = {\n        stagger: 0,\n    }) {\n        const oldClones = this.subject.global.clones; // .toReversed()\n        // check subjects that may have clones attached to them\n        const promises = oldClones.map(clone => this.checkCloneRemoval(clone, stagger)).filter(x => x); // only return promises\n        this.subject.global.clones.length = 0; // tag maybe used for something else\n        if (promises.length) {\n            return { promise: Promise.all(promises), stagger };\n        }\n        return { stagger };\n    }\n    /** Reviews elements for the presences of ondestroy */\n    checkCloneRemoval(clone, stagger) {\n        let promise;\n        const customElm = clone;\n        if (customElm.ondestroy) {\n            promise = elementDestroyCheck(customElm, stagger);\n        }\n        if (promise instanceof Promise) {\n            return promise.then(() => {\n                const parentNode = clone.parentNode;\n                // TODO: we need to remove this IF\n                if (parentNode) {\n                    parentNode.removeChild(clone);\n                }\n            });\n        }\n        const parentNode = clone.parentNode;\n        if (parentNode) {\n            parentNode.removeChild(clone);\n        }\n        return promise;\n    }\n    destroySubscriptions() {\n        const subs = this.subject.global.subscriptions;\n        for (let index = subs.length - 1; index >= 0; --index) {\n            subs[index].unsubscribe();\n        }\n        subs.length = 0;\n    }\n}\nexport class Support extends BaseSupport {\n    templater;\n    ownerSupport;\n    subject;\n    version;\n    isApp = false;\n    constructor(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\n    ownerSupport, subject, castedProps, version = 0) {\n        super(templater, subject, castedProps);\n        this.templater = templater;\n        this.ownerSupport = ownerSupport;\n        this.subject = subject;\n        this.version = version;\n    }\n    getAppSupport() {\n        let tag = this;\n        while (tag.ownerSupport) {\n            tag = tag.ownerSupport;\n        }\n        return tag;\n    }\n}\nexport function resetSupport(support) {\n    const global = support.subject.global;\n    // delete global.placeholder\n    global.context = {};\n    delete global.oldest; // may not be needed\n    delete global.newest;\n    support.subject.global.childTags.length = 0;\n    const subject = support.subject;\n    delete subject.support;\n}\n","import { isSubjectInstance } from '../../isInstance.js';\nexport function updateContextItem(context, variableName, value) {\n    const subject = context[variableName];\n    if (isSubjectInstance(value)) {\n        return; // emits on its own\n    }\n    // listeners will evaluate updated values to possibly update display(s)\n    subject.next(value);\n    return;\n}\n","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    if (!onDestroyDoubleWrap) {\n        return;\n    }\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    if (!onDestroy) {\n        return;\n    }\n    const event = { target: nextSibling, stagger };\n    return onDestroy(event);\n}\n","import { resetSupport } from '../Support.class.js';\nimport { getChildTagsToDestroy } from '../destroy.support.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport, options = { byParent: false, stagger: 0 }) {\n    const global = lastSupport.subject.global;\n    global.deleted = true;\n    global.context = {};\n    const childTags = getChildTagsToDestroy(global.childTags);\n    lastSupport.destroySubscriptions();\n    childTags.forEach(child => {\n        const subGlobal = child.subject.global;\n        delete subGlobal.newest;\n        subGlobal.deleted = true;\n    });\n    resetSupport(lastSupport);\n    lastSupport.destroyClones();\n    childTags.forEach(child => softDestroySupport(child, { byParent: true, stagger: 0 }));\n}\n","import { isLikeTags } from '../isLikeTags.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { destroyUnlikeTags } from './destroyUnlikeTags.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nexport function renderWithSupport(newSupport, lastSupport, // previous\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastStrings = lastTemplater?.tag?.strings;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        destroyUnlikeTags(lastSupport, reSupport, subject);\n    }\n    else if (lastSupport) {\n        const oldLength = lastStrings?.length;\n        const newLength = reSupport.templater.tag?.strings.length;\n        if (oldLength !== newLength) {\n            softDestroySupport(lastSupport);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return reSupport;\n}\n","import { softDestroySupport } from './softDestroySupport.function.js';\nimport { moveProviders } from '../update/updateExistingTagComponent.function.js';\nexport function destroyUnlikeTags(lastSupport, // old\nreSupport, // new\nsubject) {\n    // when a tag is destroyed, disconnect the globals\n    const global = reSupport.subject.global; // = {...oldGlobal} // break memory references\n    moveProviders(lastSupport, reSupport);\n    softDestroySupport(lastSupport);\n    delete global.deleted;\n    global.oldest = reSupport;\n    global.newest = reSupport;\n    subject.support = reSupport;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { renderSupport } from '../tag/render/renderSupport.function.js';\nexport function handleProviderChanges(appSupport, provider) {\n    let hadChanged = false;\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    for (let index = tagsWithProvider.length - 1; index >= 0; --index) {\n        const { support, renderCount, provider } = tagsWithProvider[index];\n        if (support.subject.global.deleted) {\n            continue; // i was deleted after another tag processed\n        }\n        const notRendered = renderCount === support.subject.global.renderCount;\n        if (notRendered) {\n            hadChanged = true;\n            provider.clone = deepClone(provider.instance);\n            renderSupport(support.subject.global.newest, // support, // support.subject.global.newest as Support,\n            false);\n            continue;\n        }\n    }\n    return hadChanged;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    memory.push({\n        support,\n        renderCount: support.subject.global.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        memory.push({\n            support: childTags[index],\n            renderCount: childTags[index].subject.global.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { isLikeTags } from '../isLikeTags.function.js';\nimport { renderWithSupport } from './renderWithSupport.function.js';\nimport { providersChangeCheck } from '../../state/providersChangeCheck.function.js';\n/** Returns true when rendering owner is not needed. Returns false when rendering owner should occur */\nexport function renderExistingTag(oldestSupport, // oldest with elements on html\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const lastSupport = subject.support;\n    const global = lastSupport.subject.global;\n    // share point between renders\n    newSupport.subject.global = global;\n    const preRenderCount = global.renderCount;\n    providersChangeCheck(oldestSupport);\n    // When the providers were checked, a render to myself occurred and I do not need to re-render again\n    const prevSupport = global.newest;\n    const justUpdate = preRenderCount !== global.renderCount;\n    if (justUpdate) {\n        oldestSupport.subject.global.oldest.updateBy(prevSupport);\n        return prevSupport; // already rendered during triggered events\n    }\n    const toRedrawTag = prevSupport || lastSupport || global.oldest;\n    const reSupport = renderWithSupport(newSupport, toRedrawTag, subject, ownerSupport);\n    const oldest = global.oldest || oldestSupport;\n    if (isLikeTags(prevSupport, reSupport)) {\n        subject.support = reSupport;\n        oldest.updateBy(reSupport);\n    }\n    return reSupport;\n}\n","import { deepClone, deepEqual } from '../deepFunctions.js';\nimport { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providersWithChanges = global.providers.filter(provider => !deepEqual(provider.instance, provider.clone));\n    let hadChanged = false;\n    // reset clones\n    for (let index = providersWithChanges.length - 1; index >= 0; --index) {\n        const provider = providersWithChanges[index];\n        const owner = provider.owner;\n        if (handleProviderChanges(owner, provider)) {\n            hadChanged = true;\n        }\n        provider.clone = deepClone(provider.instance);\n    }\n    return hadChanged;\n}\n","import { deepEqual } from '../../deepFunctions.js';\nimport { renderExistingTag } from './renderExistingTag.function.js';\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support, // must be latest/newest state render\nrenderUp) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    // is it just a vanilla tag, not component?\n    if (!templater.wrapper) { // || isTagTemplater(templater) \n        const ownerTag = support.ownerSupport;\n        ++global.renderCount;\n        if (ownerTag.subject.global.deleted) {\n            return support;\n        }\n        return renderSupport(ownerTag.subject.global.newest, true);\n    }\n    if (support.subject.global.locked) {\n        support.subject.global.blocked.push(support);\n        return support;\n    }\n    const subject = support.subject;\n    const oldest = support.subject.global.oldest;\n    let ownerSupport;\n    let selfPropChange = false;\n    const shouldRenderUp = renderUp && support;\n    if (shouldRenderUp) {\n        ownerSupport = support.ownerSupport;\n        if (ownerSupport) {\n            const nowProps = templater.props;\n            const latestProps = support.propsConfig.latestCloned;\n            selfPropChange = !deepEqual(nowProps, latestProps);\n        }\n    }\n    const tag = renderExistingTag(oldest, support, ownerSupport, // useSupport,\n    subject);\n    if (ownerSupport && selfPropChange) {\n        const myOwnerSupport = ownerSupport.subject.global.newest;\n        renderSupport(myOwnerSupport, true);\n        return tag;\n    }\n    return tag;\n}\n","import { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { syncStates } from './syncStates.function.js';\nexport default function callbackStateUpdate(support, callback, oldState, ...args) {\n    const state = support.state;\n    // ensure that the oldest has the latest values first\n    syncStates(state, oldState);\n    // run the callback\n    const maybePromise = callback(...args);\n    // send the oldest state changes into the newest\n    syncStates(oldState, state);\n    renderSupport(support, // support.global.newest as Support,\n    false);\n    if (maybePromise instanceof Promise) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            syncStates(oldState, state);\n            renderSupport(support, // support.global.newest as Support,\n            false);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { setUse } from './setUse.function.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport callbackStateUpdate from './callbackStateUpdate.function.js';\nlet innerCallback = (callback) => (a, b, c, d, e, f) => {\n    throw new SyncCallbackError('Callback function was called immediately in sync and must instead be call async');\n};\nexport const callbackMaker = () => innerCallback;\nconst originalGetter = innerCallback; // callbackMaker\nsetUse({\n    beforeRender: support => initMemory(support),\n    beforeRedraw: support => initMemory(support),\n    afterRender: support => {\n        support.subject.global.callbackMaker = true;\n        innerCallback = originalGetter; // prevent crossing callbacks with another tag\n    },\n});\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        const error = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n        throw error;\n    }\n    const oldState = setUse.memory.stateConfig.array;\n    const trigger = (...args) => {\n        const callbackMaker = support.subject.global.callbackMaker;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, callback, oldState, ...args);\n        }\n        return callback(...args);\n    };\n    return trigger;\n}\nfunction initMemory(support) {\n    const oldState = setUse.memory.stateConfig.array;\n    innerCallback = (callback) => {\n        const trigger = (...args) => {\n            const callbackMaker = support.subject.global.callbackMaker;\n            if (callbackMaker) {\n                return callbackStateUpdate(support, callback, oldState, ...args);\n            }\n            return callback(...args);\n        };\n        return trigger;\n    };\n}\n","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(() => {\n        const support = getSupportInCycle();\n        support?.subject.global.destroy$.toCallback(callback);\n    });\n}\n","import { setUse } from './setUse.function.js';\nfunction setCurrentSupport(support) {\n    setUse.memory.childrenCurrentSupport = support;\n}\nexport function children() {\n    const support = setUse.memory.childrenCurrentSupport;\n    const children = support.templater.children;\n    return children;\n}\nsetUse({\n    beforeRender: support => setCurrentSupport(support),\n    beforeRedraw: support => setCurrentSupport(support),\n});\n","export const tags = [];\n","import { Tag } from './Tag.class.js';\nexport function html(strings, ...values) {\n    return new Tag(strings, values);\n}\n","import { runTagCallback } from '../interpolations/bindSubjectCallback.function.js';\nimport { Support } from './Support.class.js';\nimport { castProps } from '../alterProp.function.js';\nimport { setUse } from '../state/setUse.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { html } from './html.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    const stateArray = setUse.memory.stateConfig.array;\n    // this function gets called by taggedjs\n    const wrapper = (lastSupport, subject) => executeWrap(stateArray, templater, result, lastSupport, subject);\n    return wrapper;\n}\nfunction executeWrap(stateArray, templater, result, lastSupport, subject) {\n    const global = lastSupport.subject.global;\n    ++global.renderCount;\n    const childSubject = templater.children;\n    const lastArray = global.oldest?.templater.children.lastArray;\n    if (lastArray) {\n        childSubject.lastArray = lastArray;\n    }\n    // result.original\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    let props = templater.props;\n    // When defined, this must be an update where my new props have already been made for me\n    const preCastedProps = lastSupport.propsConfig.castProps;\n    const castedProps = preCastedProps || castProps(props, lastSupport, stateArray);\n    // const latestCloned = props.map(props => deepClone(props)) // castedProps\n    // CALL ORIGINAL COMPONENT FUNCTION\n    let tag = originalFunction(...castedProps);\n    if (tag instanceof Function) {\n        tag = tag();\n    }\n    if (!tag || tag.tagJsType !== ValueTypes.tag) {\n        tag = html `${tag}`; // component returned a non-component value\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    tag.memory.arrayValue = templater.arrayValue; // tag component could have been used in array.map\n    const support = new Support(templater, lastSupport.ownerSupport, subject, castedProps, global.renderCount);\n    support.subject.global = global;\n    // ??? this should be set by outside?\n    global.oldest = global.oldest || support;\n    const nowState = setUse.memory.stateConfig.array;\n    support.state.push(...nowState);\n    if (templater.madeChildIntoSubject) {\n        const value = childSubject.value;\n        for (let index = value.length - 1; index >= 0; --index) {\n            const kid = value[index];\n            const values = kid.values;\n            for (let index = values.length - 1; index >= 0; --index) {\n                const value = values[index];\n                if (!(value instanceof Function)) {\n                    continue;\n                }\n                const valuesValue = kid.values[index];\n                if (valuesValue.isChildOverride) {\n                    continue; // already overwritten\n                }\n                // all functions need to report to me\n                kid.values[index] = function (...args) {\n                    return runTagCallback(value, // callback\n                    support.ownerSupport, this, // bindTo\n                    args);\n                };\n                valuesValue.isChildOverride = true;\n            }\n        }\n    }\n    return support;\n}\n","import { setUse } from '../state/index.js';\nimport { TemplaterResult } from './TemplaterResult.class.js';\nimport { tags } from './tag.utils.js';\nimport { getTagWrap } from './getTagWrap.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nlet tagCount = 0;\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent) {\n    /** function developer triggers */\n    const parentWrap = (function tagWrapper(...props) {\n        const templater = new TemplaterResult(props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        if (!innerTagWrap.parentWrap) {\n            innerTagWrap.parentWrap = parentWrap;\n        }\n        templater.tagged = true;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }) // we override the function provided and pretend original is what's returned\n    ;\n    parentWrap.original = tagComponent;\n    parentWrap.compareTo = tagComponent.toString();\n    const tag = tagComponent;\n    parentWrap.isTag = true;\n    parentWrap.original = tag;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUse;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Used to create a tag component that renders once and has no addition rendering cycles */\ntag.oneRender = (...props) => {\n    throw new Error('Do not call function tag.oneRender but instead set it as: `(props) => tag.oneRender = (state) => html`` `');\n};\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.route = (routeProps) => {\n    throw new Error('Do not call function tag.route but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.app = (routeTag) => {\n    throw new Error('Do not call function tag.route but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\nObject.defineProperty(tag, 'oneRender', {\n    set(oneRenderFunction) {\n        oneRenderFunction.oneRender = true;\n    },\n});\n","import { BaseSupport } from './Support.class.js';\nimport { runAfterRender, runBeforeRender } from './tagRunner.js';\nimport { TagJsSubject } from './update/TagJsSubject.class.js';\nconst appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, // (...args: unknown[]) => TemplaterResult,\nelement, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        appElements[appElmIndex].support.destroy();\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    const wrapper = app(props);\n    // const fragment = document.createDocumentFragment()\n    const template = document.createElement('template');\n    const placeholder = document.createTextNode('');\n    const support = runWrapper(wrapper, template, placeholder);\n    const global = support.subject.global;\n    support.appElement = element;\n    support.isApp = true;\n    global.isApp = true;\n    element.destroy = () => {\n        support.destroy(); // never return anything here\n    };\n    global.insertBefore = placeholder // template\n    ;\n    global.placeholder = placeholder;\n    const newFragment = support.buildBeforeElement();\n    support.subject.global.oldest = support;\n    support.subject.global.newest = support;\n    element.setUse = app.original.setUse;\n    appElements.push({ element, support });\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags: app.original.tags,\n    };\n}\nexport function runWrapper(templater, insertBefore, placeholder) {\n    let newSupport = {};\n    // TODO: A fake subject may become a problem\n    const subject = new TagJsSubject(newSupport);\n    newSupport = new BaseSupport(templater, subject);\n    subject.global.insertBefore = insertBefore;\n    subject.global.placeholder = placeholder;\n    subject.global.oldest = subject.global.oldest || newSupport;\n    subject.next(templater);\n    subject.support = newSupport;\n    runBeforeRender(newSupport, undefined);\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const support = wrapper(newSupport, subject);\n    runAfterRender(newSupport, support);\n    return support;\n}\n","export * from './tag/index.js';\nexport * from './errors.js';\nexport * from './subject.types.js';\nexport * from './isInstance.js';\nexport * from './state/index.js';\nexport * from './subject/index.js';\nexport * from './tag/Support.class.js';\nexport * from './interpolations/ElementTargetEvent.interface.js';\nexport * from './interpolations/interpolateElement.js';\nexport * from './interpolations/InsertBefore.type.js';\nexport { tagElement } from './tag/tagElement.js';\nexport { Tag, variablePrefix } from './tag/Tag.class.js';\nexport { runBeforeRender } from './tag/tagRunner.js';\nexport { renderSupport } from './tag/render/renderSupport.function.js';\nexport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nexport { isLikeValueSets } from './tag/isLikeTags.function.js';\nimport { renderTagOnly } from './tag/render/renderTagOnly.function.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly,\n};\n"],"names":["ValueTypes","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","RouteQuery","name","isStaticTag","value","tag","templater","includes","tagJsType","isTagTemplater","isTagComponent","tagComponent","isTagClass","isSubjectInstance","subject","isSubject","subscribe","isTagArray","Array","every","x","combineLatest","subjects","output","Subject","subscribeWith","callback","valuesSeen","values","setValue","index","length","subscription","clones","shift","subscriptions","map","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","next","newValue","handler","methodResponse","setHandler","onSubscription","subscribers","_value","set","constructor","this","defineValueOn","countSubject","globalSubCount$","unsubscribe","findIndex","sub","splice","removeSubFromArray","add","push","getSubscription","orgCallback","lastValue","emit","subs","toPromise","Promise","res","toCallback","_subscription","pipe","operations","setMethods","all","args","arg","static","ValueSubject","super","willCallback","utils","willPromise","then","willSubscribe","getSupportInCycle","setUse","memory","stateConfig","support","use","useMe","beforeRender","beforeRedraw","afterRender","beforeDestroy","tagUse","TagError","Error","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","array","state","config","rearray","stateLength","getStateValue","initState","defaultValue","checkValue","oldState","StateEchoBack","getCallbackValue","toString","JSON","stringify","console","error","wrapper","oldStates","newStates","tagFunction","parentWrap","original","warn","item","syncStates","stateFrom","stateTo","fromValue","getSetMethod","restate","oldValue","initValue","Function","newState","global","newest","result","watch","currentValues","setupWatch","defaultFinally","init","before","final","previous","pastResult","undefined","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","method","nowSupport","setTo","oldestState","letState","makeStateResult","y","letProp","getSetProp","myProp","deepClone","makeDeepClone","WeakMap","visited","has","Date","RegExp","clone","isArray","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","getTime","isArrayDeepEqual","keys1","keys","keys2","isObjectDeepEqual","newWatch","providers","constructMethod","stateDiffMemory","stateDiff","provider","oldStateCount","instance","owner","children","cm","compareTo","inject","ownerSupport","find","msg","isLikeTags","support0","support1","templater0","templater1","tag0","tag1","strings0","strings","strings1","string","isLikeValueSets","values0","values1","runBeforeRender","runAfterRender","tagClosed$","runBeforeDestroy","deleted","hasLiveElements","childTags","filter","child","oldest","forEach","renderTagOnly","newSupport","prevSupport","oldRenderCount","renderCount","parentSupport","lastOwnerSupport","runtimeOwnerSupport","lastState","runBeforeRedraw","beforeWithRender","reSupport","variablePrefix","escapeVariable","escapeSearch","Tag","arrayValue","html","destroyTagMemory","oldSupport","destroy","context","isSimpleType","destroyArrayTag","counts","stagger","removed","getValueType","type","function","date","tagArray","unknown","cloneValueArray","props","getChildTagsToDestroy","allTags","cTag","TemplaterResult","tagged","madeChildIntoSubject","childSubject","templaterResult","kid","kidsToTagArraySubject","TagJsSubject","tagJsSubject","getNewGlobal","lastRun","destroy$","blocked","processNewTag","Support","specialAttribute","element","names","split","style","classList","remove","hasPropChanges","pastCloneProps","castedProps","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onDelete","compareOriginal","processTagResult","insertBefore","subjectTag","lastSupport","updateBy","processTagResultUpdate","fragment","buildBeforeElement","placeholder","parentNode","processTag","newSupportByTemplater","added","tagFakeTemplater","getFakeTemplater","fake","isTag","setupNewSupport","processSubjectComponent","options","label","substring","ownGlobal","preClones","reGlobal","renderWithSupport","myClones","fClone","renderSubjectComponent","castProps","stateArray","checkProp","alterProp","newProp","seen","toCall","wrap","callWith","noCycle","run","allMatched","renderSupport","callbackPropOwner","assign","getPropWrap","subValue","afterCheckProp","hasSetter","getOwnPropertyDescriptor","pastValue","updateExistingTagComponent","renderUp","oldWrapper","newWrapper","isSameTag","hasChanged","newTemplater","propsChanged","propsConfig","latestCloned","propsChanged2","kidsChanged","oldCloneKidValues","lastClonedKidValues","newClonedKidValues","hasKidsChanged","hasSupportChanged","newPropsArray","priorPropConfig","priorPropsArray","newArray","syncPriorPropFunction","syncFunctionProps","locked","isLikeTag","oldestTag","softDestroySupport","buildNewTag","afterTagRender","priorProp","oldOwnerState","useLocks","runTagCallback","bindTo","findTagToCallback","bind","callbackResult","lastResult","block","checkAfterCallbackPromise","last","renderCallbackSupport","afterTagCallback","startRegX","endRegX","isTagVar","search","processAttribute","attrName","scope","howToSet","getContextValueByVarString","processNameValueAttr","processScopedNameValueAttr","attrValue","removeAttribute","processNameOnlyAttr","isSpecialAttr","replace","reverse","join","isSpecial","action","newAttrValue","oneRender","isChildOverride","subjectFunction","bindSubjectCallback","processAttributeSubjectValue","callbackFun","fun","howToSetAttribute","setAttribute","howToSetInputValue","interpolateAttributes","attrNames","getAttributeNames","nodeName","getAttribute","interpolateReplace","processTagArray","lastArray","document","createTextNode","removeChild","setPlaceholderElm","runtimeInsertBefore","destroyArrayItem","subTag","tagClass","prevArrayValue","destroyItem","valueA","valueB","areLikeValues","previousSupport","itemSubject","setupNewTemplater","prevSubject","template","getTemplate","processAddTagArrayItem","updateBeforeTemplate","lastFirstChild","parent","textNode","castTextValue","processRegularValue","castedValue","oldClone","textContent","oneRenderToSupport","processFirstSubjectValue","v","processFirstRegularValue","swapInsertBefore","updateExistingValue","valueType","displaySubject","hasLastValue","newType","destroySimpleValue","arraySubject","wasArray","isValueTag","checkDestroyPrevious","subjectSup","newestState","prepareUpdateToComponent","isClass","valueSupport","handleStillTag","subscribeToTemplate","called","mutatingCallback","interpolateTemplate","hasAttribute","afterElmBuild","elm","textarea","match","dynamic","_elm","_name","scanTextAreaValue","diff","nextSibling","onInitDoubleWrap","oninit","onInitWrap","onInit","target","elementInitCheck","focus","select","interpolateContentTemplates","tagComponents","subChild","isRenderEndTemplate","nextTagComponent","tagName","interpolateElement","interpolatedTemplates","interpolation","content","nextTagComponents","processChildrenAttributes","interpolateString","expression","startsWith","id","interpolateToTemplates","afterInterpolateElement","container","firstChild","nextNextSibling","appendChild","buildClones","prefixSearch","BaseSupport","isApp","appElement","clonePropsBy","kidValue","latest","update","elementContainer","createDocumentFragment","tempDraw","createElement","innerHTML","thisTag","stringsMatch","updateContext","_string","variableName","updateContextItem","processNewValue","tempTag","updateConfig","updateValues","byParent","destroySubscriptions","subGlobal","resetSupport","mainPromise","promise","destroyClones","async","promises","checkCloneRemoval","customElm","ondestroy","onDestroyDoubleWrap","onDestroyWrap","onDestroy","elementDestroyCheck","version","getAppSupport","lastTemplater","lastStrings","oldLength","newLength","moveProviders","destroyUnlikeTags","handleProviderChanges","appSupport","hadChanged","tagsWithProvider","getTagsWithProvider","renderExistingTag","oldestSupport","preRenderCount","providersWithChanges","providersChangeCheck","ownerTag","selfPropChange","callbackStateUpdate","maybePromise","finally","innerCallback","a","b","c","d","e","f","callbackMaker","originalGetter","initMemory","setCurrentSupport","childrenCurrentSupport","tags","getTagWrap","originalFunction","preCastedProps","nowState","valuesValue","executeWrap","tagCount","innerTagWrap","tagIndex","route","routeProps","app","routeTag","oneRenderFunction","appElements","tagElement","appElmIndex","appElm","runWrapper","newFragment","hmr"],"sourceRoot":""}