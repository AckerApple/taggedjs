{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/cycles/getSupportInCycle.function.ts","webpack://taggedjs/./ts/render/dom/blankHandler.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/shallowPropMatch.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContexts.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processFunctionAttr.function.ts","webpack://taggedjs/./ts/tagJsVars/processAttributeUpdate.function.ts","webpack://taggedjs/./ts/tagJsVars/processSimpleAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/render/addOneContext.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/arrays/processTagArray.ts","webpack://taggedjs/./ts/tag/update/arrays/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/destroyArrayContext.function.ts","webpack://taggedjs/./ts/tag/destroyHtmlDomMeta.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/destroySupportByContextItem.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/render/runAfterRender.function.ts","webpack://taggedjs/./ts/render/callTag.function.ts","webpack://taggedjs/./ts/state/reState.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/render/checkRenderUp.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bubbleEvent.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/render/attributes/processStandAloneAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateNameOnlyAttrValue.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/render/attributes/processTagJsAttribute.function.ts","webpack://taggedjs/./ts/render/dom/processAttributeArray.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElement.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribeWith.function.ts","webpack://taggedjs/./ts/tagJsVars/processSubscribeAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/processSubscribeWithAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribeWith.function.ts","webpack://taggedjs/./ts/tag/update/handleTagTypeChangeFrom.function.ts","webpack://taggedjs/./ts/tag/update/checkStillSubscription.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/tag/update/deleteContextSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/tagJsVars/pipe.function.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/host.function.ts","webpack://taggedjs/./ts/tag/update/getOverrideTagVar.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/convertTagToElementManaged.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/onInit.function.ts","webpack://taggedjs/./ts/state/onDestroy.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tagJsVars/tagInject.function.ts","webpack://taggedjs/./ts/state/onRender.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/processUpdateSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSignal.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/promise.function.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/cycles/setContextInCycle.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/processOuterDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/elements/attributeCallables.ts","webpack://taggedjs/./ts/elements/elementFunctions.ts","webpack://taggedjs/./ts/elements/destroyDesignElement.function.ts","webpack://taggedjs/./ts/elements/processDesignElementUpdate.function.ts","webpack://taggedjs/./ts/elements/processChildren.function.ts","webpack://taggedjs/./ts/elements/processElementVarFunction.function.ts","webpack://taggedjs/./ts/elements/processElementVar.function.ts","webpack://taggedjs/./ts/elements/processDesignElementInit.function.ts","webpack://taggedjs/./ts/elements/htmlTag.function.ts","webpack://taggedjs/./ts/elements/noElement.function.ts","webpack://taggedjs/./ts/elements/index.ts","webpack://taggedjs/./ts/version.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/** Only used in TagSupport */\nexport function getNewGlobal(contextItem) {\n    // TODO: Not need for basic supports, only tag()\n    contextItem.renderCount = contextItem.renderCount || 0;\n    contextItem.varCounter = 0;\n    // TODO: Not need for basic supports, only tag()\n    contextItem.state = {\n        newer: {\n            state: [],\n            states: [],\n        },\n    };\n    return contextItem.global = {\n        blocked: [],\n    };\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","import { setUseMemory } from '../../state/index.js';\nimport { setContextInCycle } from './setContextInCycle.function.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    setContextInCycle(support.context);\n    return setUseMemory.stateConfig.support = support;\n}\n","export const blankHandler = function blankHandler() {\n    return undefined;\n};\n","import { blankHandler } from \"./dom/blankHandler.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(_promise) {\n    /*\n    if(paintRemoveAwaits.length) {\n      paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push( ...paintRemoves )\n      paintRemoves = []\n    }\n  \n    paintRemoveAwaits.push({promise, paintRemoves})\n    paintRemoves = []\n    */\n}\n// let paintRemoveAwaits: {promise: Promise<any>, paintRemoves: PaintCommand[]}[] = []\nexport let paintCommands = [];\n// export let paintRemoves: PaintCommand[] = []\nexport const paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\n/** you must lock before calling this function */\nexport function paint() {\n    if (painting.locks > 0) {\n        // throw new Error('double paint')\n        return;\n    }\n    runCycles();\n}\nfunction runCycles() {\n    ++painting.locks;\n    runPaintCycles();\n    --painting.locks;\n    runAfterCycle();\n}\n/** Deletes happen last */\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    const removes = paintRemoves.length;\n    runPaintRemoves();\n    // paintRemoves = []\n    paintRemoves.splice(0, removes);\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element, caller) {\n    paintRemoves.push([paintRemover, [element, caller]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element, _caller) {\n    const parentNode = element.parentNode;\n    /*\n    if(!element) {\n      console.debug('no element by', _caller)\n    }\n    if(!parentNode) {\n      console.debug('no parentNode by', _caller)\n    }\n    */\n    parentNode.removeChild(element);\n}\n/** insertBefore. For parent.appendChild() see paintAppend */\nexport function paintBefore(relative, element, _caller) {\n    const parentNode = relative.parentNode;\n    parentNode.insertBefore(element, relative);\n}\n/** parent.appendChild(). For insertBefore see paintBefore */\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler, _caller) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm, _caller);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm, 'paintBeforeElementString');\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n    // TODO: Start using this instead\n    return value instanceof Function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function findStateSupportUpContext(context) {\n    const stateMeta = context.state;\n    if (stateMeta && stateMeta.newest && stateMeta.newest) {\n        return stateMeta.newest;\n    }\n    if (context.parentContext) {\n        return findStateSupportUpContext(context.parentContext);\n    }\n}\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const context = component.context;\n    const stateMeta = context.state;\n    if (!stateMeta) {\n        return component;\n    }\n    return stateMeta.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevContext = prevSupport.context;\n    const stateMeta = prevContext.state;\n    const prevStateMeta = stateMeta.older;\n    // const prevStateMeta = stateMeta.newer as ContextStateSupport\n    // const prevStateMeta = stateMeta.older || stateMeta.newer as ContextStateSupport\n    const prevStates = prevStateMeta.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        oldStates.lastValues = lastValues;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState } from './stateHandlers.js';\nimport { firstStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** To be called before rendering anything with a state */\nexport function initState(context) {\n    setContextInCycle(context);\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    const state = config.state = [];\n    const states = config.states = [];\n    config.statesIndex = 0;\n    const stateMeta = context.state = context.state || {};\n    stateMeta.newer = { state, states };\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.state.length];\n    config.state.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    const context = getContextInCycle();\n    if (!context || !context.state) {\n        const msg = 'State requested but TaggedJs is not currently rendering a tag or host';\n        console.error(msg, {\n            config,\n            context,\n            function: config.support?.templater.wrapper?.original\n        });\n        throw new Error(msg);\n    }\n    const newer = context.state.newer;\n    config.state = newer.state;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.state.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    value;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n        if (arguments.length > 0) {\n            this.value = value;\n        }\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster.\n     * Once called, unsubscribe occurs.\n     * No subscription to manage UNLESS the callback will never occur THEN subscription needs to be closed with result.unsubscribe() */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        // return this 10-2025 remove\n        return subscription;\n    }\n    pipe(...operations) {\n        const args = [];\n        if ('value' in this) {\n            args.push(this.value);\n        }\n        const subject = new Subject(...args);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    _value;\n    constructor(...args) {\n        super(...args);\n        this._value = args[0];\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        state: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","import { removeContextInCycle, setContextInCycle } from './cycles/setContextInCycle.function.js';\nexport function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    for (const context of contexts) {\n        // const context = contexts[index]\n        processUpdateOneContext(values, context, support);\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\ncontextItem, ownerSupport) {\n    if (contextItem.deleted) {\n        return;\n    }\n    // some values, like style, get rearranged and there value appearance may not match context appearance\n    const valueIndex = contextItem.valueIndex;\n    const newValue = values[valueIndex];\n    // Removed, let the tagJsVars do the checking\n    // Do not continue if the value is just the same\n    /*\n    if(newValue === contextItem.value) {\n      return\n    }\n    */\n    const tagJsVar = contextItem.tagJsVar;\n    setContextInCycle(contextItem);\n    tagJsVar.processUpdate(newValue, contextItem, ownerSupport, values);\n    removeContextInCycle();\n    contextItem.value = newValue;\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const contexts = olderSupport.context.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, contexts);\n    --painting.locks;\n    paint();\n}\nfunction updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { isArray } from '../isInstance.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            // cover null and undefined\n            if (!prop && !pastProp) {\n                continue;\n            }\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = support.context.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    // global.deleted = true\n    support.context.destroy$.next();\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContexts(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContexts(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.destroy(child, ownerSupport);\n            child.deleted = true;\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = child.state.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = child.contexts;\n        // recurse\n        destroyContexts(subTags, support);\n        global.deleted = true;\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = child.state.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = child.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\ncontextItem, ownerSupport) {\n    const tagJsType = contextItem.tagJsVar.tagJsType;\n    const processUpdate = tagJsType && ['tag-conversion', 'element'].includes(tagJsType);\n    if (processUpdate) {\n        // calls processDesignElementUpdate\n        contextItem.tagJsVar.processUpdate(newValue, contextItem, ownerSupport, []);\n        contextItem.value = newValue;\n        return 0;\n    }\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    ++contextItem.updateCount;\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\n","import { removeContextInCycle, setContextInCycle } from \"../../tag/cycles/setContextInCycle.function.js\";\nexport function domProcessContextItem(value, support, contextItem, appendTo, insertBefore) {\n    const subject = support.context;\n    subject.locked = 3;\n    contextItem.target = contextItem.target || appendTo;\n    setContextInCycle(contextItem);\n    contextItem.tagJsVar.processInit(value, contextItem, support, insertBefore, appendTo);\n    removeContextInCycle();\n    contextItem.value = value;\n    delete subject.locked;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n        case 'autoSelect':\n            return 'autoselect';\n        case 'autofocus':\n        case 'autoFocus':\n            return 'autofocus';\n    }\n    return false;\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            // element.setAttribute(\"autofocus\", 'true')\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value; // style.backgroundGround\n    element.style.setProperty(smallName, value); // style.background-ground\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\n","import { isObject } from \"../../index.js\";\nimport { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    paintContent.push([setNonFunctionInputValue, [element, name, value]]);\n}\nfunction howToSetInputObjectValue(element, name, value) {\n    if (typeof element[name] !== 'object') {\n        element[name] = {};\n    }\n    // Handle object values by setting properties directly\n    for (const key in value) {\n        const subValue = value[key];\n        paintContent.push([setObjectValue, [element, name, key, subValue]]);\n    }\n    if (element[name].setProperty) {\n        for (const key in value) {\n            const subValue = value[key];\n            paintContent.push([setPropertyValue, [element, name, key, subValue]]);\n        }\n    }\n}\nexport function howToSetStandAloneAttr(element, name, _value) {\n    element.setAttribute(name, '');\n}\nexport function setNonFunctionInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used for checked, selected, and so on */\nexport function setBooleanAttribute(element, name, value) {\n    if (value) {\n        element[name] = true;\n    }\n    else {\n        element[name] = false;\n    }\n}\nexport function setSimpleAttribute(element, name, value) {\n    // for checked=true\n    ;\n    element[name] = value;\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\nfunction setPropertyValue(element, name, key, value) {\n    ;\n    element[name].setProperty(key, value);\n}\n/** main processor for things like <div style=${{ maxWidth: '100vw' }}> */\nfunction setObjectValue(element, name, key, value) {\n    ;\n    element[name][key] = value;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { setNonFunctionInputValue } from './howToSetInputValue.function.js';\nimport { processFunctionAttr } from './processFunctionAttr.function.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial) {\n    contextItem.target = element;\n    contextItem.howToSet = howToSet;\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    if (value?.tagJsType) {\n        return processTagJsAttribute(attrName, value, contextItem, support, element);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, contextItem);\n}\nfunction processTagJsAttribute(name, value, contextItem, ownerSupport, element) {\n    value.processInitAttribute(name, value, element, value, contextItem, ownerSupport, setNonFunctionInputValue);\n    contextItem.tagJsVar = value;\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, context) {\n    if (typeof value === 'function') {\n        return processFunctionAttr(value, context, attrName, element, howToSet);\n    }\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n","import { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { Subject, valueToTagJsVar } from '../../index.js';\n/** Used for bolts like div.style(() => {{backgroundColor:}}) */\nexport function processFunctionAttr(value, parentContext, // parent context\nattrName, element, howToSet) {\n    const innerValue = value();\n    const tagJsVarOverride = {\n        tagJsType: 'dynamic-attr',\n        matchesInjection: (inject) => {\n            const tagJsVar = subContext.tagJsVar;\n            if (tagJsVar.matchesInjection) {\n                const rtn = tagJsVar.matchesInjection(inject, subContext);\n                return rtn;\n            }\n        },\n        hasValueChanged: (_value, _contextItem, ownerSupport) => {\n            const newValue = value();\n            return subContext.tagJsVar.hasValueChanged(newValue, subContext, ownerSupport);\n        },\n        processInit: blankHandler,\n        processInitAttribute: blankHandler,\n        destroy: (_contextItem, ownerSupport) => {\n            subContext.tagJsVar.destroy(subContext, ownerSupport);\n        },\n        processUpdate: (value, contextItem, ownerSupport, values) => {\n            ++contextItem.updateCount;\n            const newValue = value();\n            // const oldValue = subContext.value\n            // const newTagJsVar = valueToTagJsVar(newValue)\n            subContext.tagJsVar.processUpdate(newValue, // newTagJsVar as any,\n            subContext, ownerSupport, values);\n            subContext.value = newValue;\n        }\n    };\n    const subContext = {\n        updateCount: 0,\n        isAttr: true,\n        target: element,\n        parentContext,\n        value: innerValue, // used for new value comparing\n        tagJsVar: valueToTagJsVar(innerValue),\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        contexts: [subContext],\n        target: element,\n        parentContext,\n        value,\n        tagJsVar: tagJsVarOverride,\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    subContext.tagJsVar.processInitAttribute(attrName, innerValue, element, subContext.tagJsVar, subContext, {}, howToSet);\n    return contextItem;\n}\n","import { valueToTagJsVar } from \"./valueToTagJsVar.function.js\";\nexport function processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet) {\n    const oldTag = contextItem.tagJsVar; // contextItem.tagJsVar as TagJsVar\n    const tagValue = value;\n    const checkResult = oldTag.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n    ownerSupport);\n    if (checkResult > 0) {\n        oldTag.destroy(contextItem, ownerSupport);\n        element.removeAttribute(name);\n        const newTagVar = valueToTagJsVar(value);\n        newTagVar.isAttr = true;\n        newTagVar.processInitAttribute(name, value, element, newTagVar, contextItem, ownerSupport, howToSet);\n        contextItem.tagJsVar = newTagVar;\n        return;\n    }\n}\n","import { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { checkSimpleValueChange, deleteSimpleAttribute } from \"./getSimpleTagVar.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\n/** init runner */\nexport function processSimpleAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, contextItem, _ownerSupport, howToSet) {\n    // function swapping\n    tagJsVar.destroy = deleteSimpleAttribute;\n    tagJsVar.hasValueChanged = checkSimpleValueChange;\n    tagJsVar.processUpdate = (value, contextItem, ownerSupport) => {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet);\n    };\n    const isSpecial = isSpecialAttr(name);\n    processNonDynamicAttr(name, value, element, howToSet, isSpecial, contextItem);\n    contextItem.tagJsVar = tagJsVar;\n}\n","import { forceUpdateExistingValue } from \"../index.js\";\nimport { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { processSimpleAttribute } from \"./processSimpleAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nexport function deleteSimpleAttribute(contextItem) {\n    const element = contextItem.target;\n    const name = contextItem.attrName;\n    element.removeAttribute(name);\n}\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInitAttribute: processSimpleAttribute,\n        processInit: processSimpleValueInit,\n        destroy: deleteSimpleValue,\n        // TODO: get to using only checkSimpleValueChange\n        hasValueChanged: checkUpdateDeleteSimpleValueChange, // For attributes, this gets switched to checkSimpleValueChange\n        processUpdate: processStringUpdate, // For attributes, this gets switched to processAttributeUpdate\n        // processUpdate: tagValueUpdateHandler, // For attributes, this gets switched to processAttributeUpdate\n    };\n}\nfunction processStringUpdate(newValue, // newValue\ncontextItem, ownerSupport) {\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, insertBefore, _appendTo) {\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processSimpleValueInit']];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(context) {\n    if (!context.simpleValueElm && context.paint) {\n        context.paint[0] = blankHandler;\n        return; // I'm being deleted before my first render even occurred\n    }\n    const elm = context.simpleValueElm;\n    delete context.simpleValueElm;\n    addPaintRemover(elm, 'deleteSimpleValue');\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || newValue === contextItem.value; // !(typeof(newValue) === BasicTypes.object)\n    if (isRegularUpdate) {\n        return 0; // no need to destroy, just update display\n    }\n    return 6; // 'changed-simple-value'\n}\nexport function checkUpdateDeleteSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || !(typeof (newValue) === BasicTypes.object);\n    if (isRegularUpdate) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return 0; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processNowRegularValue']];\n    paintCommands.push(paint);\n}\n","import { isArray } from '../isInstance.js';\nimport { destroyArrayContext } from './destroyArrayContext.function.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContext(subject);\n        return 9; // 'array'\n    }\n    return 0;\n}\n","import { checkArrayValueChange } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/arrays/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroyArrayContext } from '../tag/destroyArrayContext.function.js';\n/** how to process an array */\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInitAttribute: blankHandler,\n        processInit: processArrayInit,\n        processUpdate: processArrayUpdates,\n        hasValueChanged: checkArrayValueChange,\n        destroy: destroyArrayContext,\n    };\n}\nfunction processArrayUpdates(newValue, contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    if (Array.isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport);\n        return;\n    }\n    const tagUpdateResponse = tagValueUpdateHandler(newValue, contextItem, ownerSupport);\n    if (tagUpdateResponse === 0) {\n        processTagArray(contextItem, newValue, ownerSupport);\n    }\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","import { Subject } from '../subject/Subject.class.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\nexport function getNewContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = {\n        updateCount: 0,\n        value,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n        parentContext,\n        // TODO: remove with html``\n        // valueIndex: contexts?.length || -1, // when -1 its a raw bolt value\n        // valueIndex: contexts.length\n        valueIndex: parentContext.varCounter,\n    };\n    return contextItem;\n}\n/** auto adds onto parent.contexts */\nexport function addOneContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = getNewContext(value, contexts, withinOwnerElement, parentContext);\n    contexts.push(contextItem);\n    ++parentContext.varCounter;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { getNewContext } from '../../render/addOneContext.function.js';\n/** Used by arrays and subcontext creators like subscribe. Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, contexts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = getNewContext(value, contexts, true, ownerSupport.context);\n    contextItem.withinOwnerElement = false;\n    contextItem.placeholder = element;\n    if (!appendTo) {\n        contextItem.placeholder = insertBefore;\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from '../tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from '../createAndProcessContextItem.function.js';\nexport function processTagArray(contextItem, value, // arry of Tag classes\nownerSupport, appendTo) {\n    const noLast = contextItem.lastArray === undefined;\n    if (noLast) {\n        contextItem.lastArray = [];\n    }\n    const lastArray = contextItem.lastArray;\n    let runtimeInsertBefore = contextItem.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        contextItem.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, contextItem.lastArray, ownerSupport, runtimeInsertBefore, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\n/** new and old array items processed here */\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\nappendTo) {\n    const item = castArrayItem(array[index]);\n    const previousContext = lastArray[index];\n    if (previousContext) {\n        return reviewPreviousArrayItem(item, previousContext, lastArray, ownerSupport, index, runtimeInsertBefore, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, context, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\nappendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        if (Array.isArray(value)) {\n            context.tagJsVar.processUpdate(value, context, ownerSupport, []);\n            context.value = value;\n            return context;\n        }\n        tagValueUpdateHandler(value, context, ownerSupport);\n        return context;\n    }\n    // NEW REPLACEMENT\n    const contextItem = createAndProcessContextItem(value, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nexport function castArrayItem(item) {\n    const isBasicFun = typeof item === 'function' && item.tagJsType === undefined;\n    if (isBasicFun) {\n        const fun = item;\n        item = fun();\n    }\n    return item;\n}\n","import { destroySupport } from '../../../render/destroySupport.function.js';\nimport { castArrayItem } from './processTagArray.js';\n/** 1 = destroyed, 2 = value changes, 0 = no change */\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = castArrayItem(value[index]);\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(context) {\n    const global = context.global;\n    destroyArrayItemByGlobal(global, context);\n}\nfunction destroyArrayItemByGlobal(global, context) {\n    if (global && context.state?.oldest) {\n        const support = context.state.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    context.tagJsVar.destroy(context, {});\n}\n","import { destroyArrayItem } from './update/arrays/compareArrayItems.function.js';\nexport function destroyArrayContext(context) {\n    ++context.updateCount;\n    const lastArray = context.lastArray;\n    destroyArray(context, lastArray);\n}\n/** Deletes entire array context not just one */\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { addPaintRemover } from '../render/paint.function.js';\n/** Destroy dom elements and dom space markers */\nexport function destroyHtmlDomMeta(htmlDomMeta) {\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker, 'destroyMarker');\n    }\n    const dom = clone.domElement;\n    addPaintRemover(dom, 'destroyClone');\n}\n","import { destroyArray } from './destroyArrayContext.function.js';\nimport { addPaintRemover } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from './destroyHtmlDomMeta.function.js';\nimport { isPromise } from '../index.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(context, allPromises) {\n    const subContexts = context.contexts;\n    smartRemoveByContext(subContexts, allPromises);\n    destroyContextHtml(context);\n}\nexport function destroyContextHtml(context) {\n    destroyHtmlDomMeta(context.htmlDomMeta);\n}\nfunction smartRemoveByContext(contexts, allPromises) {\n    for (const context of contexts) {\n        if (context.withinOwnerElement) {\n            const tagJsVar = context.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = context.supportOwner;\n                const hostDestroy = tagJsVar.destroy(context, newest);\n                if (isPromise(hostDestroy)) {\n                    allPromises.push(hostDestroy);\n                }\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = context.lastArray;\n        if (lastArray) {\n            destroyArray(context, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = context.simpleValueElm;\n        if (elm) {\n            delete context.simpleValueElm;\n            addPaintRemover(elm, 'smartRemoveByContext');\n            continue;\n        }\n        const subGlobal = context.global;\n        if (subGlobal === undefined) {\n            continue; // context\n        }\n        subGlobal.deleted = true;\n        const oldest = context.state?.oldest;\n        if (oldest) {\n            smartRemoveKids(context, allPromises);\n            continue;\n        }\n    }\n}\n","import { destroyContexts } from '../tag/destroyContexts.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const context = support.context;\n    global.deleted = true;\n    context.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const subContexts = context.contexts;\n    destroyContexts(subContexts, support);\n    // tag() only destroy\n    if (support.templater.wrapper) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(context, promises);\n    delete context.state;\n    delete context.contexts;\n    delete context.returnValue;\n    delete context.providers;\n    return promises;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { destroySupport } from '../render/destroySupport.function.js';\nexport function destroySupportByContextItem(context) {\n    ++context.updateCount;\n    const global = context.global;\n    const state = context.state;\n    const lastSupport = state.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    destroySupportContext(context);\n}\nfunction destroySupportContext(context) {\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    delete context.contexts;\n    delete context.state;\n    delete context.global;\n    context.renderCount = 0;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** When return > 0 then its the same tag */\nexport function checkTagValueChange(newValue, contextItem) {\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            return 7; // 'tag-swap'\n        }\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        if (newValue.wrapper?.original === contextItem.value.wrapper?.original) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    // destroySupportByContextItem(contextItem)\n    return 8; // 'no-longer-tag'\n}\n/*\nexport function checkTagValueChangeAndUpdate(\n  newValue: unknown,\n  contextItem: ContextItem,\n) {\n  const checkValue = checkTagValueChange(newValue, contextItem)\n\n  const global = contextItem.global as SupportTagGlobal\n  const lastSupport = contextItem.state?.newest as AnySupport\n  \n  if(checkValue === 7) {\n    destroySupport(lastSupport, global)\n    getNewGlobal(contextItem as SupportContextItem)\n    return 7 // 'tag-swap'\n  }\n  \n  if(checkValue === 8) {\n    destroySupportByContextItem(contextItem)\n    return 8\n  }\n\n  const isValueTag = isStaticTag(newValue)\n  if(isValueTag) {\n    // always cause a redraw of static tags (was false)\n    tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      lastSupport as AnySupport,\n    )\n\n    return 0\n  }\n\n  const isTag = (newValue as any)?.tagJsType\n  if(isTag) {\n    const state = contextItem.state as ContextStateMeta\n    const support = state.newest as AnySupport\n    const ownerSupport = support.ownerSupport as AnySupport\n    const result = tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      ownerSupport,\n    )\n\n    const doNotRedraw = result === true\n\n    if(doNotRedraw) {\n      return 0\n    }\n\n    return 88 // its same tag with new values\n  }\n\n  destroySupportByContextItem(contextItem)\n  return 8\n}\n*/\nexport function checkTagValueChangeAndUpdate(newValue, contextItem) {\n    const global = contextItem.global;\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport);\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const state = contextItem.state;\n        const support = state.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/addOneContext.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, contexts, support, // owner\nparentContext, depth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, contexts, isWithinOwnerElement, parentContext);\n    contextItem.placeholder = marker;\n    contextItem.target = appendTo;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([\n            paintBefore, [insertBefore, marker, 'attachDynamicDom.attachDynamicDom']\n        ]);\n    }\n    domProcessContextItem(value, support, contextItem, appendTo, insertBefore);\n    return contextItem;\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\n/** Called when one tag changes and we need to find other tags that will need to be rendered */\nexport function providersChangeCheck(support) {\n    const context = support.context;\n    const providers = context.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../cycles/getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, currentDepth) {\n    return props;\n    return props.map(function eachCastProp(prop, pos) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, currentDepth, pos);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth, pos // arguments position\n) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth, pos);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, pos, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth, pos);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth, pos);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth, pos) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth, pos // argument position\n) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport, pos) {\n    // restore object to have original function on destroy\n    if (depth <= 0) {\n        return;\n    }\n    const context = newSupport.context;\n    const castedProps = context.value?.props;\n    if (castedProps) {\n        // check for old prop subscription\n        const prop = castedProps[pos][index];\n        if (prop?.subscription) {\n            prop.subscription(); // unsubscribe to prevent this old argument/prop from being called on destroy\n            prop.restore(); // put original value back\n        }\n    }\n    const altPropRestore = () => {\n        newProp[index] = originalValue;\n    };\n    newProp[index].subscription = newSupport.context.destroy$.toCallback(altPropRestore);\n    newProp[index].restore = altPropRestore;\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const ownerContext = ownerSupport.context;\n    const newest = ownerContext.state?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const context = newest.context;\n        const global = context.global;\n        if (context.locked) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        if (!global) {\n            /*\n            context.tagJsVar.processUpdate(\n              context.value,\n              context,\n              ownerSupport,\n              [],\n            )\n      */\n            ownerContext.tagJsVar.processUpdate(ownerContext.value, ownerContext, ownerSupport, []);\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = subject.state.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    if (!global || !subject.state.newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    const newest = subject.state.newest;\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const context = oldSupport.context;\n    const global = context.global;\n    let pIndex = -1;\n    const providers = context.providers = context.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = contextItem.state.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n}\n","import { hasPropChanges } from './hasPropChanges.function.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContexts.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const context = lastSupport.context;\n    const global = context.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(context.contexts);\n    softDestroyOne(context);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(child.context);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(context);\n}\nfunction softDestroyOne(context) {\n    context.global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(context, []);\n    delete context.contexts;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // tag returns another function expected to be called\n        if (typeof (tag) === BasicTypes.function && tag.tagJsType === undefined) {\n            tag = tag();\n        }\n    }\n    useSupport.context.returnValue = tag;\n    useSupport.returnValue = tag;\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.context.state.newer = { ...config };\n    removeContextInCycle();\n    return useSupport;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterSupportRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    runAfterRender(support.context);\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n/** run after rendering anything with state */\nexport function runAfterRender(context) {\n    saveState(context);\n    // TODO: prove this is worth having\n    // checkStateMismatch(config, support)\n    clearStateConfig();\n    // setUseMemory.tagClosed$.next(ownerSupport)\n}\nfunction saveState(context) {\n    const config = setUseMemory.stateConfig;\n    const subject = context || config.context;\n    subject.state = subject.state || {};\n    subject.state.newer = { ...config };\n    const support = config.support;\n    subject.state.newest = support;\n}\nexport function clearStateConfig() {\n    const config = setUseMemory.stateConfig;\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.state;\n    delete config.states;\n    removeContextInCycle();\n}\n","import { ValueTypes } from '../tag/index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { runAfterSupportRender } from './runAfterRender.function.js';\nexport function callTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    let reSupport;\n    const templater = newSupport.templater;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, context, ownerSupport, newSupport.appSupport);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, context, prevSupport);\n    }\n    runAfterSupportRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\n","import { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { runRestate } from './stateHandlers.js';\nimport { reStatesHandler } from './states.utils.js';\nexport function reState(context) {\n    setContextInCycle(context);\n    const stateMeta = context.state;\n    return reStateByPrev(stateMeta.newer.state);\n}\nexport function reStateByPrev(prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.state = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    return config;\n}\nexport function reStateSupport(newSupport, prevSupport, prevState) {\n    reStateByPrev(prevState);\n    const config = setUseMemory.stateConfig;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\n","import { initState } from '../state/state.utils.js';\nimport { callTag } from './callTag.function.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { reStateSupport } from '../state/reState.function.js';\nexport function reRenderTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    const stateMeta = context.state;\n    const prevState = stateMeta.older.state;\n    reStateSupport(newSupport, prevSupport, prevState);\n    return callTag(newSupport, prevSupport, context, ownerSupport);\n}\n/** Used during first renders of a support */\nexport function firstTagRender(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    initState(newSupport.context);\n    setSupportInCycle(newSupport);\n    const result = callTag(newSupport, prevSupport, context, ownerSupport);\n    removeContextInCycle();\n    return result;\n}\nexport function getSupportOlderState(support) {\n    const context = support?.context;\n    const stateMeta = context?.state;\n    return stateMeta?.older?.state;\n}\n/*\nexport function getSupportNewerState(support?: AnySupport) {\n  const context = support?.context as SupportContextItem\n  const stateMeta = context?.state\n  return stateMeta?.newer?.state\n}\n*/ \n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { firstTagRender, getSupportOlderState, reRenderTag } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\ncontext) {\n    let reSupport;\n    const olderState = getSupportOlderState(lastSupport);\n    // const olderState = getSupportNewerState(lastSupport)\n    if (olderState) {\n        reSupport = reRenderTag(newSupport, lastSupport, context);\n    }\n    else {\n        reSupport = firstTagRender(newSupport, lastSupport, context);\n    }\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const context = reSupport.context;\n        context.state.oldest = reSupport;\n        context.state.newest = reSupport;\n        // context.state.older = context.state.newer\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && context.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n        // context.state.older = context.state.newer\n        // context.state.newer = context.state.older\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return {\n        support: reSupport,\n        wasLikeTags: isLikeTag\n    };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    if (result.wasLikeTags) {\n        const oldest = subject.state.oldest; // || result.support\n        updateSupportBy(oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject);\n}\n","import { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = 4;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(subject.state.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownContext = ownerSupport.context;\n    const newest = ownContext.state.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch } from '../tag/hasSupportChanged.function.js';\nimport { shallowPropMatch } from '../tag/shallowPropMatch.function.js';\nexport function checkRenderUp(templater, support) {\n    const global = support.context.global;\n    if (global && global.deleted) {\n        return false;\n    }\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { checkRenderUp } from \"../../render/checkRenderUp.function.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const global = support.context.global;\n    if (global && global.deleted === true) {\n        return supports;\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const providers = newSupport.context.providers;\n    if (providers) {\n        const proSupports = providersChangeCheck(newSupport);\n        supports.push(...proSupports);\n    }\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const context = support.context;\n    const global = context.global;\n    if (!global) {\n        context.tagJsVar.processUpdate(context.value, context, support.ownerSupport, []);\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    const stateMeta = context.state;\n    renderSupport(stateMeta.newest);\n}\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    const stateMeta = support.context.state;\n    const newestStateMeta = newestSupport.context.state;\n    const fromStates = stateMeta.newer.states;\n    const toStates = newestStateMeta.newer.states;\n    return syncStatesArray(fromStates, toStates);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        subject.locked = 2;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const subject = last.context;\n        const global = subject.global;\n        delete subject.locked;\n        if (subject.deleted === true || global?.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, subject.state.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = 1; // prevent another render from re-rendering this tag\n    // ++painting.locks\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.context.state.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    // --painting.locks\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, last) {\n    const global = last.context.global;\n    if (global?.deleted) {\n        return;\n    }\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","export function bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.originalStopPropagation = event.stopPropagation;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n            event.stopPropagation = event.originalStopPropagation;\n            delete event.originalStopPropagation;\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { bubbleEvent } from './bubbleEvent.function.js';\nexport function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    const replaceEventName = getEventReferenceName(eventName);\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const context = support.context;\n    const eventReg = context.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nexport function getEventReferenceName(eventName) {\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    return '_' + eventName;\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { BasicTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { processAttribute } from './processAttribute.function.js';\n// single/stand alone attributes\nexport function processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    const newContexts = [];\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const isSpecial = isSpecialAttr(name); // only object variables are evaluated for is special attr\n            const value = attrValue[name];\n            const howToSet = setNonFunctionInputValue;\n            const subContext = processAttribute(name, value, values, element, ownerSupport, howToSet, contexts, parentContext, isSpecial);\n            if (subContext !== undefined) {\n                if (Array.isArray(subContext)) {\n                    newContexts.push(...subContext);\n                }\n                else {\n                    newContexts.push(subContext);\n                }\n            }\n        }\n        return newContexts;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processStandAloneAttribute } from '../../render/attributes/processStandAloneAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue) || attrValue === '') {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    const standAloneResult = processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext);\n    if (standAloneResult) {\n        contexts.push(...standAloneResult);\n    }\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateNameOnlyAttrValue.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\n/** Currently universally used for all attributes */\nexport function processUpdateAttrContext(value, contextItem, ownerSupport, values) {\n    const attrContextItem = contextItem;\n    const tagValue = value;\n    if (tagValue?.tagJsType) {\n        const oldValue = contextItem.value;\n        // its now a tagVar value but before was not\n        if (!oldValue?.tagJsType) {\n            tagValue.isAttr = true;\n            setContextInCycle(contextItem);\n            tagValue.processInitAttribute(attrContextItem.attrName, value, attrContextItem.target, tagValue, attrContextItem, ownerSupport, setNonFunctionInputValue);\n            removeContextInCycle();\n            attrContextItem.tagJsVar = tagValue;\n            return;\n        }\n        oldValue.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n        ownerSupport);\n        return;\n    }\n    if (attrContextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, attrContextItem.value, attrContextItem.target, // global.element as Element,\n        ownerSupport, attrContextItem.howToSet, [], // Context, but we dont want to alter current\n        attrContextItem.parentContext);\n        attrContextItem.value = value;\n        return;\n    }\n    const element = attrContextItem.target;\n    processAttributeEmit(value, attrContextItem.attrName, attrContextItem, element, ownerSupport, attrContextItem.howToSet, attrContextItem.isSpecial);\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { processStandAloneAttribute } from './processStandAloneAttribute.function.js';\nimport { processTagJsVarAttribute } from './processTagJsAttribute.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(attrName, value, values, // all the variables inside html``\nelement, support, howToSet, //  = howToSetInputValue\ncontexts, parentContext, isSpecial) {\n    const varIndex = getTagJsVar(attrName);\n    let isNameVar = varIndex >= 0 || (value === undefined && typeof (attrName) !== 'string');\n    let valueInValues = values[varIndex];\n    // value or name from bolt?\n    if (value?.tagJsType) {\n        valueInValues = value; // the value is a tagJsVar\n    }\n    else if (attrName?.tagJsType) {\n        isNameVar = true;\n        valueInValues = attrName; // the name is a tagJsVar\n        value = attrName;\n    }\n    const tagJsVar = valueInValues;\n    if (tagJsVar?.tagJsType) {\n        return processTagJsVarAttribute(value, [], // contexts,\n        parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar);\n    }\n    if (isNameVar) {\n        // old way of setting by html``\n        if (varIndex === -1 && isNameVar) {\n            valueInValues = attrName; // its a name only value attribute\n        }\n        const contextItem = getNewContext(valueInValues, [], // contexts,\n        true, parentContext);\n        contextItem.valueIndex = varIndex;\n        contextItem.isAttr = true;\n        contextItem.target = element;\n        contextItem.isNameOnly = true;\n        contextItem.howToSet = howToSet;\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // single/stand alone attributes\n        const aloneResult = processStandAloneAttribute(values, valueInValues, element, support, howToSet, contexts, parentContext);\n        if (aloneResult) {\n            contexts.push(...aloneResult);\n        }\n        return contextItem;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, [], // contexts,\n        howToSet, values, support.context);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, [], // contexts,\n        parentContext, howToSet, support, isSpecial, valueVar);\n    }\n    // simple name/value attribute\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, parentContext);\n}\n/** Only used during updates */\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, _subject) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(\n        // subject,\n        newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processTagCallbackFun(\n// subject: AttributeContextItem,\nnewAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    // const tagJsVar = subject.tagJsVar // = valueToTagJsVar(newAttrValue)\n    // tagJsVar.processUpdate = processUpdateAttrContext\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/index.js';\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { Subject } from '../../subject/Subject.class.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, contexts, howToSet, //  = howToSetInputValue\nvalues, parentContext) {\n    const startIndex = contexts.length;\n    const createdContexts = [];\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = contexts.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                updateCount: 0,\n                isAttr: true,\n                target: element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n                valueIndex: parentContext.varCounter, // contexts.length,\n                parentContext,\n                destroy$: new Subject(),\n                render$: new Subject(),\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHandler(value, contextItem, newSupport, newValues) {\n                ++contextItem.updateCount;\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            createdContexts.push(contextItem);\n            ++parentContext.varCounter;\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n    return createdContexts;\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, parentContext, howToSet, //  = howToSetInputValue\nsupport, isSpecial, varIndex) {\n    if (typeof (value) === BasicTypes.function) {\n        ++parentContext.varCounter;\n        return processTagCallbackFun(\n        // contextItem,\n        value, support, attrName, element);\n    }\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        target: element,\n        attrName,\n        howToSet,\n        value,\n        withinOwnerElement: true,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        valueIndex: varIndex,\n        parentContext,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial);\n    contextItem.value = value;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** adds onto parent.contexts */\nexport function processTagJsVarAttribute(value, contexts, parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar) {\n    // getOneContext\n    const contextItem = getNewContext(value, contexts || [], true, parentContext);\n    contextItem.target = element;\n    contextItem.valueIndex = varIndex;\n    contextItem.isAttr = true;\n    contextItem.isNameOnly = isNameVar;\n    contextItem.stateOwner = getSupportWithState(support);\n    contextItem.supportOwner = support;\n    setContextInCycle(contextItem);\n    tagJsVar.processInitAttribute(attrName, value, // tagJsVar,\n    element, tagJsVar, contextItem, support, setNonFunctionInputValue);\n    removeContextInCycle();\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = tagJsVar;\n    return contextItem;\n}\n","import { howToSetStandAloneAttr, setNonFunctionInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nexport function processAttributeArray(attrs, values, domElement, support, \n// contexts: ContextItem[],\nparentContext) {\n    for (const attr of attrs) {\n        const name = attr[0];\n        const value = attr[1];\n        // const isSpecial2 = !value?.tagJsVar && (typeof(name) === 'string' && isSpecialAttr(name))\n        const isSpecial = attr[2] || false; // isSpecial2\n        let howToSet = attr.length > 1 ? setNonFunctionInputValue : howToSetStandAloneAttr;\n        if (attr[3]) {\n            howToSet = attr[3];\n        }\n        // const contexts = support.context.contexts\n        const contexts = parentContext.contexts;\n        const newContext = processAttribute(name, value, values, domElement, support, howToSet, contexts, parentContext, isSpecial) || undefined;\n        if (typeof newContext === 'object') {\n            contexts.push(newContext);\n            ++parentContext.varCounter;\n        }\n    }\n}\n","import { paintAppends, paintAppend, paintCommands, paintBefore } from \"../paint.function.js\";\nimport { processAttributeArray } from \"./processAttributeArray.function.js\";\nexport function attachDomElement(domElement, node, values, support, parentContext, appendTo, insertBefore) {\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        processAttributeArray(node.at, values, domElement, support, \n        // contexts,\n        parentContext);\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement, 'appendToAttachDomElement']]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement, 'insertBeforeAttachDomElement']]);\n    }\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppendElementString, paintAppends, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nimport { attachDomElement } from \"./attachDomElement.function.js\";\nimport { Subject } from \"../../subject/Subject.class.js\";\nimport { isFunction } from \"../../index.js\";\nexport function attachDomElements(nodes, values, support, parentContext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const context = support.context;\n    const contexts = context.contexts;\n    parentContext = context;\n    // const contexts = parentContext.contexts\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    // loop map of elements that need to be put down on document\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const v = node.v;\n        const isNum = !isNaN(v);\n        if (isNum) {\n            // const valueIndex = context.varCounter // contexts.length\n            // const valueIndex = (parentContext as SupportContextItem).varCounter // contexts.length\n            const valueIndex = Number(v); // (parentContext as SupportContextItem).varCounter // contexts.length\n            const realValue = values[valueIndex];\n            const isSkipFun = isFunction(realValue) && realValue.tagJsType === undefined;\n            if (isSkipFun) {\n                ++parentContext.varCounter;\n                // TODO: I dont think we ever get in here?\n                continue;\n            }\n            const contextItem = attachDynamicDom(realValue, contexts, support, parentContext, depth, appendTo, insertBefore);\n            contextItem.valueIndex = valueIndex;\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        const domElement = newNode.domElement = document.createElement(node.nn);\n        // Create parent context for attributes first\n        const newParentContext = {\n            updateCount: 0,\n            isAttrs: true,\n            target: domElement,\n            parentContext,\n            contexts: [],\n            destroy$: new Subject(),\n            render$: new Subject(),\n            tagJsVar: {\n                tagJsType: 'new-parent-context'\n            },\n            valueIndex: -1,\n            withinOwnerElement: true,\n        };\n        newParentContext.varCounter = 0;\n        // one single html element. This is where attribute processing takes place\n        attachDomElement(domElement, node, values, support, newParentContext, appendTo, insertBefore);\n        // Update parent context with element and attribute contexts\n        newParentContext.target = domElement;\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, newParentContext, \n            // contexts,\n            depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, contexts };\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Merges strings & values with dom meta into a html array tree */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, appendTo, insertBefore) {\n    const subject = support.context;\n    // TODO this is only needed for components and not basic tags\n    subject.state = subject.state || {};\n    const stateMeta = subject.state;\n    stateMeta.oldest = support;\n    stateMeta.newest = support;\n    subject.state.older = subject.state.newer;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, support.context, appendTo, insertBefore);\n    subject.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, parentContext, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const context = support.context;\n    parentContext = context;\n    context.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, parentContext, 0, // depth\n    appendTo, insertBefore);\n    return result;\n}\n/** Extracts variables from support in order to merge strings & values with dom meta into a html array tree */\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChangeAndUpdate } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\nimport { blankHandler } from '../dom/blankHandler.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem) {\n    const support = contextItem.state.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInitAttribute: blankHandler,\n        processInit: processTagInit,\n        processUpdate: blankHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: blankHandler,\n        propWatch: 'shallow', // deprecate\n        key: blankHandler,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    subject.contexts = subject.contexts || [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\nappendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker, 'subMarker']]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement, 'subAppendTo']]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement, 'subInsertBefore']]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.state = {};\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processInitAttribute: blankHandler,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        },\n        matchesInjection(inject, context) {\n            if (templater.wrapper === inject) {\n                return context;\n            }\n            if (templater.wrapper?.original === inject?.original) {\n                return context;\n            }\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, subject, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { firstTagRender } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    firstTagRender(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, appendTo, insertBefore);\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribeWith(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    const subContext = setupSubscribe(value, contextItem, ownerSupport, insertBefore, appendTo);\n    if (!subContext.hasEmitted) {\n        emitSubContext(value, subContext);\n    }\n    return subContext;\n}\nexport function emitSubContext(value, subContext) {\n    const observables = value.Observables;\n    const observable = observables[0];\n    if (!subContext.hasEmitted) {\n        if ('withDefault' in value) {\n            subContext.subValueHandler(value.withDefault, 0);\n            return;\n        }\n        if ('value' in observable) {\n            subContext.subValueHandler(observable.value, 0);\n            return;\n        }\n        return; // nothing to emit\n    }\n    const emitValue = subContext.lastValues[0].value;\n    subContext.subValueHandler(emitValue, 0);\n}\n","import { setNonFunctionInputValue } from \"../index.js\";\nimport { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { unsubscribeContext, checkToPaint, setupSubscribeCallbackProcessor } from \"../tag/update/setupSubscribe.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\nexport function processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // same as value\ncontextItem, ownerSupport) {\n    // change how the delete occurs\n    value.destroy = unsubscribeContext;\n    const isSpecial = isSpecialAttr(name);\n    const onOutput = function onSubValue(callbackValue, syncRun) {\n        processNonDynamicAttr(name, callbackValue, element, setNonFunctionInputValue, isSpecial, contextItem);\n        checkToPaint(syncRun);\n    };\n    const subContext = setupSubscribeCallbackProcessor(value.Observables, ownerSupport, onOutput, value, contextItem);\n    contextItem.subContext = subContext;\n    contextItem.value = value;\n    contextItem.tagJsVar = value;\n    value.processUpdate = function processAttributeUpdateWrap(value, contextItem2, ownerSupport) {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, setNonFunctionInputValue);\n    };\n    return { subContext, onOutput };\n}\n","import { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nexport function processSubscribeWithAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // its the same as the value\ncontextItem, ownerSupport) {\n    const { subContext } = processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\n    element, value, contextItem, ownerSupport);\n    if (!subContext.hasEmitted) {\n        emitSubScriptionAsIs(value, subContext);\n    }\n}\nexport function emitSubScriptionAsIs(value, subContext) {\n    const tagJsVar = subContext.tagJsVar;\n    const onOutput = tagJsVar.onOutput; // value.onOutput\n    const observables = value.Observables;\n    let obValue = observables[0]?.value || value.withDefault;\n    // subContext.hasEmitted = true\n    // subContext.lastValues[0] = obValue\n    if (value.callback) {\n        obValue = value.callback(obValue);\n    }\n    onOutput(obValue, true, subContext);\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribeWith.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { processSubscribeWithAttribute } from \"./processSubscribeWithAttribute.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    // const support = getSupportInCycle() as AnySupport\n    // const context = getSupportWithState(support).context\n    /*\n    const context = getContextInCycle() as ContextItem\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        onOutput: blankHandler, // this gets set within setupSubscribe\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeWithAttribute,\n        processInit: processSubscribeWith,\n        hasValueChanged: checkSubscribeValueChanged,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        // states: newer.states,\n        Observables: [Observable],\n    };\n}\n/** checks is a previous tag var was a subscription but now has changed */\nexport function checkSubscribeValueChanged(value, contextItem) {\n    if (!value?.tagJsType) {\n        return 1; // its not a subscription anymore\n    }\n    const newObserves = value.Observables;\n    if (!newObserves) {\n        return 2; // its not a subscription anymore\n    }\n    const oldValue = contextItem.value;\n    const oldObserves = oldValue.Observables;\n    if (!oldObserves || oldObserves.length !== newObserves.length) {\n        return 3; // not the same subscription\n    }\n    const allMatch = newObserves.every((ob, index) => ob === oldObserves[index]);\n    if (!allMatch) {\n        return 4;\n    }\n    return 0; // still the same\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** used to handle when value was subscribe but now is something else */\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem) {\n    const isDifferent = !newValue || !newValue.tagJsType || newValue.tagJsType !== originalType;\n    if (isDifferent) {\n        const oldTagJsVar = contextItem.tagJsVar;\n        oldTagJsVar.destroy(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, // subSubContext,\n        ownerSupport, 99);\n        return 99;\n    }\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { handleTagTypeChangeFrom } from './handleTagTypeChangeFrom.function.js';\nexport function checkStillSubscription(newValue, contextItem, ownerSupport) {\n    const subContext = contextItem.subContext;\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    if (!subContext || !subContext.hasEmitted) {\n        return 0;\n    }\n    subContext.tagJsVar = newValue;\n    subContext.valuesHandler(subContext.lastValues, 0);\n    return 0;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\nimport { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { checkStillSubscription } from \"../tag/update/checkStillSubscription.function.js\";\nimport { Subject } from \"../index.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeAttribute,\n        processInit: setupSubscribe,\n        hasValueChanged: checkSubscribeValueChanged,\n        processUpdate: checkStillSubscription,\n        // processUpdate: processUpdateSubscribe,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states,\n        Observables: [Observable],\n    };\n}\nsubscribe.all = subscribeAll;\nfunction subscribeAll(subjects, callback) {\n    return subscribe(Subject.all(subjects), callback);\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteContextSubContext(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subscription = contextItem.subContext;\n    const result = deleteSubContext(subscription, ownerSupport);\n    delete contextItem.subContext;\n    return result;\n}\nexport function deleteSubContext(subContext, ownerSupport) {\n    subContext.deleted = true;\n    const appendMarker = subContext.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker, 'deleteSubContext');\n        delete subContext.appendMarker;\n    }\n    // delete (contextItem as any).destroy\n    if (!subContext.hasEmitted) {\n        return;\n    }\n    const subContextItem = subContext.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.destroy(subContextItem, ownerSupport);\n    return 76;\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, [], insertBefore);\n}\n","import { deleteContextSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, contextItem, newSupport) {\n    ++contextItem.updateCount;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        hasValueChanged: () => 0, // not expected to do anything\n        processInitAttribute: blankHandler,\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        destroy: deleteContextSubContext,\n    };\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    /*\n    const support = getSupportInCycle() as AnySupport\n    const context = getSupportWithState(support).context\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: blankHandler,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInit: processPipe,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states: newer.states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: values,\n    };\n    return setupSubscribe(subValue, contextItem, ownerSupport, undefined, appendTo);\n}\n","import { getContextInCycle, paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\nimport { findStateSupportUpContext } from \"../interpolations/attributes/getSupportWithState.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const context = getContextInCycle();\n    // const support = getSupportWithState(context)\n    // const parentContext = context?.parentContext\n    if (!context) {\n        throw new Error('output must be used in render sync with a parent context');\n    }\n    const support = findStateSupportUpContext(context);\n    // const support = getSupportInCycle() as AnySupport\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    if (callback.wrapped === true) {\n        return callback;\n    }\n    const newCallback = (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport.context);\n    };\n    newCallback.wrapped = true;\n    return newCallback;\n}\nexport function syncWrapCallback(args, callback, context) {\n    const stateMeta = context.state;\n    const newerStates = stateMeta.newer.states;\n    const olderStates = stateMeta.older ? stateMeta.older.states : newerStates;\n    const newestOwner = stateMeta.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newerStates, olderStates);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(olderStates, newerStates);\n    // now render the owner\n    paintAfters.push([() => {\n            const newGlobal = newestOwner.context.global;\n            const ignore = newGlobal === undefined || newGlobal.deleted === true;\n            if (ignore) {\n                ++painting.locks;\n                newestOwner.context.tagJsVar.processUpdate(newestOwner.context.value, newestOwner.context, newestOwner, []);\n                --painting.locks;\n                paint();\n                return; // its not a tag anymore\n            }\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { initState } from \"../state/state.utils.js\";\nimport { reState } from '../state/reState.function.js';\nimport { runAfterRender } from \"../render/runAfterRender.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/handleTagTypeChangeFrom.function.js\";\nimport { isFunction } from \"../index.js\";\n/** Use to gain access to element\n * @callback called every render\n */\nexport function host(callback, options = {}) {\n    const baseHost = {\n        tagJsType: ValueTypes.host,\n        processInitAttribute: processHostAttribute,\n        // TODO: maybe a host value can change?\n        hasValueChanged: () => 0,\n        processInit: processHost, // This should be a throw error because only attribute is supported\n        processUpdate: processHostUpdate,\n        destroy: deleteHost,\n        options: { callback, ...options },\n        matchesInjection(inject, context) {\n            const options = inject?.options;\n            if (!options) {\n                return false;\n            }\n            const injectCallback = options?.callback;\n            // Check if the inject target is a host with the same callback\n            if (injectCallback === callback) {\n                return context;\n            }\n            return false;\n        },\n    };\n    const returnFunction = (...args) => {\n        const hostValue = {\n            ...returnFunction,\n            options: { arguments: args, ...options, callback },\n        };\n        return hostValue;\n    };\n    Object.assign(returnFunction, baseHost);\n    // returnFunction.options = { callback }\n    return returnFunction;\n}\n// Attach the functions to the host namespace\n;\nhost.onInit = (callback) => {\n    return host(() => { }, { onInit: callback });\n};\nhost.onDestroy = (callback) => {\n    return host(() => { }, { onDestroy: callback });\n};\nfunction processHostUpdate(newValue, contextItem, ownerSupport) {\n    if (isFunction(newValue) && !newValue?.tagJsType) {\n        throw new Error('issue on its way');\n    }\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, \n    // tagJsVar,\n    ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const oldTagJsVar = contextItem.tagJsVar;\n    const oldOptions = oldTagJsVar.options;\n    // const element = (contextItem as any as AttributeContextItem).target as HTMLInputElement\n    const newHost = newValue;\n    reState(contextItem);\n    const args = (newHost.options.arguments || oldOptions.arguments || []);\n    contextItem.returnValue = newHost.options.callback(...args);\n    runAfterRender(contextItem);\n}\nfunction processHostAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, // same as value not needed\ncontextItem) {\n    return processHost(tagJsVar, contextItem);\n}\n/* Only runs on host() init */\nfunction processHost(tagJsVar, contextItem) {\n    const element = contextItem.target;\n    const state = contextItem.state = {};\n    initState(contextItem);\n    processHostTagJsVar(element, tagJsVar, contextItem, state);\n    runAfterRender(contextItem);\n}\n/** first time run */\nfunction processHostTagJsVar(element, tagJsVar, contextItem, state) {\n    const args = tagJsVar.options.arguments || [];\n    const returnValue = tagJsVar.options.callback(...args);\n    // Store the return value for tag.inject to access\n    contextItem.returnValue = returnValue;\n    // DEPRECATED\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        // const element = contextItem.target as HTMLInputElement\n        options.onInit(element, tagJsVar, contextItem, state);\n    }\n    return returnValue;\n}\nfunction deleteHost(contextItem) {\n    ++contextItem.updateCount;\n    const attrContext = contextItem;\n    const tagJsVar = attrContext.tagJsVar;\n    const options = tagJsVar.options;\n    if (attrContext.destroy$.subscribers.length) {\n        // TODO: Not sure if this needed\n        setContextInCycle(contextItem);\n        syncWrapCallback([], attrContext.destroy$.next.bind(attrContext.destroy$), contextItem);\n        // TODO: Not sure if this needed\n        removeContextInCycle();\n    }\n    // DEPRECATED\n    // TODO: remove this code and use tag.onDestroy instead\n    if (options.onDestroy) {\n        const element = attrContext.target;\n        const hostDestroy = function processHostDestroy() {\n            setContextInCycle(contextItem);\n            const result = options.onDestroy(element, tagJsVar, attrContext, attrContext.state);\n            removeContextInCycle();\n            return result;\n        };\n        const stateOwner = contextItem.stateOwner;\n        return syncWrapCallback([], hostDestroy, stateOwner.context);\n    }\n}\n","import { isPromise } from '../../index.js';\nimport { paint } from '../../render/index.js';\nimport { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { makeRealUpdate, afterDestroy } from './processFirstSubjectComponent.function.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used when a tag() does not return html`` */\nexport function getOverrideTagVar(context, newContext, support, subject) {\n    // support.context = subject as SupportContextItem\n    const overrideTagVar = {\n        tagJsType: 'tag-conversion',\n        // processInitAttribute: newContext.tagJsVar.processInitAttribute,\n        processInitAttribute: blankHandler, // cannot be an attribute ever\n        processInit: (_value, _contextItem, _ownerSupport) => {\n            const renderContent = context.returnValue;\n            return newContext.tagJsVar.processInit(renderContent, newContext, support, subject.placeholder);\n        },\n        processUpdate: (value, context, ownerSupport) => {\n            if (context.locked || context.deleted) {\n                return;\n            }\n            ++context.updateCount;\n            const oldValue = context.value;\n            const oldType = oldValue.tagJsType;\n            const newType = value?.tagJsType;\n            const hasTypeChanged = newType !== oldType;\n            const hasChanged = checkTagValueChange(value, context);\n            // check to see if the tagConversion itself has changed\n            const changed = hasChanged || hasTypeChanged || overrideTagVar.hasValueChanged(value, context, // aka contextItem,\n            support);\n            if (changed) {\n                overrideTagVar.destroy(context, support);\n                updateToDiffValue(value, context, // newContext\n                ownerSupport, 789);\n                return;\n            }\n            context.locked = 467;\n            context.render$.next(); // cause tag.onRender to fire\n            const convertValue = context.returnValue;\n            makeRealUpdate(newContext, value, context, convertValue, support);\n            delete context.locked;\n        },\n        hasValueChanged: (_value, _context, support) => {\n            const newValue = context.returnValue;\n            const checkResult = newContext.tagJsVar.hasValueChanged(newValue, newContext, support);\n            return checkResult;\n        },\n        destroy: (contextItem, ownerSupport) => {\n            ++context.updateCount;\n            context.deleted = true;\n            delete context.returnValue;\n            const result = newContext.tagJsVar.destroy(newContext, support);\n            if (isPromise(result)) {\n                return result.then(() => {\n                    const result = afterDestroy(context, ownerSupport);\n                    paint();\n                    return result;\n                });\n            }\n            context.destroy$.next();\n            return afterDestroy(context, ownerSupport);\n        }\n    };\n    return overrideTagVar;\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { firstTagRender } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { castProps } from '../props/alterProp.function.js';\nimport { convertTagToElementManaged } from './convertTagToElementManaged.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nfunction createSupportWithProps(templater, subject, ownerSupport) {\n    const newSupport = createSupport(templater, subject, ownerSupport, ownerSupport?.appSupport);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const support = firstTagRender(newSupport, subject.state.newest, // existing tag\n    subject);\n    return support;\n}\nexport function processReplacementComponent(templater, context, ownerSupport) {\n    const support = createSupportWithProps(templater, context, ownerSupport);\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, support.ownerSupport, context);\n    }\n    buildBeforeElement(support, undefined, // element for append child\n    context.placeholder);\n    return support;\n}\nexport function makeRealUpdate(newContext, value, context, convertValue, support) {\n    const castedProps = castProps(value.props, support, // ownerSupport,\n    0);\n    newContext.value.props = castedProps;\n    const propsConfig = support.propsConfig;\n    if (propsConfig) {\n        propsConfig.castProps = castedProps;\n    }\n    ;\n    newContext.updatesHandler = context.updatesHandler;\n    if (context.updatesHandler) {\n        setContextInCycle(context);\n        const updatesHandler = context.updatesHandler;\n        updatesHandler(castedProps); // updates()\n        removeContextInCycle();\n    }\n    newContext.tagJsVar.processUpdate(convertValue, newContext, support, []);\n    newContext.value = convertValue;\n}\nexport function afterDestroy(context, _ownerSupport) {\n    delete context.returnValue;\n    delete context.global // = {} as any;\n    ;\n    context.contexts = [];\n    ;\n    context.htmlDomMeta = [];\n    delete context.updatesHandler;\n    // context.value.destroy(context, ownerSupport)\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, appendTo) {\n    const support = createSupportWithProps(templater, subject, ownerSupport);\n    // DISCOVER IF tag() did NOT return dom|html\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, ownerSupport, subject);\n    }\n    return processFirstTagResult(support, appendTo);\n}\n","import { Subject } from '../../index.js';\nimport { valueToTagJsVar } from '../../tagJsVars/index.js';\nimport { getOverrideTagVar } from './getOverrideTagVar.js';\nexport function convertTagToElementManaged(support, ownerSupport, subject) {\n    const context = support.context;\n    const newValue = support.returnValue; // context.returnValue\n    // EXAMPLE: ['a','b'].map(x=> tag(() => [div,span]).key(x))\n    /*\n    if(Array.isArray(newValue)) {\n      ;(newValue as any).key = (arrayValue: any) => keyTag(arrayValue, newValue)\n    }\n    */\n    const tagJsVar = valueToTagJsVar(newValue);\n    delete context.global;\n    context.contexts = [];\n    const newContext = {\n        updateCount: 0,\n        value: newValue,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        placeholder: context.placeholder,\n        // not important\n        valueIndex: -1,\n        withinOwnerElement: true,\n        parentContext: context,\n        contexts: context.contexts, // share contexts especially so providers properly crawl my available contexts\n        // contexts: subject.contexts, // share contexts especially so providers properly crawl my available contexts\n    };\n    // context.contexts = [ newContext ] as ContextItem[] & SupportContextItem[]\n    const overrideTagVar = getOverrideTagVar(context, newContext, support, subject);\n    context.tagJsVar = overrideTagVar;\n    // TODO: should we be calling this here?\n    tagJsVar.processInit(newValue, newContext, support, subject.placeholder);\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, appendTo) {\n    const result = buildBeforeElement(support, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\n_insertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processFirstSubjectComponent(value, contextItem, ownerSupport, appendTo);\n    }\n    return processReplacementComponent(value, contextItem, ownerSupport);\n}\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { tag } from '../index.js';\nimport { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const context = getContextInCycle();\n        if (context.global) {\n            const nowSupport = getSupportInCycle();\n            return checkToResolvePromise(result, nowSupport, { resolvePromise, resolveValue });\n        }\n    });\n    return tag;\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n","import { state } from \"./state.function.js\";\nimport { getContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const context = getContextInCycle();\n        context.destroy$.toCallback(callback);\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { callback, promise, setUseMemory, state } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../tag/checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from '../tag/destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { getContextInCycle, getElement as getTagElement } from '../tag/cycles/setContextInCycle.function.js';\nimport { tagInject } from './tagInject.function.js';\nimport { onInit as tagOnInit } from '../state/onInit.function.js';\nimport { onDestroy as tagOnDestroy } from '../state/onDestroy.function.js';\nimport { onRender as tagOnRender } from '../state/onRender.function.js';\nimport { getInnerHTML as tagGetInnerHTML } from '../index.js';\nlet tagCount = 0;\nconst onClick = makeEventListener('click');\nconst onMouseDown = makeEventListener('mousedown');\nfunction makeEventListener(type) {\n    return function eventListener(toBeCalled) {\n        const wrapped = callback(toBeCalled); // should cause render to occur\n        // run one time\n        state(() => {\n            const element = getTagElement();\n            element.addEventListener(type, wrapped);\n        });\n        return wrapped; // this is what you remove\n    };\n}\nconst tagElement = {\n    get: getTagElement,\n    onclick: onClick,\n    click: onClick,\n    onClick,\n    mousedown: onMouseDown,\n    onmousedown: onMouseDown,\n    onMouseDown: onMouseDown,\n};\ndefineGetSet('onclick', onClick);\ndefineGetSet('click', onClick);\ndefineGetSet('onMouseDown', onMouseDown);\ndefineGetSet('onmousedown', onMouseDown);\ndefineGetSet('mousedown', onMouseDown);\nfunction defineGetSet(name, eventFn) {\n    Object.defineProperty(tag, name, {\n        get() {\n            return eventFn;\n        },\n        set(fn) {\n            return eventFn(fn);\n        },\n    });\n}\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        templater.hasValueChanged = checkTagValueChangeAndUpdate;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    const returnWrap = parentWrap;\n    // used for argument updates\n    returnWrap.updates = (handler) => {\n        const context = getContextInCycle();\n        context.updatesHandler = handler;\n        return true;\n    };\n    returnWrap.getInnerHTML = tagGetInnerHTML;\n    return returnWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n// actually placing of items into tag memory\n;\ntag.element = tagElement;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.inject = tagInject;\ntag.onInit = tagOnInit;\ntag.onDestroy = tagOnDestroy;\ntag.onRender = tagOnRender;\ntag.getInnerHTML = tagGetInnerHTML;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.destroy = destroySupportByContextItem;\n        oneRenderFunction.hasValueChanged = function renderOnceNeverChanges() {\n            return 0;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.hasValueChanged = checkTagValueChangeAndUpdate;\n        renderFunction.destroy = destroySupportByContextItem;\n    },\n});\nObject.defineProperty(tag, 'promise', {\n    set(target) {\n        promise(target);\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch } from './hasSupportChanged.function.js';\nimport { shallowPropMatch } from './shallowPropMatch.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nimport { hasPropLengthsChanged } from '../render/checkRenderUp.function.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Inject a parent tag or host into the current context\n * For host functions, returns the value returned by the host callback\n * For tag components, returns the tag instance itself\n */\nexport function tagInject(targetItem) {\n    const context = getContextInCycle();\n    if (!context) {\n        throw new Error('tag.inject can only be called within a tag or host context');\n    }\n    // Search up the context tree for a matching parent\n    let currentContext = context.parentContext;\n    while (currentContext) {\n        // Check if this is an attributes context with child contexts\n        const contexts = currentContext.contexts;\n        if (contexts) {\n            // Search within the attributes contexts\n            for (const attrContext of contexts) {\n                if (attrContext.isAttr && attrContext.tagJsVar?.matchesInjection) {\n                    // Use the matchesInjection method if available\n                    const inContext = attrContext.tagJsVar.matchesInjection(targetItem, attrContext);\n                    if (inContext !== undefined) {\n                        // For host values, return the returnValue from the context\n                        return inContext.returnValue;\n                    }\n                }\n            }\n        }\n        // Check if this context has a tagJsVar with matchesInjection\n        if (currentContext.tagJsVar?.matchesInjection) {\n            if (currentContext.tagJsVar.matchesInjection(targetItem, currentContext)) {\n                // For tag components, return the tag instance\n                return currentContext.returnValue;\n            }\n        }\n        // Move up to the parent context\n        currentContext = currentContext.parentContext;\n    }\n    const message = `Could not find parent context for tag.inject ${targetItem}`;\n    console.error(message, { targetItem, context });\n    throw new Error(message);\n}\n","import { getContextInCycle, removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onRender(callback) {\n    const context = getContextInCycle();\n    const callbackWrap = (_isFirst) => {\n        // remember current context (old)\n        // const oldIndex = setUseMemory.stateConfig.statesIndex\n        const lastContext = getContextInCycle();\n        // set to inner context cycle with previous state position\n        setContextInCycle(context);\n        const result = callback();\n        // restore previous cycle\n        removeContextInCycle();\n        setContextInCycle(lastContext);\n        return result;\n    };\n    const subscription = context.render$.subscribe(() => callbackWrap());\n    const result = callbackWrap();\n    tag.onDestroy(() => subscription.unsubscribe());\n    return result;\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    const global = context.global;\n    global.blocked = [];\n    // context.state.newer = context.state.newer || { ...setUseMemory.stateConfig }\n    if (!context.state) {\n        context.state = {\n            newer: {\n                state: [],\n                states: [],\n            }\n        };\n    }\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, // when appSupport not defined then this support becomes appSupport\nappSupport, castedProps) {\n    support.appSupport = appSupport || support;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsubject, ownerSupport, // when not\nappSupport, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport || support;\n    support.ownerSupport.appSupport = appSupport || support.ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        // its html/dom based tag\n        const support = contextItem.state.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, contextItem.placeholder);\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = newValue;\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    // When last value was not a component\n    if (!contextItem.state.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, contextItem, ownerSupport, ownerSupport.appSupport);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, subject, ownerSupport, ownerSupport.appSupport);\n    const lastSubject = oldSupport.context;\n    const oldest = lastSubject.state.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './arrays/processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, context, ownerSupport, ignoreOrDestroyed) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    delete context.deleted;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(context, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(context, newValue, ownerSupport);\n        context.oldTagJsVar = context.tagJsVar;\n        context.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        context.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) { // TODO: is this check really needed?\n        processNowRegularValue(newValue, context);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.hasValueChanged(newValue, contextItem, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === 0) {\n        return ignoreOrDestroyed; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed);\n    return ignoreOrDestroyed;\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { checkStillSubscription } from './checkStillSubscription.function.js';\nimport { emitSubContext } from './processSubscribeWith.function.js';\nexport function processUpdateSubscribe(newValue, contextItem, ownerSupport) {\n    const resultNum = checkStillSubscription(newValue, // subValue,\n    contextItem, ownerSupport);\n    if (contextItem.hasEmitted !== true) {\n        const Observables = contextItem.value.Observables;\n        if (!Observables) {\n            return;\n        }\n        const Observable = Observables[0];\n        // const subValue = Observable.value\n        if (!('value' in Observable)) {\n            return; // its never emitted\n        }\n    }\n    if (resultNum === 0 && newValue.callback) {\n        const subContext = contextItem.subContext;\n        emitSubContext(newValue, subContext);\n    }\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { deleteSubContext } from './deleteContextSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { processUpdateSubscribe } from './processUpdateSubscribe.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nexport function setupSubscribe(value, contextItem, ownerSupport, insertBeforeOriginal, // optional but will always be made\nappendTo) {\n    const observables = value.Observables;\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    let onOutput = function onSubValue(value, syncRun, subContext) {\n        onFirstSubContext(value, subContext, ownerSupport, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = subContext.tagJsVar.onOutput = function subscriptionUpdate(updateValue, syncRun, subContext) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport);\n            aContext.tagJsVar.processUpdate(updateValue, aContext, ownerSupport, [updateValue]);\n            // processUpdateContext(ownerSupport)\n            aContext.value = updateValue;\n            checkToPaint(syncRun);\n        };\n    };\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, (value, syncRun, subContext) => onOutput(value, syncRun, subContext), value, contextItem);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    value.processUpdate = processUpdateSubscribe;\n    value.onOutput = onOutput;\n    return subContext;\n}\n/** After calling this function you need to set `contextItem.subContext = subContext` */\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\nonOutput, tagJsVar, contextItem) {\n    // const component = getSupportWithState(ownerSupport)\n    // onValue mutates so function below calls original and mutation\n    function subValueHandler(value, index) {\n        subContext.lastValues[index] = {\n            value,\n            tagJsVar: valueToTagJsVar(value),\n            oldTagJsVar: subContext.lastValues[index]?.tagJsVar\n        };\n        valuesHandler(subContext.lastValues, index);\n    }\n    function valuesHandler(newValues, index) {\n        const newestParentTagJsVar = subContext.tagJsVar;\n        const callback = newestParentTagJsVar?.callback;\n        if (callback) {\n            setContextInCycle(contextItem);\n            const responseValue = newestParentTagJsVar.callback(...newValues.map(x => x.value));\n            onOutput(responseValue, syncRun, subContext);\n            removeContextInCycle();\n            return;\n        }\n        const newValue = newValues[index].value;\n        onOutput(newValue, syncRun, subContext);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        subValueHandler,\n        valuesHandler,\n        tagJsVar,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => subValueHandler(value, index)));\n        syncRun = false;\n    });\n    tagJsVar.onOutput = onOutput;\n    return subContext;\n}\nexport function unsubscribeContext(contextItem) {\n    const subscription = contextItem.subContext;\n    if (!subscription) {\n        return; // TODO: wonder why this happens, maybe subscription never emits?\n    }\n    const subscriptions = subscription.subscriptions;\n    subscriptions.forEach(sub => sub.unsubscribe());\n    delete contextItem.subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subContext = contextItem.subContext;\n    unsubscribeContext(contextItem);\n    return deleteSubContext(subContext, ownerSupport);\n}\nexport function checkToPaint(syncRun) {\n    if (syncRun) {\n        return;\n    }\n    if (setUseMemory.stateConfig.support) {\n        return;\n    }\n    paint();\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nexport function processSignal(value, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: [value],\n    };\n    setupSubscribe(subValue, contextItem, ownerSupport, _insertBefore, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSignal.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { checkSubscribeValueChanged } from '../tagJsVars/subscribeWith.function.js';\nimport { processUpdateSubscribe } from '../tag/update/processUpdateSubscribe.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        tagJsType: ValueTypes.signal,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInitAttribute: blankHandler,\n        processInit: processSignal,\n        processUpdate: processUpdateSubscribe,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        destroy: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { ValueSubject } from '../subject/index.js';\nimport { tag } from '../tag/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback).pastResult;\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup).pastResult;\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const isFun = typeof (currentValues) === 'function';\n    const realValues = isFun ? currentValues() : currentValues;\n    const isFirstRender = previous.values === undefined;\n    let renderCount = 0;\n    if (isFirstRender) {\n        if (typeof (currentValues) === 'function') {\n            tag.onRender(() => {\n                ++renderCount;\n                if (renderCount === 1) {\n                    return; // first run is already performed\n                }\n                const realValues = currentValues();\n                processRealValues(realValues);\n            });\n        }\n    }\n    function processRealValues(realValues) {\n        // First time running watch?\n        if (previous.values === undefined) {\n            if (before && !before(realValues)) {\n                previous.values = realValues;\n                return previous; // do not continue\n            }\n            const castedInit = init || callback;\n            const result = castedInit(realValues, previous.values);\n            previous.pastResult = final(result);\n            previous.values = realValues;\n            return previous;\n        }\n        const allExact = realValues.every((item, index) => item === previous.values[index]);\n        if (allExact) {\n            return previous;\n        }\n        if (before && !before(realValues)) {\n            previous.values = realValues;\n            return previous; // do not continue\n        }\n        const result = callback(realValues, previous.values);\n        previous.pastResult = final(result);\n        previous.values.length = 0;\n        previous.values.push(...realValues);\n        return previous;\n    }\n    return processRealValues(realValues);\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => {\n                return new ValueSubject(undefined);\n            });\n            const oldState = state(() => ({\n                state: setUseMemory.stateConfig.state,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                const handler = (realValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(realValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.state;\n                        const context = firstSupport.context;\n                        const stateMeta = context.state;\n                        const oldestStateSupport = stateMeta.older;\n                        if (oldestStateSupport) {\n                            const oldestState = oldestStateSupport.state;\n                            const newStates = oldState.states;\n                            const oldStates = oldestStateSupport.states;\n                            oldSyncStates(newestState, oldestState, newStates, oldStates);\n                        }\n                    }\n                    subject.next(setTo);\n                };\n                setupWatch(currentValues, handler, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            state: setUseMemory.stateConfig.state,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            const context = nowSupport.context;\n            const stateMeta = context.state;\n            const newer = stateMeta.newer;\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        state: setUseMemory.stateConfig.state,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        const context = nowSupport.context;\n        const stateMeta = context.state;\n        const newer = stateMeta.newer;\n        if (newer) {\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n        }\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.state.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.state.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const context = support.context;\n            // const global = context.global as SupportTagGlobal\n            const providers = context.providers = context.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const context = owner.ownerSupport.context;\n            // const ownGlobal = context.global as SupportTagGlobal\n            const ownerProviders = context.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const context = support.context;\n                const providers = context.providers = context.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { paint } from '../tag/index.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const context = getContextInCycle();\n    const callbackState = state({\n        callback,\n    });\n    // ensure only one trigger instance created and always returned\n    const callbackTrigger = state(() => createTrigger(context, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callbackState));\n    // always update callback to latest in cycle\n    callbackState.callback = callback;\n    return callbackTrigger;\n}\nexport function createTrigger(context, oldState, callbackState) {\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        // ++painting.locks\n        const result = callbackStateUpdate(context, oldStates, callbackState.callback, ...args);\n        // --painting.locks\n        paint();\n        return result;\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nimport { findStateSupportUpContext } from '../interpolations/attributes/getSupportWithState.function.js';\nexport default function callbackStateUpdate(context, _oldStates, callback, ...args) {\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    const newestSupport = findStateSupportUpContext(context);\n    // TODO: This if may not be ever doing anything\n    if (!newestSupport) {\n        return maybePromise;\n    }\n    // context.global && \n    if (newestSupport.context.global) {\n        renderSupport(newestSupport); // TODO: remove with html``\n    }\n    else {\n        const supContext = newestSupport.context;\n        supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n        []);\n    }\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            if (context.global) {\n                renderSupport(newestSupport); // TODO: remove\n            }\n            else {\n                const supContext = newestSupport.context;\n                supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n                []);\n            }\n        });\n    }\n    return maybePromise;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport const callbackMaker = () => {\n    const context = getContextInCycle();\n    // const support = getSupportInCycle()\n    // callback as typeof innerCallback\n    if (!context) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(context, oldState, { callback });\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { createTrigger } from './callback.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nconst emptyCallback = () => undefined;\n/** Attach a promise to the render cycle so resolve triggers a re-render. */\nexport function promise(target) {\n    const context = getContextInCycle();\n    const callbackState = state({ callback: emptyCallback });\n    const promiseState = state({ current: undefined });\n    const trigger = state(() => createTrigger(context, setUseMemory.stateConfig, callbackState));\n    if (promiseState.current !== target) {\n        promiseState.current = target;\n        const currentPromise = target;\n        target.then(() => {\n            if (promiseState.current !== currentPromise) {\n                return;\n            }\n            trigger();\n        });\n    }\n}\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { setUseMemory } from '../../state/index.js';\nexport function getContextInCycle() {\n    return setUseMemory.stateConfig.context;\n}\n/** Gets the current element associated with taggedjs document processing */\nexport function getElement() {\n    const context = getContextInCycle();\n    return context.target;\n}\n// const contextCycles: ContextItem[] = []\nexport function setContextInCycle(context) {\n    // contextCycles.push(context)\n    return setUseMemory.stateConfig.context = context;\n}\nexport function removeContextInCycle() {\n    // contextCycles.pop()\n    delete setUseMemory.stateConfig.context;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    const stateMeta = contextItem.state = contextItem.state || {};\n    stateMeta.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    insertBefore, appendTo);\n    // contextItem.handler = function outDomTagHanlder(\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate = function outDomTagHanlder(value, contextItem2, newSupport) {\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.hasValueChanged = checkOuterTagValueChange;\n}\nfunction checkOuterTagValueChange(newValue, contextItem) {\n    return checkTagValueChangeAndUpdate(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem);\n}\n/** tag(html``) When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInitAttribute: blankHandler,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            return keyTag(arrayValue, tag);\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\nexport function keyTag(arrayValue, tag) {\n    keyTag(arrayValue, tag);\n    tag.arrayValue = arrayValue;\n    return tag;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInitAttribute: blankHandler,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { setSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\nimport { removeContextInCycle } from './cycles/setContextInCycle.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\nconst TAG_ELEMENT_MARKER = '__taggedjs_tag_element__';\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, // aka appElement\nprops) {\n    const wasTagged = element[TAG_ELEMENT_MARKER];\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (wasTagged || appElmIndex >= 0) {\n        console.warn('tagElement called multiple times for the same element', { element });\n    }\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n    }\n    ;\n    element[TAG_ELEMENT_MARKER] = true;\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    const newest = subject.state.newest;\n    initState(newest.context);\n    setSupportInCycle(newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            subject.state.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const result = renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n    removeContextInCycle();\n    return result;\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        processInitAttribute: blankHandler,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const context = {\n        updateCount: 0,\n        value: templater,\n        valueIndex: 0,\n        varCounter: 0,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        state: {},\n        // parentContext: undefined as any,\n        tagJsVar,\n    };\n    // sets new global on context\n    getNewGlobal(context);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    context.events = {};\n    loadNewBaseSupport(templater, context, appElement);\n    return context;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    // Initialize older/newer with empty state if first render\n    if (!subject.state.oldest) {\n        subject.state.oldest = newSupport;\n        subject.state.older = subject.state.newer;\n    }\n    subject.state.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { processReplacementComponent } from '../tag/update/processFirstSubjectComponent.function.js';\n// Imports used only by the commented-out runWrapper/executeStateWrap functions:\n// import { ContextStateSupport } from '../tag/ContextStateMeta.type.js'\n// import { Wrapper } from '../index.js'\n// import { createSupport } from '../tag/createSupport.function.js'\n// import { runAfterSupportRender } from './runAfterRender.function.js'\n// import { executeWrap } from './executeWrap.function.js'\n// import { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js'\n// import { reStateSupport } from '../state/reState.function.js'\nexport function renderTagElement(app, global, templater, templater2, element, // appElement\ncontext, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    context.placeholder = placeholder;\n    /*\n    const support = runWrapper(\n      templater,\n      placeholder,\n      element,\n      context,\n      isAppFunction,\n    )\n    */\n    global.isApp = true;\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = context.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        context.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    const ownerSupport = {\n        appSupport: {\n            appElement: element,\n            context,\n        },\n        appElement: element\n    };\n    const support = processReplacementComponent(templater, context, ownerSupport);\n    support.appElement = element;\n    // support.appSupport = support\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    /*\n    const newFragment = registerTagElement(\n      support,\n      element,\n      global,\n      templater,\n      app,\n      placeholder,\n    )\n    */\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\n","function isTemplateStringsArray(value) {\n    return (Array.isArray(value) &&\n        Object.prototype.hasOwnProperty.call(value, 'raw'));\n}\nexport function makeAttrCallable(attrName, attr) {\n    return function (item, stringsOrValue, values) {\n        if (isTemplateStringsArray(stringsOrValue)) {\n            const attrValue = stringsOrValue.reduce((all, chunk, index) => all + chunk + (values[index] ?? ''), '');\n            return attr(item, [attrName, attrValue]);\n        }\n        return attr(item, [attrName, stringsOrValue]);\n    };\n}\n","import { isFunction, isObject } from '../index.js';\nimport { setBooleanAttribute, setNonFunctionInputValue, setSimpleAttribute } from '../interpolations/attributes/howToSetInputValue.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { makeAttrCallable } from './attributeCallables.js';\nfunction callbackWrapper(item, eventName, callback) {\n    const clone = getPushKid(item, item.elementFunctions);\n    return callbackWrapper2(clone, eventName, callback);\n}\nfunction callbackWrapper2(item, eventName, callback) {\n    function wrapCallback(e) {\n        return wrapCallback.toCallback(e);\n    }\n    wrapCallback.toCallback = callback;\n    item.listeners.push([eventName, wrapCallback]);\n    item.allListeners.push([eventName, wrapCallback]);\n    return item;\n}\nfunction attr(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    clone.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsVar\n    }\n    return clone;\n}\n/** attrs({names: values}) */\nfunction attrs(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    Object.entries(args).map(args => {\n        clone.attributes.push(args);\n        if (isValueForContext(args[0])) {\n            registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsVar\n        }\n        else if (isValueForContext(args[1])) {\n            registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsVar\n        }\n    });\n    return clone;\n}\nconst style = makeAttrCallable('style', attr);\nconst idCallable = makeAttrCallable('id', attr);\nconst classCallable = makeAttrCallable('class', attr);\nconst href = makeAttrCallable('href', attr);\nconst value = makeAttrCallable('value', attr);\nconst placeholder = makeAttrCallable('placeholder', attr);\nconst src = makeAttrCallable('src', attr);\nconst title = makeAttrCallable('title', attr);\nconst type = makeAttrCallable('type', attr);\nconst checked = makeAttrCallable('checked', attr);\nconst disabled = makeAttrCallable('disabled', attr);\nconst selected = makeAttrCallable('selected', attr);\nconst minLength = makeAttrCallable('minLength', attr);\nconst maxLength = makeAttrCallable('maxLength', attr);\nconst cellPadding = makeAttrCallable('cellpadding', attr);\nconst cellSpacing = makeAttrCallable('cellspacing', attr);\nconst border = makeAttrCallable('border', attr);\nfunction attr2(item, args) {\n    // const clone = getPushKid(item as any, item.elementFunctions)\n    // clone.attributes.push(args as Attribute)\n    item.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], item); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], item); // the attrValue is a function or TagJsVar\n    }\n    return item;\n}\nexport function elementFunctions(item) {\n    /** Used for all element callbacks */\n    function makeCallback(eventName) {\n        return function (callback) {\n            return callbackWrapper(item, eventName, callback);\n        };\n    }\n    // TODO: This maybe the old way of doing things (see callables)\n    // This seems to be for supporting div.onClick()\n    const callables_other = {\n        // ...eventCallables,\n        onClose: makeCallback('onclose'),\n        onDoubleClick: makeCallback('ondblclick'),\n        onClick: makeCallback('click'),\n        // onclick: makeCallback('click'),\n        // click: makeCallback('click'),\n        onBlur: makeCallback('onblur'),\n        onChange: makeCallback('onchange'),\n        onInput: makeCallback('oninput'),\n        // onchange: makeCallback('onchange'),\n        // change: makeCallback('onchange'),\n        onMousedown: makeCallback('onmousedown'),\n        onMouseup: makeCallback('onmouseup'),\n        onMouseover: makeCallback('onmouseover'),\n        onMouseout: makeCallback('onmouseout'),\n        onKeydown: makeCallback('onkeydown'),\n        onKeyup: makeCallback('onkeyup'),\n        // onkeyup: makeCallback('onkeyup'),\n        // keyup: makeCallback('onkeyup'),\n        /* apply attribute via attr(name: string, value?: any): **/\n        attr: (...args) => attr(item, args),\n        attrs: (attributes) => attrs(item, attributes),\n        /** Used for setting array index-key value */\n        key: function (arrayValue) {\n            ;\n            this.arrayValue = arrayValue;\n            return this;\n        },\n        /** Use as div.style`border:${border}` or div.style(() => `border:${border}`) */\n        style: ((stringsOrValue, ...values) => {\n            return style(item, stringsOrValue, values);\n        }),\n        /** Use as div.id`main` or div.id(() => `main-${1}`) */\n        id: ((stringsOrValue, ...values) => {\n            return idCallable(item, stringsOrValue, values);\n        }),\n        /** Use as div.class`primary` or div.class(() => `primary`) */\n        class: ((stringsOrValue, ...values) => {\n            return classCallable(item, stringsOrValue, values);\n        }),\n        /** Use as a.href`/path` or a.href(() => `/path`) */\n        href: ((stringsOrValue, ...values) => {\n            return href(item, stringsOrValue, values);\n        }),\n        /** Use as input.value`text` or input.value(() => `${value}`) */\n        value: ((stringsOrValue, ...values) => {\n            return value(item, stringsOrValue, values);\n        }),\n        /** Use as input.placeholder`text` or input.placeholder(() => `${value}`) */\n        placeholder: ((stringsOrValue, ...values) => {\n            return placeholder(item, stringsOrValue, values);\n        }),\n        /** Use as input.src`text` or input.src(() => `${value}`) */\n        src: ((stringsOrValue, ...values) => {\n            return src(item, stringsOrValue, values);\n        }),\n        /** Use as input.type`text` or input.type(() => `${value}`) */\n        type: ((stringsOrValue, ...values) => {\n            return type(item, stringsOrValue, values);\n        }),\n        /** Use as input.type`text` or input.type(() => `${value}`) */\n        title: ((stringsOrValue, ...values) => {\n            return title(item, stringsOrValue, values);\n        }),\n        /** Use as input.checked`boolean` or input.checked(() => `${boolean}`) */\n        checked: ((stringsOrValue, ...values) => {\n            return checked(item, stringsOrValue, values);\n        }),\n        /** Use as input.checked`boolean` or input.checked(() => `${boolean}`) */\n        disabled: ((stringsOrValue, ...values) => {\n            return disabled(item, stringsOrValue, values);\n        }),\n        /** Use as input.checked`boolean` or input.checked(() => `${boolean}`) */\n        selected: ((stringsOrValue, ...values) => {\n            return selected(item, stringsOrValue, values);\n        }),\n        cellSpacing: ((stringsOrValue, ...values) => {\n            return cellSpacing(item, stringsOrValue, values);\n        }),\n        cellPadding: makeAttr(cellPadding, item),\n        border: makeAttr(border, item),\n    };\n    return callables_other;\n}\nfunction makeAttr(handler, item) {\n    return ((stringsOrValue, ...values) => {\n        return handler(item, stringsOrValue, values);\n    });\n}\nfunction setClassValue(element, name, value) {\n    if (isObject(value)) {\n        Object.entries(value).forEach(([name, value]) => {\n            if (value) {\n                element.classList.add(name);\n            }\n            else {\n                element.classList.remove(name);\n            }\n        });\n        return; // howToSetInputObjectValue(element, name, value as Record<string, any>)\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used during updates */\nexport function registerMockAttrContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\nexport function isValueForContext(value) {\n    return Array.isArray(value) || isFunction(value) || value?.tagJsType;\n}\nfunction setupAttr(attrName, howToSet) {\n    return (item, value) => attr2(item, [attrName, value, false, howToSet]);\n}\nfunction makeCallback(eventName) {\n    return (item, callback) => {\n        return callbackWrapper2(item, eventName, callback);\n    };\n}\nconst eventCallables = {\n    onClose: makeCallback('onclose'),\n    onClick: makeCallback('click'),\n    onDoubleClick: makeCallback('ondblclick'),\n    onDblClick: makeCallback('ondblclick'),\n    onBlur: makeCallback('onblur'),\n    onChange: makeCallback('onchange'),\n    onInput: makeCallback('oninput'),\n    onMousedown: makeCallback('onmousedown'),\n    onMouseDown: makeCallback('onmousedown'),\n    onMouseup: makeCallback('onmouseup'),\n    onMouseUp: makeCallback('onmouseup'),\n    onMouseover: makeCallback('onmouseover'),\n    onMouseOver: makeCallback('onmouseup'),\n    onMouseout: makeCallback('onmouseout'),\n    onMouseOut: makeCallback('onmouseout'),\n    onKeyup: makeCallback('onkeyup'),\n    onKeyUp: makeCallback('onkeyup'),\n    onKeydown: makeCallback('onkeydown'),\n    onKeyDown: makeCallback('onkeydown'),\n};\nconst callables = {\n    checked: setupAttr('checked', setBooleanAttribute),\n    disabled: setupAttr('disabled', setBooleanAttribute),\n    selected: setupAttr('selected', setBooleanAttribute),\n    /** element.setAttribute('style', x)  */\n    class: setupAttr('class', setClassValue),\n    ...eventCallables\n};\nexport function loopObjectAttributes(item, object) {\n    const result = Object.entries(object).reduce((all, [name, value]) => {\n        if (name in callables) {\n            return callables[name](item, value);\n        }\n        return attr2(item, [name, value, false, setNonFunctionInputValue]);\n    }, item);\n    return result;\n}\n","import { isPromise } from '../index.js';\nimport { paint, painting } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\nimport { destroyContextHtml } from '../tag/smartRemoveKids.function.js';\nexport function destroyDesignElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            context.deleted = true;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                // destroyContextHtml(context)\n                destroyHtmlDomMeta(htmlDomMeta);\n                // delete context.htmlDomMeta\n                context.htmlDomMeta = [];\n                // context.deleted = true\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n    destroyContextHtml(context);\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    // context.deleted = true\n    delete context.contexts;\n    context.deleted = true;\n}\nexport function destroyDesignByContexts(contexts, ownerSupport, promises) {\n    const context = contexts[0];\n    const result = context.tagJsVar.destroy(context, ownerSupport);\n    context.deleted = true;\n    if (isPromise(result)) {\n        return promises.push(result.then(() => {\n            if (contexts.length > 1) {\n                return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n            }\n        }));\n    }\n    if (context.htmlDomMeta) {\n        destroyContextHtml(context);\n        delete context.htmlDomMeta;\n    }\n    if (contexts.length > 1) {\n        return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n    }\n}\n","import { updateToDiffValue } from '../tag/update/updateToDiffValue.function.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nexport function processDesignElementUpdate(value, context, ownerSupport) {\n    const skip = context.locked || context.deleted === true;\n    if (skip) {\n        return; // something else is running an event\n    }\n    ++context.updateCount;\n    const hasChanged = checkTagElementValueChange(value, context);\n    if (hasChanged) {\n        destroyDesignElement(context, ownerSupport);\n        // delete context.htmlDomMeta // The next value needs to know its not been deleted\n        context.htmlDomMeta = []; // The next value needs to know its not been deleted\n        // context.deleted = true // its not deleted but changed\n        delete context.deleted; // its not deleted but changed\n        updateToDiffValue(value, context, // newContext,\n        ownerSupport, 789);\n        return;\n    }\n    const contexts = context.contexts;\n    const vContexts = value.contexts || [];\n    const ogListeners = context.tagJsVar.allListeners;\n    const allListeners = value.allListeners;\n    allListeners.forEach((newListener, index) => {\n        // ensure the latest callback is always called. Needed for functions within array maps\n        const wrapCallback = ogListeners[index][1];\n        wrapCallback.toCallback = newListener[1].toCallback;\n    });\n    if (contexts.length !== vContexts.length) {\n        console.info('context mismatch', {\n            value,\n            context,\n            conValues: contexts.map(x => x.value),\n            vContexts,\n            deleted: context.deleted\n        });\n        throw new Error('super issue discovered');\n    }\n    context.locked = 79;\n    contexts.forEach((context, index) => {\n        context.tagJsVar.processUpdate(vContexts[index], // context.value,\n        context, ownerSupport);\n    });\n    delete context.locked;\n}\nexport function checkTagElementValueChange(value, context) {\n    const oldValue = context.value;\n    if (oldValue === value) {\n        return 0; // has not changed\n    }\n    // return 1 // it has changed\n    const notElement = !value || value.tagJsType !== 'element';\n    if (notElement) {\n        return 1;\n    }\n    const newKidLength = value.innerHTML.length;\n    const oldKidLength = context.value.innerHTML.length;\n    const kidLengthChanged = newKidLength !== oldKidLength;\n    if (kidLengthChanged) {\n        return 1;\n    }\n    const newAttrLength = value.attributes.length;\n    const oldAttrLength = context.value.attributes.length;\n    const kidAttrChanged = newAttrLength !== oldAttrLength;\n    if (kidAttrChanged) {\n        return 1;\n    }\n    return 0;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { getNewContext } from '../render/addOneContext.function.js';\nimport { paintCommands } from '../render/paint.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nimport { processElementVarFunction } from './processElementVarFunction.function.js';\nexport function processChildren(innerHTML, parentContext, ownerSupport, element, // appendTo\npaintBy) {\n    innerHTML.forEach(item => {\n        const type = typeof item;\n        switch (type) {\n            case 'string':\n            case 'boolean':\n            case 'number':\n                return handleSimpleInnerValue(item, element, paintBy);\n            case 'function': {\n                if (item.tagJsType === 'element') {\n                    break; // skip\n                }\n                const result = processElementVarFunction(item, element, parentContext, ownerSupport, paintBy);\n                return result;\n            }\n        }\n        if (item === null || item === undefined) {\n            return handleSimpleInnerValue(item, element, paintBy);\n        }\n        if (item.tagJsType === 'element') {\n            const newElement = processElementVar(item, parentContext, ownerSupport, parentContext.contexts);\n            paintCommands.push([paintBy, [element, newElement]]);\n            const htmlDomMeta = parentContext.htmlDomMeta;\n            htmlDomMeta.push({\n                nn: newElement.tagName,\n                domElement: newElement,\n                // at: newElement.attributes,\n                at: [],\n            });\n            return;\n        }\n        return processNonElement(item, parentContext, element, ownerSupport, paintBy);\n    });\n}\n/** used when a child is not another element and requires init processing */\nexport function processNonElement(item, parentContext, element, ownerSupport, paintBy) {\n    const newContext = getNewContext(item, [], // addedContexts\n    true, parentContext);\n    const contexts = parentContext.contexts;\n    contexts.push(newContext);\n    newContext.target = element;\n    newContext.placeholder = document.createTextNode('');\n    paintCommands.push([paintBy, [element, newContext.placeholder]]);\n    setContextInCycle(newContext);\n    newContext.tagJsVar.processInit(item, newContext, // context, // newContext,\n    ownerSupport, newContext.placeholder);\n    removeContextInCycle();\n    return newContext;\n}\nexport function handleSimpleInnerValue(value, element, paintBy) {\n    const castedValue = castTextValue(value);\n    const text = document.createTextNode(castedValue);\n    paintCommands.push([paintBy, [element, text]]);\n    return text;\n}\n","import { isFunction, Subject } from '../index.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processNonElement } from './processChildren.function.js';\nexport function processElementVarFunction(item, element, parentContext, ownerSupport, paintBy) {\n    const subContexts = [];\n    const subContext = {\n        updateCount: 0,\n        parentContext,\n        contexts: subContexts,\n        target: element,\n        value: item,\n        htmlDomMeta: [],\n        tagJsVar: {\n            tagJsType: 'dynamic-text',\n            hasValueChanged: () => 0,\n            processInit: blankHandler,\n            processInitAttribute: blankHandler,\n            destroy: (_c, ownerSupport) => {\n                ++subContext.updateCount;\n                subContexts.forEach(subSub => subSub.tagJsVar.destroy(subSub, ownerSupport));\n            },\n            processUpdate: (value, contextItem, ownerSupport, values) => {\n                ++subContext.updateCount;\n                setContextInCycle(aSubContext);\n                let newValue = value(aSubContext);\n                const underFunction = subContext.underFunction;\n                delete subContext.underFunction;\n                if (newValue instanceof Function && !newValue.tagJsType) {\n                    if (underFunction && newValue.toString() === underFunction.toString()) {\n                        newValue = aSubContext.value;\n                    }\n                    else {\n                        subContext.underFunction = newValue;\n                        newValue = newValue();\n                    }\n                }\n                const result = aSubContext.tagJsVar.processUpdate(newValue, aSubContext, ownerSupport, values);\n                aSubContext.value = newValue;\n                contextItem.value = value;\n                removeContextInCycle();\n                return result;\n            }\n        },\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    // addedContexts.push(subContext)\n    setContextInCycle(subContext);\n    let trueValue = item();\n    const isAgainFunc = isFunction(trueValue) && !trueValue.tagJsType;\n    if (isAgainFunc) {\n        ;\n        subContext.underFunction = trueValue;\n        trueValue = trueValue(); // function returns function\n    }\n    const aSubContext = processNonElement(trueValue, subContext, // parentContext,\n    element, ownerSupport, paintBy);\n    const contexts = parentContext.contexts;\n    contexts.push(subContext);\n    removeContextInCycle();\n    return aSubContext;\n}\n","import { isPromise } from '../index.js';\nimport { addSupportEventListener } from '../interpolations/attributes/addSupportEventListener.function.js';\nimport { afterTagCallback } from '../interpolations/attributes/bindSubjectCallback.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nimport { isSpecialAttr } from '../interpolations/attributes/isSpecialAttribute.function.js';\nimport { renderTagUpdateArray } from '../interpolations/attributes/renderTagArray.function.js';\nimport { processAttributeArray } from '../render/dom/processAttributeArray.function.js';\nimport { paint, paintAppend, painting } from '../render/paint.function.js';\nimport { processChildren } from './processChildren.function.js';\n/** The first and recursive processor for elements */\nexport function processElementVar(value, context, ownerSupport, _addedContexts) {\n    const element = document.createElement(value.tagName);\n    context.target = element;\n    // mark special attributes\n    value.attributes.forEach(x => {\n        const name = x[0];\n        if (typeof (name) !== 'string') {\n            return;\n        }\n        x[2] = isSpecialAttr(name);\n    });\n    processAttributeArray(value.attributes, [], // values,\n    element, ownerSupport, context);\n    /*\n    value.listeners.forEach((listener, index) =>\n      registerListener(value, index, ownerSupport, listener, element)\n    )*/\n    processChildren(value.innerHTML, context, // parentContext\n    ownerSupport, element, paintAppend);\n    value.listeners.forEach((listener, index) => registerListener(value, index, ownerSupport, listener, element));\n    return element;\n}\nfunction registerListener(value, index, ownerSupport, listener, element) {\n    const wrap = (...args) => {\n        const listenScope = value.listeners[index];\n        const toCall = listenScope[1];\n        const stateSupport = getSupportWithState(ownerSupport);\n        const updateCount = stateSupport.context.updateCount;\n        stateSupport.context.locked = 1;\n        ++painting.locks;\n        const result = toCall(...args);\n        --painting.locks;\n        delete stateSupport.context.locked;\n        const needsRender = updateCount === stateSupport.context.updateCount;\n        if (needsRender) {\n            return afterTagCallback(result, stateSupport);\n        }\n        else {\n            paint();\n        }\n        if (isPromise(result)) {\n            return result.then(() => {\n                const newest = stateSupport.context.state.newest;\n                renderTagUpdateArray([newest]);\n                return 'promise-no-data-ever';\n            });\n        }\n        return 'no-data-ever';\n    };\n    addSupportEventListener(ownerSupport.appSupport, listener[0], // eventName\n    element, wrap);\n}\n","import { paintBefore, paintCommands } from '../render/paint.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nexport function processDesignElementInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    // prevent children from calling a parent function and causing a mid render\n    context.locked = 34;\n    const element = processElementVar(value, context, ownerSupport, context.contexts);\n    delete context.locked;\n    paintCommands.push([paintBefore, [insertBefore, element, 'htmlTag.processInit']]);\n    const dom = {\n        nn: value.tagName,\n        domElement: element,\n        at: value.attributes, // TODO: most likely does nothing\n    };\n    context.htmlDomMeta = [dom];\n    return element;\n}\n","import { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions, isValueForContext, loopObjectAttributes } from './elementFunctions.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processDesignElementInit } from './processDesignElementInit.function.js';\nexport function htmlTag(tagName) {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler,\n        processInit: processDesignElementInit,\n        destroy: destroyDesignElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName,\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = tagName;\n    return pushKid;\n}\nexport function getPushKid(element, _elmFunctions) {\n    const pushKid = (...args) => {\n        const newElement = { ...pushKid };\n        newElement.attributes = [...pushKid.attributes];\n        newElement.listeners = [...pushKid.listeners];\n        newElement.allListeners = [...pushKid.allListeners];\n        if (args.length > 0 &&\n            typeof args[0] === 'object' &&\n            !Array.isArray(args[0]) &&\n            !args[0].tagJsType // TODO: need better attribute detection\n        ) {\n            loopObjectAttributes(newElement, args[0]);\n            args.splice(0, 1);\n        }\n        newElement.innerHTML = args;\n        // review each child for potential to be context\n        args.forEach(arg => {\n            if (!isValueForContext(arg)) {\n                return;\n            }\n            if (arg.tagJsType === 'element') {\n                newElement.allListeners.push(...arg.allListeners);\n                if (arg.contexts) {\n                    // the argument is an element so push up its contexts into mine\n                    if (!newElement.contexts) {\n                        // newElement.contexts = [...arg.contexts]\n                        newElement.contexts = arg.contexts;\n                    }\n                    else {\n                        newElement.contexts.push(...arg.contexts);\n                    }\n                }\n                return;\n            }\n            registerMockChildContext(arg, newElement);\n        });\n        return newElement;\n    };\n    Object.assign(pushKid, element);\n    Object.assign(pushKid, elementFunctions(pushKid));\n    pushKid.attributes = [...element.attributes];\n    pushKid.listeners = [...element.listeners];\n    pushKid.allListeners = [...element.allListeners];\n    return pushKid;\n}\n/** used during updates */\nfunction registerMockChildContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\n","import { paint, paintBefore, painting } from '../render/paint.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions } from './elementFunctions.js';\nimport { destroyDesignByContexts } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processChildren } from './processChildren.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\n/** used when you do NOT have a root element returned for your function */\nexport const noElement = noElementMaker();\nexport function noElementMaker() {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler, // its never an attribute\n        processInit: processNoElmInit,\n        destroy: destroyNoElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName: 'no-element',\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = 'no-element';\n    return pushKid;\n}\nfunction processNoElmInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    processChildren(value.innerHTML, context, ownerSupport, insertBefore, paintBefore);\n}\nfunction destroyNoElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                destroyHtmlDomMeta(htmlDomMeta);\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n}\n","import { htmlTag } from './htmlTag.function.js';\nexport { htmlTag };\nexport { noElement } from './noElement.function.js';\nexport const button = htmlTag('button');\nexport const select = htmlTag('select');\nexport const option = htmlTag('option');\nexport const input = htmlTag('input');\nexport const textarea = htmlTag('textarea');\n// HEAD & SUPPORT ELEMENTS\nexport const htmlDoc = htmlTag('html'); // TODO: get this named to html\nexport const head = htmlTag('head');\nexport const title = htmlTag('title');\nexport const meta = htmlTag('meta');\nexport const link = htmlTag('link');\nexport const style = htmlTag('style');\nexport const body = htmlTag('body');\nexport const noscript = htmlTag('noscript');\n// BLOCK ELEMENTS\nexport const hr = htmlTag('hr');\nexport const h1 = htmlTag('h1');\nexport const h2 = htmlTag('h2');\nexport const h3 = htmlTag('h3');\nexport const h4 = htmlTag('h4');\nexport const h5 = htmlTag('h5');\nexport const h6 = htmlTag('h6');\nexport const ol = htmlTag('ol');\nexport const ul = htmlTag('ul');\nexport const li = htmlTag('li');\nexport const div = htmlTag('div');\nexport const main = htmlTag('main');\nexport const section = htmlTag('section');\nexport const header = htmlTag('header');\nexport const footer = htmlTag('footer');\nexport const form = htmlTag('form');\nexport const fieldset = htmlTag('fieldset');\nexport const legend = htmlTag('legend');\nexport const dialog = htmlTag('dialog');\nexport const pre = htmlTag('pre');\n// TABLE ELEMENTS\nexport const table = htmlTag('table');\nexport const tr = htmlTag('tr');\nexport const td = htmlTag('td');\nexport const th = htmlTag('th');\nexport const thead = htmlTag('thead');\nexport const tbody = htmlTag('tbody');\nexport const tfoot = htmlTag('tfoot');\n// INLINE ELEMENTS\nexport const a = htmlTag('a');\nexport const img = htmlTag('img');\nexport const br = htmlTag('br');\nexport const label = htmlTag('label');\nexport const p = htmlTag('p');\nexport const small = htmlTag('small');\nexport const span = htmlTag('span');\nexport const strong = htmlTag('strong');\nexport const b = htmlTag('b');\nexport const sup = htmlTag('sup');\nexport const nav = htmlTag(\"nav\");\nexport const figure = htmlTag(\"figure\");\nexport const figcaption = htmlTag(\"figcaption\");\nexport const code = htmlTag(\"code\");\n// OTHER\nexport const canvas = htmlTag('canvas');\nexport const svg = htmlTag('svg');\nexport const path = htmlTag('path');\nexport const polygon = htmlTag('polygon');\nexport const rect = htmlTag('rect');\n","export const version = \"3.1.8\";\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { firstTagRender, reRenderTag } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport * from './deepFunctions.js';\nexport * from './elements/index.js';\nexport { version } from './version.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    firstTagRender, reRenderTag, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","varCounter","state","newer","states","global","blocked","RouteQuery","_name","setUseMemory","stateConfig","support","setSupportInCycle","setContextInCycle","context","addPaintRemoveAwait","_promise","paintCommands","paintRemoves","paintContent","paintAppends","paintAfters","painting","locks","removeLocks","setContent","text","textNode","textContent","paint","removes","length","content","runPaintRemoves","splice","runPaintCycles","nowPaintAfters","runAfterCycle","addPaintRemover","element","caller","push","paintRemover","_caller","parentNode","removeChild","paintBefore","relative","insertBefore","paintAppend","appendChild","contentCleaner","document","createElement","toPlainTextElm","innerHTML","createTextNode","paintBeforeText","callback","textElm","paintBeforeElementString","paintAppendElementString","empty","ImmutableTypes","BasicTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","isSimpleType","value","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","findStateSupportUpContext","stateMeta","newest","parentContext","getSupportWithState","component","ownerSupport","returnArgs","args","firstStatesHandler","setter","config","statesIndex","reStatesHandler","oldStates","prevSupport","older","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","StateEchoBack","getStateValue","defaultValue","checkValue","getCallbackValue","runRestate","restate","getContextInCycle","msg","console","error","wrapper","original","Error","initValue","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","values","setValue","x","index","item","subscription","clones","shift","subscriptions","map","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","add","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","arguments","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","undefined","processUpdateOneContext","deleted","valueIndex","tagJsVar","processUpdate","removeContextInCycle","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","processUpdateContext","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","cloneValueArray","cloneTagJsValue","shallowPropMatch","props","pastCloneProps","len","pastProp","obEntries","entries","subItem","objectItemMatches","name","pastValue","runBeforeDestroy","providers","provider","children","destroy$","destroyContexts","childTags","child","lastArray","childValue","destroy","iSubs","forEach","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","from","updateCount","forceUpdateExistingValue","domProcessContextItem","appendTo","locked","target","processInit","castTextValue","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","specialAttribute","specialName","autofocus","autoselect","names","split","paintStyle","classListAdd","classListRemove","processSpecialClass","smallName","style","setProperty","classList","remove","select","focus","howToSetInputValue","howToSetInputObjectValue","setNonFunctionInputValue","subValue","setObjectValue","setPropertyValue","howToSetStandAloneAttr","setAttribute","setSimpleAttribute","setBooleanAttribute","removeAttribute","processDynamicNameValueAttribute","howToSet","isSpecial","processInitAttribute","processTagJsAttribute","processNonDynamicAttr","innerValue","tagJsVarOverride","matchesInjection","inject","subContext","hasValueChanged","_contextItem","isAttr","valueToTagJsVar","withinOwnerElement","render$","processFunctionAttr","processAttributeUpdate","oldTag","tagValue","newTagVar","processSimpleAttribute","_ownerSupport","deleteSimpleAttribute","checkSimpleValueChange","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkUpdateDeleteSimpleValueChange","processStringUpdate","_appendTo","castedValue","placeholder","simpleValueElm","elm","oldClone","processUpdateRegularValue","checkArrayValueChange","destroyArrayContext","getArrayTagVar","processArrayInit","processArrayUpdates","processTagArray","_insertBefore","getBasicTagVar","getNewContext","createAndProcessContextItem","noLast","runtimeInsertBefore","removed","filteredLast","newRemoved","compareArrayItems","reviewArrayItem","array","castArrayItem","previousContext","couldBeSame","reviewPreviousArrayItem","newLength","at","lessLength","prevContext","destroyArrayItem","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","oldest","destroySupport","destroyArrayItemByGlobal","destroyArray","destroyHtmlDomMeta","htmlDomMeta","destroyClone","marker","domElement","smartRemoveKids","allPromises","supportOwner","hostDestroy","subGlobal","smartRemoveByContext","destroyContextHtml","promises","returnValue","isLikeTags","newSupport","oldSupport","isLike","isLikeBaseTags","_innerHTML","outerHTML","templater0","templater1","newTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","every","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","destroySupportContext","checkTagValueChange","lastSupport","isTag","tryUpdateToTag","attachDynamicDom","depth","addOneContext","handleProviderChanges","appSupport","tagsWithProvider","memory","cSubject","getTagsWithProvider","mapToSupport","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","castProps","currentDepth","isSkipPropValue","syncPriorPropFunction","priorProp","mem","oldProp","updateExistingArray","hasSetter","getOwnPropertyDescriptor","updateExistingObject","updateExistingTagComponent","oldWrapper","newWrapper","isSameTag","skipComparing","swapTags","hasChanged","newTemplater","latestProps","propsConfig","latest","propsChanged","hasPropChanges","propWatch","hasSupportChanged","renderSupport","newProps","castedProps","syncFunctionProps","lastPropsConfig","syncSupports","PropWatches","DEEP","deepCompareDepth","shallowCompareDepth","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","executeWrap","useSupport","originalFunction","stateless","runAfterRender","saveState","clearStateConfig","callTag","reSupport","createSupport","runAfterSupportRender","reStateByPrev","prevState","reRenderTag","reStateSupport","firstTagRender","getSupportOlderState","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","processTag","inlineHtml","pop","checkRenderUp","selfPropChange","nowProps","hasPropLengthsChanged","IMMUTABLE","immutablePropMatch","SHALLOW","hasPropsToOwnerChanged","getUpTags","supports","isComponent","continueUp","proSupports","prosWithChanges","hasChange","owner","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","syncStatesArray","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","checkToResolvePromise","callbackResult","last","resolvePromise","resolveValue","newestSupport","newestStateMeta","thenResolveBy","bindSubjectCallback","subjectFunction","bindTo","apply","afterTagCallback","runTagCallback","tagFunction","noData","promiseNoData","bubbleEvent","event","replaceEventName","stopped","originalStopPropagation","stopPropagation","defaultPrevented","addSupportEventListener","eventName","appElement","getEventReferenceName","eventReg","events","listener","addEventListener","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","attrValue","processStandAloneAttribute","newContexts","processAttribute","processUpdateAttrContext","attrContextItem","oldValue","isNameOnly","standAloneResult","updateNameOnlyAttrValue","_subject","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","variablePrefix","variableSuffix","placeholderRegex","getTagVarIndex","search","createDynamicArrayAttribute","startIndex","createdContexts","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","join","newValues","getTagJsVar","attrPart","varIndex","isNameVar","valueInValues","stateOwner","oldTagJsVar","processTagJsVarAttribute","aloneResult","valueVar","createDynamicAttribute","special","paintContentPush","processAttributeArray","attrs","attr","newContext","attachDomElement","node","attachDomElements","nodes","v","isNaN","Number","realValue","newNode","nn","attachDomText","newParentContext","isAttrs","ch","tc","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","attributes","attrMatch","parseAttrString","pushTo","inputString","filter","notEmptyStringMapper","part","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","replacePlaceholders","valueCount","currentTail","loopTail","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","mapped","lengthMapper","lastRuns","getDomMeta","stringId","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","template","interpolation","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachHtmlDomMeta","ph","tagFakeTemplater","processTagInit","newSupportByTemplater","createHtmlSupport","processNewSubjectTag","getTemplaterResult","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","wrap","processRenderOnceInit","processSubscribeWith","setupSubscribe","hasEmitted","emitSubContext","observable","Observables","subValueHandler","withDefault","emitValue","processSubscribeAttribute","_tagJsVar","unsubscribeContext","onOutput","callbackValue","syncRun","checkToPaint","setupSubscribeCallbackProcessor","contextItem2","processSubscribeWithAttribute","observables","obValue","emitSubScriptionAsIs","Observable","checkSubscribeValueChanged","deleteAndUnsubscribe","newObserves","oldObserves","ob","handleTagTypeChangeFrom","originalType","updateToDiffValue","checkStillSubscription","valuesHandler","deleteContextSubContext","deleteSubContext","appendMarker","subContextItem","onFirstSubContext","handleInnerHTML","oldProcessInit","processInnerHTML","insertBeforeOriginal","guaranteeInsertBefore","checkInnerHTML","getInnerHTML","processPipe","wrapped","newCallback","syncWrapCallback","newerStates","olderStates","newestOwner","c","newGlobal","options","baseHost","processHostAttribute","processHost","processHostUpdate","deleteHost","injectCallback","returnFunction","assign","oldOptions","newHost","onInit","processHostTagJsVar","attrContext","onDestroy","getOverrideTagVar","overrideTagVar","renderContent","oldType","newType","hasTypeChanged","convertValue","updatesHandler","makeRealUpdate","_context","afterDestroy","convertTagToElementManaged","createSupportWithProps","newPropsConfig","processReplacementComponent","processFirstSubjectComponent","processFirstTagResult","processTagComponentInit","tagCount","onClick","makeEventListener","onMouseDown","type","toBeCalled","tagElement","onclick","click","mousedown","onmousedown","defineGetSet","eventFn","fn","parentWrap","innerTagWrap","getTagWrap","setUse","ValueTypes","tagIndex","returnWrap","updates","NONE","castedPastProps","allFunctionsMatch","compare","subCastedProps","subCompareProps","matched","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","use","deepPropWatch","route","_routeProps","targetItem","currentContext","inContext","message","onRender","callbackWrap","_isFirst","lastContext","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","promise","shallowMapper","deepMapper","getBaseSupport","baseSupport","upgradeBaseToSupport","clonePropsBy","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","ignoreOrDestroyed","before","processNowRegularValue","processUpdateSubscribe","resultNum","updateValue","aContext","newestParentTagJsVar","responseValue","processSignal","initialValue","Signal","Set","unsub","delete","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","pastResult","defaultFinally","init","final","previous","realValues","isFirstRender","processRealValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","previousValues","nowSupport","setTo","newestState","oldestStateSupport","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","cm","ownerProviders","find","warn","TagError","details","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","callbackState","callbackTrigger","createTrigger","_oldStates","maybePromise","supContext","finally","callbackStateUpdate","callbackMaker","syncError","emptyCallback","promiseState","current","trigger","currentPromise","firstSignal","sig","editors","readers","resignal","Proxy","action","getElement","processOuterDomTagInit","checkOuterTagValueChange","getDomTag","setHTML","acceptInnerHTML","useTagVar","taggedJs","appElements","TAG_ELEMENT_MARKER","wasTagged","appElmIndex","appElm","templater2","isApp","debug","loadNewBaseSupport","getNewSubject","isAppFunction","removeEventListener","toAwait","newFragment","createDocumentFragment","renderTagElement","makeAttrCallable","stringsOrValue","isTemplateStringsArray","chunk","callbackWrapper2","wrapCallback","e","listeners","allListeners","getPushKid","elementFunctions","isValueForContext","registerMockAttrContext","idCallable","classCallable","href","src","title","checked","disabled","selected","cellPadding","cellSpacing","border","attr2","makeCallback","callbackWrapper","onClose","onDoubleClick","onBlur","onChange","onInput","onMousedown","onMouseup","onMouseover","onMouseout","onKeydown","onKeyup","id","class","makeAttr","mockElm","setupAttr","eventCallables","onDblClick","onMouseUp","onMouseOver","onMouseOut","onKeyUp","onKeyDown","callables","destroyDesignElement","destroyDesignByContexts","processDesignElementUpdate","checkTagElementValueChange","vContexts","ogListeners","newListener","info","conValues","processChildren","paintBy","handleSimpleInnerValue","subContexts","_c","subSub","aSubContext","underFunction","Function","trueValue","processNonElement","processElementVarFunction","newElement","processElementVar","_addedContexts","toCall","stateSupport","registerListener","processDesignElementInit","htmlTag","pushKid","_elmFunctions","loopObjectAttributes","registerMockChildContext","noElement","processNoElmInit","destroyNoElement","noElementMaker","input","htmlDoc","head","meta","body","noscript","hr","h1","h2","h3","h4","h5","h6","ol","ul","li","div","main","section","header","footer","fieldset","legend","dialog","pre","table","tr","td","th","thead","tbody","tfoot","a","img","br","label","p","small","span","strong","b","sup","nav","figure","figcaption","code","canvas","svg","path","polygon","rect","hmr"],"sourceRoot":""}