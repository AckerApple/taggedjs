{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContext.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/checkSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribe.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/render/afterRender.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/update/deleteSubContext.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/processOuterDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/render/registerNewTagElement.function.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/tagJsVars/pipe.function.ts","webpack://taggedjs/./ts/tagJsVars/host.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribeWith.function.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(contextItem) {\n    ;\n    contextItem.renderCount = contextItem.renderCount || 0;\n    return contextItem.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit': // when read in compile process\n        case 'init': // when read in realtime\n            return 'init';\n        case 'ondestroy': // when read in compile process\n        case 'destroy': // when read in realtime\n            return 'destroy';\n    }\n    return false;\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push([howToSetFirstInputValue, [element, name, value]]);\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles init, destroy, autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName, support, counts) {\n    switch (specialName) {\n        case 'init': { // aka oninit\n            const stagger = counts.added++;\n            // run delayed after elements placed down\n            paintAfters.push([paintSpecialAttribute, [element, stagger, value]]);\n            return;\n        }\n        case 'destroy': { // aka ondestroy\n            const stagger = counts.removed++;\n            const global = support.context.global;\n            global.destroys = global.destroys || [];\n            global.destroys.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                return value(event); // call destroy/ondestroy\n            });\n            return;\n        }\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value;\n    element.style.setProperty(smallName, value);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\nfunction paintSpecialAttribute(element, stagger, value) {\n    const event = {\n        target: element,\n        stagger,\n    };\n    value(event); // call init/oninit\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.context.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    return setUseMemory.stateConfig.support = support;\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.context.global.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function initState(support) {\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    setSupportInCycle(support);\n}\nexport function reState(newSupport, prevSupport, prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","export function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    const counts = { added: 0, removed: 0 };\n    while (index < len) {\n        processUpdateOneContext(values, index, contexts, support, counts);\n        ++index;\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport, counts) {\n    const newValue = values[index];\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate(newValue, ownerSupport, contextItem, values, counts);\n    contextItem.value = newValue;\n    // contextItem.tagJsVar = valueToTagJsVar(newValue)\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.context.global;\n    const context = global.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    // baseSupport.appSupport = baseSupport\n    const global = context.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport, counts) {\n    const isComp = isTagComponent(newValue);\n    contextItem.tagJsVar = newValue;\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport, counts);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, counts, undefined, // appendTo,\n    contextItem.placeholder);\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport, counts) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, counts, undefined, // appendTo,\n        contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = global.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const global = oldSupport.context.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n    contextItem.placeholder);\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = oldSupport.context;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\nownerSupport, contextItem, _values, counts) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport, counts);\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContext(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContext(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.delete(child, ownerSupport);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.contexts;\n        // recurse\n        destroyContext(subTags, support);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContextItem(subject);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArrayContextItem(subject) {\n    const lastArray = subject.lastArray;\n    destroyArray(subject, lastArray);\n}\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { paint, paintCommands, painting, paintRemover } from '../render/paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.contexts;\n    const destroys = global.destroys;\n    if (destroys) {\n        return processContextDestroys(destroys, global, allPromises);\n    }\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\nconst promises = [];\nfunction destroyCall(destroy) {\n    const maybePromise = destroy();\n    const isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        promises.push(maybePromise);\n    }\n}\n// Elements that have a destroy or ondestroy attribute\nfunction processContextDestroys(destroys, global, allPromises) {\n    promises.length = 0;\n    destroys.forEach(destroyCall);\n    if (promises.length) {\n        const lastPromise = Promise.all(promises)\n            .then(() => {\n            ++painting.locks;\n            // continue to remove\n            smartRemoveByContext(global.contexts, allPromises);\n            destroyClones(global);\n            --painting.locks;\n            paint();\n        });\n        // run destroy animations\n        allPromises.push(lastPromise);\n        return;\n    }\n    ++painting.locks;\n    smartRemoveByContext(global.contexts, allPromises);\n    destroyClones(global);\n    --painting.locks;\n    paint();\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.locked) {\n            continue;\n        }\n        if (subject.withinOwnerElement) {\n            const tagJsVar = subject.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = subject.supportOwner;\n                tagJsVar.delete(subject, newest);\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintCommands.push([paintRemover, [elm, 'destroy simpleValueElm']]);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        paintCommands.push([paintRemover, [marker, 'destroy-marker-clone']]);\n    }\n    const dom = clone.domElement;\n    if (!dom) {\n        return;\n    }\n    paintCommands.push([paintRemover, [dom, 'destroy-clone']]);\n}\n","import { destroyContext } from '../tag/destroyContext.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.context;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.contexts;\n    destroyContext(context, support);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nimport { destroySupport } from '../../render/destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    const element = item.simpleValueElm;\n    delete item.simpleValueElm;\n    paintCommands.push([paintRemover, [element, 'array-delete']]);\n}\n","export function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    // const tagJsVar = valueToTagJsVar(value)\n    // contextItem.tagJsVar = tagJsVar\n    const tagJsVar = contextItem.tagJsVar;\n    return tagJsVar.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nexport function domProcessContextItem(value, support, contextItem, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    // contextItem.handler = tagValueUpdateHandler\n    const subject = support.context;\n    subject.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    delete subject.locked;\n    contextItem.value = value;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { tagValueUpdateHandler } from \"../tag/update/tagValueUpdateHandler.function.js\";\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInit: processSimpleValueInit,\n        delete: deleteSimpleValue,\n        // TODO: get down to only one\n        checkValueChange: checkSimpleValueChange,\n        processUpdate: tagValueUpdateHandler,\n    };\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo, insertBefore) {\n    // value = value.value\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(contextItem) {\n    const elm = contextItem.simpleValueElm;\n    delete contextItem.simpleValueElm;\n    paintCommands.push([paintRemover, [elm, 'simple-tag-remove']]);\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return -1; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\n","import { checkArrayValueChange, destroyArrayContextItem } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInit: processArrayInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkArrayValueChange,\n        delete: destroyArrayContextItem,\n    };\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, counts, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = {\n        value,\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement: false,\n        placeholder: element,\n    };\n    if (!appendTo) {\n        paintCommands.push([paintBefore, [insertBefore, element]]);\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            // 👁️ COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, ownerSupport, itemSubject, undefined, counts);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, counts);\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport, counts) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.checkValueChange(newValue, contextItem, counts, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nexport function checkSubContext(newValue, ownerSupport, contextItem, values, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const subscription = contextItem.subContext;\n    if (!subscription.hasEmitted) {\n        return -1;\n    }\n    subscription.callback = newValue.callback;\n    subscription.valuesHandler(subscription.lastValues);\n    return -1;\n}\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem, counts) {\n    if (!newValue || !newValue.tagJsType || newValue.tagJsType !== originalType) {\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.delete(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, ownerSupport, 99, counts);\n        return 99;\n    }\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, counts, insertBefore);\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { deleteSubContext } from './deleteSubContext.function.js';\nimport { checkSubContext } from './checkSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nexport function setupSubscribe(observables, contextItem, ownerSupport, counts, callback, appendTo, insertBeforeOriginal) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, counts, insertBefore, callback);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    // contextItem.handler = checkSubContext\n    contextItem.tagJsVar.processUpdate = checkSubContext;\n    return subContext;\n}\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore, callback) {\n    const component = getSupportWithState(ownerSupport);\n    let onOutput = function onSubValue(value) {\n        onFirstSubContext(value, subContext, ownerSupport, counts, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = function subscriptionUpdate(updateValue) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport, { added: 0, removed: 0 });\n            checkToPaint(syncRun);\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    function valueHandler(value, index) {\n        subContext.lastValues[index] = value;\n        valuesHandler(subContext.lastValues);\n    }\n    function valuesHandler(values) {\n        const newComponent = component.context.global.newest;\n        syncSupports(newComponent, component);\n        if (subContext.callback) {\n            const responseValue = subContext.callback(...values);\n            onOutput(responseValue);\n            return;\n        }\n        onOutput(values[0]);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        valueHandler,\n        valuesHandler,\n        callback,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => valueHandler(value, index)));\n        syncRun = false;\n    });\n    return subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.subscriptions.forEach(sub => sub.unsubscribe());\n    return deleteSubContext(contextItem, ownerSupport);\n}\nfunction checkToPaint(syncRun) {\n    if (!syncRun && !setUseMemory.stateConfig.support) {\n        paint();\n    }\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    return setupSubscribe(value.Observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSubscribeWith(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    const observables = value.Observables;\n    const subscription = setupSubscribe(observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n    if (!subscription.hasEmitted) {\n        const obValue = observables[0]?.value;\n        subscription.valueHandler((obValue || value.withDefault), 0);\n    }\n    return subscription;\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, appendTo) {\n    setupSubscribe([value], contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { handleTagTypeChangeFrom } from '../tag/update/checkSubContext.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        // processUpdate: tagValueUpdateHandler,\n        // processUpdate: checkSubContext,\n        processUpdate: (newValue, ownerSupport, contextItem, _values, counts) => handleTagTypeChangeFrom(ValueTypes.signal, newValue, ownerSupport, contextItem, counts),\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        delete: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.context.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.context.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const ownGlobal = owner.ownerSupport.context.global;\n            const ownerProviders = ownGlobal.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const global = support.context.global;\n                const providers = global.providers = global.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.context.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.context.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    // OLDEST UPDATE NEWEST: send the oldest state changes into the newest\n    //syncStatesArray(oldStates, newestSupport.states)\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            // syncStatesArray(oldStates, newestSupport.states)\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.context.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, global, mode, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        // const global0 = subject.global as SupportTagGlobal\n        subject.locked = true;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const global = last.context.global;\n        //clearTimeout(timeout)\n        if (global.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        const subject = last.context;\n        const global1 = last.context.global;\n        delete subject.locked;\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, global1.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","import { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const nowSupport = getSupportInCycle();\n        return checkToResolvePromise(result, nowSupport, nowSupport.context.global, 'onInit', { resolvePromise, resolveValue });\n    });\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.context.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nexport function checkTagValueChange(newValue, contextItem, counts) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport, counts);\n        return -1;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return -1;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destroySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.context;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const global = support.context.global;\n    global.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, counts, contexts, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem, // could be tag via result.tag\ncounts) {\n    const global = contextItem.global;\n    const support = global.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.contexts = [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker]]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement]]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem, counts);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(function eachCastProp(prop) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, depth);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.context.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const global = ownerSupport.context.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const subject = newest.context;\n        const global = subject.global;\n        if (!global || subject.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from '../tag/checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n","import { executeWrap } from './executeWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    runBeforeRender(newSupport, prevSupport);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\nfunction runBeforeRender(newSupport, prevSupport) {\n    const prevState = prevSupport?.state;\n    if (prevState) {\n        reState(newSupport, prevSupport, prevState);\n        return;\n    }\n    initState(newSupport);\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { renderTagOnly } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    buildBeforeElement(support, counts, undefined, // element for append child\n    subject.placeholder);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    return processFirstTagResult(support, counts, appendTo);\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, counts, appendTo) {\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../tag/checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.delete = destroySupportByContextItem;\n        oneRenderFunction.checkValueChange = function renderOnceNeverChanges() {\n            return -1;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.checkValueChange = checkTagValueChange;\n        renderFunction.delete = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from '../render/renderSupport.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContext.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.context;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.contexts);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject) {\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.context.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const global = subject.global;\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    if (result.wasLikeTags) {\n        updateSupportBy(global.oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject, { added: 0, removed: 0 });\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../tag/hasSupportChanged.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = true;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(global.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownGlobal = ownerSupport.context.global;\n    const newest = ownGlobal.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.context.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, global, 'bind', { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from '../../render/attributes/processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nconst actions = ['init', 'destroy']; // oninit ondestroy\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        if (isSpecial && actions.includes(attrName)) {\n            specialAttribute(attrName, value, element, attrName, support, counts);\n            return;\n        }\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial, support, counts);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.context.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processNameOnlyAttrValue } from '../../render/attributes/processAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateAttribute.function.js';\nexport function processUpdateAttrContext(value, ownerSupport, contextItem, values) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        { added: 0, removed: 0 });\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, { added: 0, removed: 0 });\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { addOneContext } from '../index.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, // all the variables inside html``\nattrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        if (value.tagJsType) {\n            contextItem.tagJsVar = value;\n            contextItem.stateOwner = getSupportWithState(support);\n            contextItem.supportOwner = support;\n            return processHost(element, value, contextItem);\n        }\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // stand alone attributes\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, context, howToSet, support, counts, values);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, context, howToSet, support, counts, isSpecial);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nfunction processHost(element, hostVar, contextItem) {\n    hostVar.processInit(element, hostVar, contextItem);\n    return;\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special, // string name of special\n        support, counts);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    const tagJsVar = subject.tagJsVar; // = valueToTagJsVar(newAttrValue)\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, values) {\n    const startIndex = context.length;\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = context.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHanlder(value, newSupport, contextItem, newValues) {\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            context.push(contextItem);\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, isSpecial) {\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        isAttr: true,\n        element,\n        attrName,\n        withinOwnerElement: true,\n        tagJsVar,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n    contextItem.value = value;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, marker]]);\n    }\n    domProcessContextItem(value, support, contextItem, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { howToSetFirstInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { paintAppend, paintAppendElementString, paintAppends, paintBefore, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nexport const blankHandler = function blankHandler() {\n    return undefined;\n};\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, context, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        for (const attr of node.at) {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            processAttribute(values, name, domElement, support, howToSetFirstInputValue, context, isSpecial, counts, value);\n        }\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement]]);\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { blankHandler } from \"./dom/attachDomElements.function.js\";\nexport let paintCommands = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore and element.parentNode.removeChild\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function paintRemover(element) {\n    const parentNode = element.parentNode;\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element) {\n    relative.parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nexport function deleteSubContext(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.deleted = true;\n    delete contextItem.subContext;\n    const appendMarker = subscription.appendMarker;\n    if (appendMarker) {\n        paintCommands.push([paintRemover, [appendMarker, 'subcontext-delete']]);\n        delete subscription.appendMarker;\n    }\n    delete contextItem.delete;\n    // contextItem.handler = tagValueUpdateHandler\n    // const tagJsVar = contextItem.tagJsVar as TagJsVar\n    //tagJsVar.processUpdate = tagValueUpdateHandler\n    if (!subscription.hasEmitted) {\n        return;\n    }\n    const subContextItem = subscription.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.delete(subContextItem, ownerSupport);\n    return 76;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem, counts);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    counts, appendTo, insertBefore);\n    // contextItem.handler = function outDomTagHanlder(\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate = function outDomTagHanlder(value, newSupport, contextItem2, _values, counts) {\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport, counts);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.checkValueChange = checkOuterTagValueChange;\n}\nfunction checkOuterTagValueChange(newValue, contextItem, counts) {\n    return checkTagValueChange(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem, // subContext.contextItem as any,\n    counts);\n}\n/** When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { getStringTag } from './processOuterDomTagInit.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nexport function registerTagElement(support, element, global, templater, app, placeholder) {\n    console.debug('🏷️ Building element into tag...', { element, app, support });\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    console.debug('🏷️ Element Tag DOM built ✅');\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterRender } from '../render/afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reState } from '../state/state.utils.js';\nexport function renderTagElement(app, global, templater, templater2, element, subject, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn('🏷️🏷️ Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    return renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const subject = {\n        value: templater,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        tagJsVar,\n    };\n    const global = getNewGlobal(subject);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\n","import { paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport);\n    };\n}\nexport function syncWrapCallback(args, callback, ownerSupport) {\n    const newestOwner = ownerSupport.context.global.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newestOwner.states, ownerSupport.states);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(ownerSupport.states, newestOwner.states);\n    // now render the owner\n    safeRenderSupport(newestOwner);\n    paint();\n    return c;\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { checkSubContext, ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    const support = getSupportInCycle();\n    const states = support ? getSupportWithState(support).states : [];\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        processUpdate: checkSubContext,\n        // processUpdate: tagValueUpdateHandler,\n        // processUpdate: blankHandler,\n        // checkValueChange: checkTagValueChange,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states,\n        Observables: [Observable],\n    };\n}\n","import { deleteSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, newSupport, contextItem, _values, counts) {\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport, counts);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, counts, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, counts, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, counts, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        delete: deleteSubContext,\n    };\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processPipe,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, counts, appendTo) {\n    return setupSubscribe(values, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { paintAfters } from \"../render/paint.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/checkSubContext.function.js\";\n/** Use to gain access to element */\nexport function host(callback, options = {}) {\n    return {\n        tagJsType: ValueTypes.host,\n        processInit: processHost,\n        processUpdate: processHostUpdate,\n        delete: deleteHost,\n        options: { callback, ...options },\n    };\n}\nfunction processHostUpdate(newValue, ownerSupport, contextItem, _values, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    const element = contextItem.element;\n    options.callback(element, newValue);\n}\nfunction processHost(element, tagJsVar, contextItem) {\n    tagJsVar.options.callback(element, tagJsVar);\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        const element = contextItem.element;\n        options.onInit(element, tagJsVar, contextItem);\n    }\n}\nfunction deleteHost(contextItem) {\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    if (options.onDestroy) {\n        const element = contextItem.element;\n        const hostDestroy = function processHostDestroy() {\n            options.onDestroy(element);\n        };\n        paintAfters.push([function hostCloser() {\n                const stateOwner = contextItem.stateOwner;\n                syncWrapCallback([], hostDestroy, stateOwner);\n            }, []]);\n    }\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribeWith,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables: [Observable],\n    };\n}\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { renderTagOnly } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","global","RouteQuery","_name","variablePrefix","variableSuffix","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","placeholderRegex","RegExp","getTagVarIndex","value","search","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","length","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","index","textContent","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","pop","attributes","attrMatch","parseAttrString","element","nn","at","ch","push","textNode","pushTo","tc","postProcessTagsInComments","inputString","split","filter","notEmptyStringMapper","part","attrValue","undefined","notEmpty","noValue","lowerName","toLowerCase","fixedName","eventName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","x","forEach","isSpecial","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","strings","values","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","join","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","replacePlaceholders","valueCount","currentTail","i","loopTail","attrs","processAttributes","children","innerLoopTail","examineChild","child","textChild","string","secondMatch","wIndex","parseInt","isNaN","varContent","after","splice","v","lastIndex","mapped","tagJsVar","lengthMapper","lastRuns","getDomMeta","stringId","array","map","Number","getStringsId","lastRun","matches","every","isLastRunMatched","domMetaMap","template","interpolation","howToSetInputValue","name","paintContent","howToSetFirstInputValue","setAttribute","removeAttribute","specialAttribute","specialName","support","counts","stagger","added","paintAfters","paintSpecialAttribute","removed","context","destroys","target","autofocus","autoselect","names","paintStyle","shift","classListAdd","classListRemove","processSpecialClass","Error","smallName","style","setProperty","classList","add","remove","select","focus","isSimpleType","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","handleProviderChanges","appSupport","provider","tagsWithProvider","memory","childTags","cSubject","getTagsWithProvider","mapToSupport","deepClone","maxDepth","makeDeepClone","clone","create","getPrototypeOf","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","getSupportInCycle","setUseMemory","stateConfig","setSupportInCycle","getSupportWithState","component","ownerSupport","newest","returnArgs","args","firstStatesHandler","setter","config","states","statesIndex","reStatesHandler","oldStates","prevSupport","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","stateArray","reState","newSupport","prevState","runRestate","StateEchoBack","getStateValue","state","callback","defaultValue","checkValue","getCallbackValue","restate","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","setValue","item","subscription","clones","subscriptions","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","syncSupports","newestSupport","syncStatesArray","from","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","processUpdateOneContext","processUpdate","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","painting","locks","len","processUpdateContext","paint","cloneValueArray","cloneTagJsValue","shallowMapper","shallowCompareDepth","deepMapper","props","deepCompareDepth","getBaseSupport","castedProps","baseSupport","blocked","destroy$","upgradeBaseToSupport","propsConfig","castProps","propWatch","PropWatches","IMMUTABLE","latest","SHALLOW","clonePropsBy","createHtmlSupport","createSupport","tryUpdateToTag","isComp","processInit","placeholder","oldSupport","oldWrapper","wrapper","newWrapper","isSameTag","skipComparing","isLikeTags","innerHTML","_innerHTML","outerHTML","oldestSupport","oldest","destroySupport","swapTags","hasChanged","newTemplater","latestProps","pastCloneProps","propsChanged","hasPropChanges","hasSupportChanged","newProps","syncFunctionProps","lastPropsConfig","DEEP","locked","renderSupport","updateExistingTagComponent","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","tagValueUpdateHandler","_values","forceUpdateExistingValue","runBeforeDestroy","providers","destroyContext","lastArray","childValue","delete","iSubs","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","checkArrayValueChange","destroyArrayContextItem","destroyArray","destroyArrayItem","smartRemoveKids","allPromises","promises","destroyCall","lastPromise","smartRemoveByContext","destroyClones","processContextDestroys","destroy","maybePromise","withinOwnerElement","supportOwner","elm","simpleValueElm","paintCommands","paintRemover","subGlobal","deleted","htmlDomMeta","destroyClone","marker","domElement","compareArrayItems","newLength","lessLength","prevContext","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","destroyArrayItemByGlobal","processFirstSubjectValue","appendTo","insertBefore","domProcessContextItem","castTextValue","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkValueChange","checkSimpleValueChange","castedValue","paintBeforeText","oldClone","setContent","processUpdateRegularValue","getArrayTagVar","processArrayInit","processTagArray","valueToTagJsVar","getBasicTagVar","createAndProcessContextItem","document","createTextNode","paintBefore","paintAppends","paintAppend","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","updateToDiffValue","ignoreOrDestroyed","before","processNowRegularValue","checkSubContext","handleTagTypeChangeFrom","subContext","hasEmitted","valuesHandler","originalType","onFirstSubContext","guaranteeInsertBefore","appendMarker","setupSubscribe","observables","insertBeforeOriginal","onOutput","checkToPaint","syncRun","updateValue","valueHandler","responseValue","observable","setupSubscribeCallbackProcessor","deleteAndUnsubscribe","deleteSubContext","processSubscribe","Observables","processSubscribeWith","obValue","withDefault","processSignal","initialValue","Signal","Set","unsub","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","defaultFinally","init","final","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","owner","cm","compareTo","inject","ownerProviders","find","msg","console","warn","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","syncError","createTrigger","finally","callbackStateUpdate","callbackMaker","renderTagUpdateArray","supports","mapTagUpdate","checkToResolvePromise","callbackResult","last","mode","resolvePromise","resolveValue","global1","getUpTags","thenResolveBy","onInit","onDestroy","firstSignal","sig","editors","readers","resignal","Proxy","action","isLike","isLikeBaseTags","templater0","templater1","newTag","oldTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings1","values0","values1","valuesLengthsMatch","allVarsMatch","isLikeValueSets","isLikeStringTags","checkTagValueChange","lastSupport","isTag","destroySupportByContextItem","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachDomElements","attachHtmlDomMeta","addOneContext","processTag","ph","tagFakeTemplater","processTagInit","newSupportByTemplater","processNewSubjectTag","getTemplaterResult","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","depth","checkProp","alterProp","already","mem","wrap","toCall","callWith","noCycle","apply","run","callbackPropOwner","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","executeWrap","useSupport","originalFunction","stateless","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","checkStateMismatch","tagFunction","newStates","error","hint","throwStateMismatch","runAfterRender","renderTagOnly","runBeforeRender","reSupport","processRenderOnceInit","processFirstSubjectComponent","newPropsConfig","processFirstTagResult","processTagComponentInit","processResult","processReplacementComponent","tagCount","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","pastProp","obEntries","subItem","objectItemMatches","use","deepPropWatch","route","_routeProps","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","pastValue","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","cGlobal","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","inlineHtml","checkRenderUp","selfPropChange","nowProps","hasPropsToOwnerChanged","isComponent","continueUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","bindSubjectCallback","subjectFunction","bindTo","eventHandlerSupport","renderCallbackSupport","afterTagCallback","runTagCallback","noData","promiseNoData","actions","processNonDynamicAttr","howToSet","addSupportEventListener","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","parentNode","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","processUpdateAttrContext","isNameOnly","processNameOnlyAttrValue","updateNameOnlyAttrValue","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","createDynamicArrayAttribute","startIndex","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","isAttr","newValues","createDynamicAttribute","processDynamicNameValueAttribute","getTagJsVar","attrPart","processAttribute","nameVar","stateOwner","hostVar","processHost","valueVar","special","paintContentPush","attachDynamicDom","blankHandler","nodes","node","newNode","attachDomText","attachDomElement","createElement","attr","paintAppendElementString","paintBeforeElementString","text","content","nowPaintAfters","removeChild","relative","appendChild","contentCleaner","toPlainTextElm","textElm","subContextItem","processDomTagInit","processOuterDomTagInit","contextItem2","checkOuterTagValueChange","getDomTag","setHTML","oldProcessInit","acceptInnerHTML","useTagVar","stringTag","getStringTag","putOneDomDown","newFragment","loadNewBaseSupport","renderTagElement","templater2","isAppFunction","isFirstRender","executeStateWrap","runWrapper","isApp","removeEventListener","toAwait","debug","appElements","createDocumentFragment","domItem","registerTagElement","taggedJs","tagElement","appElmIndex","appElm","getNewSubject","syncWrapCallback","newestOwner","c","Observable","handleInnerHTML","realValue","processInnerHTML","checkInnerHTML","getInnerHTML","processPipe","options","processHostUpdate","deleteHost","hostDestroy","hmr"],"sourceRoot":""}