{"version":3,"file":"bundle.js","mappings":"AACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,KCA3E,SAASI,EAAaC,GAIzB,OAFAA,EAAQC,YAAcD,EAAQC,aAAe,EAEtCD,EAAQE,OAAS,CAAC,CAC7B,C,ktBCLO,MAAMC,EACT,GAAAV,CAAIW,GACA,MAAO,MACX,ECHG,MAAMC,EAAQ,GACd,IAAIC,EAOAC,GANX,SAAWD,GACPA,EAAuB,OAAI,SAC3BA,EAAuB,OAAI,SAC3BA,EAAwB,QAAI,UAC5BA,OAAe,GAAe,WACjC,CALD,CAKGA,IAAmBA,EAAiB,CAAC,IAExC,SAAWC,GACPA,EAAqB,SAAI,WACzBA,EAAiB,KAAI,OACrBA,EAAoB,QAAI,UACxBA,EAAmB,OAAI,QAC1B,CALD,CAKGA,IAAeA,EAAa,CAAC,IAChC,MAEaC,EAAa,CACtBC,IAAK,OACLC,IAAK,MACLC,UAAW,YACXC,aAAc,eACdC,SAAU,WACVb,QAAS,UACTc,aAAc,eACdC,WAAY,aACZC,YAAa,cACbC,QAZYC,KAAKC,OCZd,SAASC,EAAOC,GAEnB,OADgBC,KAELC,GAAM,IAAMC,EAAOH,KAEvBG,EAAOH,EAClB,CAEO,SAASG,EAAOH,GACnB,IAAII,EAAQJ,EACZ,MAAMK,EAAc,IAAIC,IACxB,MAAO,CACH,SAAIF,GACA,OAAOA,CACX,EACA,SAAIA,CAAMG,GACFH,IAAUG,IACVH,EAAQG,EAERF,EAAYG,SAAQC,GAAYA,EAASF,KAEjD,EACA,SAAAG,CAAUD,GACNA,EAASL,GACTC,EAAYM,IAAIF,GAEhB,MAAMG,EAAQ,IAAMP,EAAYQ,OAAOJ,GAGvC,OADAG,EAAME,YAAcF,EACbA,CACX,EAER,CClCO,SAASG,EAAaX,GACzB,OAAQA,GACJ,KAAKnB,EAAe+B,OACpB,KAAK/B,EAAegC,OACpB,KAAKhC,EAAeiC,QAChB,OAAO,EAEf,OAAO,CACX,CACO,SAASC,EAAYf,GACxB,IAAKA,EACD,OAAO,EAGX,OADkBA,EAAMgB,WAEpB,KAAKjC,EAAWE,IAChB,KAAKF,EAAWC,IAChB,KAAKD,EAAWG,UACZ,OAAO,EAEf,OAAO,CACX,CAEO,SAAS+B,EAAejB,GAC3B,MAAMkB,EAAUlB,GAAOgB,UACvB,OAAOE,IAAYnC,EAAWI,cAAgB+B,IAAYnC,EAAWQ,WACzE,CAEO,SAAS4B,EAAkB5C,GAC9B,OAAO6C,EAAS7C,WAAmBA,EAAQ+B,YAAcxB,EAAWuC,QACxE,CACO,SAASC,EAAUtB,GACtB,OAAOA,GAASuB,EAAWvB,EAAMwB,KACrC,CACO,SAASD,EAAWvB,GACvB,cAAcA,IAAUlB,EAAWuC,QACvC,CACO,SAASD,EAASpB,GACrB,cAAc,IAAYlB,EAAW2C,QAAoB,OAAVzB,CACnD,CACO,SAAS0B,EAAQ1B,GACpB,OAAO2B,MAAMD,QAAQ1B,EACzB,CC1CO,SAAS4B,EAAcC,GAC1B,MAAMC,EAAS,IAAIC,EA6BnB,OADAD,EAAOE,cA3BY3B,IACf,MAAM4B,EAAa,GACbC,EAAS,GACTC,EAAW,CAACC,EAAGC,KACjBJ,EAAWI,IAAS,EACpBH,EAAOG,GAASD,EAEhB,GADqBH,EAAWK,SAAWT,EAASS,OACpD,CAGA,IAAK,MAAMC,KAAQN,EACf,IAAKM,EACD,OAIRlC,EAAS6B,EAAQM,EAPjB,CAO8B,EAE5BC,EAAS,IAAIZ,GAEbW,EADWC,EAAOC,QACMpC,WAAU8B,GAAKD,EAASC,EAAG,KACnDO,EAAgBF,EAAOG,KAAI,CAACrE,EAAS8D,IAChC9D,EAAQ+B,WAAU8B,GAAKD,EAASC,EAAGC,EAAQ,OAGtD,OADAG,EAAaG,cAAgBA,EACtBH,CAAY,EAGhBV,CACX,CCzBO,SAASe,EAAgBtE,EAAS8B,EAAUJ,GAC/C,MAAM6C,EAAef,EAAQgB,gBAC7BhB,EAAQgB,gBAAgBC,KAAKF,EAAa9C,MAAQ,GAClD,MAAMwC,EAAe,WACjBA,EAAa9B,aACjB,EAcA,OAbA8B,EAAanC,SAAWA,EACxBmC,EAAaG,cAAgB,GAE7BH,EAAa9B,YAAc,WACvB,OA0BR,SAAqB8B,EAAcvC,EAAaI,IA1ChD,SAA4BJ,EAAaI,GACrC,MAAMgC,EAAQpC,EAAYgD,WAAUC,GAAOA,EAAI7C,WAAaA,KAC7C,IAAXgC,GACApC,EAAYkD,OAAOd,EAAO,EAElC,CAsCIe,CAAmBnD,EAAaI,GAChC,MAAMgD,EAAStB,EAAQgB,gBACvBhB,EAAQgB,gBAAgBC,KAAKK,EAAOrD,MAAQ,GAE5CwC,EAAa9B,YAAc,IAAM8B,EAEjC,MAAMG,EAAgBH,EAAaG,cACnC,IAAK,MAAMO,KAAOP,EACdO,EAAIxC,cAER,OAAO8B,CACX,CAtCe9B,CAAY8B,EAAcvC,EAAaI,EAClD,EACAmC,EAAajC,IAAO2C,IAChBV,EAAaG,cAAcW,KAAKJ,GACzBV,GAEXA,EAAaQ,KAAQhD,IACjBK,EAASL,EAAOwC,EAAa,EAE1BA,CACX,CACO,SAASe,EAAgBvD,EAAOwD,EAASC,GAC5C,MAAMC,EAAe,IAAIF,GACnBG,EAAcD,EAAahB,QAC3BM,EAAQ7C,IACV,GAAIuD,EAAapB,OACb,OAAOiB,EAAgBpD,EAAUuD,EAAcD,GAEnDA,EAAWtD,EAAS,EAExB,IAAIyD,EAAUZ,EACd,MAEMa,EAAiBF,EAAY3D,EADjB,CAAE8D,WADA1B,GAAMwB,EAAUxB,EACJY,SAEhCY,EAAQC,EACZ,CCvCO,MAAM9B,EACT/B,MACA+D,eAEAP,QAAU,GACVQ,WAAY,EAEZ/D,YAAc,GACd+B,cACA,WAAAiC,CAAYjE,EAEZ+D,GACIG,KAAKlE,MAAQA,EACbkE,KAAKH,eAAiBA,CAE1B,CACA,SAAAzD,CAAUD,GACN,MAAMmC,EAAeK,EAAgBqB,EAAM7D,EAAU6D,KAAKjE,aAEpD+B,EAAgBkC,KAAKlC,cAC3B,GAAIA,EAAe,CAEf,GAAIkC,KAAKV,QAAQlB,OAAQ,CACrB,MAAM6B,EAAc9D,EACpBA,EAAYL,IACRuD,EAAgBvD,EAAOkE,KAAKV,SAASY,GAAaD,EAAYC,EAAW5B,IAAc,CAE/F,CACA,OAAOR,EAAc3B,EACzB,CAKA,OAJA6D,KAAKjE,YAAYqD,KAAKd,GAClB0B,KAAKH,gBACLG,KAAKH,eAAevB,GAEjBA,CACX,CACA,IAAAQ,CAAKhD,GACDkE,KAAKlE,MAAQA,EACbkE,KAAKG,MACT,CACAC,IAAMJ,KAAKlB,KAAKuB,KAAKL,MACrB,IAAAG,GACI,MAAMrE,EAAQkE,KAAKlE,MAGbwE,EAAON,KAAKjE,YAElB,IAAK,MAAMiD,KAAOsB,EACdtB,EAAI7C,SAASL,EAAOkD,EAE5B,CACA,SAAAuB,GACI,OAAO,IAAIC,SAAQC,IACfT,KAAK5D,WAAU,CAAC8B,EAAGI,KACfA,EAAa9B,cACbiE,EAAIvC,EAAE,GACR,GAEV,CAEA,UAAAwC,CAAWvE,GACP,MAAMmC,EAAe0B,KAAK5D,WAAU,CAAC8B,EAAGyC,KACpC,MAAMC,EAAaD,GAAYnE,YAC3BoE,EACAA,IAGAC,YAAW,IAAMvC,EAAa9B,eAAe,GAEjDL,EAAS+B,EAAE,IAEf,OAAO8B,IACX,CACA,IAAAc,IAAQC,GACJ,MAAM1G,EAAU,IAAIwD,EAAQmC,KAAKlE,OAIjC,OAHAzB,EAAQ2G,WAAWD,GACnB1G,EAAQyD,cAAiBI,GAAM8B,KAAK5D,UAAU8B,GAC9C7D,EAAQyE,KAAOZ,GAAK8B,KAAKlB,KAAKZ,GACvB7D,CACX,CACA,UAAA2G,CAAWD,GACPf,KAAKV,QAAUyB,CACnB,CACA,UAAOE,CAAIC,GAWP,OAAOxD,EAVUwD,EAAKxC,KAAIyC,IACtB,GAAIlE,EAAkBkE,GAClB,OAAOA,EAMX,OAJU,IAAItD,EAAQsD,GAAK7C,IACvBA,EAAaQ,KAAKqC,GACX7C,IAEH,IAGhB,CACA8C,uBAAyB,IAAIvD,EAAQ,GAElC,MAAMwD,UAAmBxD,EAC5B/B,MACA+D,eACAyB,OACA,WAAAvB,CAAYjE,EAEZ+D,GACI0B,MAAMzF,EAAO+D,GACbG,KAAKlE,MAAQA,EACbkE,KAAKH,eAAiBA,EACtBG,KAAKsB,OAASxF,EACd0F,EAAcxB,KAClB,CACA,IAAAlB,CAAKhD,GACDkE,KAAKsB,OAASxF,EACdkE,KAAKG,MACT,CACA,IAAAA,GACI,MAAMrE,EAAQkE,KAAKsB,OAGbhB,EAAON,KAAKjE,YAElB,IAAK,MAAMiD,KAAOsB,EACdtB,EAAI7C,SAASL,EAAOkD,EAE5B,EAEG,SAASwC,EAAcnH,GAC1BV,OAAOC,eAAeS,EAAS,QAAS,CAEpC,GAAA+F,CAAItE,GACAzB,EAAQiH,OAASxF,EACjBzB,EAAQ8F,MACZ,EAEArG,IAAG,IACQO,EAAQiH,QAG3B,CC5IO,MAAMG,UAAqB5D,EAC9B/B,MACA,WAAAiE,CAAYjE,GACRyF,MAAMzF,GACNkE,KAAKlE,MAAQA,CACjB,CACA,SAAAM,CAAUD,GACN,MAAMmC,EAAeiD,MAAMnF,UAAUD,GAGrC,OADAA,EAAS6D,KAAKlE,MAAOwC,GACdA,CACX,EAEG,MAAMoD,UAAwB7D,EACjC/B,MACA,WAAAiE,CAAYjE,GACRyF,MAAMzF,GACNkE,KAAKlE,MAAQA,EACbkE,KAAKsB,OAASxF,EACd0F,EAAcxB,KAClB,CACA,SAAA5D,CAAUD,GACN,MAAMmC,EAAeiD,MAAMnF,UAAUD,GAGrC,OADAA,EAAS6D,KAAKsB,OAAQhD,GACfA,CACX,EC3BG,SAASqD,EAAaxF,GACzB,MAAO,CAAE+D,EAAW0B,KAChBA,EAAMhC,YAAW,KACG,IAEpBzD,EAAS+D,EAAW0B,EAAM9C,KAC7B,CACL,CAEO,SAAS+C,EAAY1F,GACxB,MAAO,CAAE+D,EAAW0B,KAChBA,EAAMhC,YAAW,KACG,IAELzD,EAAS+D,GACjB5C,MAAKY,GAAK0D,EAAM9C,KAAKZ,IAC/B,CACL,CAEO,MAAM4D,EAAiB3F,GACnB,CAAE+D,EAAW0B,KAChBA,EAAMhC,YAAW,KACG,IAEpB,MACMtB,EADSnC,EAAS+D,GACI9D,WAAU8B,IAClCI,EAAa9B,cACboF,EAAM9C,KAAKZ,EAAE,GAEpB,EC3BE,SAAStC,EAAMmG,GAClB,OAAOC,EAAaC,YAAYC,SAASxC,QAAQqC,EACrD,CCFO,SAASI,EAAmBC,GAC/B,MAAMC,EAASL,EAAaC,YAE5BI,EAAOC,OAAOD,EAAOE,aAAeH,EAIpC,OAHgBC,EAAOG,QACfF,OAAOD,EAAOE,aAAeH,IACnCC,EAAOE,YACFH,GAAO,IAAIlB,KACdtF,EAAMsF,GACCA,IAEf,CACO,SAASuB,EAAgBL,GAC5B,MAAMC,EAASL,EAAaC,YACtBO,EAAUH,EAAOG,QACjBD,EAAcF,EAAOE,YACrBG,EAAcL,EAAOK,YACrBC,EAAYD,GAAaJ,OAAOC,GAChCK,EAAa,GAKnBD,GAJiB,IAAIzB,KACjB0B,EAAWxD,KAAK8B,GACTA,KAGX,IAAI/C,EAAQ,EAcZ,OAFAqE,EAAQF,OAAOD,EAAOE,aAAeH,IACnCC,EAAOE,YACFH,GAbU,IAAIlB,KAGjBmB,EAAOQ,WAAWzD,KAAK,CACnBtF,IAAK,IAAMoH,EACXa,aAAcb,IAElB,MAAMhB,EAAY0C,EAAWzE,GAE7B,QADEA,EACK+B,CAAS,GAKxB,CCvCO,SAAS4C,EAAUN,EAASH,GAC/BA,EAAOH,SAASxC,QAAUqD,EAC1BV,EAAOH,SAASc,cAAgBb,EAChCE,EAAOY,QAAU,GACjBZ,EAAOQ,WAAa,GACpBR,EAAOC,OAAS,GAChBD,EAAOE,YAAc,EACrBF,EAAOG,QAAUA,CACrB,CACO,SAASU,EAAQV,EAASH,EAAQc,EAAWC,GAEhDf,EAAOY,QAAUE,EACjBd,EAAOQ,WAAa,GACpBR,EAAOC,OAASc,EAChBf,EAAOE,YAAc,EACrBF,EAAOH,SAASxC,QAAU2D,EAC1BhB,EAAOH,SAASc,cAAgBP,EAChCJ,EAAOG,QAAUA,CACrB,CACO,MAAMc,GCpBN,SAASC,EAAc3H,GAC1B,MAAMO,EAAWP,EAAMO,SACvB,IAAKA,EACD,OAAOP,EAAMmG,aAEjB,MAAOjG,GDkBJ,SAA0BK,GAC7B,MAAOL,GAASK,EAASmH,IAClBE,GAAcrH,EAASL,GAC9B,MAAO,CAACA,EAAO0H,EACnB,CCtBoBC,CAAiBtH,GACjC,OAAOL,CACX,CCLO,SAASuH,IACZ,MAAMhB,EAASL,EAAaC,YAEtByB,EADUrB,EAAOY,QACCZ,EAAOQ,WAAWzE,QAE1C,OADAiE,EAAOQ,WAAWzD,KAAKsE,GAChBA,EAAQ3B,YACnB,CACO,SAASgB,EAAchB,GAC1B,MAAMM,EAASL,EAAaC,YAE5B,IAAI0B,EAAY5B,EAKhB,UAJW,IAAmBnH,EAAWuC,WACrCwG,EAAY5B,YAGL,IAAgBnH,EAAWuC,SAAU,CAC5C,MAAMyG,EAAWD,EACjBA,EAAY,YAAyBzC,GAEjC,OADe0C,KAAY1C,EAE/B,EACAyC,EAAUC,SAAWA,CACzB,CACA,MAAMxE,EAAO,CACTtF,IAAK,WACD,OAAOyJ,EAAcnE,EACzB,EACA2C,aAAc4B,GAGlB,OADAtB,EAAOQ,WAAWzD,KAAKA,GAChBuE,CACX,CC/BO,MAAME,EAAa,IAAIhG,OAAQiG,GAAW,SAAmBxF,GAC3D3C,MACD2C,EAAaQ,MAErB,ICJakD,EAAe,CACxBC,YAAa,CACTY,WAAY,GACZvH,QAASC,KAAKC,MACd0G,SAAU,CACNxC,QAASqD,EACTC,cAAeb,IAGvB0B,WAAU,GCNP,SAASE,EAAavB,EAC7BwB,GACI,IAAK,IAAI7F,EAAQ,EAAGA,EAAQqE,EAAQF,OAAOlE,SAAUD,EAAO,CACxD,IAAI8F,EACJ,MAAMC,EAAS1B,EAAQF,OAAOnE,GACxBiE,EAAS4B,EAAc1B,OAAOnE,GACpC+F,GAAO,IAAIhG,KACP+F,EAAM/F,EACCA,KAEXkE,GAAO,IACI6B,GAEf,CAEJ,CAEO,SAASE,EAAWC,EAAWC,EAASC,EAAYC,GACvD,IAAK,IAAIpG,EAAQiG,EAAUhG,OAAS,EAAGD,GAAS,IAAKA,EAAO,CACxD,MACMqG,EADkBJ,EAAUjG,GACArE,MAG5BqC,EADgBkI,EAAQlG,GACChC,SAC1BA,GAGLA,EAASqI,EACb,CAEA,IAAK,IAAIrG,EAAQoG,EAAWnG,OAAS,EAAGD,GAAS,IAAKA,EAAO,CACzD,MAAMsG,EAAY,GACZC,EAAiB,IAAIxD,KACvBuD,EAAUrF,KAAK8B,GACRA,IAIXyD,EAFwBJ,EAAWpG,IAEnBuG,GAChB,IAAIE,EAAW,EAEf,MAAMC,EAAiB,IAAIC,IAChBL,EAAUG,KAGrBN,EAAWnG,GAAO0G,EACtB,CACJ,CCzCO,MAAME,EAAQ,CAAEC,EAAe7I,IAC3B8I,EAAWD,EAAe7I,GAE/B+I,EAAkBhH,GAAMA,EAgB9B,MAAM+G,EAAa,CAACD,EAAe7I,GAAYgJ,OAAMC,SAAQC,QAAQH,GAAoB,CAAC,KACtF,MAAMI,EAAW1J,EAAM,CACnB2J,gBAAYzB,EACZ9F,YAAQ8F,IAEN0B,EAAiBF,EAAStH,OAEhC,QAAuB8F,IAAnB0B,EAA8B,CAC9B,GAAIJ,IAAWA,EAAOJ,GAElB,OADAM,EAAStH,OAASgH,EACXM,EAASC,WAEpB,MACME,GADaN,GAAQhJ,GACD6I,EAAeQ,GAGzC,OAFAF,EAASC,WAAaF,EAAMI,GAC5BH,EAAStH,OAASgH,EACXM,EAASC,UACpB,CAEA,GADiBP,EAAcU,OAAM,CAACrH,EAAMF,IAAUE,IAASmH,EAAerH,KAE1E,OAAOmH,EAASC,WAEpB,GAAIH,IAAWA,EAAOJ,GAElB,OADAM,EAAStH,OAASgH,EACXM,EAASC,WAEpB,MAAME,EAAStJ,EAAS6I,EAAeQ,GAIvC,OAHAF,EAASC,WAAaF,EAAMI,GAC5BD,EAAepH,OAAS,EACxBoH,EAAepG,QAAQ4F,GAChBM,EAASC,UAAU,EAE9B,SAASI,EAAeC,EAAUC,GA8C9B,OA7CAlM,OAAOC,eAAeiM,EAAU,SAAU,CACtC,GAAA/L,GACI,MAAMiL,EAAQa,IAEd,OADAb,EAAMe,MAAMX,KAAO,KAAe,EAC3BJ,CACX,IAEJpL,OAAOC,eAAeiM,EAAU,YAAa,CACzC,GAAA/L,GACI,MAAMiM,EAAWH,IACXI,EAAepK,GAAM,IAAMD,OAC3BtB,EAAUuB,GAAM,IAAM,IAAI6F,OAAaqC,KACvCmC,EAAWrK,GAAM,KAAM,CACzBiH,WAAYb,EAAaC,YAAYY,WACrCP,OAAQN,EAAaC,YAAYK,WAE/B4D,EAAS,CAAClB,EAAe7I,KAC3B8I,EAAWD,GAAe,CAACA,EAAeQ,KACtC,MAAMW,EAAaxK,KACbyK,EAAQjK,EAAS6I,EAAeQ,GACtC,GAAIW,IAAeH,EAAc,CAC7B,MAAMK,EAAcJ,EAASpD,WAEvByD,EADSN,EAAa3L,QAAQE,OACd+L,OAItBnC,EAAWkC,EAHSC,EAAO1K,MACTqK,EAAS3D,OACTgE,EAAOhE,OAE7B,CACAjI,EAAQyE,KAAKsH,EAAM,GACpBL,EAASD,OACLzL,GAIX,OAFA6L,EAAOJ,MAAQC,EAASD,MACxBH,GAAe,IAAMO,GAAQA,GACtBA,CACX,IAEJvM,OAAOC,eAAeiM,EAAU,SAAU,CACtC,GAAA/L,GACI,MAAMiL,EAAQa,IAEd,OADAb,EAAMe,MAAMV,OAAUJ,GAAkBA,EAAcU,OAAMxH,GAAKA,IAC1D6G,CACX,IAEGc,CACX,CCxGO,SAASxL,EAAQqB,GAEpB,OADgBC,KAELC,GAAM,IAAM,IAAIiC,EAAQnC,KAE5B,IAAImC,EAAQnC,EACvB,CCVO,SAAS4G,EAAOF,GAEnB,OADeJ,EAAaC,YACdC,SAASc,cAAcZ,EACzC,CCGO,SAASmE,EAAQnE,GACpB,MAAMoE,EAAc/K,EAAO,IACrBgL,EAAShL,EAAO,GAChBiL,EAAWjL,EAAO,GACxB,IAAIkL,EAAY,GACZC,EAAS,EA6Bb,OA5BAF,EAAS5K,MAAQ2K,EAAO3K,MACxBsG,GAAO,IAAIpE,KACP2I,EAAY3I,EACLA,KAGX+G,EAAM4B,GAAW,OACXC,EACFJ,EAAY1K,MAAQ6K,EACpBvE,GAAO,IAAMuE,GAAU,IAG3BrE,GAAO,KACH,GAAIsE,EAUA,OATAxE,GAAO,IAAIpE,KACPwI,EAAY1K,MAAQkC,EAChByI,GAAUC,EACHF,EAAY1K,MAEhBkC,KAEX0I,EAAS5K,MAAQ2K,EAAO3K,YACtB2K,EAAO3K,MAGbsG,GAAO,IAAMoE,EAAY1K,OAAM,MAEjC8K,EACKJ,EAAY1K,KACvB,CHoEA6J,GAAe,IA/Ff,SAAkBG,GACd,MAAMI,EAAS,CAAClB,EAAe7I,IACpB8I,EAAWD,EAAe7I,EAAU2J,GAI/C,OAFAI,EAAOJ,MAAQA,EACfH,GAAe,IAAMO,GAAQA,GACtBA,CACX,CAwFqBW,CAAS,CAAC,IAAI9B,GClGnC1K,EAAQiH,OAAUxF,IACd,MAAMgL,EAAclL,GAAM,WACtB,MAAO,CACHiH,WAAYb,EAAaC,YAAYY,WACrCP,OAAQN,EAAaC,YAAYK,OAEzC,IACM6D,EAAaxK,KACnB,OAAOC,GAAM,WAKT,OAJgB,IAAI6F,EAAa3F,GAAOgF,MAAK5C,IACzCiG,EAAWgC,EAAWvK,MAAOkL,EAAYjE,WAAYsD,EAAW7D,OAAQwE,EAAYxE,QAC7EpE,IAGf,GAAE,EAaN7D,EAAQ4G,IAXR,SAAaC,GACT,MAAM4F,EAAclL,GAAM,KAAM,CAC5BiH,WAAYb,EAAaC,YAAYY,WACrCP,OAAQN,EAAaC,YAAYK,WAE/B6D,EAAaxK,KACnB,OAAOkC,EAAQoD,IAAIC,GAAMJ,MAAK5C,IAC1BiG,EAAWgC,EAAWvK,MAAOkL,EAAYjE,WAAYsD,EAAW7D,OAAQwE,EAAYxE,QAC7EpE,IAEf,EGpCO,MAAM6I,EAAY,CACrBC,OAASC,IACL,MAAMC,EAAkBtL,GAAM,KAAM,CAAGuL,UAAW,EAAGC,cAAUtD,MAE/D,GAAIoD,EAAgBC,UAAW,CAC3B,IAAIjJ,EAAIgJ,EAAgBC,UACxB,KAAOjJ,KACHtC,OAAMkI,GAGV,OADelI,OAAMkI,EAEzB,CACA,MAAM2B,EAAS7J,GAAM,KACjB,MAAMqG,EAAcD,EAAaC,YAC3BoF,EAAgBpF,EAAYY,WAAWzE,OAEvCkJ,EAAWL,EAAgBhN,UAAY,IAAIgN,EAAoBA,IAC/DzE,EAAUP,EAAYO,QACtB2E,EAAYlF,EAAYY,WAAWzE,OAASiJ,EAC5CD,EAAW,CACbH,kBACAK,WACAH,YACAI,MAAO/E,EACPgF,SAAU,IAEdN,EAAgBE,SAAWA,EAC3B,MAAM7M,EAASiI,EAAQnI,QAAQE,OAI/B,OAHkBA,EAAOwM,UAAYxM,EAAOwM,WAAa,IAC/C3H,KAAKgI,GACfF,EAAgBC,UAAYA,EACrBG,CAAQ,IAEbG,EAAKR,EACLS,EAAYD,EAAGC,UAAYD,EAAGE,WAEpC,OADAT,EAAgBE,SAASH,gBAAgBS,UAAYA,EAC9CjC,CAAM,EAOjBmC,OAAS7H,GAEEnE,GAAM,KAET,MAAM6L,EAAK1H,EACL2H,EAAYD,EAAGC,UAAYD,EAAGC,WAAa3H,EAAY4H,WACvDnF,EAAU7G,KACVoL,EAAY,GAClB,IAAIQ,EAAQ,CACRM,aAAcrF,EAAQqF,cAE1B,KAAON,EAAMM,cAAc,CACvB,MACMC,EADYP,EAAMM,aAAaxN,QAAQE,OACZwM,UACjC,IAAKe,EAAgB,CACjBP,EAAQA,EAAMM,aACd,QACJ,CACA,MAAMT,EAAWU,EAAeC,MAAKX,IACjCL,EAAU3H,KAAKgI,GAEf,GADyBA,EAASH,gBAAgBS,YAAcA,EAE5D,OAAO,CACX,IAEJ,GAAIN,EAAU,CACV,MAAM7M,EAASiI,EAAQnI,QAAQE,OAI/B,OAHkBA,EAAOwM,UAAYxM,EAAOwM,WAAa,IAC/C3H,KAAKgI,GACfA,EAASI,SAASpI,KAAKoD,GAChB4E,EAASE,QACpB,CACAC,EAAQA,EAAMM,YAClB,CACA,MAAMG,EAAM,8BAA8BjI,EAAYkI,QAAQlI,IAE9D,MADAmI,QAAQC,KAAK,GAAGH,yBAA4BjB,GACtC,IAAIqB,MAAMJ,EAAI,KClFzB,MAAMK,UAAiBD,MAC1BE,QACA,WAAAvI,CAAYwI,EAASC,EAAWF,EAAU,CAAC,GACvC/G,MAAMgH,GACNvI,KAAKiI,KAAOI,EAASJ,KACrBjI,KAAKsI,QAAU,IAAKA,EAASE,YACjC,EAEG,MAAMC,UAAwBJ,EACjC,WAAAtI,CAAYwI,EAASD,GACjB/G,MAAMgH,EAAS,qBAAsBD,GACrCtI,KAAKiI,KAAOQ,EAAgBR,IAChC,EAEG,MAAMS,UAA2BL,EACpC,WAAAtI,CAAYwI,EAASD,GACjB/G,MAAMgH,EAAS,uBAAwBD,GACvCtI,KAAKiI,KAAOS,EAAmBT,IACnC,EAEG,MAAMU,UAA0BN,EACnC,WAAAtI,CAAYwI,EAASD,GACjB/G,MAAMgH,EAAS,sBAAuBD,GACtCtI,KAAKiI,KAAOU,EAAkBV,IAClC,ECtBG,SAASW,GAAU7O,EAAK8O,GAE3B,OAAOC,GAAc/O,EAAK8O,EAC9B,CACA,SAASC,GAAc/O,EAEvB8O,GAEI,GAAY,OAAR9O,UAAuBA,IAAQa,EAAW2C,OAC1C,OAAOxD,EAQX,GAAI8O,EAAW,EACX,OAAO9O,EAGX,GAAIA,aAAewB,KACf,OAAO,IAAIA,KAAKxB,GAEpB,GAAIA,aAAegP,OACf,OAAO,IAAIA,OAAOhP,GAGtB,MAAMiP,EAAQxL,EAAQzD,GAAO,GAAKJ,OAAOqN,OAAOrN,OAAOsP,eAAelP,IAEtE,GAAIyD,EAAQzD,GACR,IAAK,IAAImP,EAAI,EAAGA,EAAInP,EAAIqE,OAAQ8K,IAC5BF,EAAME,GAAKJ,GAAc/O,EAAImP,GAAIL,EAAW,QAIhD,IAAK,MAAMpP,KAAOM,EACVJ,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKN,KAC1CuP,EAAMvP,GAAOqP,GAAc/O,EAAIN,GAAMoP,EAAW,IAI5D,OAAOG,CACX,CACO,SAASG,GAAUC,EAAMC,EAAMR,GAClC,OAAOS,GAAYF,EAAMC,EAAMR,EACnC,CACA,SAASS,GAAYF,EAAMC,EAE3BR,GAEI,QADoBO,IAASC,IA2DRE,EA1DcH,EA0DTI,EA1DeH,GA2DpBhM,EAAWkM,KAAQlM,EAAWmM,IAC5BD,EAAI5B,aAAe6B,EAAI7B,eAvD1CkB,EAAW,UAGJO,IAASxO,EAAW2C,eAAiB8L,IAASzO,EAAW2C,SAE5D6L,aAAgB7N,MAAQ8N,aAAgB9N,KACjC6N,EAAKK,YAAcJ,EAAKI,UAK/BjM,EAAQ4L,IAAS5L,EAAQ6L,GA+BrC,SAA0BD,EAAMC,EAAMR,GAClC,GAAIO,EAAKhL,SAAWiL,EAAKjL,OACrB,OAAO,EAEX,IAAK,IAAI8K,EAAI,EAAGA,EAAIE,EAAKhL,OAAQ8K,IAC7B,IAAKI,GAAYF,EAAKF,GAAIG,EAAKH,GAAIL,EAAW,GAC1C,OAAO,EAGf,OAAO,CACX,CAxCmBa,CAAiBN,EAAMC,EAAMR,EAAW,IAE1CrL,EAAQ4L,KAAS5L,EAAQ6L,IAS1C,SAA2BD,EAAMC,EAEjCR,GACI,MAAMc,EAAQhQ,OAAOiQ,KAAKR,GACpBS,EAAQlQ,OAAOiQ,KAAKP,GAC1B,GAAqB,IAAjBM,EAAMvL,QAAiC,IAAjByL,EAAMzL,OAC5B,OAAO,EAEX,GAAIuL,EAAMvL,SAAWyL,EAAMzL,OACvB,OAAO,EAEX,IAAK,MAAM3E,KAAOkQ,EAAO,CAErB,IADiBE,EAAMC,SAASrQ,KACd6P,GAAYF,EAAK3P,GAAM4P,EAAK5P,GAAMoP,EAAW,GAC3D,OAAO,CAEf,CACA,OAAO,CACX,CAtBekB,CAAkBX,EAAMC,EAAMR,EAAW,KAkCxD,IAAyBU,EAAKC,CA/B9B,CC/EO,SAASQ,GAAmBC,EAAWC,GAC1C,MAAMlP,EAAY,CACdiP,YACAC,QACApN,UAAWjC,EAAWG,UACtBvB,IAAK,SAAqB0Q,GAEtB,OADAnP,EAAUmP,WAAaA,EAChBnP,CACX,GAEJ,OAAOA,CACX,CCZO,MAAMoP,GAAO,GCOb,SAASC,GAAUH,EAAOI,EAAYC,GACzC,OAAOL,EAAMxL,KAAI1E,GAGd,SAAmBA,EAAM6N,EAAcyC,EAAYC,GACtD,GAAI1N,EAAY7C,KAAUA,EACtB,OAAOA,EAEX,IAAK6N,EACD,OAAO7N,EAEX,OAAOwQ,GAAUxQ,EAAM6N,EAAcyC,EAAYC,EACrD,CAX6BE,CAAUzQ,EAAMsQ,EAAWzC,aAAcyC,EAAYC,IAClF,CAWO,SAASC,GAAU1O,EAAO+L,EAAcyC,EAAYC,GACvD,IAAKzO,EACD,OAAOA,EAEX,GAAIA,EAAMgB,UACN,OAAOhB,EAEX,UAAW,IAAYlB,EAAWuC,SAC9B,OA4DD,SAAqBrB,EAAO+L,GAC/B,MAAM6C,EAAU5O,EAAM6O,IAEtB,GAAID,EACA,OAAO5O,EAEX,MAAM8O,EAAO,YAAuB1J,GAChC,OAAO0J,EAAKC,UAAU3J,EAC1B,EASA,OARA0J,EAAKhH,SAAW9H,EAChB8O,EAAKD,IAAM7O,EAEX8O,EAAKC,OAAS,YAAyB3J,GACnC,OAOD,SAA2B2J,EAAQC,EAAUjD,GAChD,MAAMtN,EAASsN,EAAaxN,QAAQE,OAC9BwQ,EAASxQ,GAAQwQ,QAAUlD,EAE3BmD,OAA6BlH,IADZnI,KAEjBsP,EAAiBJ,KAAUC,GAC3BI,EAAM,WACR,MAAM3Q,EAASwQ,EAAO1Q,QAAQE,OAE9B,IAAgB,IAAZyQ,EAAmB,CAEnB,IADqC,IAAlBzQ,EAAO4Q,OAEtB,OAAOF,CAEf,CAEA,OAWD,SAA2BF,EAAQlD,GACtC,MAAMxN,EAAU0Q,EAAO1Q,QACjB+Q,EAAWC,GAAaN,EAAO/P,WACrC,GAAIoQ,EAAU,CASV,OAReE,GAAiBzD,EAAckD,EASlD,CACA,MAAMxQ,EAASF,EAAQE,OACvBA,EAAO4Q,QAAS,EAChBI,GAAuBhR,EAAOwQ,OAAQA,EAAQlD,EAAcxN,UACrDE,EAAO4Q,MAClB,CA9BQK,CAAkBT,EAAQlD,GACnBoD,CACX,EACA,GAAID,EACA,OAAOE,IAGX,OADAlJ,EAAa6B,WAAWnD,WAAWwK,GAC5BD,CACX,CA9BeQ,CAAkBb,EAAKD,IAAKzJ,EAAM2G,EAC7C,EAEAlO,OAAO+R,OAAOd,EAAM9O,GACb8O,CACX,CA9Eee,CAAY7P,EAAO+L,GAE9B,GAAI0C,IAAUqB,GACV,OAAO9P,EAGX,OADa+P,GAAgB/P,GAElBA,EAEP0B,EAAQ1B,GAKhB,SAAwBA,EAAOwO,EAAYzC,EAAc0C,GACrD,IAAK,IAAIpM,EAAQrC,EAAMsC,OAAS,EAAGD,GAAS,IAAKA,EAAO,CACpD,MAAM2N,EAAWhQ,EAAMqC,GAEvB,GADArC,EAAMqC,GAASqM,GAAUsB,EAAUjE,EAAcyC,EAAYC,EAAQ,UAC1D,IAAe3P,EAAWuC,SAAU,CAC3C,GAAI2O,EAASnB,IACT,SAEJoB,GAAexB,EAAQ,EAAGpM,EAAO2N,EAAUhQ,EAAOwO,EACtD,CACJ,CACA,OAAOxO,CACX,CAhBekQ,CAAelQ,EAAOwO,EAAYzC,EAAc0C,GAiB/D,SAAyBzO,EAAOwO,EAAYzC,EAAc0C,GACtD,MAAMX,EAAOjQ,OAAOiQ,KAAK9N,GACzB,IAAK,MAAMmM,KAAQ2B,EAAM,CACrB,MAAMkC,EAAWhQ,EAAMmM,GACjBxC,EAAS+E,GAAUsB,EAAUjE,EAAcyC,EAAYC,EAAQ,GAErE,GADoBzO,EAAMmM,KACNxC,EAChB,SAEJ,MAAMwG,EAAStS,OAAOuS,yBAAyBpQ,EAAOmM,GAEtD,KADkBgE,GAAQnS,KAAOmS,GAAQ7L,OAIzCtE,EAAMmM,GAAQxC,SACH,IAAa7K,EAAWuC,UAAU,CACzC,GAAI2O,EAASnB,IACT,SAEJoB,GAAexB,EAAQ,EAAGtC,EAAM6D,EAAUhQ,EAAOwO,EACrD,CACJ,CACA,OAAOxO,CACX,CAtCWqQ,CAAgBrQ,EAAOwO,EAAYzC,EAAc0C,EAC5D,CAsCA,SAASwB,GAAexB,EAAOpM,EAAOiO,EAAeC,EAAS/B,GAE1D,GAAIC,EAAQ,EAAG,CACX,MAAMhQ,EAAS+P,EAAWjQ,QAAQE,OAClC8R,EAAQlO,GAAOG,aAAe/D,EAAO+R,SAAS5L,YAAW,WACrD2L,EAAQlO,GAASiO,CACrB,GACJ,CACJ,CA6CO,SAASP,GAAgB/P,GAC5B,cAAc,IAAYlB,EAAW2C,SAAWzB,GAASA,EAAMgB,SACnE,CCpIO,SAASyP,GAAYvR,EAAWyK,EAAQ+G,EAAYC,GACvD,MAAMC,EAAmBjH,EAAO7B,SAEhC,IAAI9I,EADcE,EAAU8B,YAAcjC,EAAWQ,YAGjDP,EAAME,KAGNF,EAAM4R,KAAoBD,UAEf,IAAU7R,EAAWuC,WAC5BrC,EAAMA,MAGdA,EAAIE,UAAYA,EAChBA,EAAUF,IAAMA,EAChB,MAAMuH,EAASL,EAAaC,YAI5B,OAHAuK,EAAW5Q,MAAQyG,EAAOQ,WAC1B2J,EAAWlK,OAASD,EAAOC,OAEpBkK,CACX,CCpBO,SAASG,GAAgB3O,GAC5B,OAAOA,EAAOU,IAAIkO,GACtB,CAEO,SAASA,GAAgB9Q,EAAO+M,GACnC,MAAM/N,EAAMgB,EACNgB,EAAYhB,GAAOgB,UACzB,GAAIA,EACA,OAAQA,GACJ,KAAKjC,EAAWQ,YACZ,OACJ,KAAKR,EAAWE,IAChB,KAAKF,EAAWC,IAChB,KAAKD,EAAWG,UACZ,OAAO2R,GAAgB7R,EAAIkD,QAGvC,OAAIR,EAAQ1B,GACD6Q,GAAgB7R,GAEpB8N,GAAU9M,EAAO+M,EAC5B,CCrBO,SAASgE,GAAe7R,EAAWX,EAASoS,GAC/C,MAAMK,EAAc,CAChB9R,YACAX,UACAoS,cACAM,gBAAYjJ,GAGVvJ,EAASF,EAAQE,OAGvB,OAFAA,EAAOyS,QAAU,GACjBzS,EAAO+R,SAAW,IAAIzO,EACfiP,CACX,CACO,SAASG,GAAqBjS,EACrCwH,EAASuK,EAAYN,GAEjBjK,EAAQ5G,MAAQ,GAChB4G,EAAQF,OAAS,GACjBE,EAAQuK,WAAaA,EACrB,MAAM7C,EAAQlP,EAAUkP,MAIxB,OAHIA,IACA1H,EAAQ0K,YCpBT,SAAsB1K,EAAS0H,EAAOG,GACzC,MAAMrP,EAAYwH,EAAQxH,UAC1B,GAAIA,EAAU8B,YAAcjC,EAAWQ,YAAvC,CAGA,OAAQL,EAAUiP,WACd,KAAKkD,GAAYC,UACb,OAAO5K,EAAQ0K,YAAc,CACzBG,OAAQnD,EACRG,aAER,KAAK8C,GAAYG,QACb,OAAO9K,EAAQ0K,YAAc,CACzBG,OAAQnD,EAAMxL,KAAIR,GAAK0O,GAAgB1O,EAAGqP,MAC1ClD,aAGZ,OAAO7H,EAAQ0K,YAAc,CACzBG,OAAQnD,EAAMxL,KAAIwL,GAAS0C,GAAgB1C,EAAO0B,MAClDvB,YAfJ,CAiBJ,CDD8BmD,CAAahL,EAAS0H,EAAOuC,IAEhDjK,CACX,CACO,SAASiL,GAAezS,EAC/B6M,EAAckF,EAAY1S,EAASoS,GAC/B,MAAMjK,EAAU,CACZxH,YACAX,UACAoS,cACAM,gBAAYjJ,GAIhB,OAFAtB,EAAQqF,aAAeA,EACvBrF,EAAQuK,WAAaA,EACdvK,CACX,CACO,SAASkL,GAAW1S,EAC3B6M,EAAckF,EAAY1S,EAASoS,GAC/B,MAAMjK,EAAUqK,GAAe7R,EAAWX,EAASoS,GAEnD,OADAjK,EAAQqF,aAAeA,EAChBoF,GAAqBjS,EAAWwH,EAASuK,EAAYN,EAChE,CEvBO,SAASkB,GAAe3S,EAAWsP,EAAYsD,GAClD,MAAM/E,EAAW7N,EAAUiP,YAAckD,GAAYU,KAAOjC,GAAmB2B,GACzErD,EAAQlP,EAAUkP,MAClBgD,EAAc5C,EAAW4C,YAE/B,IAAIY,EAAiBZ,EAAY7C,UACjC,MAAM0D,EAAkBH,GAAaV,YAC/Bc,EAAgBD,GAAiB1D,UACnC2D,IACAd,EAAY7C,UAAY2D,EACxBF,EAAiBG,GAAkB3D,EAAYsD,EAAaA,EAAY/F,aAAcqC,EAAOrB,IAGjG,OADoBiF,GAAkBzD,GAAUH,EAAOI,EAAY,EAEvE,CC9BA,IAAI4D,GAAW,EAER,IAAIf,GAWJ,SAASrS,GAAIG,EAAcgP,EAAYkD,GAAYG,SAEtD,MAAMa,EAAa,YAAuBjE,GACtC,MAAMlP,EAAYgP,GAAmBC,EAAWC,GAChDlP,EAAU8B,UAAYjC,EAAWI,aAEjC,MAAMmT,EDhBP,SAAoBpT,EAAWyK,GAWlC,OATgB,SAAoB6E,EAAYjQ,EAASuT,GAGrD,MAAMnB,EAAckB,GAAe3S,EAAWsP,EAAYsD,GACpD/F,EAAeyC,EAAWzC,aAC1B2E,EAAakB,GAAW1S,EAAW6M,EAAcyC,EAAWyC,WAClE1S,EAASoS,GACT,OAAOF,GAAYvR,EAAWyK,EAAQ+G,EAAYC,EACtD,CAEJ,CCI6B4B,CAAWrT,EAAWmT,GAQ3C,OAPAC,EAAaxK,SAAW3I,EAMxBD,EAAUsT,QAAUF,EACbpT,CACX,EACMF,EAAMG,EAQZ,OAPAkT,EAAWvK,SAAW3I,EAEtBH,EAAIsP,KAAOA,GACXtP,EAAIyT,OAASvM,EACblH,EAAID,WAAaA,EACjBC,EAAI0T,SAAWN,KACf9D,GAAKhL,KAAK+O,GACHA,CACX,CAMA,SAASM,KACL,MAAM,IAAIrG,MAAM,mGACpB,CCzCO,SAASsG,GAAexE,EAC/ByE,EACA1E,GAEI,GADsB2E,GAAsB1E,EAAOyE,GAE/C,OAAO,GAEX,OAAQ1E,GACJ,KAAKkD,GAAY0B,KACb,OAAO,EACX,KAAK1B,GAAYG,QACb,OAAOwB,GAAiB5E,EAAOyE,GACnC,KAAKxB,GAAYC,UACb,OAAO2B,GAAmB7E,EAAOyE,GAEzC,OAEJ,SAA+BzE,EAAOyE,GAElC,IAAIlC,EAAcvC,EACd8E,EAAkBL,EACtBlC,EAAc,IAAIvC,GAClB8E,EAAkB,IAAKL,GAAkB,IAEzC,IAD0BlC,EAAY/G,OAAM,CAAC5J,EAAOqC,IAMxD,SAAwBrC,EAAOqC,EAAOsO,EAAauC,GAC/C,MAAMC,EAAUD,EAAgB7Q,GAChC,UAAW,IAAYvD,EAAW2C,OAAQ,CACtC,MAAM2R,EAAiB,IAAKpT,GACtBqT,EAAkB,IAAKF,GAAW,CAAC,GACnCG,EAAUzV,OAAO0V,QAAQH,GAAgBxJ,OAAM,EAAEjM,EAAKqC,KAAWwT,GAAaxT,EAAOqT,EAAgB1V,IAAM,YACtGyV,EAAezV,UACf0V,EAAgB1V,EAAI,MAE/B,OAAO2V,CACX,CACA,OAAOE,GAAaxT,EAAOmT,GAAS,KAChCxC,EAAYxN,OAAOd,EAAO,GAC1B6Q,EAAgB/P,OAAOd,EAAO,EAAE,GAExC,CArBkEoR,CAAezT,EAAOqC,EAAOsO,EAAauC,KAEpG,OAAO,EAEX,OAAO,CACX,CAbWQ,CAAsBtF,EAAOyE,EACxC,CA8BA,SAASW,GAAaxT,EAAOmT,EAASQ,GAClC,UAAa,IAAY7U,EAAWuC,SAChC,QAAOgM,GAAUrN,EAAOmT,EAASrD,KAAoB,EAGzD,UADkBqD,IACWrU,EAAWuC,SACpC,OAAO,EAGX,MAAMuS,EAAkBT,GAASrL,SAC7B8L,IACAT,EAAUS,GAEG5T,EAAM8H,WAEnB9H,EAAQA,EAAM8H,UAIlB,OAFoB9H,EAAM6L,aACJsH,EAAQtH,YAE1B8H,IACO,IAEXA,IACO,EACX,CCxEO,SAASV,GAAmB7E,EAAOyE,GAEtC,MAAMgB,EAAMzF,EAAM9L,OAClB,IAAK,IAAID,EAAQ,EAAGA,EAAQwR,IAAOxR,EAAO,CAGtC,GAFa+L,EAAM/L,KACFwQ,EAAexQ,GAE5B,OAAO,CAEf,CACA,OAAO,CACX,CACO,SAAS2Q,GAAiB5E,EAAOyE,GAEpC,MAAMgB,EAAMzF,EAAM9L,OAClB,IAAK,IAAID,EAAQ,EAAGA,EAAQwR,IAAOxR,EAAO,CACtC,MAAMnE,EAAOkQ,EAAM/L,GACbyR,EAAWjB,EAAexQ,GAChC,GAAIX,EAAQxD,IAASwD,EAAQoS,GAAW,CACpC,GAAI5V,IAAS4V,EACT,SAEJ,OAAO,CACX,CACA,UAAW,IAAWhV,EAAWuC,iBAAmB,IAAevC,EAAWuC,SAG9E,UAAW,IAAWvC,EAAW2C,QAYjC,GAAIvD,IAAS4V,EAGb,OAAO,SAdH,UAAW,IAAqBhV,EAAW2C,OAAQ,CAC/C,MAAMsS,EAAYlW,OAAO0V,QAAQrV,GACjC,IAAK,MAAM8V,KAAWD,EAAW,CAE7B,IADeE,GAAkBD,EAASF,GAEtC,OAAO,GAEf,CACJ,CAOR,CACA,OAAO,CACX,EF9CA,SAAWzC,GACPA,EAAkB,KAAI,OAEtBA,EAAqB,QAAI,UACzBA,EAAkB,KAAI,OACtBA,EAAuB,UAAI,WAC9B,CAND,CAMGA,KAAgBA,GAAc,CAAC,IA8BlCrS,GAAIM,WACJ,WACI,MAAM,IAAIgN,MAAM,8GACpB,EAOAtN,GAAIc,MAAQ6S,GACZ3T,GAAIkV,IAAMvB,GACV3T,GAAImV,MACJ,SAAiBC,GACb,MAAM,IAAI9H,MAAM,0HACpB,EAKAtN,GAAIqV,IAAM,SAAUC,GAChB,MAAM,IAAIhI,MAAM,0HACpB,EACAtN,GAAIuV,cAAgBvV,GACpBA,GAAIwV,eAAiB,SAAwBrV,GACzC,OAAOH,GAAIG,EAAckS,GAAYC,UACzC,EACAtS,GAAIyV,WAAa,SAAoBtV,GACjC,OAAOH,GAAIG,EAAckS,GAAYG,QACzC,EAEA3T,OAAOC,eAAekB,GAAK,aAAc,CACrC,GAAAsF,CAAIoQ,GACAA,EAAkB1T,UAAYjC,EAAWO,UAC7C,IAGJzB,OAAOC,eAAekB,GAAK,QAAS,CAChC,GAAAsF,CAAIqQ,GAEAA,EAAe7M,SAAW,CACtB2K,OAAQvM,EACRoI,KAAI,IAERqG,EAAe3T,UAAYjC,EAAWQ,WAC1C,IAEJ1B,OAAOC,eAAekB,GAAK,MAAO,CAC9B,GAAAsF,CAAIqQ,GAEAA,EAAe7M,SAAW,CACtB2K,OAAQvM,EACRoI,KAAI,IAERqG,EAAe3T,UAAYjC,EAAWQ,WAC1C,IE5CG,MAAMkS,GAAsB,EACtB3B,GAAmB,GAChC,SAASmE,IAAmB9H,EAAMnM,GAAQ8T,GACtC,MAAMc,EAAYd,EAAS3H,GAC3B,cAAW,IAAYrN,EAAWuC,iBAAmB,IAAgBvC,EAAWuC,UAGzEuT,IAAc5U,CACzB,CChEO,IAAI6U,GAAe,GACfC,GAAe,GACfC,GAAa,GAEbC,GAAe,GAEfC,GAAqB,GACrBC,GAAc,GAClB,MAAMC,GAAW,CACpBC,MAAO,GAEJ,SAASC,KACZ,KAAIF,GAASC,MAAQ,GAArB,CAGA,IAAK,IAAI/S,EAAQwS,GAAavS,OAAS,EAAGD,GAAS,IAAKA,EAAO,CAC3D,MAAMiT,EAAWT,GAAaxS,GACXiT,EAASC,WACjBC,YAAYF,EAC3B,CACA,IAAK,MAAMG,KAAWX,GAClBW,IAEJ,IAAK,MAAOC,EAAMC,KAAaZ,GAC3BY,EAASC,YAAcF,EAE3B,IAAK,MAAMhW,KAAOsV,GACdtV,EAAImW,SAASC,YAAYpW,EAAIqW,SAEjC,IAAK,MAAM,QAAEA,EAAO,SAAEF,KAAcZ,GAChCY,EAASN,WAAWS,aAAaD,EAASF,GAE9ChB,GAAe,GACfC,GAAe,GACfE,GAAe,GACfC,GAAqB,GACrBF,GAAa,GACb,IAAK,MAAMrV,KAAOwV,GACdxV,IAEJwV,GAAc,EA1Bd,CA2BJ,CCtCO,SAASe,GAAqBjW,EACrCkW,GACI,MAAMP,EAAWQ,SAASC,eAAepW,GAKzC,OAJAiV,GAAmB3R,KAAK,CACpByS,QAASJ,EACTE,SAAUK,IAEPP,CACX,CACO,SAASU,GAAcrW,GAC1B,OAAQA,GACJ,UAAKgI,EACL,KAAK,EACL,KAAK,KACD,OAAOpJ,EAEf,OAAOoB,CACX,CCnBO,SAASsW,GAAiB5P,EAASjI,GACtC,MAAMwM,EAAYxM,EAAOwM,UACzB,GAAIA,EACA,IAAK,MAAMK,KAAYL,EACnB,IAAK,IAAI5I,EAAQiJ,EAASI,SAASpJ,OAAS,EAAGD,GAAS,IAAKA,EAAO,CAClDiJ,EAASI,SAASrJ,GACtB9D,QAAQE,SAAWA,GACzB6M,EAASI,SAASvI,OAAOd,EAAO,EAExC,CAGJ5D,EAAO+R,UACP/R,EAAO+R,SAASxN,OAEpB0D,EAAQnI,QAAQC,YAAc,CAClC,CCfO,SAAS+X,GAAsBC,GAClC,IAAK,MAAMC,KAASD,EAAW,CAC3B,MAAME,EAAYD,EAAMC,UACxB,GAAIA,EAAW,CACXH,GAAsBG,EAAU9T,KAAIR,GAAKA,EAAEuU,WAC3C,QACJ,CACA,MAAMlY,EAASgY,EAAMhY,OACrB,IAAKA,EACD,SAEJ,MAAMiI,EAAUjI,EAAOwQ,OACjB2H,EAAQnY,EAAOkE,cACjBiU,GACAA,EAAMxW,SAAQyW,GAAQA,EAAKnW,gBAE3BO,EAAeyF,EAAQxH,YACvBoX,GAAiB5P,EAASjI,GAG9B8X,GADgB9X,EAAOkY,QAE3B,CACJ,CACO,SAASG,GAA0BN,EAAWlI,EAAO,GAAI9J,EAAO,IACnE,IAAK,MAAMiS,KAASD,EAAW,CAC3B,MAAM/X,EAASgY,EAAMhY,OACrB,IAAKA,EACD,SAEJ,MAAMiI,EAAUjI,EAAOwQ,OACvB,GAAIvI,EAAS,CACT4H,EAAKhL,KAAKoD,GACV,MAAMkQ,EAAQnY,EAAOkE,cACjBiU,GACApS,EAAKlB,QAAQsT,EAErB,CACA,MAAMG,EAAUtY,EAAOkY,QACnBI,GACAD,GAA0BC,EAASzI,EAAM9J,EAEjD,CACA,MAAO,CAAE8J,OAAM9J,OACnB,CC1CO,SAASwS,GAAgBtQ,EAASjI,EAAQwY,GAC7BvQ,EAAQnI,QAAxB,MACMoY,EAAUlY,EAAOkY,QAGjBO,EAAWzY,EAAOyY,SACxB,GAAIA,EACA,OAMR,SAAgCA,EAAUzY,EAAQwY,GAC9C,MAAME,EAAW,GAQjB,GAPAD,EAAS9W,SAAQgX,IACb,MAAMC,EAAeD,IACHC,aAAwB3S,SAEtCyS,EAAS7T,KAAK+T,EAClB,IAEAF,EAAS7U,OAAQ,CACjB,MAAMgV,EAAc5S,QAAQS,IAAIgS,GAC3B3V,MAAK,OACJ2T,GAASC,MAEXmC,GAAqB9Y,EAAOkY,QAASM,GACrCO,GAAc/Y,KACZ0W,GAASC,MACXC,IAAO,IAIX,YADA4B,EAAY3T,KAAKgU,EAErB,GACEnC,GAASC,MACXmC,GAAqB9Y,EAAOkY,QAASM,GACrCO,GAAc/Y,KACZ0W,GAASC,MACXC,IACJ,CAlCeoC,CAAuBP,EAAUzY,EAAQwY,GAEpDM,GAAqBZ,EAASM,GAC9BO,GAAc/Y,EAClB,CA+BA,SAAS8Y,GAAqBZ,EAASM,GACnC,IAAK,MAAM1Y,KAAWoY,EAAS,CAC3B,GAAIpY,EAAQmZ,mBACR,SAEJ,MAAMhB,EAAYnY,EAAQmY,UAC1B,GAAIA,EAAW,CACXiB,GAAapZ,EAASmY,GACtB,QACJ,CAEA,MAAMkB,EAAMrZ,EAAQsZ,eACpB,GAAID,EAAK,QACErZ,EAAQsZ,eACfhD,GAAavR,KAAKsU,GAClB,QACJ,CACA,MAAME,EAAYvZ,EAAQE,OAC1B,QAAkBuJ,IAAd8P,EACA,SAEJ,IAA0B,IAAtBA,EAAUC,QACV,SAEJD,EAAUC,SAAU,EACpB,MAAMvN,EAASsN,EAAUtN,OACrBA,GACAwM,GAAgBxM,EAAQsN,EAAWb,EAG3C,CACJ,CAEA,SAASO,GAAc/Y,GAECA,EAAOuZ,YAEf5X,SAAQ8M,IAChB,MAAM+K,EAAS/K,EAAM+K,OACjBA,GACApD,GAAavR,KAAK2U,GAEtB,MAAMhZ,EAAMiO,EAAMgL,WACbjZ,GAGL4V,GAAavR,KAAKrE,EAAI,GAG9B,CC3FO,SAASkZ,GAAezR,EAASjI,GACpC,MAAMF,EAAUmI,EAAQnI,QACxBE,EAAOsZ,SAAU,EACjBxZ,EAAQC,YAAc,EACtB,MAAM2Y,EAAW,GAOjB,OALAZ,GADgB9X,EAAOkY,SAEnBlY,EAAO+R,UACP8F,GAAiB5P,EAASjI,GAE9BuY,GAAgBtQ,EAASjI,EAAQ0Y,GAC1BA,CACX,CCbO,SAASiB,GAAkBpY,EAAOqC,EAAOqU,EAAW2B,EAASC,GAChE,MAAMC,EAAYvY,EAAMsC,OAAS,EAC3BkW,EAAKnW,EAAQgW,EACbI,EAAaD,EAAK,GAAKD,EAAYC,EACnCE,EAAchC,EAAUrU,GAAOsU,QACrC,GAAI8B,EAEA,OADAE,GAAiBD,EAAaJ,GACvB,EAEX,MAEM3O,EAGV,SAA0BiP,EAAQC,EAAaH,EAAaJ,EAAQ5B,EAAWrU,GAC3E,MAAMyW,EAASD,GAAeD,IAAWC,EAAYxK,WACrD,GAAIyK,EAyBA,OAFAH,GAAiBD,EAAaJ,GAC9B5B,EAAUvT,OAAOd,EAAO,GACjB,EAEX,OAAO,CACX,CAjCmB0W,CAFAL,EAAY1Y,MAAMqO,WACbrO,EAAMqC,GAC2BqW,EAAaJ,EAAQ5B,EAAWrU,GACrF,OAAOsH,CACX,CAgCO,SAASgP,GAAiBpW,EAAM+V,IAKvC,SAAkC7Z,EAAQ8D,GACtC,GAAI9D,EAAQ,CAER0Z,GADgB1Z,EAAO+L,OACC/L,EAC5B,KACK,CACD,MAAMsX,EAAUxT,EAAKsV,sBACdtV,EAAKsV,eACZhD,GAAavR,KAAKyS,EACtB,CACJ,CAbIiD,CADezW,EAAK9D,OACa8D,KAC/B+V,EAAOD,OACb,CC7CO,SAASY,GAAsB9Y,EAAU5B,GAE5C,IAAKmD,EAAQvB,GAAW,CAGpB,OADAwX,GAAapZ,EADKA,EAAQmY,WAEnB,CACX,CACA,OAAO,CACX,CACO,SAASiB,GAAapZ,EAASmY,GAClC,MAAM4B,EAAS,CAAEY,MAAO,EAAGb,QAAS,GACpC,IAAK,IAAIhW,EAAQ,EAAGA,EAAQqU,EAAUpU,SAAUD,EAC5CsW,GAAiBjC,EAAUrU,GAAQiW,UAEhC/Z,EAAQmY,SACnB,CACO,SAASyC,GAAuBhZ,EAAU5B,GAE7C,GADmB4B,gBACQ,IAAerB,EAAW2C,OAGjD,OCxBD,SAAmCzB,EAAOoZ,GAC7C,MAAMC,EAAchD,GAAcrW,GAC5BsZ,EAAWF,EAAYvB,eAC7B9C,GAAWzR,KAAK,CAAC+V,EAAaC,GAClC,CDmBQC,CAA0BpZ,EAAU5B,IAC5B,EAEZ,MAAMqZ,EAAMrZ,EAAQsZ,eAGpB,cAFOtZ,EAAQsZ,eACfhD,GAAavR,KAAKsU,GACX,CACX,CEhCO,SAAS4B,GAAWC,EAC3BC,GACI,MAAMC,EAAaF,EAASva,UACtB0a,EAAaF,EAASxa,UACtB2a,EAAOF,GAAY3a,KAAOya,EAC1BK,EAAOF,EAAW5a,IACxB,GAAI2a,GAAY3Y,YAAcjC,EAAWQ,YACrC,OAAOoa,EAAW1a,MAAQ2a,EAAW3a,IAEzC,OAAQ4a,EAAK7Y,WACT,KAAKjC,EAAWE,IACZ,OAAI6a,GAAM9Y,YAAcjC,EAAWE,KAaxC,SAAuB4a,EAAMC,GAChC,MAAMC,EAAWF,EAAK5a,IAChB+a,EAAWF,EAAK7a,IACtB,OAAO8a,IAAaC,CACxB,CAdmBC,CAAcJ,EAAMC,GAE/B,KAAK/a,EAAWC,IAAK,CACjB,MAAMkb,EAalB,SAA0BL,EAAMC,EAAML,EACtCC,GACI,MAAMS,EAAWN,EAAKO,QAChBC,EAAWP,EAAKM,QACtB,GAAID,EAAS7X,SAAW+X,EAAS/X,OAC7B,OAAO,EAKX,IAH2B6X,EAASvQ,OAAM,CAAChJ,EAAQyB,IAAUgY,EAAShY,GAAOC,SAAW1B,EAAO0B,SAI3F,OAAO,EAEX,MAAMgY,EAAUb,EAASva,UAAUgD,QAAU2X,EAAK3X,OAC5CqY,EAAUb,EAASxa,UAAUgD,QAAU4X,EAAK5X,OAClD,OAEG,SAAyBoY,EAASC,GACrC,MAAMC,EAAqBF,EAAQhY,SAAWiY,EAAQjY,OACtD,IAAKkY,EACD,OAAO,EAEX,MAAMC,EAAeF,EAAQ3Q,OAAM,CAAC5J,EAAOqC,KACvC,MAAMuJ,EAAY0O,EAAQjY,GAE1B,UAD2B,IAAYvD,EAAWuC,iBAAmB,IAAgBvC,EAAWuC,SAC/E,CAEb,SADoBrB,EAAM6L,aAAeD,EAAUC,WAKvD,CACA,OAAO,CAAI,IAEf,GAAI4O,EACA,OAAO,EAEX,OAAO,CACX,CAvBWC,CAAgBJ,EAASC,EACpC,CA7ByBI,CAAiBd,EAAMC,EAAML,EAAUC,GACpD,OAAOQ,CACX,EAEJ,MAAM,IAAI5N,MAAM,wBAAwBuN,EAAK7Y,YACjD,CCrBO,SAAS4Z,GAAmB7E,EAAS5J,EAAMnM,GAC9C8U,GAAaxR,MAAK,KACduX,GAAwB9E,EAAS5J,EAAMnM,EAAM,GAErD,CACO,SAAS6a,GAAwB9E,EAAS5J,EAAMnM,QACrCgI,IAAVhI,IAAiC,IAAVA,GAA6B,OAAVA,EAI9C+V,EAAQ+E,aAAa3O,EAAMnM,GAHvB+V,EAAQgF,gBAAgB5O,EAIhC,CCXO,SAAS6O,GAAiB7O,EAAMnM,EAAO+V,EAASkF,EAAavU,EAAS4R,GACzE,OAAQ2C,GAEJ,IAAK,OAAQ,CACT,MAAMC,EAAU5C,EAAOY,MASvB,YAPAhE,GAAY5R,MAAK,KAKbtD,EAJc,CACVmb,OAAQpF,EACRmF,WAEQ,GAGpB,CACA,IAAK,UAAW,CACZ,MAAMA,IAAY5C,EAAOD,QACnB5Z,EAASiI,EAAQnI,QAAQE,OAS/B,OARAA,EAAOyY,SAAWzY,EAAOyY,UAAY,QACrCzY,EAAOyY,SAAS5T,MAAK,IAKVtD,EAJO,CACVmb,OAAQpF,EACRmF,aAKZ,CACA,IAAK,YAED,YADAhG,GAAY5R,MAAK,IAAMyS,EAAQqF,UAEnC,IAAK,aAED,YADAlG,GAAY5R,MAAK,IAAMyS,EAAQsF,WAEnC,IAAK,QAAS,CACV,MAAMC,EAAQnP,EAAKoP,MAAM,KAEzB,YADAzG,GAAaxR,MAAK,IAAMyS,EAAQyF,MAAMF,EAAM,IAAMtb,GAEtD,CACA,IAAK,QAED,YAIZ,SAA6BmM,EAAMnM,EAAO+V,GACtC,MAAMuF,EAAQnP,EAAKoP,MAAM,KAGzB,GAFAD,EAAM5Y,QAEF1C,EAAO,CACP,IAAK,MAAMmM,KAAQmP,EACfxG,GAAaxR,MAAK,IAAMyS,EAAQ0F,UAAUlb,IAAI4L,KAElD,MACJ,CAEA,IAAK,MAAMA,KAAQmP,EACfxG,GAAaxR,MAAK,IAAMyS,EAAQ0F,UAAUC,OAAOvP,IAEzD,CAnBYwP,CAAoBxP,EAAMnM,EAAO+V,GAGzC,MAAM,IAAIzJ,MAAM,gCAAgC2O,MAAgB9O,IACpE,CC9CO,SAASyP,GAAsB3K,EAAY3F,GAC9C,MAAMuQ,EAIV,SAA6BnV,EAAS4E,EAAUwQ,EAAS,IACrD,MAAMvd,EAAUmI,EAAQnI,QACxBud,EAAOxY,KAAK,CACRoD,UACAlI,YAAaD,EAAQC,YACrB8M,aAEJ,MAAMkL,EAAYlL,EAASI,SAC3B,IAAK,IAAIrJ,EAAQmU,EAAUlU,OAAS,EAAGD,GAAS,IAAKA,EAAO,CACxD,MAAMoU,EAAQD,EAAUnU,GAClB0Z,EAAWtF,EAAMlY,QACvBud,EAAOxY,KAAK,CACRoD,QAAS+P,EACTjY,YAAaud,EAASvd,YACtB8M,YAER,CACA,OAAOwQ,CACX,CAtB6BE,CAAoB/K,EAAY3F,GACzD,OAAOuQ,CACX,CCCO,SAASI,GAAUvV,EAASwV,EAAW,IAC1C,MAAMzd,EAASiI,EAAQnI,QAAQE,OAEzB0d,EAAa5M,GADD7I,EAAQxH,WAEpB6M,EAAerF,EAAQqF,aAC7B,GAAItN,EAAO4Q,OAEP,OADA6M,EAAS5Y,KAAKoD,GACPwV,EAGX,GAAIC,EACA,OAAOF,GAAUlQ,EAAcmQ,GAEnC,MAAM1N,EAAa9H,EACb0V,EAAcnb,EAAeuN,EAAWtP,WACxC8B,EAAY0F,EAAQxH,UAAU8B,UAE9Bqb,EADgBtQ,GAAgB/K,IAAcjC,EAAWQ,eACzB6c,GCsBnC,SAAuBrQ,EAAc7M,EAAWwH,GACnD,MAAM4V,EAOV,SAAgCpd,EAAWwH,GACvC,MAAM6V,EAAWrd,EAAUkP,MACrBgD,EAAc1K,EAAQ0K,YACtBoL,EAAcpL,EAAYG,OAEhC,GADmBuB,GAAsByJ,EAAUC,GAE/C,OAAO,EAEX,OAAQtd,EAAUiP,WACd,KAAKkD,GAAYC,UACb,OAAO2B,GAAmBsJ,EAAUC,GACxC,KAAKnL,GAAYG,QACb,OAAOwB,GAAiBuJ,EAAUC,GAE1C,OAAQnP,GAAUkP,EAAUC,EAAa1M,GAC7C,CAtB2B2M,CAAuBvd,EAAWwH,GAEzD,GAAIqF,GAAgBuQ,EAChB,OAAO,EAEX,OAAO,CACX,CD7ByDI,CAAc3Q,EAAcyC,EAAWtP,UAAWsP,IACjGmO,EErBH,SAA8BjW,GACjC,MACMuE,EADSvE,EAAQnI,QAAQE,OACNwM,UACzB,IAAKA,EACD,MAAO,GAEX,MAAM2R,EAAkB,GAExB,IAAK,MAAMtR,KAAYL,EAAW,CAC9B,MACM4R,EAAYjB,GADJtQ,EAASG,MACwBH,GAC/CsR,EAAgBtZ,QAAQuZ,EAAUja,KAAIR,GAAKA,EAAEsE,UACjD,CACA,OAAOkW,CACX,CFOwBE,CAAqBtO,GAEzC,OADA0N,EAAS5Y,QAAQqZ,GACbN,GACAJ,GAAUlQ,EAAcmQ,GACpBE,GACAF,EAAS5Y,KAAKkL,GAEX0N,IAEXA,EAAS5Y,KAAKkL,GACP0N,EACX,CG/BO,SAASa,GAAqBb,KAC/B/G,GAASC,MACX8G,EAAS9b,QAAQ4c,MACf7H,GAASC,MACXC,IACJ,CACA,SAAS2H,GAAatW,GAClB,MAAMjI,EAASiI,EAAQnI,QAAQE,OAC1BA,GAGL,GAAcA,EAAOwQ,OACzB,CCRA,MAAMgO,GAAS,eACTC,GAAgB,uBACf,SAASC,GAAoBnd,EAAO0G,GACvC,MAAMjI,EAASiI,EAAQnI,QAAQE,OAEzB2e,EAAkB,SAAUrH,EAAS3Q,GACvC,IAAuB,IAAnB3G,EAAOsZ,QAIX,OAQD,SAAwB/X,EAAO0G,EAAS2W,EAAQjY,GAEnD,IAAIkY,EAAY5W,EAChB,KAAO4W,EAAUvR,eAAiB9K,EAAeqc,EAAUpe,YACvDoe,EAAYA,EAAUvR,aAE1B,MAAMxN,EAAU+e,EAAU/e,QACpBE,EAASF,EAAQE,OACvBA,EAAO4Q,QAAS,EAEhB,MAAMF,EAAiBnP,EAAMud,MAAMF,EAAQjY,UACpC3G,EAAO4Q,OAEd,OAEG,SAA0BF,EAAgBqO,GAC7C,MAAM/e,EAAS+e,EAAoBjf,QAAQE,OAC3C,OAEJ,SAA+Bgf,EAAMtO,EAAgB1Q,GAGjD,OADAse,GADqBd,GAAUwB,IAI5B,SAAmCtO,EAAgBsO,EAAMhf,GAC5D,GAAI6C,EAAU6N,GAAiB,CAG3B,OAFgBsO,EAAKlf,QAAQE,OACrB4Q,QAAS,EACVF,EAAe3N,MAAK,KACvB,IAAuB,IAAnB/C,EAAOsZ,QACP,OAAOmF,UAEKO,EAAKlf,QAAQE,OACd4Q,OAGf,OADA0N,GADqBd,GAAUwB,IAExBP,EAAa,GAE5B,CACA,OAAOD,EACX,CAlBWS,CAA0BvO,EAAgBsO,EAAMhf,EAC3D,CANWkf,CAAsBH,EAAqBrO,EAAgB1Q,EACtE,CANmBmf,CAAiBzO,EAAgBmO,EAEpD,CAtBeO,CAAeT,EAAgBU,YAAaV,EAAgB1W,QACnEqP,EAAS3Q,EACb,EAIA,OAFAgY,EAAgBU,YAAc9d,EAC9Bod,EAAgB1W,QAAUA,EACnB0W,CACX,CCnBA,MAAMW,GAAU,CAAC,OAAQ,WAkBlB,SAASC,GAAsBC,EAAUje,EAAO+V,EAASmI,EAAU5F,EAAQ5R,EAASyX,GACvF,GAAIA,EACA,OAAOnD,GAAiBiD,EAAUje,EAAO+V,EAASoI,EAAWzX,EAAS4R,GAE1E4F,EAASnI,EAASkI,EAAUje,EAChC,CC3BO,SAASoe,GAAwB1X,EAAS2X,EAAWtI,EAAS1V,GACjE,MAAMuX,EAAMlR,EAAQ4X,WAEF,SAAdD,IACAA,EAAY,YAEhB,MAAME,EAAmB,IAAMF,EAGzBG,EADS9X,EAAQnI,QAAQE,OACPggB,OACxB,IAAKD,EAASH,GAAY,CACtB,MAAMK,EAAW,SAAuBC,GACpCA,EAAMC,wBAA0BD,EAAME,gBACtCC,GAAYH,EAAOJ,EAAkBI,EAAMxD,OAC/C,EACAqD,EAASH,GAAaK,EACtB9G,EAAImH,iBAAiBV,EAAWK,EACpC,CAGA3I,EAAQwI,GAAoBle,EAC5B0V,EAAQsI,GAAahe,CACzB,CACA,SAASye,GAAYH,EAAOJ,EAAkBpD,GAC1C,MAAM9a,EAAW8a,EAAOoD,GACxB,GAAIle,EAAU,CACV,IAAI2e,GAAU,EAMd,GALAL,EAAME,gBAAkB,WACpBG,GAAU,EACVL,EAAMC,wBAAwBvgB,KAAKsgB,EACvC,EACAte,EAASse,GACLA,EAAMM,kBAAoBD,EAC1B,MAER,CACA,MAAMzJ,EAAa4F,EAAO5F,WACtBA,GACAuJ,GAAYH,EAAOJ,EAAkBhJ,EAE7C,CCvCO,SAAS2J,GAAyBnJ,EAASoJ,EAAczY,EAASuX,GACrE,MAAMmB,EAAM,YAAaha,GACrB,OAAOga,EAAItB,YAAY/H,EAAS3Q,EACpC,EAEAga,EAAItB,YAAcqB,EAClBC,EAAI1Y,QAAUA,EACd0X,GAAwB1X,EAAQuK,WAAYgN,EAAUlI,EACtDqJ,EACJ,CCTO,SAASC,GAAcpB,GAC1B,GAAIA,EAASqB,WAAW,UACpB,MAAO,QAEX,MAAMC,EASH,SAAyBtB,GAC5B,OAAQA,GACJ,IAAK,aACD,MAAO,aACX,IAAK,YACD,MAAO,YACX,IAAK,SACL,IAAK,OACD,MAAO,SACX,IAAK,YACL,IAAK,UACD,MAAO,UAEf,OAAO,CACX,CAvB0BuB,CAAgBvB,GACtC,OAAsB,IAAlBsB,KAGAtB,EAASqB,WAAW,WACb,OAGf,CCXA,MAAMG,GAAc,CAAEvG,MAAO,EAAGb,QAAS,GAClC,SAASqH,GAAyBxd,EAAQlC,EAAOoZ,EAAarN,GACjE,GAAIqN,EAAYuG,WAKZ,OCLD,SAAiCzd,EAAQ0d,EAAWxb,EAAW2R,EAAShK,EAAcmS,EAAUvH,EAAS2B,GAE5G,GAAIlU,EAAW,CACX,GAAIyb,GAAiBD,GAEjB,YADA7J,EAAQgF,gBAAgB3W,GAG5B,UAAW,IAAgBtF,EAAW2C,OAElC,UADyB,IAAgB3C,EAAW2C,OAEhD,IAAK,MAAM0K,KAAQ/H,EAEX+H,KAAQyT,GAGZ9K,GAAaxR,MAAK,WACdyS,EAAQgF,gBAAgB5O,EAC5B,SAIJ,IAAK,MAAMA,KAAQ/H,EACf0Q,GAAaxR,MAAK,WACdyS,EAAQgF,gBAAgB5O,EAC5B,GAIhB,CACA2T,GAAyB5d,EAAQ0d,EAAW7J,EAAShK,EAAcmS,EAAUvH,EAAS2B,EAC1F,CD7BQyH,CAAwB7d,EAAQlC,EAAOoZ,EAAYpZ,MAAOoZ,EAAYrD,QACtEhK,EAAcqN,EAAY8E,SAAU,GACpCuB,SACArG,EAAYpZ,MAAQA,GAGxB,MAAM+V,EAAUqD,EAAYrD,QAC5BiK,GAAqBhgB,EAAOoZ,EAAY6E,SAAU7E,EAAarD,EAAShK,EAAcqN,EAAY8E,SAAU9E,EAAY+E,UAAWsB,IACnIrG,EAAYpZ,MAAQA,CAExB,CEFO,SAASigB,GAAiB/d,EAAQ+b,EAAUlI,EAASrP,EAASwX,EACrEvH,EAASwH,EAAW7F,EAAQtY,GACxB,MAAMkgB,EAAUC,GAAYlC,GAE5B,GADkBiC,GAAW,EACd,CACX,MAAMlgB,EAAQkC,EAAOge,GACf9G,EAAcgH,GAAcpgB,EAAO2W,GAAS,GAQlD,OAPAyC,EAAYiH,QAAS,EACrBjH,EAAYrD,QAAUA,EACtBqD,EAAY8E,SAAWA,EACvB9E,EAAYuG,YAAa,EAEzBvG,EAAYxV,QAAU,CAACzD,EAAUmgB,IAAcZ,GAAyBY,EAAWngB,EAAUiZ,EAAa1S,QAC1GoZ,GAAyB5d,EAAQlC,EAAO+V,EAASrP,EAASwX,EAAUvH,EAAS2B,EAEjF,CACA,MAAMiI,EAAWJ,GAAYngB,GAC7B,GAAIugB,GAAY,EAAG,CACf,MAAMvgB,EAAQkC,EAAOqe,GACfnH,EAAc,CAChBiH,QAAQ,EACRtK,UACAkI,SAAUA,EACVuC,iBAAkBrH,GAClBzB,oBAAoB,GAExBf,EAAQrT,KAAK8V,GAEb,OADkBjY,EAAkBiY,EAAYpZ,OA0CxD,SAA8Cie,EAAU7E,EAAarD,EAASrP,EAASwX,EAAUC,EAAW7F,GACpG6F,GACArJ,GAAaxR,MAAK,WACdyS,EAAQgF,gBAAgBkD,EAC5B,IAEJ,MAAMwC,EAAsBrH,EAAYpZ,MACxC,GAAImB,EAAkBsf,GAAsB,CACxCrH,EAAYxV,QAAU8c,GACtB,MAAMrgB,EAAW,SAA6B8e,GAC1Ca,GAAqBb,EAAclB,EAAU7E,EAAarD,EAASrP,EAASwX,EAAUC,EAAW7F,EACrG,EAEMpV,EAAMud,EAAoBngB,UAAUD,GAEpC5B,EAAS2a,EAAY3a,QACdA,EAAOkE,cAAgBlE,EAAOkE,eAAiB,IACvDW,KAAKJ,EACd,CAEA,YADA8c,GAAqB5G,EAAYpZ,MAAOie,EAAU7E,EAAarD,EAASrP,EAASwX,EAAUC,EAAW7F,EAE1G,CA7DmBqI,CAAqC1C,EAAU7E,EAAarD,EAASrP,EAASwX,EAAUC,EAAW7F,IAE9Gc,EAAYxV,QAAU,CAACzD,EAAUmgB,IAAcZ,GAAyBY,EAAWngB,EAAUiZ,EAAa1S,GNvC3G,SAA0CuX,EAAUje,EAAOoZ,EAAarD,EAASmI,EAAUxX,EAAS4R,EAAQ6F,GAC/G/E,EAAY6E,SAAWA,EACvB7E,EAAYrD,QAAUA,EACtBqD,EAAY8E,SAAWA,SACZ,IAAYpf,EAAWuC,SAC1B8c,GAAaJ,GAAQ/P,SAASiQ,GAC9BjD,GAAiBiD,EAAUje,EAAO+V,EAASkI,EAAUvX,EAAS4R,GAG3DsI,GAAsBxH,EAAapZ,EAAO0G,EAASuX,EAAUlI,IAExEqD,EAAY6E,SAAWA,EACvB7E,EAAYrD,QAAUA,EACtBqD,EAAY8E,SAAWA,EACvB9E,EAAY+E,UAAYA,EACjBH,GAAsBC,EAAUje,EAAO+V,EAASmI,EAAU5F,EAAQ5R,EAASyX,GACtF,CMmCQ0C,CAAiC5C,EAAUje,EAAOoZ,EAAarD,EAASmI,EAAUxX,EAAS4R,EAAQ6F,QACnG/E,EAAYpZ,MAAQA,GAExB,CACA,OAAOge,GAAsBC,EAAUje,EAAO+V,EAASmI,EAAU5F,EAAQ5R,EAASyX,EACtF,CACO,SAAS2B,GAAyB5d,EAAQ0d,EAAW7J,EAAShK,EAAcmS,EAAUvH,EAAS2B,GAClG,IAAIuH,GAAiBD,GAIrB,UAAWA,IAAc9gB,EAAW2C,OASX,IAArBme,EAAUtd,QAGd4b,EAASnI,EAAS6J,EAAWhhB,QAXzB,IAAK,MAAMuN,KAAQyT,EAAW,CAC1B,MAAM5f,EAAQ4f,EAAUzT,GACxB8T,GAAiB/d,EAAQiK,EAAM4J,EAAShK,EAAcmS,EAAUvH,EAAS0I,GAAclT,GACvFmM,EAAQtY,EACZ,CAQR,CAwBO,SAASggB,GAAqBb,EAAclB,EAAU1f,EAASwX,EAASrP,EAASwX,EAAUC,EAAW7F,GAEzG,OAAI/W,EAAW4d,GA2BnB,SAAqBzY,EAASyY,EAAcpJ,EAASkI,EAAUE,EAAWD,EAAU3f,EAAS+Z,GACzF,MAAM9F,EAAU9L,EAAQxH,UAAUsT,QAGlC,IAFkBA,GAASxR,WAAawR,GAAS1K,UAAU9G,aAC3BjC,EAAWO,WAEvC,OAAOshB,GAAsBriB,EAAS4gB,EAAczY,EAASuX,EAAUlI,GAE3E,OAAO+K,GAA6B3B,EAAcpJ,EAASkI,EAAUE,EAAWD,EAAUxX,EAAS4R,EACvG,CAlCeyI,CAAYra,EAASyY,EAAcpJ,EAASkI,EAAUE,EAAWD,EAAU3f,EAAS+Z,GAExFwI,GAA6B3B,EAAcpJ,EAASkI,EAAUE,EAAWD,EAAUxX,EAAS4R,EACvG,CACO,SAASwI,GAA6B3B,EAAcpJ,EAASkI,EAAU+C,EAAS9C,EAAUxX,EAAS4R,GAEtG,IAAgB,IAAZ0I,EAAJ,CAKA,OAAQ7B,GACJ,UAAKnX,EACL,KAAK,EACL,KAAK,KAID,YAHA8M,GAAaxR,MAAK,WACdyS,EAAQgF,gBAAgBkD,EAC5B,IAGR,GAAI1c,EAAW4d,GACX,OAAOD,GAAyBnJ,EAASoJ,EAAczY,EAASuX,GAGpEC,EAASnI,EAASkI,EAAUkB,EAd5B,MAHInE,GAAiBiD,EAAUkB,EAAcpJ,EAASiL,EAClDta,EAAS4R,EAiBjB,CAUO,SAASsI,GAAsBriB,EAAS4gB,EAAczY,EAASuX,EAAUlI,GAC5E,MAAMkL,EAAU1iB,EAAQyB,MACxB,OAAIihB,GAAWA,EAAQnD,aAAemD,EAAQva,SAC1Cua,EAAQnD,YAAcqB,EACtB8B,EAAQva,QAAUA,EACXua,GAIJ/B,GAAyBnJ,EADhCoJ,EAAehC,GAAoBgC,EAAczY,GACMA,EAASuX,EACpE,CACA,SAASkC,GAAYe,GACjB,OAAI9f,EAAS8f,IAAa,aAAcA,EAC7BA,EAASC,UACZ,CAEZ,CACO,SAAStB,GAAiBD,GAC7B,OAAO5X,MAAc4X,IAAmC,IAAUA,CACtE,CCxJO,MAAMc,GAAe,KAAe,EACrCU,GAA+B,iBAAbjL,UAAyBA,SAASkL,cAAc,OACjE,SAASC,GAAkBC,EAAOrf,EAAQwE,EAAS4R,EAC1D3B,EAASlI,EACT+S,EAAUxL,EAAcxR,EAAO,IAC3B,MAAMvF,EAAM,GACRuiB,QAA6BxZ,IAAjBgO,IACZA,EAAeG,SAASC,eAAexX,GACvCoW,GAAa1R,KAAK,CACdyS,QAASC,EACTH,SAAU2L,IAEdA,OAAWxZ,GAEf,IAAK,IAAI3F,EAAQ,EAAGA,EAAQkf,EAAMjf,SAAUD,EAAO,CAC/C,MAAMof,EAAOF,EAAMlf,GACbrC,EAAQyhB,EAAKC,EAEnB,IADeC,MAAM3hB,GACV,CACP,MAAMqC,EAAQsU,EAAQrU,OAEtBsf,GADc1f,EAAOG,GACGA,EAAOsU,EAASjQ,EAASlC,EAAM8T,EAAQ7J,EAAO+S,EAAUxL,GAChF,QACJ,CACA,MAAM6L,EAAU,CAAC,EAEjB,GADA5iB,EAAIqE,KAAKue,GACO,SAAZJ,EAAKK,GAAe,CACpBC,GAAcF,EAASJ,EAAMD,EAAUxL,GACvC,QACJ,CAEA,MAAMkC,EAAa8J,GAAiBH,EAASJ,EAAMvf,EAAQwE,EAASiQ,EAAS2B,EAAQkJ,EAAUxL,GAC3FyL,EAAKQ,KACLJ,EAAQI,GAAKX,GAAkBG,EAAKQ,GAAI/f,EAAQwE,EAAS4R,EAAQ3B,EAASlI,EAAQ,EAAGyJ,EAAYlC,EAAcxR,GAAMvF,IAE7H,CACA,MAAO,CAAEuF,OAAMvF,MAAK0X,UACxB,CACA,SAASqL,GAAiBH,EAASJ,EAAMvf,EAAQwE,EAASiQ,EAAS2B,EAAQkJ,EAAUxL,GACjF,MAAMkC,EAAa2J,EAAQ3J,WAAa/B,SAASkL,cAAcI,EAAKK,IAwBpE,OAtBIL,EAAKjJ,IACLiJ,EAAKjJ,GAAGpY,SAAQ8hB,IACZ,MAAM/V,EAAO+V,EAAK,GACZliB,EAAQkiB,EAAK,GACb/D,EAAY+D,EAAK,KAAM,EAC7BjC,GAAiB/d,EAAQiK,EAAM+L,EAAYxR,EAE3CmU,GAAyBlE,EAASwH,EAAW7F,EAAQtY,EAAM,IAG/DwhB,EACAxM,GAAa1R,KAAK,CACdyS,QAASmC,EACTrC,SAAU2L,IAIdvM,GAAmB3R,KAAK,CACpByS,QAASmC,EACTrC,SAAUG,IAGXkC,CACX,CACA,SAAS6J,GAAcF,EAASJ,EAAMhW,EAAOuK,GACzC,MAAML,EAAWkM,EACXjhB,EAAS+U,EAASwM,GAAKV,EAAKU,GAClCf,GAAQgB,UAAYxhB,EACpB,MAAMsX,EAAavC,EAASuC,WAAa/B,SAASC,eAAegL,GAAQiB,WACrE5W,EACAuJ,GAAa1R,KAAK,CACdyS,QAASmC,EACTrC,SAAUpK,IAIdwJ,GAAmB3R,KAAK,CACpByS,QAASmC,EACTrC,SAAUG,GAGtB,CACA,SAAS4L,GAAiB5hB,EAAOqC,EAAOsU,EAASjQ,EAASlC,EAAM8T,EAChE7J,EACA+S,EAAUxL,GACN,MAAMiC,EAAS9B,SAASC,eAAexX,GAEjCwa,EAAcgH,GAAcpgB,EAAO2W,EADZlI,EAAQ,GAerC,GAbA2K,EAAYkJ,YAAcrK,EACtBuJ,EACAxM,GAAa1R,KAAK,CACduS,SAAU2L,EACVzL,QAASkC,IAIbhD,GAAmB3R,KAAK,CACpBuS,SAAUG,EACVD,QAASkC,IAGb9W,EAAkBnB,GAUlB,OATAwE,EAAKlB,KAAK,CACN0S,aAAciC,EACduJ,WACAjjB,QAASyB,EACT0G,UACA4R,SACAc,qBAEJA,EAAYxV,QAAU8c,IAI1BtH,EAAYxV,QAAU,CAACzD,EAAUoiB,EAAY/T,EAAYgU,IAAmBC,GAAoBD,EAAgBriB,EAAUqO,GAC3G9H,EAAQnI,QAAQE,OACxB4Q,QAAS,EAChBqT,GAAyB1iB,EAAOoZ,EAAa1S,EAAS4R,EAAQkJ,EAAUxL,UACxDtP,EAAQnI,QAAQE,OACjB4Q,OACf+J,EAAYpZ,MAAQA,CAExB,CC9HO,SAAS2iB,GAAmBjc,EAAS4R,EAAQkJ,EAAUxL,GAC1D,MACMvX,EADUiI,EAAQnI,QACDE,OACvBA,EAAO+L,OAAS9D,EAChBjI,EAAOwQ,OAASvI,IACdyO,GAASC,MACX,MAAMzL,EAOV,SAA2BjD,EAAS4R,EAAQkJ,EAAUxL,GAClD,MAAM4M,EASV,SAAqBlc,GACjB,MAAMxH,EAAYwH,EAAQxH,UACpB2jB,EAAU3jB,EAAUF,IAC1B,GAAI6jB,EAAQ7hB,YAAcjC,EAAWE,IACjC,OAAO4jB,EAAQ5jB,IAEnB,MAAMmb,EAAUyI,EAAQzI,QACxB,OAAO0I,GAAW1I,EAASyI,EAAQ3gB,OACvC,CAjBoB6gB,CAAYrc,GACtBmc,EAAUnc,EAAQxH,UAAUF,IAC5BkD,EAAS2gB,EAAQ3gB,OACjByU,EAAU,GACVlY,EAASiI,EAAQnI,QAAQE,OAC/BA,EAAOkY,QAAUA,EACjB,MAAMhN,EAAS2X,GAAkBsB,EAAS1gB,EAAQwE,EAAS4R,EAAQ3B,EAAS,EAAG6K,EAAUxL,GACzF,OAAOrM,CACX,CAhBmBqZ,CAAkBtc,EAAS4R,EAAQkJ,EAAUxL,GAK5D,OAJAvX,EAAOuZ,YAAcrO,EAAO1K,MAC1BkW,GAASC,MAGJzL,CACX,CAoBO,SAASyW,GAAcpgB,EAAO2W,EAASe,GAC1C,MAAM0B,EAAc,CAChBpZ,QACAwgB,iBAAkBrH,GAClBzB,sBAGJ,OADAf,EAAQrT,KAAK8V,GACNA,CACX,CCrCO,SAAS6J,GAAWlX,EAC3BxN,EACA+Z,GACI,MACM5R,EADSnI,EAAQE,OACAwQ,OACvBvI,EAAQqF,aAAeA,EACvBxN,EAAQiiB,iBAAmB0C,GAC3B,MACMvZ,EAASgZ,GAAmBjc,EAAS4R,OAAQtQ,EADxCzJ,EAAQ+jB,aAEnB,IAAK,MAAMpf,KAAOyG,EAAOnF,KACrB2e,GAAoBjgB,GAExB,OAAOwD,CACX,CAOO,SAAS0c,KAIZ,MAHa,CACTpiB,UAAWjC,EAAWG,UAG9B,CAEO,SAASmkB,GAAsBnkB,EAAW6M,EAAcxN,GAC3D,MAAMmI,EAAUiL,GAAezS,EAAW6M,EAAcA,EAAakF,WAAY1S,GAGjF,OAFeA,EAAQE,OAChBkY,QAAU,GACVjQ,CACX,CC7BO,SAAS4c,GAAwBphB,EACxCG,EAAOsU,EAAS5K,GACZ,MAAM/L,EAAQkC,EAAOG,GAEf+W,EAAczC,EAAQtU,GAE5B,GAAIrC,IAAUoZ,EAAYpZ,MACtB,QAGJ4D,EADgBwV,EAAYxV,SACpB5D,EAAOkC,EAAQ6J,EAAcqN,GACrCA,EAAYpZ,MAAQA,CACxB,CCtBO,SAASujB,GAAgBC,EAAcC,GAC1C,MACM9M,EADS6M,EAAajlB,QAAQE,OACbkY,SAOpB,SAA+B6M,EAAcC,GAChD,MAAMC,EAAWD,EAAavkB,UAAUF,KAAOykB,EAAavkB,UACtDgD,EAASuhB,EAAavkB,UAAUgD,QAAUwhB,EAAQxhB,OAClDlD,EAAMwkB,EAAatkB,UAAUF,IACnCA,EAAIkD,OAASA,CACjB,CAXIyhB,CAAsBH,EAAcC,KAClCtO,GAASC,MDNR,SAA8B1O,EAASiQ,GAC1C,MACMzU,EADUwE,EAAQxH,UAAUF,IACXkD,OACvB,IAAIG,EAAQ,EACZ,MAAMwR,EAAM3R,EAAOI,OACnB,KAAOD,EAAQwR,GACXyP,GAAwBphB,EAAQG,EAAOsU,EAASjQ,KAC9CrE,CAGV,CCHIuhB,CAAqBJ,EAAc7M,KACjCxB,GAASC,MACXC,IACJ,CCcA,SAASwO,GAAc7jB,EAAO+L,EAAcqN,GACxCA,EAAYoH,iBAAmB0C,GAC/B,MAAMlkB,EAAMgB,EACZ,IAAId,EAAYF,EAAIE,UAEfA,IACDA,EAAYgP,GAAmBmD,GAAYU,MAC3C7S,EAAUF,IAAMA,EAChBA,EAAIE,UAAYA,GAEpB,MAAMT,EAAS2a,EAAY3a,OAASH,EAAa8a,GAC3CnK,EAASxQ,EAAOwQ,OAAS2C,GAAW1S,EAAW6M,EAAcA,EAAakF,WAAYmI,GAE5F,OADA3a,EAAO+L,OAASyE,EACTmK,CACX,CC/BO,SAAS0K,GAAgBvlB,EAASyB,EACzC+L,EAAcuM,EAAQkJ,GAClB,MAAMuC,OAA+B/b,IAAtBzJ,EAAQmY,UACnBqN,IACAxlB,EAAQmY,UAAY,IAExB,MAAMA,EAAYnY,EAAQmY,UAC1B,IAAIsN,EAAsBzlB,EAAQ+jB,YAC9BjK,EAAU,EAEd,MAAM4L,EAAe,GAErB,IAAKF,EAAQ,CAET,IAAK,IAAI1hB,EAAQ,EAAGA,EAAQqU,EAAUpU,SAAUD,EAAO,CACnD,MAAME,EAAOmU,EAAUrU,GAEjB6hB,EAAa9L,GAAkBpY,EAAOqC,EAAOqU,EAAW2B,EAASC,GACpD,IAAf4L,EAKe,IAAfA,EAIJ7L,GAAoB6L,EAHhB7hB,GAAgB,EALhB4hB,EAAa3gB,KAAKf,EAS1B,CACAhE,EAAQmY,UAAYuN,CACxB,CACA,MAAM3hB,EAAStC,EAAMsC,OACrB,IAAK,IAAID,EAAQ,EAAGA,EAAQC,IAAUD,EAAO,CAEzC2hB,EADmBG,GAAgBnkB,EAAOqC,EAAO9D,EAAQmY,UAAW3K,EAAciY,EAAqB1L,EAAQkJ,GAC9Ec,WACrC,CACJ,CACA,SAAS6B,GAAgBC,EAAO/hB,EAAOqU,EAAW3K,EAAciY,EAChE1L,EAAQkJ,GACJ,MAAMjf,EAAO6hB,EAAM/hB,GACbmH,EAAWkN,EAAUrU,GAC3B,OAAImH,EAMR,SAAiCxJ,EAAOqkB,EAAa3N,EAAW3K,EAAc1J,EAAO2hB,EACrF1L,EAAQkJ,GACJ,MAAM8C,EAAc5N,EAAUpU,OAASD,EACvC,GAAIiiB,EAEA,OADA7B,GAAoB4B,EAAarkB,EAAO+L,GACjCsY,EAEX,MAAM1a,EAAS4a,GAAuBvkB,EAAOgkB,EAC7CjY,EAAcuM,EAAQ5B,EAAW8K,GACjC,OAAO7X,CACX,CAfe6a,CAAwBjiB,EAAMiH,EAASmN,QAASD,EAAW3K,EAAc1J,EAAO2hB,EAAqB1L,EAAQkJ,GAEjH+C,GAAuBhiB,EAAMyhB,EACpCjY,EAAcuM,EAAQ5B,EAAW8K,EACrC,CAYA,SAAS+C,GAAuBvkB,EAAOsJ,EACvCyC,EAAcuM,EAAQ5B,EAAW8K,GAC7B,MAAM6C,EAAc,CAChBrkB,QACAwgB,iBAAkBrH,GAClBzB,oBAAoB,GAExBY,EAAOY,MAAQZ,EAAOY,MAAQ,EAC9B,MAAMuL,EAAiBtO,SAASC,eAAe,IAuB/C,OAtBAiO,EAAY/B,YAAcmC,EACrBjD,GACDvM,GAAmB3R,KAAK,CACpByS,QAAS0O,EACT5O,SAAUvM,IDxEf,SAA8BtJ,EAAO+L,EAAcqN,GACtD,MAAMpY,EAAYhB,EAAMgB,UACxB,GAAIA,EACA,OAAQA,GACJ,KAAKjC,EAAWG,UAGZ2kB,GAFkB7jB,EACIhB,IACH+M,EAAcqN,GACjC,MAEJ,KAAKra,EAAWC,IAChB,KAAKD,EAAWE,IACZ4kB,GAAc7jB,EAAO+L,EAAcqN,GAKnD,CC0DIsL,CAAqB1kB,EAAO+L,EAAcsY,GAC1C3B,GAAyB1iB,EAAOqkB,EAAatY,EAAcuM,EAAQkJ,GAEnE6C,EAAYrkB,MAAQA,EAEpB0W,EAAUpT,KAAK,CACXqT,QAAS0N,EACT5lB,OAAQ4lB,EAAY5lB,SAEpB+iB,GACAxM,GAAa1R,KAAK,CACdyS,QAAS0O,EACT5O,SAAU2L,IAGX6C,CACX,CCvFA,MAAMM,GAAY,CAAEzL,MAAO,EAAGb,QAAS,GAEhC,SAASoK,GAAoBrJ,EAAajZ,EACjD4L,GAEI,GAAI5L,IAAaiZ,EAAYpZ,MACzB,OAGJ,MAAM4kB,EAAoBxL,EAAYoH,iBAAiBrgB,EAAUiZ,GAEjE,IAA2B,IAAvBwL,EACA,OAGJ,MAAM5jB,EAAYb,GAAYA,EAASa,UACvC,GAAIA,EAAJ,CACI,GAAIA,IAAcjC,EAAWO,WACzB,OAEJulB,GAAezL,EAAajZ,EAAU4L,EAE1C,MACIrK,EAAQvB,GACR2jB,GAAgB1K,EAAajZ,EAAU4L,EAAc,CAAEmN,MAAO,EAAGb,QAAS,WAGnE,IAAevZ,EAAWuC,SAIjCujB,GxBhCD,SAAgC5kB,EAAOzB,GAC1CA,EAAQiiB,iBAAmBrH,GAC3B,MAAM7P,EAAS/K,EAAQ+jB,YACjBjJ,EAAchD,GAAcrW,GAElCzB,EAAQsZ,eAAiB5B,GAAqBoD,EAAa/P,EAC/D,CwB2BQwb,CAAuB3kB,EAAUiZ,GAJjCA,EAAYpZ,MAAQG,CAM5B,CAqBO,SAAS4kB,GAAyB7lB,EAAWka,EAAarN,GAG7D,IAFeqN,EAAY3a,OAEfwQ,OAER,YADA+V,GAA4B9lB,EAAWka,EAAarN,EAAc,CAAEmN,MAAO,EAAGb,QAAS,KC3DxF,SAAoCtM,EAAcrF,EACzDnI,GACI,MAAME,EAASF,EAAQE,OACjBqT,EAAcrT,EAAOwQ,OACrBgW,EAAanT,EAAY5S,UAAUsT,QACnC0S,EAAaxe,EAAQxH,UAAUsT,QACrC,IAAI2S,GAAY,EAChB,MAAMnkB,EAAY0F,EAAQxH,UAAU8B,UAC9BokB,EAAgBrmB,EAAWQ,cAAgByB,GAAajC,EAAWO,aAAe0B,EACxF,GAAIokB,EACAD,EAAYze,EAAQxH,UAAU8B,YAAcjC,EAAWO,YAAcka,GAAW1H,EAAapL,QAE5F,GAAIue,GAAcC,EAAY,CAI/BC,EAHoBF,EAAWnd,WACXod,EAAWpd,QAGnC,CACA,MAAM5I,EAAYwH,EAAQxH,UAC1B,IAAKimB,EAED,YA+ER,SAAkB5mB,EAASW,EAC3B6M,GACI,MAAMtN,EAASF,EAAQE,OACjB4mB,EAAgB5mB,EAAO+L,OAC7B2N,GAAekN,EAAe5mB,GAC9BH,EAAaC,GACb,MAAMiQ,EAAawW,GAA4B9lB,EAAWX,EAASwN,EAAc,CAAEmN,MAAO,EAAGb,QAAS,GAE1G,CAxFQiN,CAAS/mB,EAASW,EAAW6M,GAGjC,MAAMwZ,EAAaH,GlC9BhB,SAA2BtT,EAAa0T,GAK3C,OADqB5S,GAHD4S,EAAapX,MACb0D,EAAYV,YACGG,OAC8BO,EAAY5S,UAAUiP,UAE3F,CkCwBwCsX,CAAkB3T,EAAa5S,GAEnE,IAAKqmB,EAAY,CAGb,YA2DR,SAAsBrmB,EAAWwH,EAASoL,EAAa/F,EAAcgB,GAEjE,MAAM2Y,EAAWxmB,EAAUkP,MACrBuC,EAAcwB,GAAkBzL,EAASoL,EAAa/F,EAAc2Z,EAAU3Y,GAC9EqE,EAAc1K,EAAQ0K,YAE5BA,EAAY7C,UAAYoC,EACxB,MAAMsB,EAAkBH,EAAYV,YAEpCa,EAAgBV,OAASH,EAAYG,MAEzC,CAvEQ,CAAarS,EAAWwH,EAASoL,EAAa/F,EAD7B7M,EAAUiP,YAAckD,GAAYU,KAAOjC,GAAmB2B,GAGnF,CACA,GAAIhT,EAAO4Q,OAEP,YADA5Q,EAAOyS,QAAQ5N,KAAKoD,GAGxB,GAAcA,KACZnI,EAAQC,WAEd,CD0BImnB,CAA2B5Z,EADX6F,GAAW1S,EAAW6M,EAAcA,EAAakF,WAAYmI,GAE7EA,EACJ,CACO,SAASwM,GAA2Blf,EAAS0S,EAAapZ,EAAO+L,UACzD,IAAYjN,EAAWuC,UApBtC,SAAwByQ,EAAavT,EAASyB,EAAO+L,GACjD,MACM8Z,EAAejU,GADH5R,EAAMd,WAAac,EACM+L,EAAcA,EAAakF,WAAY1S,GAIlFglB,GAHoBzR,EAAYvT,QACFE,OACL+L,OACDqb,EAC5B,CAgBIC,CAAepf,EAAS0S,EAAapZ,EAAO+L,EAEhD,CAEO,SAAS8Y,GAAezL,EAAajZ,EAC5C4L,GACI,MAAM/K,EAAYb,EAASa,UAE3B,GADeC,EAAed,GAM1B,YAJ2B6H,IAAvBoR,EAAY3a,QACZH,EAAa8a,GAEjB2L,GAAyB5kB,EAAUiZ,EAAarN,IACzC,EAGX,MAAMtN,EAAS2a,EAAY3a,OAC3B,GAAIA,EAAQ,CAER,MAAMiI,EAAUjI,EAAOwQ,OACvB,GAAIvI,EAEA,OADAkf,GAA2Blf,EAAS0S,EAAajZ,EAAU4L,IACpD,CAEf,CACA,OAAQ/K,GACJ,KAAKjC,EAAWG,UAEZ,OADA+jB,GAAWlX,EAAcqN,EAAauL,KAC/B,EAEX,KAAK5lB,EAAWC,IAChB,KAAKD,EAAWE,IAEZ,OApEZ,SAAqBe,EAAOoZ,EAAarN,GACrC,MAAM/M,EAAMgB,EACZ,IAAId,EAAYF,EAAIE,UACfA,IACDA,EAAYkkB,KACZpkB,EAAIE,UAAYA,EAChBA,EAAUF,IAAMA,IAEDoa,EAAY3a,OAAS2a,EAAY3a,OAASH,EAAa8a,IAChEnK,OAASoU,GAAsBnkB,EAAW6M,EAAcqN,GAClE6J,GAAWlX,EAAcqN,EAAauL,GAC1C,CAwDYoB,CAAY5lB,EAAUiZ,EAAarN,IAC5B,EAGf,OAAO,CACX,CE/GO,SAASmX,GAAoB/iB,EAAUiZ,GAC1C,MAAM3a,EAAS2a,EAAY3a,OACrBqT,EAAcrT,GAAQwQ,OAG5B,GAFmBlO,EAAYZ,GAEf,CAGZ,OADiBqZ,GAHNrZ,EAGyB2R,KAEhCqG,GAAerG,EAAarT,GAC5BH,EAAa8a,GACN,EAGf,CACA,MAAM4M,EAAQ7lB,GAAUa,UACxB,GAAIglB,EAAO,CAIP,OAAkB,IADHnB,GAAezL,EAAajZ,EAF3B1B,EAAOwQ,OACMlD,gBAEH,CAC9B,CAEA,OAAwC,IAApC+F,EAAYvT,QAAQC,oBACb4a,EAAY3a,OACnB2a,EAAY5a,YAAc,EAC1B0W,GAAY5R,MAAK,KACb6U,GAAerG,EAAarT,GAC5ByW,GAAYxS,QACZ2S,IAAO,IAEJ,IAGX8C,GAAerG,EAAarT,UACrB2a,EAAY3a,OACnB2a,EAAY5a,YAAc,EACnB,EACX,CCzCO,SAASynB,GAAmBzT,EAASjU,EAASwN,GACjD,MAAM7M,EAAYgP,GAAmBmD,GAAYU,MACjD7S,EAAU8B,UAAYwR,EAAQxR,UAC9B,MAAM0F,EAAU2c,GAAsBnkB,EAAW6M,EAAcxN,GAE/D,SAASuQ,IAEL,OADA5P,EAAUF,IAAawT,IAChB9L,CACX,CAIA,OAHAxH,EAAUsT,QAAU1D,EACpBA,EAAK9N,UAAYwR,EAAQxR,UACzB8N,EAAKhH,SAAW0K,EAAQ1K,UAAY0K,EAC7B9L,CACX,CCfO,SAASwf,GAAmB3f,EAAQG,GACvC,MAAMS,EAAUZ,EAAOY,QACnBA,EAAQ7E,QAAU6E,EAAQ7E,SAAWiE,EAAOQ,WAAWzE,QAK/D,SAA4B6E,EAAST,EAASH,GAC1C,MAAMkG,EAAU,2DAA2DtF,EAAQ7E,qBAAqBiE,EAAOQ,WAAWzE,UACpHkQ,EAAU9L,EAAQxH,WAAWsT,QACnC,IAAIsL,EAActL,GACdA,GAAS1K,UAGJ0K,GAAS1K,YAFdgW,EAActL,EAAQ1K,UAK1B,MAAM0E,EAAU,CACZ3F,UAAWN,EAAOQ,WAClBof,UAAW5f,EAAOY,QAClB2W,cACA5e,UAAWwH,EAAQxH,WAEjBknB,EAAQ,IAAIxZ,EAAmBH,EAASD,GAE9C,MADAJ,QAAQga,MAAMC,GAAM7Z,GACd4Z,CACV,CAvBQE,CAAmBnf,EAAST,EAASH,EAE7C,CACA,MAAM8f,GAAO,kQCDN,SAASE,GAAe7f,EAASqF,GACpC,MAAMxN,EAAUmI,EAAQnI,UACtBA,EAAQC,YAEV,MAAM+H,EAASL,EAAaC,mBACrBI,EAAOG,QACdA,EAAQ5G,MAAQyG,EAAOQ,WAEvBb,EAAa6B,WAAW/E,KAAK+I,GAC7Bma,GAAmB3f,EAAQG,GAC3BnI,EAAQE,OAAOwQ,OAASvI,CAC5B,CCXO,SAAS8f,GAAchY,EAAY5H,EAC1CrI,EAASwN,GACL,MAAMtN,EAASF,EAAQE,OACjBgoB,EAAiBloB,EAAQC,YACzB6I,EAAYT,GAAa9G,MACzByG,EAASL,EAAaC,YAC5B,GAAIkB,EAAW,CACX,MAAMC,EAAaV,EAAYJ,OAC/BD,EAAOK,YAAcA,EACrBQ,EAAQoH,EAAYtI,EAAaC,YAAakB,EAAWC,EAC7D,MAEIN,EAAUwH,EAAYjI,GAE1B,MAAMrH,EAAYsP,EAAWtP,UAC7B,IAAIwnB,EAEJ,GAAIxnB,EAAU8B,YAAcjC,EAAWQ,YAAa,CAKhDmnB,EAAYjW,GAAYvR,EAJTA,EAEI0S,GAAW1S,EAAW6M,EAAcyC,EAAWyC,WAClE1S,IAEAmoB,EAAUlgB,OAASgI,EAAWhI,MAClC,KACK,CAIDkgB,GAAYlU,EAFItT,EAAUsT,SAENhE,EAAYjQ,EAASqI,GACzC8f,EAAUlgB,OAASgI,EAAWhI,MAClC,CAIA,OAHA+f,GAAeG,EAAW3a,GAGtBxN,EAAQC,YAAcioB,EAAiB,EAChChoB,EAAOwQ,OAEXyX,CACX,CCxCO,SAASC,GAAqBznB,EAAW6M,EAChDxN,EACA+Z,EAAQkJ,EAAUxL,GACdzX,EAAQiiB,iBAAmB0C,GAC3B,MAAMxc,EAAU2c,GAAsBnkB,EAAW6M,EAAcxN,GAC/DmI,EAAQqF,aAAeA,EACvB,MAAMpC,EAASgZ,GAAmBjc,EAAS4R,EAAQkJ,EAAUA,OAAWxZ,EAAYgO,GACpF,IAAK,MAAM/W,KAAO0K,EAAO1K,IACjBA,EAAIgZ,SACAuJ,EACAxM,GAAa1R,KAAK,CACdyS,QAAS9W,EAAIgZ,OACbpC,SAAU2L,IAIdvM,GAAmB3R,KAAK,CACpByS,QAAS9W,EAAIgZ,OACbpC,SAAUG,KAIlB/W,EAAIiZ,aAOAsJ,EACAxM,GAAa1R,KAAK,CACdyS,QAAS9W,EAAIiZ,WACbrC,SAAU2L,IAIdvM,GAAmB3R,KAAK,CACpByS,QAAS9W,EAAIiZ,WACbrC,SAAUG,KAK1B,IAAI3T,GAAS,EACb,MAAMC,EAASqH,EAAOnF,KAAKlC,OAAS,EAEpC,KAAOD,IAAUC,GAAQ,CAErB6gB,GADYxZ,EAAOnF,KAAKnC,GAE5B,CACA,OAAOqE,CACX,CC5CO,SAASgc,GAAyB1iB,EAAOoZ,EAChDrN,EACAuM,EACAkJ,EAAUxL,GACN,MAAMhV,EAAYhB,GAAOgB,UACzB,OAAIA,EAoBR,SAA8BA,EAAWoY,EAAapZ,EAAO+L,EAC7DuM,EACAkJ,EAAUxL,GAEN,SADEoD,EAAY5a,YACNwC,GAEJ,KAAKjC,EAAWG,UAEZ,OADAka,EAAYoH,iBAAmB0C,GAC3B1B,EACOmF,GAAqB3mB,EAAO+L,EAAcqN,EAAad,EAAQkJ,EAAUxL,GAE7EiN,GAAWlX,EAAcqN,EAAad,GACjD,KAAKvZ,EAAWE,IAChB,KAAKF,EAAWC,IAAK,CACjBoa,EAAYoH,iBAAmB0C,GAC/B,MAAMlkB,EAAMgB,EACZ,IAAId,EAAYF,EAAIE,UACfA,IACDA,EbhCT,SAA0BF,GAC7B,MAAME,EAAYkkB,KAGlB,OAFAlkB,EAAUF,IAAMA,EAChBA,EAAIE,UAAYA,EACTA,CACX,Ca2B4B0nB,CAAiB5nB,IAEjC,MAAMP,EAASH,EAAa8a,GAC5B,OAAIoI,EACOmF,GAAqBznB,EAAW6M,EAAcqN,EAAad,EAAQkJ,EAAUxL,IAExFvX,EAAOwQ,OAASoU,GAAsBnkB,EAAW6M,EAAcqN,GAC/DA,EAAYoH,iBAAmB0C,GACxBD,GAAWlX,EAAcqN,EAAad,GACjD,CACA,KAAKvZ,EAAWQ,YAChB,KAAKR,EAAWI,aAGZ,GAFAb,EAAa8a,GACbA,EAAYoH,iBAAmB0C,GAC3B1B,EAAU,CACV,MAAMqF,EClDf,SAAsC3nB,EAAWX,EAASwN,EAAcuM,EAAQkJ,GAGnF,MAAMhT,EAAaoD,GAAW1S,EAAW6M,EAAcA,EAAakF,WAAY1S,GAC1EuoB,EAAiBtY,EAAW4C,YAClC,GAAI0V,EAAgB,CAChB,MAAMnW,EAAczR,EAAU8B,YAAcjC,EAAWI,aAAe,GAAK0S,GAAe3S,EAAWsP,GACrGsY,EAAevY,UAAYoC,CAC/B,CACA,MAAMlS,EAASF,EAAQE,QACjB,QAAEiI,GAAYqgB,GAAkBvY,EAAY/P,EAAOwQ,OACzD1Q,EAASwN,GAET,OClBG,SAA+BrF,EAAS4R,EAAQkJ,GACnD,IAAIwF,EAAchS,GAAa1S,OAC/B,MAAMqH,EAASgZ,GAAmBjc,EAAS4R,EAAQkJ,OAAUxZ,GAC7D,IAAK,MAAM/I,KAAO0K,EAAO1K,IACjBA,EAAIiZ,YACJlD,GAAa7R,OAAO6jB,IAAe,EAAG,CAClCjR,QAAS9W,EAAIiZ,WACbrC,SAAU2L,IAGdviB,EAAIgZ,QACJjD,GAAa7R,OAAO6jB,IAAe,EAAG,CAClCjR,QAAS9W,EAAIgZ,OACbpC,SAAU2L,IAItB,MAAMhd,EAAOmF,EAAOnF,KACpB,IAAK,MAAMtB,KAAOsB,EACd2e,GAAoBjgB,EAG5B,CDLI+jB,CAAsBvgB,EAAS4R,EAAQkJ,GAChC9a,CACX,CDoCsCwgB,CAA6BlnB,EAAOoZ,EAAarN,EAAcuM,EAAQkJ,GAC7F,OAAOqF,CACX,CAEA,OADsB7B,GAA4BhlB,EAAOoZ,EAAarN,EAAcuM,GAGxF,KAAKvZ,EAAWO,WAAY,CACxBhB,EAAa8a,GACb,MAAM1S,EAAUuf,GAAmBjmB,EAAOoZ,EAAarN,GACvDya,GAAc9f,OAASsB,EAAWoR,EAAarN,GAC/C,MAAMpC,EAASgd,GAAqBjgB,EAAQxH,UAAW6M,EAAcqN,EAAad,EAAQkJ,EAAUxL,GAEpG,OADAoD,EAAYoH,iBAAmB0C,GACxBvZ,CACX,EAER,CAnEewd,CAAqBnmB,EAAWoY,EAAapZ,EAAO+L,EAAcuM,EAAQkJ,EAAUxL,GAE3FtU,EAAQ1B,IACR8jB,GAAgB1K,EAAapZ,EAAO+L,EAAcuM,EAAQkJ,QAC1DpI,EAAYoH,iBAAmBvH,UAG/B9X,EAAkBnB,IAK1B,SAAkCA,EAAOzB,EACzCyX,GACI,MAAMqD,EAAchD,GAAcrW,GAC5BkN,EAAQ+I,GAAqBoD,EAAarD,GAChDzX,EAAQsZ,eAAiB3K,EACzB3O,EAAQiiB,iBAAmBrH,EAC/B,CARIiO,CAAyBpnB,EAAOoZ,EAAaA,EAAYkJ,aAC7D,CGzBO,SAAS+E,GAAiBrnB,EACjCoZ,EAAa1S,GACT,MAAMjI,EAASiI,EAAQnI,QAAQE,OACzB6oB,EAActnB,IAAUoZ,EAAYpZ,MACtCvB,EAAOsZ,SAAWuP,IAGtB7E,GAAoBrJ,EAAapZ,EAAO0G,GACnCR,EAAaC,YAAYO,SAC1B2O,KAGR,CCXO,SAAS8N,IAAoB,QAAE5kB,EAAO,QAAEmI,EAAO,OAAE4R,EAAM,YAAEc,EAAW,SAAEoI,IACzE,IAAI+F,EAAU,SAAoBvnB,GAC9B0iB,GAAyB1iB,EAAOoZ,EAAa1S,EAAS,IAAK4R,GAAUkP,EAAUhG,OAAWxZ,GACrFwf,GAAYthB,EAAaC,YAAYO,SACtC2O,KAGJkS,EAAU,SAA4BvnB,GAClCqnB,GAAiBrnB,EAAOoZ,EAAa1S,EACzC,CACJ,EAKA,IAAI8gB,GAAU,EACd,MAAMtkB,EAAM3E,EAAQ+B,WAJH,SAA2BN,GACxCunB,EAAQvnB,EACZ,IAGAoZ,EAAY7a,QAAUA,EACtBipB,GAAU,EACV,MAAM/oB,EAASiI,EAAQnI,QAAQE,QAClBA,EAAOkE,cAAgBlE,EAAOkE,eAAiB,IACvDW,KAAKJ,EAEd,CHvBO,SAAS8hB,GAA4B9lB,EAAWX,EAASwN,EAAcuM,GAG1E,MAAM9J,EAAaoD,GAAW1S,EAAW6M,EAAcA,EAAakF,WAAY1S,GAC1EuoB,EAAiBtY,EAAW4C,YAClC,GAAI0V,EAAgB,CAChB,MAAMnW,EAAczR,EAAU8B,YAAcjC,EAAWI,aAAe,GAAK0S,GAAe3S,EAAWsP,GACrGsY,EAAevY,UAAYoC,CAC/B,CACA,MAAMlS,EAASF,EAAQE,QACjB,QAAEiI,GAAYqgB,GAAkBvY,EAAY/P,EAAOwQ,OACzD1Q,EAASwN,GAET,OCdG,SAAiCrF,EAAS4R,EAAQc,GACrDA,EAAYoH,iBAAmB0C,GAC/B,MAGM1e,EAFSme,GAAmBjc,EAAS4R,OAAQtQ,EADxCoR,EAAYkJ,aAGH9d,KACpB,IAAK,MAAMtB,KAAOsB,EACd2e,GAAoBjgB,EAG5B,CDGIukB,CAAwB/gB,EAAS4R,EAAQ/Z,GAClCmI,CACX,CIdO,SAASghB,GAAsBC,EAAWzpB,EAAMsQ,EAAYzC,EAAcgB,EAAU0B,GACvF,OAAIkZ,SAIAlZ,EAAQ1B,EAHD7O,SAMA,IAAgBY,EAAWuC,SAE9BnD,EAAK2Q,KACL8Y,EAAU9Y,IAAM3Q,EAAK2Q,IACd3Q,IAEXypB,EAAU9Y,IAAM3Q,EACTypB,GAEP5X,GAAgB7R,GACTA,EAEPwD,EAAQxD,GCxBT,SAA6BA,EAAMypB,EAAWnZ,EAAYzC,EAAc0C,EAAO1B,GAClF,IAAK,IAAI1K,EAAQnE,EAAKoE,OAAS,EAAGD,GAAS,IAAKA,EAAO,CACnD,MAAMD,EAAIlE,EAAKmE,GACTulB,EAAUD,EAAUtlB,GAC1BnE,EAAKmE,GAASqlB,GAAsBE,EAASxlB,EAAGoM,EAAYzC,EAAcgB,EAAU0B,EAAQ,EAChG,CACA,OAAOvQ,CACX,CDkBe2pB,CAAoB3pB,EAAMypB,EAAWnZ,EAAYzC,EAAc0C,EAAO1B,GEzB9E,SAA8B7O,EAAMypB,EAAWnZ,EAAYzC,EAAc0C,EAAO1B,GACnF,MAAMe,EAAOjQ,OAAOiQ,KAAK5P,GACzB,IAAK,MAAMiO,KAAQ2B,EAAM,CACrB,MAAMkC,EAAW9R,EAAKiO,GAEhBxC,EAAS+d,GADCC,EAAUxb,GACoB6D,EAAUxB,EAAYzC,EAAcgB,EAAU0B,EAAQ,GACpG,GAAIuB,IAAarG,EACb,SAEJ,MAAMme,EAAYjqB,OAAOuS,yBAAyBlS,EAAMiO,IAAO7H,IAC3DwjB,IAGJ5pB,EAAKiO,GAAQxC,EACjB,CACA,OAAOzL,CACX,CFWW6pB,CAAqB7pB,EAAMypB,EAAWnZ,EAAYzC,EAAc0C,EAAO1B,EAClF,CZmBO,SAASoF,GAAkB3D,EAAYsD,EAAa/F,EAAcic,EACzEjb,EAAU0B,GAAQ,GACd,GAAiB,IAAb1B,EACA,MAAM,IAAIT,MAAM,eAEpB,MACM2C,EADS6C,EAAYvT,QAAQE,OACbwQ,OACtB,IAAKA,EAAQ,CACT,MAAM0B,EAAcpC,GAAUyZ,EAAexZ,EAAYC,GACzDuZ,EAAc1kB,QAAQqN,GAGtB,OAFoBnC,EAAW4C,YACnB7C,UAAYoC,EACjBqX,CACX,CAEA,MACMC,GAFNnW,EAAc7C,GAAU6C,GACYV,YACI7C,UAClC2Z,EAAW,GACjB,IAAK,IAAI7lB,EAAQ,EAAGA,EAAQ2lB,EAAc1lB,SAAUD,EAAO,CACvD,MAAMnE,EAAO8pB,EAAc3lB,GAErBlC,EAAWunB,GADCO,EAAgB5lB,GACgBnE,EAAMsQ,EAAYzC,EAAcgB,EAAU0B,EAAQ,GACpGyZ,EAAS5kB,KAAKnD,EAClB,CAGA,OAFuBqO,EAAW4C,YACnB7C,UAAY2Z,EACpBA,CACX,CevEO,SAASC,GAAmBrW,GAC/B,MAAMrT,EAASqT,EAAYvT,QAAQE,QAC7B,KAAE+F,EAAI,KAAE8J,GAASwI,GAA0BrY,EAAOkY,SACxDyR,GAAetW,GACf,IAAK,MAAM2E,KAASnI,EAChB8Z,GAAe3R,GAEJhY,EAAOkE,eAElB6B,EAAKpE,SAAQ8C,GAAOA,EAAIxC,gBAE5BpC,EAAawT,EAAYvT,QAC7B,CACA,SAAS6pB,GAAe3R,GACpB,MAAMlY,EAAUkY,EAAMlY,QAChBE,EAASF,EAAQE,QACA,IAAnBA,EAAOsZ,UAGXtZ,EAAOsZ,SAAU,EACjBxZ,EAAQC,YAAc,EACtBwY,GAAgBP,EAAOhY,EAAQ,IACnC,CCpBO,SAASsoB,GAAkBvY,EAAYsD,EAC9CvT,EACAwN,GACI,MAAMsc,EAAgBvW,GAAa5S,UAC7BopB,EAAUD,GAAerpB,IACzB0nB,EAAYF,GAAchY,EAAYsD,EAAavT,EAASwN,GAC5Dwc,GAAazW,GAAe0H,GAAW1H,EAAa4U,GAC1D,GAAK6B,GAOA,GAAIzW,EAAa,CAClB,MAAM9S,EAAM8S,EAAY5S,UAAUF,IAC9BA,GAAOT,EAAQC,YAAc,GAQzC,SAA6BQ,EAAK8S,EAAawW,GAC3C,GAAItpB,EAAIgC,YAAcjC,EAAWE,IAAK,CAClC,MAAMupB,EAAUF,GAASrpB,IAKzB,YAHIupB,IADWxpB,EAAIC,KAEfkpB,GAAmBrW,GAG3B,CACA,GAAIwW,EAAS,CACT,MAAMG,EAAcH,EAAQlO,QAC5B,GAAIqO,EAAa,CACb,MAAMC,EAAYD,GAAanmB,OAE3BomB,IADc1pB,EAAIob,QAAQ9X,QAE1B6lB,GAAmBrW,EAE3B,CACJ,CACJ,CA1BY6W,CAAoB3pB,EAAK8S,EAAawW,EAE9C,MAZgB,EhB+Db,SAAuBxW,EAAatD,GACvC,MAAM/P,EAASqT,EAAYvT,QAAQE,OACnC,IAAImqB,GAAU,EACd,MAAM3d,EAAYxM,EAAOwM,UAAYxM,EAAOwM,WAAa,GACnD4d,EAAO5d,EAAU3I,OAAS,EAChC,KAAOsmB,IAAWC,GAAM,CACpB,MAAMvd,EAAWL,EAAU2d,GAC3B,IAAIvmB,GAAS,EACb,MAAMymB,EAAQxd,EAASI,SAASpJ,OAAS,EACzC,KAAOD,IAAUymB,GAGb,GADuBrqB,IADT6M,EAASI,SAASrJ,GACQ9D,QAAQE,OAI5C,OAFA6M,EAASI,SAASvI,OAAOd,EAAO,QAChCiJ,EAASI,SAASpI,KAAKkL,EAInC,CACJ,CgBjFQua,CAAcjX,EAAa4U,GAC3ByB,GAAmBrW,GACnB,MAAMrT,EAASioB,EAAUnoB,QAAQE,OACjCA,EAAO+L,OAASkc,EAChBjoB,EAAOwQ,OAASyX,CACpB,CAOA,MAAMsC,EAAmBlX,GAAa/F,aAEtC,OADA2a,EAAU3a,aAAgBA,GAAgBid,EACnC,CAAEtiB,QAASggB,EAAWuC,YAAaV,EAC9C,CC1BA,MAAM,GAAY,CAAErP,MAAO,EAAGb,QAAS,GAEhC,SAAS5I,GAAuBqC,EAAatD,EACpDzC,EACAxN,GACI,MAAME,EAASF,EAAQE,QACjB,QAAEiI,EAAO,YAAEuiB,GAAgBlC,GAAkBvY,EAAYsD,EAC/DvT,EAASwN,GACT,OAAIkd,GACA1F,GAAgB9kB,EAAO+L,OAAQ9D,GACxBA,IAEXuc,GAAWlX,EAAcxN,EAAS,IAC3BmI,EACX,CpCZO,SAAS6I,GAAarQ,GACzB,OAAOH,EAAWG,YAAcA,EAAU8B,SAC9C,CAEO,SAAS,GAAc0F,GAC1B,MAAMjI,EAASiI,EAAQnI,QAAQE,OAEzB0d,EAAa5M,GADD7I,EAAQxH,WAEpB6M,EAAerF,EAAQqF,aAC7B,GAAItN,EAAO4Q,OAEP,OADA5Q,EAAOyS,QAAQ5N,KAAKoD,GACbA,EAGX,GAAIyV,EAAY,CAEZ,OADe3M,GAAiBzD,EAAcrF,EAElD,CACAjI,EAAO4Q,QAAS,EAChB,MAAM9Q,EAAUmI,EAAQnI,QACpBE,EAAOyS,QAAQ5O,SACfoE,EAAUjI,EAAOyS,QAAQgY,MACzBzqB,EAAOyS,QAAU,IAErB,MAAMlS,EAAMyQ,GAAuBhR,EAAOwQ,OAAQvI,EAASqF,EAAcxN,GAEzE,cADOE,EAAO4Q,OACPrQ,CACX,CACO,SAASwQ,GAAiBzD,EAAcrF,GAC3C,MAAMyiB,EAAYpd,EAAaxN,QAAQE,OACvC,IAAK0qB,IAAmC,IAAtBA,EAAUpR,QACxB,OAAOrR,EAKX,OADe,GADAyiB,EAAUla,QAAUlD,EAGvC,CAyBO,SAAS+G,GAAsByJ,EAAUC,GAU5C,OATeD,EAASja,SACNka,EAAYla,MASlC,CqCzEO,SAASjC,GAASA,GACrB,MAAMqG,EAAU7G,KAChB,IAAK6G,EACD,MAAM0iB,GAEV,OAAOC,GAAc3iB,EAASR,EAAaC,YAC3C9F,EACJ,CACO,SAASgpB,GAAc3iB,EAASyD,EAAUvF,GAC7C,MAAM0kB,EAAgBnf,EAASpD,WACzBF,EAAYsD,EAAS3D,OAE3B,OAAO,YAAoBpB,GAEvB,OADsBsB,EAAQnI,QAAQC,YAAc,ECf7C,SAA6BkI,EAASrG,EAAU8J,KAC5D/E,GACC,MACM8C,EADSxB,EAAQnI,QAAQE,OACFwQ,OAG7BhH,EAAaC,EAAexB,GAU5B,MAAM2Q,EAAehX,KAAY+E,GA4BjC,OA1BA6C,EAAavB,EAASwB,GAStB,GAAcA,GACV5G,EAAU+V,IACVA,EAAakS,SAAQ,KAEjBthB,EAAavB,EAASwB,GAStB,GAAcA,EAAc,IAI7BmP,CACX,CD5BmBmS,CAAoB9iB,EAAS9B,EAAY,CAC5CmC,WAAYuiB,EACZ9iB,OAAQK,MACNzB,GAGHR,KAAcQ,EACzB,CACJ,CExBO,MAAMqkB,GAAgB,KACzB,MAAM/iB,EAAU7G,KAEhB,IAAK6G,EACD,MAAM0iB,GAEV,MAAMjf,EAAWjE,EAAaC,YAE9B,OAAO,SAAsB9F,GACzB,OAAOgpB,GAAc3iB,EAASyD,EAAU9J,EAC5C,CAAC,EAEQ+oB,GAAY,IAAIvc,EAAkB,iKCdxC,SAAS6c,GAAOrpB,GACnBP,EAAMO,EACV,CCFO,SAASspB,GAAUtpB,GACtBP,GAAM,WACcD,KACOtB,QAAQE,OACxB+R,SAAS5L,WAAWvE,EAC/B,GACJ,CCPO,SAASR,KACZ,OAAOqG,EAAaC,YAAYO,OACpC,CCAO,MAAMkjB,GAAiB,UACjBC,GAAiB,IACvB,SAASC,GAAa1P,EAASlY,GAClC,MAAMlD,EAAM,CACRkD,SACA6J,aAAclM,KACdmB,UAAWjC,EAAWC,IACtBob,UAEAzc,IAAI0Q,IACArP,EAAIqP,WAAaA,EACVrP,GAEX+qB,KAAM,SAAc3P,EAASlY,GAEzB,OADAlD,EAAI0M,SAAW,CAAE0O,UAASlY,UACnBlD,CACX,GAEJ,OAAOA,CACX,CACO,SAASgrB,GAAU/qB,EAAKiD,GAC3B,MAAMlD,EAAM,CACRkD,SACA6J,aAAclM,KACdZ,MACA+B,UAAWjC,EAAWE,IACtBtB,IAAK,SAAgB0Q,GAEjB,OADArP,EAAIqP,WAAaA,EACVrP,CACX,EACA+qB,KAAM,CACF9qB,IAAK,SAAaA,EAClBiD,GAEI,OADAlD,EAAI0M,SAAW,CAAEzM,IAAKA,EAAKiD,UACpBlD,CACX,IAGR,OAAOA,CACX,CCxCA,MAAMirB,GAAc,gBACdC,GAAgB,gBAChBC,GAAY,sDACZC,GAAc,2GAEb,SAASC,GAAUN,GACtB,MAAMO,EAAiB,GACjBC,EAAW,GACXC,EAAQ,GACd,IAAIC,EAAiB,KACjBC,GAAc,EACdC,EAAW,EACf,MAAMC,EAAW,IAAI3d,OAAOmd,GAAa,KAEzC,IADAL,EAqGJ,SAAkCA,GAE9B,OAAOA,EAAKc,QAAQC,IAAmB,SAAUC,GAE7C,OAAOA,EAAMF,QAAQ,WAAY,cAAcA,QAAQ,WAAY,cAAcA,QAAQ,KAAM,SAASA,QAAQ,KAAM,QAC1H,GACJ,CA3GWG,CAAyBjB,GACzBY,EAAWZ,EAAKznB,QAAQ,CAC3B,MAAM2oB,EAAWL,EAASM,KAAKnB,GAC/B,IAAKkB,EACD,MAEJ,MAAOE,EAAWC,EAASC,GAAcJ,EACnCK,EAAeH,EAAU7L,WAAW,MACpCiM,EAAgBJ,EAAUK,SAAS,MACzC,GAAIb,EAAWM,EAAS5oB,MAAO,CAC3B,MAAMuT,EAAcmU,EAAK0B,MAAMd,EAAUM,EAAS5oB,OAClD,GAAIuT,EAAY8V,OAAQ,CACGC,GAAc/V,GACtBxV,SAAQwV,IACfA,EAAY0J,WAAWsK,MACvBhU,EAAcgU,MAAoBc,EAAcb,IAEpD+B,GAAWnB,EAAgBF,EAAU3U,EAAY,GAEzD,CACJ,CAEA,GADA+U,EAAWM,EAAS5oB,MAAQ8oB,EAAU7oB,OAClCgpB,EAAc,CACdb,EAAiBD,EAAMtB,OAAS,KAChC,QACJ,CACA,MAAM2C,EAAa,GACnB,IAAIC,EACJ,KAAoD,QAA5CA,EAAY3B,GAAUe,KAAKG,KAAuB,CACtD,MAAMpN,EAAW6N,EAAU,IAAMA,EAAU,IAAMA,EAAU,GAE3D,IAAIlM,EADekM,EAAU,IAAMA,EAAU,IAAMA,EAAU,GAE7D,QAAiB9jB,IAAbiW,EACA,SAEJ,MAAM8N,EAA4B,KAAjBD,EAAU,GACrBE,OAAwBhkB,IAAd4X,GAA2BmM,EACrCE,EAAYhO,EAASiO,cACrBC,EAAYF,EAAU3M,WAAW,MAAQ8M,GAAeH,GAAaA,EAC3E,GAAID,EAAS,CAET,GADsB/N,EAASwN,MAAM,EAAG7B,GAAetnB,UAAYsnB,GAChD,CACf,MAAMyC,EAAYzC,MAAoBc,EAAcb,GACpDS,EAAehnB,KAAK,CAAC,KAAM+oB,IAC3BR,EAAWvoB,KAAK,CAAC+oB,IACjB,QACJ,CAGA,GAFqBP,EAAU,GAAGxM,WAAWrB,IACN6N,EAAU,GAAGL,MAAMxN,EAAS3b,OAAQwpB,EAAU,GAAGxpB,QAAQgqB,OAAO,SAAW,EAC9F,CAChBT,EAAWvoB,KAAK,CAAC6oB,IACjB,QACJ,CAEAvM,EADkBgK,MAAoBc,EAAcb,EAExD,CACKkC,IACDnM,EAAYkM,EAAU,IAE1B,MAAMS,EAAU,CAACJ,EAAWvM,GACtBzB,EAAYkB,GAAc4M,GAC5B9N,GACAoO,EAAQjpB,KAAK6a,GAEjB0N,EAAWvoB,KAAKipB,EACpB,CACA,MAAMxW,EAAU,CACZ+L,GAAIsJ,GAEJS,EAAWvpB,SACXyT,EAAQyC,GAAKqT,GAEbpB,GACKA,EAAexI,KAChBwI,EAAexI,GAAK,IAExBwI,EAAexI,GAAG3e,KAAKyS,IAGvBwU,EAASjnB,KAAKyS,GAEbwV,IACDf,EAAMlnB,KAAKmnB,GACXA,EAAiB1U,EAEzB,CACA,GAAI4U,EAAWZ,EAAKznB,OAAQ,CACxB,MAAMsT,EAAcmU,EAAK0B,MAAMd,GAC/B,GAAI/U,EAAY8V,OAAQ,CACGC,GAAc/V,GACtBxV,SAAQwV,IACfA,EAAY0J,WAAWsK,OACrBc,EAECkB,GAAWnB,EAAgBF,EAAU3U,KAEpD,CACJ,CACA,OAAO2U,CACX,CACA,MAAMO,GAAoB,IAAI7d,OAAO,4BAAuB,KAQ5D,SAASmf,GAAe/N,GACpB,GAAIA,EAAUiB,WAAW,MAAO,CAE5B,OADwBjB,EAAU/b,SAAW4nB,GAAc5nB,QAAU+b,IAAc6L,GAExE,WAEJ7L,EAAUoN,MAAM,EAAGpN,EAAU/b,OACxC,CACA,OAAO+b,CACX,CACA,SAASuN,GAAWnB,EAAgBF,EAAU3U,IAc9C,SAAgB6U,EAAgBF,EAAU5U,GAClC8U,GACKA,EAAexI,KAChBwI,EAAexI,GAAK,IAExBwI,EAAexI,GAAG3e,KAAKqS,IAGvB4U,EAASjnB,KAAKqS,EAEtB,CAnBI6W,CAAO/B,EAAgBF,EAJN,CACbzI,GAAI,OACJK,GAAIsK,GAA0B7W,IAGtC,CACA,SAAS6W,GAA0B1C,GAE/B,OAAOA,EAAKc,QAAQ,kCAAkC,SAAUE,GAE5D,OAAOA,EAAMF,QAAQ,WAAY,KAAKA,QAAQ,WAAY,KAAKA,QAAQ,gBAAiB,SAASA,QAAQ,gBAAiB,QAC9H,GACJ,CAYA,SAASc,GAAce,GAKnB,OAHcA,EAAYnR,MAAM0O,IAEJ0C,QAAOC,GAAiB,KAATA,GAE/C,CClKA,MAAMC,GAAe,+BACfC,GAAU,eAST,SAASC,GAAgC3S,EAASlY,GAIrD,OAKJ,SAAyBkY,EAASlY,GAC9B,MAAM8qB,EAAU5S,EAAQxX,KAAI,CAACqqB,EAAU5qB,IAC/BA,EAAQH,EAAOI,OACR2qB,EAAWrD,GAAiBvnB,EAAQwnB,GAExCoD,IAGX,OAEG,SAA8BD,EAAS5S,EAASlY,GACnD,MAAMgrB,EAAOhrB,EAAOI,OAAS8X,EAAQ9X,OACrC,GAAI4qB,EAAO,EACP,IAAK,IAAI9qB,EAAI8qB,EAAM9qB,EAAI,IAAKA,EACxB4qB,EAAQ1pB,KAAKsmB,IAAkBxP,EAAQ9X,OAASF,EAAI,GAAKynB,GAGrE,CAVIsD,CAAqBH,EAAS5S,EAASlY,GAChC8qB,CACX,CAdWI,CAFyChT,EAK/BxX,KAAIqqB,GAAYA,EAASpC,QAAQgC,IAAc,CAAC9B,EAAO1oB,IAAUyqB,GAAUzqB,MAHjDH,EAC/C,CCdA,MAAMmrB,GAAmB,IAAIpgB,OAAO2c,GAAiB,SAAWC,GAAgB,KAC1E5H,GAAK,KACJ,SAASqL,GAAoBruB,EAAKsuB,EAAYjD,EAAiB,GAAIkD,EAAc,IACpF,MAAMjD,EAAWtrB,EACjB,IAAK,IAAImO,EAAI,EAAGA,EAAImd,EAASjoB,OAAQ8K,IAAK,CACtC,MAAMqgB,EAAW,IAAID,EAAapgB,GAC5B2I,EAAUwU,EAASnd,GACzB,GAAI2I,EAAQyC,GAAI,CACZ,MAAMkV,EAAQ3X,EAAQyC,GACtBzC,EAAQyC,GAAKmV,GAAkBD,EAAOH,EAC1C,CACA,GAAIxX,EAAQkM,GAAI,CACZ,MAAMvW,EAAWqK,EAAQkM,GACnB2L,EAAgB,IAAIH,EAAUxL,IACpClM,EAAQkM,GAAKqL,GAAoB5hB,EAAU6hB,EAAYjD,EAAgBsD,EAC3E,CACAxgB,EAAIygB,GAAa9X,EAASwX,EAAYhD,EAAUnd,EACpD,CACA,OAAOmd,CACX,CACA,SAASsD,GAAapX,EAAO8W,EAAY7hB,EAAUrJ,GAC/C,GAAiB,SAAboU,EAAMqL,GACN,OAAOzf,EAEX,MAAMyrB,EAAYrX,EAClB,IAIIsU,EAJAnV,EAAckY,EAAU3L,GAC5B,UAAWvM,IAAgB/W,EAAe+B,OACtC,OAAOyB,EAGX,KAAwD,QAAhD0oB,EAAQsC,GAAiBnC,KAAKtV,KAAwB,CAC1D,MAAMmY,EAAchD,EAAM,GACpBiD,EAASC,SAASF,EAAa,IAErC,IADiBpM,MAAMqM,IAAWA,EAAST,EAC9B,CACT,MAAMW,EAAatE,GAAiBoE,EAASnE,GACvCsE,EAAQvY,EAAY6V,MAAMV,EAAM1oB,MAAQ6rB,EAAW5rB,QACzDoJ,EAASvI,OAAOd,EAAO,EAAO,CACtByf,GAAI,OACJJ,EAAGsM,IAEXpY,EAAcuY,EACdd,GAAiBe,UAAY,CACjC,CACJ,CAEA,OADAN,EAAU3L,GAAKvM,EACRvT,CACX,CACA,SAASsrB,GAAkB9B,EAAY0B,GACnC,OAAO1B,EAAWjpB,KAAI2pB,IAClB,MAAO5uB,EAAKqC,EAAOme,GAAaoO,EAChC,GAAI5uB,EAAI2hB,WAAWsK,IAAiB,CAChC,MAAMvnB,EAAQ4rB,SAAStwB,EAAIktB,QAAQjB,GAAgB,IAAK,IACxD,IAAKjI,MAAMtf,IAAUA,EAAQkrB,EACzB,MAAO,CAAC,CAAEpM,SAAU9e,GAE5B,CACA,UAAWrC,IAAUnB,EAAe+B,QAAUZ,EAAMsf,WAAWsK,IAAiB,CAC5E,MAAMvnB,EAAQ4rB,SAASjuB,EAAM6qB,QAAQjB,GAAgB,IAAK,IAC1D,IAAKjI,MAAMtf,IAAUA,EAAQkrB,EACzB,MAAO,CAAC5vB,EAAK,CAAEwjB,SAAU9e,GAAS8b,EAE1C,CACA,OAAOoO,CAAO,GAEtB,CClEO,MAAM,GAAU,eAIvB,MAAM8B,GAAe,qBACrB,SAASC,GAAmBvY,GAcxB,GAbIA,EAAQyC,KACRzC,EAAQyC,GAAKzC,EAAQyC,GAAKzC,EAAQyC,GAAG5V,KAAIsf,IACrC,GAAoB,IAAhBA,EAAK5f,OACL,OAAO4f,EAEX,MAAO,CAAEliB,GAASkiB,EAClB,UAAWliB,IAAUnB,EAAe+B,QAAUZ,EAAMsf,WAAW,IAAU,CACrE,MAAMjd,EAAQ4rB,SAASjuB,EAAM6qB,QAAQ,GAAS,IAAK,IACnD3I,EAAK,GAAK0H,GAAiBvnB,EAAQwnB,EACvC,CACA,OAAO3H,CAAI,IACV,IAELnM,EAAQkM,GAAI,CACZ,MAAMvW,EAAWqK,EAAQkM,GACzB,IAAK,IAAI7U,EAAI,EAAGA,EAAI1B,EAASpJ,OAAQ8K,IAAK,CACtC,MAAMqJ,EAAQ/K,EAAS0B,GACvB,GAAiB,SAAbqJ,EAAMqL,GAAe,CACrB,UAAWrL,EAAM0L,KAAOtjB,EAAe+B,OACnC,OAEJ6V,EAAM0L,GAAK1L,EAAM0L,GAAG0I,QAAQwD,IAAc,CAACE,EAAQlsB,IAAUunB,GAAiBvnB,EAAQwnB,IAC1F,CACAyE,GAAmB7X,EACvB,CAEwB,IAApB/K,EAASpJ,eACFyT,EAAQkM,EAEvB,CACJ,CChCA,MAAMuM,GAAW,CAAC,EAEX,SAAS1L,GAAW1I,EAASlY,GAChC,MAAMusB,ECTH,SAAsBrU,GACzB,MAAMgK,EAAQhK,EAAQxX,KAAIR,GAAKA,EAAEE,SAEjC,OADA8hB,EAAM9gB,KAAK8W,EAAQ9X,QACZosB,OAAOtK,EAAMuK,KAAK,IAC7B,CDKqBC,CAAaxU,GACxByU,EAAUL,GAASC,GACnBK,EAAUD,GEXb,SAA0BzU,EAASlY,EAAQ2sB,GAC9C,GAAIA,GACIA,EAAQzU,QAAQ9X,SAAW8X,EAAQ9X,QACdusB,EAAQzU,QAAQxQ,OAAM,CAAChJ,EAAQyB,IAEpDzB,IAAWwZ,EAAQ/X,MACCwsB,EAAQ3sB,OAAOI,SAAWJ,EAAOI,OACjD,OAAO,EAInB,OAAO,CACX,CFD+BysB,CAAiB3U,EAASlY,EAAQ2sB,GAC7D,GAAIC,EACA,OAAOD,EAAQG,WAEnB,MAAMpM,EHVH,SAAoCxI,EAASlY,GAKhD,OAJA6qB,GAAgC3S,EAASlY,GAGzBmoB,GADG0C,GAAgC3S,EAASlY,GAAQysB,KAAK,IAG7E,CGIoBM,CAA2B7U,EAASlY,GAC9CU,EAAM0qB,GAAoB1K,EAAS1gB,EAAOI,QAE5BM,EDdXxC,QAAQkuB,ICejB,MAAMY,EAAW,CACbC,mBAAennB,EACfpH,YAAQoH,EACRoS,UACAlY,SACA8sB,WAAYpsB,GAGhB,OADA4rB,GAASC,GAAYS,EACdtsB,CACX,CGxBO,SAASmnB,GAAK3P,KAAYlY,GAC7B,MAAMktB,EAAYtF,GAAa1P,EAASlY,GAClChD,EAAYgP,GAAmBmD,GAAY0B,MAGjD,OAFA7T,EAAUF,IAAMowB,EAChBA,EAAUlwB,UAAYA,EACfkwB,CACX,CACArF,GAAK9qB,IAAM,SAAUA,KAAQiD,GACzB,OAAO8nB,GAAU/qB,EAAKiD,EAC1B,ECEA,MAAMmtB,GAAc,GAQb,SAASC,GAAWjb,EAAK0B,EAAS3H,GACrC,MAAMmhB,EAAcF,GAAYpsB,WAAUusB,GAAUA,EAAOzZ,UAAYA,IACvE,GAAIwZ,GAAe,EAAG,CAClB,MAAM7oB,EAAU2oB,GAAYE,GAAa7oB,QACzCyR,GAAezR,EAASA,EAAQnI,QAAQE,QACxC4wB,GAAYlsB,OAAOosB,EAAa,GAEhCnjB,QAAQC,KAAK,8DAA+D,CAAE0J,WAClF,CAEA,IAAI7W,EAAY,IAAOuwB,EAAWrhB,GAClClP,EAAUiP,UAAYkD,GAAY0B,KAClC7T,EAAU8B,UAAYjC,EAAWQ,YAEjCL,EAAUkP,MAAQ,CAACA,GACnBlP,EAAUwwB,OAAQ,EAElB,MAAMnxB,EAkFV,SAAuBW,EAAWof,GAC9B,MAAM/f,EAAU,CACZyB,MAAOd,EACPshB,iBAAkB0C,GAClBxL,oBAAoB,EACpBlZ,YAAa,EACbC,YAAQuJ,GAENvJ,EAASH,EAAaC,GAG5B,OAFAE,EAAOggB,OAAS,CAAC,EACjBkR,GAAmBzwB,EAAWX,EAAS+f,GAChC/f,CACX,CA9FoBqxB,CAAc1wB,EAAW6W,GACnCtX,EAASF,EAAQE,OACvBuI,EAAUvI,EAAOwQ,OAAQ/I,EAAaC,aACtC,IAAIspB,EAAapb,EAAIjG,GACrB,MAAMyhB,SAAuBJ,GAAc3wB,EAAWuC,SACjDwuB,IACI5uB,EAAewuB,IAKhBhxB,EAAOwQ,OAAOmC,YAAc,CACxBG,OAAQ,CAACnD,GACTG,UAAW,CAACH,IAEhBlP,EAAUiP,UAAYshB,EAAWthB,UACjCjP,EAAU8B,UAAYyuB,EAAWzuB,UACjC9B,EAAUsT,QAAUid,EAAWjd,QAC/BtT,EAAYuwB,IAXZvwB,EAAUF,IAAMywB,EAChBA,EAAapb,IAarB,MAAMiO,EAAcnM,SAASC,eAAe,IAC5C9H,GAAKhL,KAAMpE,EAAUsT,SAAW,CAAE1K,SAAU5I,IAC5C,MAAMwH,EAAUopB,GAAW5wB,EAAWojB,EAAavM,EAASxX,EAASsxB,GAKrE,GAJApxB,EAAOixB,OAAQ,EACXG,IACAJ,EAAWzwB,IAAM0H,EAAQxH,UAAUF,MAElC+W,EACD,MAAM,IAAIzJ,MAAM,sDAAsDyJ,0BAI1EA,EAAQqB,QAAU,WACd,MAAMqH,EAAShgB,EAAOggB,OACtB,IAAK,MAAMJ,KAAaI,EAAQ,CAC5B,MAAMpe,EAAWoe,EAAOJ,GACxBtI,EAAQga,oBAAoB1R,EAAWhe,EAC3C,CACA5B,EAAOggB,OAAS,CAAC,IACftJ,GAASC,MACX,MAAM4a,EAAU7X,GAAezR,EAASjI,GAGxC,QAFE0W,GAASC,MACXC,KACO2a,CACX,IACE7a,GAASC,MACX,MAAM6a,EAUV,SAA4BvpB,EAASqP,EAAStX,EAAQS,EAAWmV,EAAKiO,GAClE,MAAM3Y,EAASgZ,GAAmBjc,EAAS,CAAEwS,MAAO,EAAGb,QAAS,GAAKtC,OAAS/N,GAC9EvJ,EAAO+L,OAAS9D,EAChBjI,EAAOwQ,OAASvI,EAChB,IAAI+L,EAASvT,EAAUuT,OACvB,GAAIvT,EAAU8B,YAAcjC,EAAWQ,YAAa,CAChD,MACMuI,EADOuM,EACSvM,SACtB2K,EAAS3K,EAAS2K,OAClB3K,EAAS4nB,OAAQ,CACrB,CAEA3Z,EAAQtD,OAASA,EACjBsD,EAAQhX,WAAaA,EACrBswB,GAAY/rB,KAAK,CAAEyS,UAASrP,YAC5B,MAAMupB,EAAc9Z,SAAS+Z,yBAC7BD,EAAYna,YAAYwM,GACxB,IAAK,MAAM6N,KAAWxmB,EAAO1K,IACzBmxB,GAAcD,EAASF,GAE3B,IAAK,MAAM/sB,KAAOyG,EAAOnF,KACrB2e,GAAoBjgB,GAExB,OAAO+sB,CACX,CAlCwBI,CAAmB3pB,EAASqP,EAAStX,EAAQS,EAAWmV,EAAKiO,GAIjF,QAHEnN,GAASC,MACXC,KACAU,EAAQD,YAAYma,GACb,CACHvpB,UACA4H,KAAI,GACJvP,WAAU,EAElB,CAuCA,SAAS4wB,GAAmBzwB,EAAWX,EAAS+f,GAC5C,MAAM7f,EAASF,EAAQE,OACjB+P,EAAauC,GAAe7R,EAAWX,GAK7C,OAJA4S,GAAqBjS,EAAWsP,EAAYA,GAC5CA,EAAW8P,WAAaA,EACxB7f,EAAO+L,OAAS/L,EAAO+L,QAAUgE,EACjC/P,EAAOwQ,OAAST,EACTA,CACX,CACO,SAASshB,GAAW5wB,EAAWojB,EAAahE,EAAY/f,EAASsxB,GACpEtxB,EAAQ+jB,YAAcA,EACtB,MAAM7jB,EAASF,EAAQE,OACjBiS,EAAajS,EAAOwQ,OACpBzE,EAAS/L,EAAO+L,OAKtB,GAJsBkG,IAAelG,GAEjCpD,EAAQsJ,EAAYxK,EAAaC,YAAaqE,EAAO1K,MAAO0K,EAAOhE,QAEnEtH,EAAU8B,YAAcjC,EAAWQ,YAAa,CAChD,MAAMoK,EAAUzK,EAAUsT,SAAW,CAAE1K,SAAU5I,GACjD,IAAK2wB,EAAe,CAChB,MAAMrhB,EAAamhB,GAAmBzwB,EAAWX,EAAS+f,GAE1D,OADAiI,GAAe/X,GACRA,CACX,CACA,MAAMnE,EAAaoG,GAAYvR,EAAWyK,EAAQ+G,GAElD,OADA6V,GAAelc,GACRA,CACX,CAEA,MACMA,GAAamI,EADHtT,EAAUsT,SACC9B,EAAYnS,GAEvC,OADAgoB,GAAelc,GACRA,CACX,CACA,SAAS+lB,GAAcnxB,EAAKgxB,GACpBhxB,EAAIiZ,YACJ+X,EAAYna,YAAY7W,EAAIiZ,YAE5BjZ,EAAIgZ,QACJgY,EAAYna,YAAY7W,EAAIgZ,OAEpC,CCjKO,MAAMqY,GAAM,CACfhB,WAAU,qBAAmB,iBAAe,GAC5C9I,cAAa,SAAO,I","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/subject/signal.function.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/alterProp.function.ts","webpack://taggedjs/./ts/tag/executeWrap.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/getSupport.function.ts","webpack://taggedjs/./ts/tag/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/paint.function.ts","webpack://taggedjs/./ts/updateBeforeTemplate.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/getChildTagsToDestroy.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/tag/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/tag/render/renderSupport.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/tag/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDomElements.function.ts","webpack://taggedjs/./ts/tag/buildBeforeElement.function.ts","webpack://taggedjs/./ts/tag/update/processTag.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/tag/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/update/processNewValue.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tag/update/updateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/tag/afterRender.function.ts","webpack://taggedjs/./ts/tag/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/interpolations/processSubscriptionUpdate.function.ts","webpack://taggedjs/./ts/interpolations/subscribeToTemplate.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/tag/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/tag/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/tag/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/restorePlaceholders.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(subject) {\n    ;\n    subject.renderCount = subject.renderCount || 0;\n    // ;(subject as SupportContextItem).renderCount = 0\n    return subject.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    subject: 'subject',\n    tagJsSubject: 'tagJsSubject',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","import { state } from '../state/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    return {\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                // Notify all subscribers\n                subscribers.forEach(callback => callback(newValue));\n            }\n        },\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    config.states[config.statesIndex] = setter;\n    const support = config.support;\n    support.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter((...args) => {\n        state(args);\n        return args;\n    });\n}\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const support = config.support;\n    const statesIndex = config.statesIndex;\n    const prevSupport = config.prevSupport;\n    const oldStates = prevSupport?.states[statesIndex];\n    const lastValues = [];\n    const regetter = (...args) => {\n        lastValues.push(args);\n        return args;\n    };\n    oldStates(regetter);\n    let index = 0;\n    const resetter = (...args) => {\n        // state(value) // fake call and do not care about result\n        // fake state() having been called\n        config.stateArray.push({\n            get: () => args,\n            defaultValue: args,\n        });\n        const lastValue = lastValues[index];\n        ++index;\n        return lastValue;\n    };\n    support.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nexport function initState(support, config) {\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.support = support;\n}\nexport function reState(support, config, prevState, prevStates) {\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = prevStates;\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.support = support;\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    for (let index = 0; index < support.states.length; ++index) {\n        let got;\n        const getter = support.states[index];\n        const setter = newestSupport.states[index];\n        getter((...x) => {\n            got = x;\n            return x;\n        });\n        setter(() => {\n            return got;\n        });\n    }\n    return;\n}\n/** @deprecated favor using syncSupports */\nexport function syncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        const oldValues = [];\n        const oldGetCallback = (...args) => {\n            oldValues.push(args);\n            return args;\n        };\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        let getIndex = 0;\n        // This is the \"get\" argument that will be called and all arguments are ignored\n        const newSetCallback = (..._) => {\n            return oldValues[getIndex++];\n        };\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.subject.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        syncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            syncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        syncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from '../subject/signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return values;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states(() => {\n        if (passed) {\n            setter((...values) => {\n                propStates2.value = values;\n                if (passes != passedOn) {\n                    return propStates2.value;\n                }\n                return values; // propStates2.value\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        setter(() => propStates2.value);\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(() => ({ stateDiff: 0, provider: undefined }));\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.subject.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        // find once, return same every time after\n        return state(() => {\n            // const memory = setUse.memory\n            const cm = constructor;\n            const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n            const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n            const providers = [];\n            let owner = {\n                ownerSupport: support.ownerSupport\n            };\n            while (owner.ownerSupport) {\n                const ownGlobal = owner.ownerSupport.subject.global;\n                const ownerProviders = ownGlobal.providers;\n                if (!ownerProviders) {\n                    owner = owner.ownerSupport; // cause reloop checking next parent\n                    continue;\n                }\n                const provider = ownerProviders.find(provider => {\n                    providers.push(provider);\n                    const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                    if (constructorMatch) {\n                        return true;\n                    }\n                });\n                if (provider) {\n                    const global = support.subject.global;\n                    const providers = global.providers = global.providers || [];\n                    providers.push(provider);\n                    provider.children.push(support);\n                    return provider.instance;\n                }\n                owner = owner.ownerSupport; // cause reloop checking next parent\n            }\n            const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n            console.warn(`${msg}. Available providers`, providers);\n            throw new Error(msg);\n        });\n    }\n};\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        propWatch,\n        props,\n        tagJsType: ValueTypes.templater,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { isInlineHtml, renderInlineHtml } from './tag/render/renderSupport.function.js';\nimport { renderExistingReadyTag } from './tag/render/renderExistingTag.function.js';\nimport { getSupportInCycle } from './tag/getSupportInCycle.function.js';\nimport { deepCompareDepth } from './tag/hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nimport { setUseMemory } from './state/index.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(prop => alterProp(prop, newSupport.ownerSupport, newSupport, depth));\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        return getPropWrap(value, ownerSupport);\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return wrap.toCall(...args);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n    wrap.toCall = function toCallRunner(...args) {\n        return callbackPropOwner(wrap.mem, args, ownerSupport);\n    };\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    const callbackResult = toCall(...callWith);\n    const run = function propCallbackProcessor() {\n        const global = newest.subject.global;\n        // are we in a rendering cycle? then its being called by alterProps\n        if (noCycle === false) {\n            const allMatched = global.locked === true;\n            if (allMatched) {\n                return callbackResult; // owner did not change\n            }\n        }\n        safeRenderSupport(newest, ownerSupport);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\nexport function safeRenderSupport(newest, ownerSupport) {\n    const subject = newest.subject;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        const result = renderInlineHtml(ownerSupport, newest);\n        // TODO: below maybe never true\n        /*\n        const global = subject.global as TagGlobal\n        if(global) {\n          delete global.locked\n        }\n        */\n        return result;\n    }\n    const global = subject.global;\n    global.locked = true;\n    renderExistingReadyTag(global.newest, newest, ownerSupport, subject);\n    delete global.locked;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    const config = setUseMemory.stateConfig;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // ++useSupport.subject.renderCount\n    return useSupport;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { clonePropsBy } from './clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, subject, castedProps) {\n    const baseSupport = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    // baseSupport.appSupport = baseSupport\n    const global = subject.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    return baseSupport;\n}\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    ;\n    support.state = [];\n    support.states = [];\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function getHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\nexport function getSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { cloneTagJsValue } from './cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { PropWatches } from './tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(x => cloneTagJsValue(x, shallowCompareDepth)),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(props => cloneTagJsValue(props, deepCompareDepth)),\n        castProps,\n    };\n}\n","import { castProps } from '../alterProp.function.js';\nimport { syncFunctionProps } from './update/updateExistingTagComponent.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { PropWatches } from './tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { getSupport } from './getSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = getSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { tags } from './tag.utils.js';\nimport { getTagWrap } from './getTagWrap.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        /*\n            if(!innerTagWrap.parentWrap) {\n              innerTagWrap.parentWrap = parentWrap as TagWrapper<unknown>\n            }\n        */\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\ntag.renderOnce = renderOnceFn;\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n/** deprecated */\n;\ntag.state = tagUseFn;\ntag.use = tagUseFn;\ntag.route = routeFn;\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\n;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.deepPropWatch = tag;\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n    },\n});\n// TODO: deprecate this\nObject.defineProperty(tag, 'state', {\n    set(renderFunction) {\n        ;\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        ;\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from './render/renderSupport.function.js';\nimport { PropWatches } from './tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, () => {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function hasSupportChanged(lastSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = lastSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, lastSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","export let paintRemoves = [];\nexport let paintContent = [];\nexport let setContent = [];\n/** array memory that runs and completes BEFORE paintInsertBefores array */\nexport let paintAppends = [];\n/** array memory that runs and completes AFTER paintAppends array */\nexport let paintInsertBefores = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0\n};\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    for (let index = paintRemoves.length - 1; index >= 0; --index) {\n        const toRemove = paintRemoves[index];\n        const parentNode = toRemove.parentNode;\n        parentNode.removeChild(toRemove);\n    }\n    for (const content of paintContent) {\n        content();\n    }\n    for (const [text, textNode] of setContent) {\n        textNode.textContent = text;\n    }\n    for (const now of paintAppends) {\n        now.relative.appendChild(now.element);\n    }\n    for (const { element, relative } of paintInsertBefores) {\n        relative.parentNode.insertBefore(element, relative);\n    }\n    paintRemoves = [];\n    paintContent = [];\n    paintAppends = [];\n    paintInsertBefores = [];\n    setContent = [];\n    for (const now of paintAfters) {\n        now();\n    }\n    paintAfters = [];\n}\n","import { paintInsertBefores } from './tag/paint.function.js';\nimport { empty } from './tag/ValueTypes.enum.js';\n// Function to update the value of x\nexport function updateBeforeTemplate(value, // value should be casted before calling here\nlastFirstChild) {\n    const textNode = document.createTextNode(value); // never innerHTML\n    paintInsertBefores.push({\n        element: textNode,\n        relative: lastFirstChild,\n    });\n    return textNode;\n}\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.subject.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.subject.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nexport function getChildTagsToDestroy(childTags) {\n    for (const child of childTags) {\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            getChildTagsToDestroy(lastArray.map(x => x.context));\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(iSub => iSub.unsubscribe());\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.context;\n        getChildTagsToDestroy(subTags);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.context;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { paint, painting, paintRemoves } from './paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(support, global, allPromises) {\n    const subject = support.subject;\n    const context = global.context;\n    // already set\n    // global.deleted = true\n    const destroys = global.destroys;\n    if (destroys) {\n        return processContextDestroys(destroys, global, allPromises);\n    }\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\n// Elements that have a destroy or ondestroy attribute\nfunction processContextDestroys(destroys, global, allPromises) {\n    const promises = [];\n    destroys.forEach(destroy => {\n        const maybePromise = destroy();\n        const isPromise = maybePromise instanceof Promise;\n        if (isPromise) {\n            promises.push(maybePromise);\n        }\n    });\n    if (promises.length) {\n        const lastPromise = Promise.all(promises)\n            .then(() => {\n            ++painting.locks;\n            // continue to remove\n            smartRemoveByContext(global.context, allPromises);\n            destroyClones(global);\n            --painting.locks;\n            paint();\n        });\n        // run destroy animations\n        allPromises.push(lastPromise);\n        return;\n    }\n    ++painting.locks;\n    smartRemoveByContext(global.context, allPromises);\n    destroyClones(global);\n    --painting.locks;\n    paint();\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.withinOwnerElement) {\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintRemoves.push(elm);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(oldest, subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    // const global = subject.global\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    htmlDomMeta.forEach(clone => {\n        const marker = clone.marker;\n        if (marker) {\n            paintRemoves.push(marker);\n        }\n        const dom = clone.domElement;\n        if (!dom) {\n            return;\n        }\n        paintRemoves.push(dom);\n    });\n    // htmlDomMeta.length = 0\n}\n","import { getChildTagsToDestroy } from './getChildTagsToDestroy.function.js';\nimport { smartRemoveKids } from './smartRemoveKids.function.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.subject;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.context;\n    getChildTagsToDestroy(context);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(support, global, promises);\n    return promises;\n}\n","import { paintRemoves } from '../paint.function.js';\nimport { destroySupport } from '../destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed, counts) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index].context;\n    if (lessLength) {\n        destroyArrayItem(prevContext, counts);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, counts, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, counts, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        // Intended to protect an array from adding and then immediately deleting\n        /*\n        // TODO: Does this code protect bad array keying?\n        if(prevContext.renderCount === 0) {\n          const newKey = newValueTag.arrayValue\n          console.warn('Possible array issue. Array is attempting to create/delete same items. Either html``.key is not unique or array changes with every render', {\n            oldKey,\n            newKey,\n            \n            prevValue: prevContext.value,\n            prevContext,\n          })\n    \n          paintAfters.push(() => {\n            destroyArrayItemByGlobal(prevContext.global, prevContext)\n            paintAfters.shift() // prevent endless recursion\n            paint()\n          })\n    \n          return 1\n        }\n        */\n        destroyArrayItem(prevContext, counts);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item, counts) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n    ++counts.removed;\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n    }\n    else {\n        const element = item.simpleValueElm;\n        delete item.simpleValueElm;\n        paintRemoves.push(element);\n    }\n}\n","// Functions in here are attached as ContextItem.checkValueChange\nimport { processUpdateRegularValue } from './update/processRegularValue.function.js';\nimport { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nimport { paintRemoves } from './paint.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        const lastArray = subject.lastArray;\n        destroyArray(subject, lastArray);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArray(subject, lastArray) {\n    const counts = { added: 0, removed: 0 };\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index], counts);\n    }\n    delete subject.lastArray;\n}\nexport function checkSimpleValueChange(newValue, subject) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, subject);\n        return -1; // no need to destroy, just update display\n    }\n    const elm = subject.simpleValueElm;\n    delete subject.simpleValueElm;\n    paintRemoves.push(elm);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { setContent } from '../paint.function.js';\nimport { checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    setContent.push([castedValue, oldClone]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, subject) {\n    subject.checkValueChange = checkSimpleValueChange;\n    const before = subject.placeholder;\n    const castedValue = castTextValue(value);\n    // Processing of regular values\n    subject.simpleValueElm = updateBeforeTemplate(castedValue, before);\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag; // || (support1 as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (tag0.tagJsType) {\n        case ValueTypes.dom: {\n            if (tag1?.tagJsType !== ValueTypes.dom) {\n                return false; // tag0 is not even same type\n            }\n            return isLikeDomTags(tag0, tag1);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(tag0, tag1, support0, support1);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${tag0.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(tag0, tag1) {\n    const domMeta0 = tag0.dom;\n    const domMeta1 = tag1.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(tag0, tag1, support0, // new\nsupport1) {\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    // strings1[index] === string // slower\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.templater.values || tag0.values;\n    const values1 = support1.templater.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { paintContent } from \"../../tag/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push(() => {\n        howToSetFirstInputValue(element, name, value);\n    });\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintAfters, paintContent } from \"../../tag/paint.function.js\";\n/** handles init, destroy, autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName, support, counts) {\n    switch (specialName) {\n        // case 'oninit' as any:\n        case 'init': {\n            const stagger = counts.added;\n            // run delayed after elements placed down\n            paintAfters.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                value(event); // call init/oninit\n            });\n            return;\n        }\n        case 'destroy': {\n            const stagger = ++counts.removed;\n            const global = support.subject.global;\n            global.destroys = global.destroys || [];\n            global.destroys.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                return value(event); // call destroy/ondestroy\n            });\n            return;\n        }\n        case 'autofocus':\n            paintAfters.push(() => element.focus());\n            return;\n        case 'autoselect':\n            paintAfters.push(() => element.select());\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push(() => element.style[names[1]] = value); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push(() => element.classList.add(name));\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push(() => element.classList.remove(name));\n    }\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.subject;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.subject;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../tag/render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(ownerSupport, newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { deepEqual } from '../../deepFunctions.js';\nimport { renderExistingReadyTag } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../hasSupportChanged.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(ownerSupport, support);\n        return result;\n    }\n    global.locked = true;\n    const subject = support.subject;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingReadyTag(global.newest, support, ownerSupport, subject);\n    delete global.locked;\n    return tag;\n}\nexport function renderInlineHtml(ownerSupport, support) {\n    const ownGlobal = ownerSupport.subject.global;\n    if (!ownGlobal || ownGlobal.deleted === true) {\n        return support;\n    }\n    // ??? new change\n    const newest = ownGlobal.newest || ownerSupport;\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(ownerSupport, templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (ownerSupport && selfPropChange) {\n        return true;\n    }\n    return false;\n}\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    /*\n    const noLength = nowProps && nowLen === 0 && latestLen === 0\n  \n    if(noLength) {\n      return false\n    }\n    */\n    return nowLen !== latestLen;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(x => x.support));\n    }\n    return prosWithChanges;\n}\n","import { paint, painting } from '../../tag/paint.function.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.subject.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise, isTagComponent } from '../../isInstance.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    const global = support.subject.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function (element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    subjectFunction.support = support;\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, bindTo, args) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const subject = component.subject;\n    const global = subject.global; // tag.subject.global as TagGlobal\n    global.locked = true; // prevent another render from re-rendering this tag\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    delete global.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.subject.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (isPromise(callbackResult)) {\n        const global0 = last.subject.global;\n        global0.locked = true;\n        return callbackResult.then(() => {\n            if (global.deleted === true) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            const global1 = last.subject.global;\n            delete global1.locked;\n            const tagsToUpdate = getUpTags(last);\n            renderTagUpdateArray(tagsToUpdate);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    for (const block of blocked) {\n        const lastResult = renderSupport(block);\n        global.newest = lastResult;\n    }\n    global.blocked = [];\n    return global.newest;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nconst actions = ['init', 'destroy']; // oninit ondestroy\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        if (isSpecial && actions.includes(attrName)) {\n            specialAttribute(attrName, value, element, attrName, support, counts);\n            return;\n        }\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial, support, counts);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.subject.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return true;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit': // when read in compile process\n        case 'init': // when read in realtime\n            return 'oninit';\n        case 'ondestroy': // when read in compile process\n        case 'destroy': // when read in realtime\n            return 'destroy';\n    }\n    return false;\n}\n","import { processAttributeEmit } from '../interpolations/attributes/processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../interpolations/attributes/updateAttribute.function.js';\nconst emptyCounts = { added: 0, removed: 0 };\nexport function processUpdateAttrContext(values, value, contextItem, ownerSupport) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        emptyCounts);\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, emptyCounts);\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../tag/paint.function.js';\nimport { isNoDisplayValue, processNameOnlyAttrValue } from './processAttribute.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { isFunction, isObject, isSubjectInstance } from '../../isInstance.js';\nimport { bindSubjectCallback } from './bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../tag/paint.function.js';\nimport { processDynamicNameValueAttribute, processNonDynamicAttr } from './processNameValueAttribute.function.js';\nimport { addOneContext, checkSimpleValueChange } from '../../tag/index.js';\nimport { processAttributeFunction } from './processAttributeCallback.function.js';\nimport { isSpecialAttr } from './isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from '../../tag/processUpdateAttrContext.function.js';\nimport { blankHandler } from '../optimizers/attachDomElements.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, attrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        // how to process value updates\n        contextItem.handler = (newValue, newValues) => processUpdateAttrContext(newValues, newValue, contextItem, support);\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        const contextItem = {\n            isAttr: true,\n            element,\n            attrName: attrName,\n            checkValueChange: checkSimpleValueChange,\n            withinOwnerElement: true,\n        };\n        context.push(contextItem);\n        const isSubject = isSubjectInstance(contextItem.value);\n        if (isSubject) {\n            return processNameValueAttributeAttrSubject(attrName, contextItem, element, support, howToSet, isSpecial, counts);\n        }\n        contextItem.handler = (newValue, newValues) => processUpdateAttrContext(newValues, newValue, contextItem, support);\n        /*\n        processNameOnlyAttrValue(\n          values,\n          newValue as any,\n          element as Element,\n          support,\n          howToSet as HowToSet,\n          context,\n          counts,\n        )\n        */\n        processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n        contextItem.value = value;\n        return;\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n/** Processor for flat attributes and object attributes */\nfunction processNameValueAttributeAttrSubject(attrName, contextItem, element, support, howToSet, isSpecial, counts) {\n    if (isSpecial) {\n        paintContent.push(function paintContent() {\n            element.removeAttribute(attrName);\n        });\n    }\n    const contextValueSubject = contextItem.value;\n    if (isSubjectInstance(contextValueSubject)) {\n        contextItem.handler = blankHandler;\n        const callback = function processAttrCallback(newAttrValue) {\n            processAttributeEmit(newAttrValue, attrName, contextItem, element, support, howToSet, isSpecial, counts);\n        };\n        //  Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        const global = contextItem.global;\n        const subs = global.subscriptions = global.subscriptions || [];\n        subs.push(sub);\n    }\n    processAttributeEmit(contextItem.value, attrName, contextItem, element, support, howToSet, isSpecial, counts);\n    return;\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special, // string name of special\n        support, counts);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push(function paintContentPush() {\n                element.removeAttribute(attrName);\n            });\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    const prevFun = subject.value;\n    if (prevFun && prevFun.tagFunction && prevFun.support) {\n        prevFun.tagFunction = newAttrValue;\n        prevFun.support = support;\n        return prevFun;\n    }\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\nexport function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nimport { howToSetFirstInputValue } from \"../attributes/howToSetInputValue.function.js\";\nimport { paintAppends, paintInsertBefores } from \"../../tag/paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { addOneContext } from \"../../tag/index.js\";\nimport { isSubjectInstance } from \"../../isInstance.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { updateExistingValue } from \"../../tag/update/updateExistingValue.function.js\";\nexport const blankHandler = () => undefined;\nconst someDiv = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore, subs = []) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push({\n            element: insertBefore,\n            relative: appendTo,\n        });\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, index, context, support, subs, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore, subs).dom;\n        }\n    }\n    return { subs, dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        node.at.forEach(attr => {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            processAttribute(values, name, domElement, support, \n            // howToSetInputValue, // maybe more performant for updates but not first renders\n            howToSetFirstInputValue, context, isSpecial, counts, value);\n        });\n    }\n    if (appendTo) {\n        paintAppends.push({\n            element: domElement,\n            relative: appendTo,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            element: domElement,\n            relative: insertBefore,\n        });\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    someDiv.innerHTML = string;\n    const domElement = textNode.domElement = document.createTextNode(someDiv.innerText);\n    if (owner) {\n        paintAppends.push({\n            element: domElement,\n            relative: owner,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            element: domElement,\n            relative: insertBefore,\n        });\n    }\n}\nfunction attachDynamicDom(value, index, context, support, subs, counts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push({\n            relative: appendTo,\n            element: marker,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            relative: insertBefore,\n            element: marker,\n        });\n    }\n    if (isSubjectInstance(value)) {\n        subs.push({\n            insertBefore: marker,\n            appendTo,\n            subject: value,\n            support, // ownerSupport,\n            counts,\n            contextItem,\n        });\n        contextItem.handler = blankHandler;\n        return;\n    }\n    // how to handle value updates\n    contextItem.handler = (newValue, _newValues, newSupport, newContextItem) => updateExistingValue(newContextItem, newValue, newSupport);\n    const global = support.subject.global;\n    global.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    const global2 = support.subject.global;\n    delete global2.locked;\n    contextItem.value = value;\n    return;\n}\n","import { attachDomElements } from '../interpolations/optimizers/attachDomElements.function.js';\nimport { checkSimpleValueChange } from './index.js';\nimport { getDomMeta } from './domMetaCollector.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.subject;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // ++global.renderCount\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const context = [];\n    const global = support.subject.global;\n    global.context = context;\n    const result = attachDomElements(domMeta, values, support, counts, context, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag; // || templater\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { getHtmlSupport } from '../getSupport.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\nsubject, // could be tag via result.tag\ncounts) {\n    const global = subject.global;\n    const support = global.newest;\n    support.ownerSupport = ownerSupport;\n    subject.checkValueChange = checkTagValueChange;\n    const ph = subject.placeholder;\n    const result = buildBeforeElement(support, counts, undefined, ph);\n    for (const sub of result.subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = getHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.context = [];\n    return support;\n}\n","export function processUpdateContext(support, context) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    while (index < len) {\n        processUpdateOneContext(values, index, context, support);\n        ++index;\n    }\n    return context;\n}\n/** returns boolean of did render */\nexport function processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport) {\n    const value = values[index];\n    // is something already there?\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (value === contextItem.value) {\n        return;\n    }\n    const handler = contextItem.handler;\n    handler(value, values, ownerSupport, contextItem);\n    contextItem.value = value;\n}\n","import { paint, painting } from './paint.function.js';\nimport { processUpdateContext } from './processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.subject.global;\n    const context = global.context;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const tempTag = (newerSupport.templater.tag || newerSupport.templater);\n    const values = newerSupport.templater.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { PropWatches } from '../tag.function.js';\nimport { getSupport } from '../getSupport.function.js';\nexport function processNewArrayValue(value, ownerSupport, contextItem) {\n    const tagJsType = value.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.templater: {\n                const templater = value;\n                const tag = templater.tag;\n                processNewTag(tag, ownerSupport, contextItem);\n                break;\n            }\n            case ValueTypes.tag:\n            case ValueTypes.dom:\n                processNewTag(value, ownerSupport, contextItem);\n                break;\n        }\n    }\n    return contextItem;\n}\nfunction processNewTag(value, ownerSupport, contextItem) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const tag = value;\n    let templater = tag.templater;\n    // TODO: Can this ever happen?\n    if (!templater) {\n        templater = getTemplaterResult(PropWatches.DEEP);\n        templater.tag = tag;\n        tag.templater = templater;\n    }\n    const global = contextItem.global = getNewGlobal(contextItem); // contextItem.global as SupportTagGlobal\n    const newest = global.newest = getSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    global.oldest = newest;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { paintAppends, paintInsertBefores } from '../paint.function.js';\nimport { processFirstSubjectValue } from './processFirstSubjectValue.function.js';\nimport { checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nimport { updateExistingValue } from './updateExistingValue.function.js';\nimport { processNewArrayValue } from './processNewValue.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed, counts);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous.context, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    return processAddTagArrayItem(item, runtimeInsertBefore, // thisInsert as any,\n    ownerSupport, counts, lastArray, appendTo);\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        updateExistingValue(itemSubject, value, ownerSupport);\n        return itemSubject;\n    }\n    const result = processAddTagArrayItem(value, runtimeInsertBefore, // thisInsert as any,\n    ownerSupport, counts, lastArray, appendTo);\n    return result;\n}\nfunction processAddTagArrayItem(value, before, // used during updates\nownerSupport, counts, lastArray, appendTo) {\n    const itemSubject = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        withinOwnerElement: false, // TODO: we need to pass down depth so we can answer this truthfully\n    };\n    counts.added = counts.added + 1; // index\n    const subPlaceholder = document.createTextNode('');\n    itemSubject.placeholder = subPlaceholder;\n    if (!appendTo) {\n        paintInsertBefores.push({\n            element: subPlaceholder,\n            relative: before,\n        });\n    }\n    processNewArrayValue(value, ownerSupport, itemSubject);\n    processFirstSubjectValue(value, itemSubject, ownerSupport, counts, appendTo);\n    // after processing\n    itemSubject.value = value;\n    // Added to previous array\n    lastArray.push({\n        context: itemSubject,\n        global: itemSubject.global,\n    });\n    if (appendTo) {\n        paintAppends.push({\n            element: subPlaceholder,\n            relative: appendTo,\n        });\n    }\n    return itemSubject;\n}\n","import { getFakeTemplater, newSupportByTemplater, processTag } from './processTag.function.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function.js';\nimport { BasicTypes, ValueTypes } from '../ValueTypes.enum.js';\nimport { updateSupportBy } from '../updateSupportBy.function.js';\nimport { isArray, isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processTagArray } from './processTagArray.js';\nimport { getSupport } from '../getSupport.function.js';\nconst fooCounts = { added: 0, removed: 0 };\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function updateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    // Have the context check itself (avoid having to detect old value)\n    const ignoreOrDestroyed = contextItem.checkValueChange(newValue, contextItem);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\nfunction updateToTag(value, contextItem, ownerSupport) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = getFakeTemplater();\n        tag.templater = templater;\n        templater.tag = tag;\n    }\n    const nowGlobal = (contextItem.global ? contextItem.global : getNewGlobal(contextItem));\n    nowGlobal.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    processTag(ownerSupport, contextItem, fooCounts);\n}\nfunction handleStillTag(lastSupport, subject, value, ownerSupport) {\n    const templater = value.templater || value;\n    const valueSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = lastSupport.subject;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\nexport function prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        processReplacementComponent(templater, contextItem, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    const support = getSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\nexport function updateContextItemBySupport(support, contextItem, value, ownerSupport) {\n    if (typeof (value) === BasicTypes.function) {\n        return;\n    }\n    handleStillTag(support, contextItem, value, ownerSupport);\n    return;\n}\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const tagJsType = newValue.tagJsType;\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            updateContextItemBySupport(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    switch (tagJsType) {\n        case ValueTypes.templater:\n            processTag(ownerSupport, contextItem, fooCounts);\n            return true;\n        // when value was not a Tag before\n        case ValueTypes.tag:\n        case ValueTypes.dom: {\n            updateToTag(newValue, contextItem, ownerSupport);\n            return true;\n        }\n    }\n    return false;\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { castProps } from '../../alterProp.function.js';\nimport { renderSupport } from '../render/renderSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { PropWatches } from '../tag.function.js';\nimport { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject) {\n    const global = subject.global;\n    const lastSupport = global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = support.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = support.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(lastSupport, support);\n    }\n    else if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(lastSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, support, lastSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (global.locked) {\n        global.blocked.push(support);\n        return;\n    }\n    renderSupport(support);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    if (maxDepth === 0) {\n        throw new Error('before here');\n    }\n    const global = lastSupport.subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.subject.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, lastSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = lastSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return lastSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(subject, templater, // new tag\nownerSupport) {\n    const global = subject.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(subject);\n    const newSupport = processReplacementComponent(templater, subject, ownerSupport, { added: 0, removed: 0 });\n    return newSupport;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/updateExistingValue.function.js';\nimport { paint, paintAfters } from './paint.function.js';\nexport function checkTagValueChange(newValue, contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        return false;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        return result === true ? -1 : false;\n    }\n    // A subject could have emitted twice in one render cycle\n    if (lastSupport.subject.renderCount === 0) {\n        delete contextItem.global;\n        contextItem.renderCount = 0;\n        paintAfters.push(() => {\n            destroySupport(lastSupport, global);\n            paintAfters.shift(); // prevent endless recursion\n            paint();\n        });\n        return 8; // never rendered\n    }\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n    return 8; // 'no-longer-tag'\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nimport { PropWatches } from '../tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from './checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.subject;\n    ++subject.renderCount;\n    // ++subject.global.renderCount\n    const config = setUseMemory.stateConfig;\n    delete config.support;\n    support.state = config.stateArray;\n    // support.states = config.states\n    setUseMemory.tagClosed$.next(ownerSupport);\n    checkStateMismatch(config, support);\n    subject.global.newest = support;\n}\n","import { executeWrap } from '../executeWrap.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { runAfterRender } from '../afterRender.function.js';\nimport { initState, reState } from '../../state/state.utils.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { getSupport } from '../getSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    const global = subject.global;\n    const oldRenderCount = subject.renderCount;\n    const prevState = prevSupport?.state;\n    const config = setUseMemory.stateConfig;\n    if (prevState) {\n        const prevStates = prevSupport.states;\n        config.prevSupport = prevSupport;\n        reState(newSupport, setUseMemory.stateConfig, prevState, prevStates);\n    }\n    else {\n        initState(newSupport, config);\n    }\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        // TODO: Not sure if useSupport could be replaced by just using \"newSupport\"\n        const useSupport = getSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        reSupport = executeWrap(templater, result, useSupport);\n        reSupport.states = newSupport.states;\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n        reSupport.states = newSupport.states;\n    }\n    runAfterRender(reSupport, ownerSupport);\n    // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n    // TODO: below most likely not needed\n    if (subject.renderCount > oldRenderCount + 1) {\n        return global.newest;\n    }\n    return reSupport;\n}\n","import { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { paintAppends, paintInsertBefores } from '../paint.function.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nexport function processNewSubjectTag(templater, ownerSupport, // owner\nsubject, // could be tag via result.tag\ncounts, appendTo, insertBefore) {\n    subject.checkValueChange = checkTagValueChange;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push({\n                    element: dom.marker,\n                    relative: appendTo, // ph.parentNode as Element,\n                });\n            }\n            else {\n                paintInsertBefores.push({\n                    element: dom.marker,\n                    relative: insertBefore, // ph.parentNode as Element,\n                });\n            }\n        }\n        if (dom.domElement) {\n            /*\n            paintAppends.push({\n              element: dom.domElement,\n              relative: appendTo as Element, // ph.parentNode as Element,\n            })\n            */\n            if (appendTo) {\n                paintAppends.push({\n                    element: dom.domElement,\n                    relative: appendTo, // ph.parentNode as Element,\n                });\n            }\n            else {\n                paintInsertBefores.push({\n                    element: dom.domElement,\n                    relative: insertBefore, // ph.parentNode as Element,\n                });\n            }\n        }\n    }\n    let index = -1;\n    const length = result.subs.length - 1;\n    //++painting.locks\n    while (index++ < length) {\n        const sub = result.subs[index];\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\n","import { checkArrayValueChange, checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { newSupportByTemplater, processTag, tagFakeTemplater } from './processTag.function.js';\nimport { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { oneRenderToSupport } from './oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { isArray, isSubjectInstance } from '../../isInstance.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return processFirstTagValue(tagJsType, contextItem, value, ownerSupport, counts, appendTo, insertBefore);\n    }\n    if (isArray(value)) {\n        processTagArray(contextItem, value, ownerSupport, counts, appendTo);\n        contextItem.checkValueChange = checkArrayValueChange;\n        return;\n    }\n    if (isSubjectInstance(value)) {\n        return; // will be subscribed to for value\n    }\n    processFirstRegularValue(value, contextItem, contextItem.placeholder);\n}\nfunction processFirstRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    const castedValue = castTextValue(value);\n    const clone = updateBeforeTemplate(castedValue, insertBefore);\n    subject.simpleValueElm = clone;\n    subject.checkValueChange = checkSimpleValueChange;\n}\nfunction processFirstTagValue(tagJsType, contextItem, value, ownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    ++contextItem.renderCount;\n    switch (tagJsType) {\n        // TODO: Do we ever get in here? because dom, tag, and component are covered below\n        case ValueTypes.templater:\n            contextItem.checkValueChange = checkTagValueChange;\n            if (appendTo) {\n                return processNewSubjectTag(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n            }\n            return processTag(ownerSupport, contextItem, counts);\n        case ValueTypes.dom:\n        case ValueTypes.tag: {\n            contextItem.checkValueChange = checkTagValueChange;\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = tagFakeTemplater(tag); // TODO: most likely a not needed performance hit\n            }\n            const global = getNewGlobal(contextItem);\n            if (appendTo) {\n                return processNewSubjectTag(templater, ownerSupport, contextItem, counts, appendTo, insertBefore);\n            }\n            global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n            contextItem.checkValueChange = checkTagValueChange;\n            return processTag(ownerSupport, contextItem, counts);\n        }\n        case ValueTypes.stateRender:\n        case ValueTypes.tagComponent: {\n            getNewGlobal(contextItem);\n            contextItem.checkValueChange = checkTagValueChange;\n            if (appendTo) {\n                const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n                return processResult;\n            }\n            const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n            return processResult;\n        }\n        case ValueTypes.renderOnce: {\n            getNewGlobal(contextItem);\n            const support = oneRenderToSupport(value, contextItem, ownerSupport);\n            renderTagOnly(support, undefined, contextItem, ownerSupport);\n            const result = processNewSubjectTag(support.templater, ownerSupport, contextItem, counts, appendTo, insertBefore);\n            contextItem.checkValueChange = checkTagValueChange;\n            return result;\n        }\n    }\n}\n","import { processFirstTagResult, processReplaceTagResult } from './processTagResult.function.js';\nimport { renderWithSupport } from '../render/renderWithSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { getSupport } from '../getSupport.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag\n    subject, ownerSupport);\n    processReplaceTagResult(support, counts, subject);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag   \n    subject, ownerSupport);\n    processFirstTagResult(support, counts, appendTo);\n    return support;\n}\n","import { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { paintAppends } from '../paint.function.js';\nimport { checkTagValueChange } from '../index.js';\nexport function processReplaceTagResult(support, counts, contextItem) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const ph = contextItem.placeholder;\n    const result = buildBeforeElement(support, counts, undefined, // element for append child\n    ph);\n    const subs = result.subs;\n    for (const sub of subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\nexport function processFirstTagResult(support, counts, appendTo) {\n    let appendIndex = paintAppends.length;\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.domElement,\n                relative: appendTo,\n            });\n        }\n        if (dom.marker) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.marker,\n                relative: appendTo,\n            });\n        }\n    }\n    const subs = result.subs;\n    for (const sub of subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\n","import { updateExistingValue } from '../tag/update/updateExistingValue.function.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { paint } from '../tag/paint.function.js';\n/** Used for values that are to subscribe to */\nexport function processSubUpdate(value, // Observable | Subject\ncontextItem, support) {\n    const global = support.subject.global;\n    const isSameValue = value === contextItem.value;\n    if (global.deleted || isSameValue) {\n        return; // same value emitted\n    }\n    updateExistingValue(contextItem, value, support);\n    if (!setUseMemory.stateConfig.support) {\n        paint();\n    }\n    return;\n}\n","import { processFirstSubjectValue } from '../tag/update/processFirstSubjectValue.function.js';\nimport { processSubUpdate } from './processSubscriptionUpdate.function.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { paint } from '../tag/paint.function.js';\n/** Used for when dynamic value is truly something to subscribe to */\nexport function subscribeToTemplate({ subject, support, counts, contextItem, appendTo, }) {\n    let onValue = function onSubValue(value) {\n        processFirstSubjectValue(value, contextItem, support, { ...counts }, syncRun ? appendTo : undefined);\n        if (!syncRun && !setUseMemory.stateConfig.support) {\n            paint();\n        }\n        // from now on just run update\n        onValue = function subscriptionUpdate(value) {\n            processSubUpdate(value, contextItem, support);\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    const callback = function subValueProcessor(value) {\n        onValue(value);\n    };\n    let syncRun = true;\n    const sub = subject.subscribe(callback);\n    contextItem.subject = subject;\n    syncRun = false;\n    const global = support.subject.global;\n    const subs = global.subscriptions = global.subscriptions || [];\n    subs.push(sub);\n    // contextItem.handler = blankHandler\n}\n","import { isSkipPropValue } from '../../alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy } from '../getChildTagsToDestroy.function.js';\nimport { getNewGlobal } from '../update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const global = lastSupport.subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.context);\n    softDestroyOne(lastSupport);\n    for (const child of tags) {\n        softDestroyOne(child);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(sub => sub.unsubscribe());\n    }\n    getNewGlobal(lastSupport.subject);\n}\nfunction softDestroyOne(child) {\n    const subject = child.subject;\n    const global = subject.global;\n    if (global.deleted === true) {\n        return;\n    }\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    subject.renderCount = 0; // TODO: most likely can be removed\n    smartRemoveKids(child, global, []);\n}\n","import { moveProviders } from '../update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.subject.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from '../update/processTag.function.js';\nimport { updateSupportBy } from '../updateSupportBy.function.js';\nconst fooCounts = { added: 0, removed: 0 };\n// TODO: This function is being called for 1st time renders WHEN renderCount === 1\nexport function renderExistingReadyTag(lastSupport, newSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const global = subject.global;\n    const { support, wasLikeTags } = renderWithSupport(newSupport, lastSupport, // renderCount <= 0 ? undefined : lastSupport\n    subject, ownerSupport);\n    if (wasLikeTags) {\n        updateSupportBy(global.oldest, support);\n        return support;\n    }\n    processTag(ownerSupport, subject, fooCounts);\n    return support;\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    const oldStateArray = oldState.stateArray;\n    const oldStates = oldState.states;\n    // const oldStates = support.states\n    return function trigger(...args) {\n        const callbackMaker = support.subject.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, toCallback, {\n                stateArray: oldStateArray,\n                states: oldStates,\n            }, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { syncSupports } from './syncStates.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, callback, oldState, // State,\n...args) {\n    const global = support.subject.global;\n    const newestSupport = global.newest;\n    // const state = newestSupport.state\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    syncSupports(newestSupport, support);\n    /*\n    syncStates(\n      state, // stateFrom\n      oldState.stateArray, // stateTo\n      newestSupport.states, // intoStates\n      oldState.states, // statesFrom\n    )\n    */\n    // run the callback\n    const maybePromise = callback(...args);\n    // OLDEST UPDATE NEWEST: send the oldest state changes into the newest\n    syncSupports(support, newestSupport);\n    /*\n    syncStates(\n      oldState.stateArray, // stateFrom\n      state, // stateTo\n      oldState.states, // intoStates\n      newestSupport.states, // statesFrom\n    )\n    */\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            syncSupports(support, newestSupport);\n            /*\n            syncStates(\n              oldState.stateArray,\n              state,\n              oldState.states,\n              newestSupport.states,\n            )\n            */\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    // oldState.support = support // TODO: should not be need and already set\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.subject.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    return tag;\n}\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    return tag;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/getDomTag.function.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                textVarMatches.forEach(textContent => {\n                    if (textContent.startsWith(variablePrefix)) {\n                        textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                });\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n            const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n            let attrValue = attrChoice;\n            if (attrName === undefined) {\n                continue;\n            }\n            const notEmpty = attrMatch[2] !== '';\n            const noValue = attrValue === undefined && notEmpty;\n            const lowerName = attrName.toLowerCase();\n            const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n            if (noValue) {\n                const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n                if (standAloneVar) {\n                    const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                    valuePositions.push(['at', valueName]);\n                    attributes.push([valueName]); // the name itself is dynamic\n                    continue;\n                }\n                const startMatched = attrMatch[0].startsWith(attrName);\n                const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n                if (standAloneAttr) {\n                    attributes.push([fixedName]);\n                    continue;\n                }\n                const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                attrValue = valueName;\n            }\n            if (!notEmpty) {\n                attrValue = attrMatch[2];\n            }\n            const attrSet = [fixedName, attrValue];\n            const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n            if (isSpecial) {\n                attrSet.push(isSpecial);\n            }\n            attributes.push(attrSet);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            textVarMatches.forEach(textContent => {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                return pushTextTo(currentElement, elements, textContent);\n            });\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postprocessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\nfunction postprocessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(part => part !== '');\n    return filteredParts;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/getDomTag.function.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nconst fragReplacer = /(^:tagvar\\d+:|:tagvar\\d+:$)/g;\nconst safeVar = '__safeTagVar';\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    htmlInterpolationToPlaceholders(strings, values);\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = sanitizePlaceholders(strings);\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction sanitizePlaceholders(fragments) {\n    return fragments.map(fragment => fragment.replace(fragReplacer, (match, index) => safeVar + index));\n}\nfunction addPlaceholders(strings, values) {\n    const results = strings.map((fragment, index) => {\n        if (index < values.length) {\n            return fragment + variablePrefix + index + variableSuffix;\n        }\n        return fragment;\n    });\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { variableSuffix, variablePrefix } from \"../../tag/getDomTag.function.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nconst placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, ...[{\n                    nn: 'text',\n                    v: wIndex\n                }]);\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    return attributes.map(attrSet => {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [{ tagJsVar: index }];\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [key, { tagJsVar: index }, isSpecial];\n            }\n        }\n        return attrSet;\n    });\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/getDomTag.function.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nexport const safeVar = '__safeTagVar';\nexport function restorePlaceholders(elements) {\n    elements.forEach(traverseAndRestore);\n}\nconst safeReplacer = /__safeTagVar(\\d+)/g;\nfunction traverseAndRestore(element) {\n    if (element.at) {\n        element.at = element.at ? element.at.map(attr => {\n            if (attr.length === 1) {\n                return attr;\n            }\n            const [, value] = attr;\n            if (typeof value === ImmutableTypes.string && value.startsWith(safeVar)) {\n                const index = parseInt(value.replace(safeVar, ''), 10);\n                attr[1] = variablePrefix + index + variableSuffix;\n            }\n            return attr;\n        }) : [];\n    }\n    if (element.ch) {\n        const children = element.ch;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.nn === 'text') {\n                if (typeof child.tc !== ImmutableTypes.string) {\n                    return;\n                }\n                child.tc = child.tc.replace(safeReplacer, (_match, index) => variablePrefix + index + variableSuffix);\n            }\n            traverseAndRestore(child);\n        }\n        // Remove empty children array\n        if (children.length === 0) {\n            delete element.ch;\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { restorePlaceholders } from '../interpolations/optimizers/restorePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    // Restore any sanitized placeholders in text nodes\n    restorePlaceholders(map);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(x => x.length);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { getStringTag, getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from './tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { getBaseSupport, upgradeBaseToSupport } from './getSupport.function.js';\nimport { subscribeToTemplate } from '../interpolations/subscribeToTemplate.function.js';\nimport { buildBeforeElement } from './buildBeforeElement.function.js';\nimport { tags } from './tag.utils.js';\nimport { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkTagValueChange } from './checkTagValueChange.function.js';\nconst appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.subject.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest, setUseMemory.stateConfig);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const placeholder = document.createTextNode('');\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nfunction registerTagElement(support, element, global, templater, app, placeholder) {\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    for (const sub of result.subs) {\n        subscribeToTemplate(sub);\n    }\n    return newFragment;\n}\nfunction getNewSubject(templater, appElement) {\n    const subject = {\n        value: templater,\n        checkValueChange: checkTagValueChange,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n    };\n    const global = getNewGlobal(subject);\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\nfunction loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const useSupport = global.newest;\n    const oldest = global.oldest;\n    const isFirstRender = useSupport === oldest;\n    if (!isFirstRender) {\n        reState(useSupport, setUseMemory.stateConfig, oldest.state, oldest.states);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = (templater.wrapper || { original: templater });\n        if (!isAppFunction) {\n            const newSupport = loadNewBaseSupport(templater, subject, appElement);\n            runAfterRender(newSupport);\n            return newSupport;\n        }\n        const nowSupport = executeWrap(templater, result, useSupport);\n        runAfterRender(nowSupport);\n        return nowSupport;\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(useSupport, subject);\n    runAfterRender(nowSupport);\n    return nowSupport;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","export * from './tag/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport * from './state/index.js';\nexport { states } from './state/states.function.js';\nexport * from './subject/index.js';\nexport * from './interpolations/index.js';\nexport * from './tag/getSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './interpolations/attributes/ElementTargetEvent.interface.js';\nimport { renderTagOnly } from './tag/render/renderTagOnly.function.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './tag/paint.function.js';\nexport { tagElement, renderWithSupport, renderSupport, renderTagOnly, paint, };\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","subject","renderCount","global","RouteQuery","_name","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","tagJsSubject","renderOnce","stateRender","version","Date","now","signal","initialValue","getSupportInCycle","state","Signal","value","subscribers","Set","newValue","forEach","callback","subscribe","add","unsub","delete","unsubscribe","isSimpleType","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","isObject","function","isPromise","isFunction","then","object","isArray","Array","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","values","setValue","x","index","length","item","subscription","clones","shift","subscriptions","map","getSubscription","countSubject","globalSubCount$","next","findIndex","sub","splice","removeSubFromArray","valSub","push","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","handler","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","args","arg","static","Subjective","_value","super","defineValueOn","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","defaultValue","setUseMemory","stateConfig","handlers","firstStatesHandler","setter","config","states","statesIndex","support","reStatesHandler","prevSupport","oldStates","lastValues","stateArray","initState","runFirstState","statesHandler","rearray","reState","prevState","prevStates","runRestate","StateEchoBack","getStateValue","checkValue","getCallbackValue","restate","initValue","original","tagClosed$","undefined","syncSupports","newestSupport","got","getter","syncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","oldGetCallback","stateFromTarget","getIndex","newSetCallback","_","watch","currentValues","setupWatch","defaultFinally","init","before","final","previous","pastResult","previousValues","result","every","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","oldest","letProp","propStates2","passes","passedOn","nowValues","passed","newWatch","oldestState","providers","create","constructMethod","stateDiffMemory","stateDiff","provider","oldStateCount","instance","owner","children","cm","compareTo","toString","inject","ownerSupport","ownerProviders","find","msg","name","console","warn","Error","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","deepClone","maxDepth","makeDeepClone","RegExp","clone","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","getTemplaterResult","propWatch","props","arrayValue","tags","castProps","newSupport","depth","checkProp","alterProp","already","mem","wrap","toCall","callWith","newest","noCycle","callbackResult","run","locked","isInline","isInlineHtml","renderInlineHtml","renderExistingReadyTag","safeRenderSupport","callbackPropOwner","assign","getPropWrap","deepCompareDepth","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","destroy$","executeWrap","useSupport","castedProps","originalFunction","cloneValueArray","cloneTagJsValue","getBaseSupport","baseSupport","appSupport","blocked","upgradeBaseToSupport","propsConfig","PropWatches","IMMUTABLE","latest","SHALLOW","shallowCompareDepth","clonePropsBy","getHtmlSupport","getSupport","getCastedProps","lastSupport","DEEP","preCastedProps","lastPropsConfig","lastCastProps","syncFunctionProps","tagCount","parentWrap","innerTagWrap","getTagWrap","wrapper","setUse","tagIndex","tagUseFn","hasPropChanges","pastCloneProps","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","len","pastProp","obEntries","subItem","objectItemMatches","use","route","_routeProps","app","_routeTag","deepPropWatch","immutableProps","watchProps","oneRenderFunction","renderFunction","pastValue","paintRemoves","paintContent","setContent","paintAppends","paintInsertBefores","paintAfters","painting","locks","paint","toRemove","parentNode","removeChild","content","text","textNode","textContent","relative","appendChild","element","insertBefore","updateBeforeTemplate","lastFirstChild","document","createTextNode","castTextValue","runBeforeDestroy","getChildTagsToDestroy","childTags","child","lastArray","context","iSubs","iSub","getChildTagsToSoftDestroy","subTags","smartRemoveKids","allPromises","destroys","promises","destroy","maybePromise","lastPromise","smartRemoveByContext","destroyClones","processContextDestroys","withinOwnerElement","destroyArray","elm","simpleValueElm","subGlobal","deleted","htmlDomMeta","marker","domElement","destroySupport","compareArrayItems","removed","counts","newLength","at","lessLength","prevContext","destroyArrayItem","oldKey","newValueTag","isDiff","runArrayItemDiff","destroyArrayItemByGlobal","checkArrayValueChange","added","checkSimpleValueChange","contextItem","castedValue","oldClone","processUpdateRegularValue","isLikeTags","support0","support1","templater0","templater1","tag0","tag1","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","values0","values1","valuesLengthsMatch","allVarsMatch","isLikeValueSets","isLikeStringTags","howToSetInputValue","howToSetFirstInputValue","setAttribute","removeAttribute","specialAttribute","specialName","stagger","target","focus","select","names","split","style","classList","remove","processSpecialClass","handleProviderChanges","tagsWithProvider","memory","cSubject","getTagsWithProvider","getUpTags","supports","inlineHtml","isComponent","continueUp","selfPropChange","nowProps","latestProps","hasPropsToOwnerChanged","checkRenderUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","noData","promiseNoData","bindSubjectCallback","subjectFunction","bindTo","component","apply","eventHandlerSupport","last","checkAfterCallbackPromise","renderCallbackSupport","afterTagCallback","runTagCallback","tagFunction","actions","processNonDynamicAttr","attrName","howToSet","isSpecial","addSupportEventListener","eventName","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","processAttributeFunction","newAttrValue","fun","isSpecialAttr","startsWith","specialAction","isSpecialAction","emptyCounts","processUpdateAttrContext","isNameOnly","attrValue","isNoDisplayValue","processNameOnlyAttrValue","updateNameOnlyAttrValue","processAttributeEmit","processAttribute","nameVar","getTagJsVar","addOneContext","isAttr","newValues","valueVar","checkValueChange","contextValueSubject","blankHandler","processNameValueAttributeAttrSubject","processTagCallbackFun","processDynamicNameValueAttribute","processAttributeSubjectValue","callbackFun","special","prevFun","attrPart","tagJsVar","someDiv","createElement","attachDomElements","nodes","appendTo","node","v","isNaN","attachDynamicDom","newNode","nn","attachDomText","attachDomElement","ch","attr","tc","innerHTML","innerText","placeholder","_newValues","newContextItem","updateExistingValue","processFirstSubjectValue","buildBeforeElement","domMeta","thisTag","getDomMeta","loadDomMeta","attachHtmlDomMeta","processTag","checkTagValueChange","subscribeToTemplate","getFakeTemplater","newSupportByTemplater","processUpdateOneContext","updateSupportBy","olderSupport","newerSupport","tempTag","updateSupportValuesBy","processUpdateContext","processNewTag","processTagArray","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","array","itemSubject","couldBeSame","processAddTagArrayItem","reviewPreviousArrayItem","subPlaceholder","processNewArrayValue","fooCounts","ignoreOrDestroyed","tryUpdateToTag","processNowRegularValue","prepareUpdateToComponent","processReplacementComponent","oldWrapper","newWrapper","isSameTag","skipComparing","oldestSupport","swapTags","hasChanged","newTemplater","hasSupportChanged","newProps","updateExistingTagComponent","updateContextItemBySupport","valueSupport","handleStillTag","updateToTag","isTag","oneRenderToSupport","checkStateMismatch","newStates","error","hint","throwStateMismatch","runAfterRender","renderTagOnly","oldRenderCount","reSupport","processNewSubjectTag","tagFakeTemplater","processResult","newPropsConfig","renderWithSupport","appendIndex","processFirstTagResult","processFirstSubjectComponent","processFirstTagValue","processFirstRegularValue","processSubUpdate","isSameValue","onValue","syncRun","processReplaceTagResult","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","lastTemplater","lastTag","isLikeTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","lastOwnerSupport","wasLikeTags","pop","ownGlobal","syncError","createTrigger","oldStateArray","finally","callbackStateUpdate","callbackMaker","onInit","onDestroy","variablePrefix","variableSuffix","getStringTag","html","getDomTag","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","splitByTagVar","pushTextTo","attributes","attrMatch","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","search","attrSet","pushTo","postprocessTagsInComments","inputString","filter","part","fragReplacer","safeVar","htmlInterpolationToPlaceholders","results","fragment","diff","balanceArrayByArrays","addPlaceholders","placeholderRegex","replacePlaceholders","valueCount","currentTail","loopTail","attrs","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","safeReplacer","traverseAndRestore","_match","lastRuns","stringId","Number","join","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","htmlInterpolationToDomMeta","template","interpolation","stringTag","appElements","tagElement","appElmIndex","appElm","templater2","isApp","loadNewBaseSupport","getNewSubject","isAppFunction","runWrapper","removeEventListener","toAwait","newFragment","createDocumentFragment","domItem","putOneDomDown","registerTagElement","hmr"],"sourceRoot":""}