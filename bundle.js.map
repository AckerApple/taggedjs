{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContext.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/checkSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribe.function.ts","webpack://taggedjs/./ts/subject/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/state/subscribeWith.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/render/afterRender.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/update/deleteSubContext.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/render/registerNewTagElement.function.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(subject) {\n    ;\n    subject.renderCount = subject.renderCount || 0;\n    // ;(subject as SupportContextItem).renderCount = 0\n    return subject.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return true;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit': // when read in compile process\n        case 'init': // when read in realtime\n            return 'oninit';\n        case 'ondestroy': // when read in compile process\n        case 'destroy': // when read in realtime\n            return 'destroy';\n    }\n    return false;\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\n/*\nfunction sanitizePlaceholders(fragments: string[]) {\n  return fragments.map(santizeFragment)\n}\n\nfunction santizeFragment(fragment: string) {\n  return fragment.replace(\n    fragReplacer,\n    (match, index) => safeVar + index)\n}\n*/\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    // subject: 'subject',\n    // tagJsSubject: 'tagJsSubject',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push([howToSetFirstInputValue, [element, name, value]]);\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles init, destroy, autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName, support, counts) {\n    switch (specialName) {\n        case 'init': { // aka oninit\n            const stagger = counts.added++;\n            // run delayed after elements placed down\n            paintAfters.push([paintSpecialAttribute, [element, stagger, value]]);\n            return;\n        }\n        case 'destroy': { // aka ondestroy\n            const stagger = counts.removed++;\n            const global = support.subject.global;\n            global.destroys = global.destroys || [];\n            global.destroys.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                return value(event); // call destroy/ondestroy\n            });\n            return;\n        }\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value;\n    element.style.setProperty(smallName, value);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\nfunction paintSpecialAttribute(element, stagger, value) {\n    const event = {\n        target: element,\n        stagger,\n    };\n    value(event); // call init/oninit\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.subject.global.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nexport function initState(support, config) {\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.support = support;\n}\nexport function reState(newSupport, prevSupport, config, prevState) {\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","import { BasicTypes } from \"../index.js\";\nimport { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintRemover } from \"../render/paint.function.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInit: processSimpleValueInit,\n        checkValueChange: checkSimpleValueChange,\n        delete: deleteSimpleValue,\n    };\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo, insertBefore) {\n    // value = value.value\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, (x) => {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(contextItem) {\n    const elm = contextItem.simpleValueElm;\n    delete contextItem.simpleValueElm;\n    delete contextItem.tagJsVar;\n    // is it being destroyed before it was even built?\n    if (contextItem.paint !== undefined) {\n        const paintIndex = paintCommands.findIndex(paint => paint === contextItem.paint);\n        paintCommands.splice(paintIndex, 1);\n        return;\n    }\n    paintCommands.push([paintRemover, [elm]]);\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return -1; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    setContent.push([castedValue, oldClone]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, (x) => {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.subject.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.subject.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContext(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContext(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.delete(child, ownerSupport);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.context;\n        // recurse\n        destroyContext(subTags, support);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.context;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { paint, paintCommands, painting, paintRemover } from '../render/paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.context;\n    // already set\n    // global.deleted = true\n    const destroys = global.destroys;\n    if (destroys) {\n        return processContextDestroys(destroys, global, allPromises);\n    }\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\nconst promises = [];\nfunction destroyCall(destroy) {\n    const maybePromise = destroy();\n    const isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        promises.push(maybePromise);\n    }\n}\n// Elements that have a destroy or ondestroy attribute\nfunction processContextDestroys(destroys, global, allPromises) {\n    promises.length = 0;\n    destroys.forEach(destroyCall);\n    if (promises.length) {\n        const lastPromise = Promise.all(promises)\n            .then(() => {\n            ++painting.locks;\n            // continue to remove\n            smartRemoveByContext(global.context, allPromises);\n            destroyClones(global);\n            --painting.locks;\n            paint();\n        });\n        // run destroy animations\n        allPromises.push(lastPromise);\n        return;\n    }\n    ++painting.locks;\n    smartRemoveByContext(global.context, allPromises);\n    destroyClones(global);\n    --painting.locks;\n    paint();\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.withinOwnerElement) {\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintCommands.push([paintRemover, [elm]]);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    htmlDomMeta.forEach(destroyClone);\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        paintCommands.push([paintRemover, [marker]]);\n    }\n    const dom = clone.domElement;\n    if (!dom) {\n        return;\n    }\n    paintCommands.push([paintRemover, [dom]]);\n}\n","import { destroyContext } from '../tag/destroyContext.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.subject;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.context;\n    destroyContext(context, support);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nimport { destroySupport } from '../../render/destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    const element = item.simpleValueElm;\n    delete item.simpleValueElm;\n    paintCommands.push([paintRemover, [element]]);\n}\n","import { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContextItem(subject);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArrayContextItem(subject) {\n    const lastArray = subject.lastArray;\n    destroyArray(subject, lastArray);\n}\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, subject, castedProps) {\n    const baseSupport = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    // baseSupport.appSupport = baseSupport\n    const global = subject.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\nownerSupport, contextItem, _values, counts) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport, counts);\n}\nexport function prepareUpdateToComponent(templater, contextItem, ownerSupport, counts) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, counts, undefined, // appendTo,\n        contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject) {\n    const global = subject.global;\n    const lastSupport = global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = support.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = support.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(lastSupport, support);\n    }\n    else if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(lastSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, support, lastSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (global.locked) {\n        global.blocked.push(support);\n        return;\n    }\n    renderSupport(support);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = lastSupport.subject;\n    const global = subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.subject.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, lastSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = lastSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return lastSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n    contextItem.placeholder);\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(lastSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = lastSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, lastSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","import { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nexport function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const tagJsVar = valueToTagJsVar(value);\n    contextItem.tagJsVar = tagJsVar;\n    return tagJsVar.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nimport { tagValueUpdateHandler } from \"../../tag/update/tagValueUpdateHandler.function.js\";\nexport function domProcessContextItem(value, support, contextItem, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    contextItem.handler = tagValueUpdateHandler;\n    const global = support.subject.global;\n    global.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    const global2 = support.subject.global;\n    delete global2.locked;\n    contextItem.value = value;\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = {\n        value,\n        withinOwnerElement: false,\n        placeholder: element,\n    };\n    if (!appendTo) {\n        paintCommands.push([paintBefore, [insertBefore, element]]);\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            // 👁️ COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, ownerSupport, itemSubject, undefined, counts);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n","import { checkArrayValueChange, destroyArrayContextItem } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/processTagArray.js';\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInit: processArrayInit,\n        checkValueChange: checkArrayValueChange,\n        delete: destroyArrayContextItem,\n    };\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, counts, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","import { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\nexport function processUpdateContext(support, context) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    const counts = { added: 0, removed: 0 };\n    while (index < len) {\n        processUpdateOneContext(values, index, context, support, counts);\n        ++index;\n    }\n    return context;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport, counts) {\n    const value = values[index];\n    // is something already there?\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (value === contextItem.value) {\n        return;\n    }\n    const handler = contextItem.handler;\n    handler(value, ownerSupport, contextItem, values, counts);\n    contextItem.value = value;\n    contextItem.tagJsVar = valueToTagJsVar(value);\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.subject.global;\n    const context = global.context;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { prepareUpdateToComponent } from './tagValueUpdateHandler.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport, counts) {\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport, counts);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, counts, undefined, // appendTo,\n    contextItem.placeholder);\n    return true;\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(lastSupport, subject, value, ownerSupport) {\n    const templater = value.templater || value;\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = lastSupport.subject;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, counts);\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport, counts) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.checkValueChange(newValue, contextItem, counts);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nexport function checkSubContext(newValue, ownerSupport, contextItem, _values, counts) {\n    if (!newValue || !newValue.tagJsType || newValue.tagJsType !== ValueTypes.subscribe) {\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.delete(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, ownerSupport, 99, counts);\n        return 99;\n    }\n    const subscription = contextItem.subContext;\n    if (!subscription.hasEmitted) {\n        return -1;\n    }\n    subscription.callback = newValue.callback;\n    subscription.valueHandler(subscription.lastValue);\n    return -1;\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore) {\n    subContext.hasEmitted = true;\n    subContext.contextItem = createAndProcessContextItem(value, ownerSupport, counts, insertBefore);\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { deleteSubContext } from './deleteSubContext.function.js';\nimport { checkSubContext } from './checkSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nexport function setupSubscribe(observable, contextItem, ownerSupport, counts, callback, appendTo, insertBeforeOriginal) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = setupSubscribeCallbackProcessor(observable, ownerSupport, counts, insertBefore, callback);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    contextItem.handler = checkSubContext;\n    return subContext;\n}\nexport function setupSubscribeCallbackProcessor(observable, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore, callback) {\n    const component = getSupportWithState(ownerSupport);\n    let onValue = function onSubValue(value) {\n        onFirstSubContext(value, subContext, ownerSupport, counts, insertBefore);\n        // from now on just run update\n        onValue = function subscriptionUpdate(value) {\n            forceUpdateExistingValue(subContext.contextItem, value, ownerSupport, { added: 0, removed: 0 });\n            if (!syncRun && !setUseMemory.stateConfig.support) {\n                paint();\n            }\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    function valueHandler(value) {\n        subContext.lastValue = value;\n        const newComponent = component.subject.global.newest;\n        syncSupports(newComponent, component);\n        if (subContext.callback) {\n            value = subContext.callback(value);\n        }\n        onValue(value);\n    }\n    let syncRun = true;\n    const subContext = {\n        valueHandler,\n        callback,\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    subContext.subscription = observable.subscribe(valueHandler);\n    syncRun = false;\n    return subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.subscription.unsubscribe();\n    return deleteSubContext(contextItem, ownerSupport);\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    return setupSubscribe(value.Observable, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSubscribeWith(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    const observable = value.Observable;\n    const subscription = setupSubscribe(observable, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n    if (!subscription.hasEmitted) {\n        subscription.valueHandler((observable.value || value.withDefault));\n    }\n    return subscription;\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, appendTo) {\n    setupSubscribe(value, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { state } from '../state/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                // Notify all subscribers\n                subscribers.forEach(callback => callback(newValue));\n            }\n        },\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.subject.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from '../subject/signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.subject.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const ownGlobal = owner.ownerSupport.subject.global;\n            const ownerProviders = ownGlobal.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const global = support.subject.global;\n                const providers = global.providers = global.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.subject.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.subject.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    // OLDEST UPDATE NEWEST: send the oldest state changes into the newest\n    //syncStatesArray(oldStates, newestSupport.states)\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            // syncStatesArray(oldStates, newestSupport.states)\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.subject.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        delete: deleteAndUnsubscribe,\n        checkValueChange: function subscribeDoNothing() {\n            console.debug('weird to be here');\n            return -1;\n        },\n        Observable,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n    };\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribeWith,\n        delete: deleteAndUnsubscribe,\n        checkValueChange: function subscribeDoNothing() {\n            return -1;\n        },\n        Observable,\n        callback,\n        withDefault,\n        states: getSupportWithState(getSupportInCycle()).states,\n    };\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag; // || (support1 as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (tag0.tagJsType) {\n        case ValueTypes.dom: {\n            if (tag1?.tagJsType !== ValueTypes.dom) {\n                return false; // tag0 is not even same type\n            }\n            return isLikeDomTags(tag0, tag1);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(tag0, tag1, support0, support1);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${tag0.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(tag0, tag1) {\n    const domMeta0 = tag0.dom;\n    const domMeta1 = tag1.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(tag0, tag1, support0, // new\nsupport1) {\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.templater.values || tag0.values;\n    const values1 = support1.templater.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nexport function checkTagValueChange(newValue, contextItem, counts) {\n    const global = contextItem.global;\n    if (!global) {\n        return 663; // its not a tag this time\n    }\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        return 77; // always cause a redraw of static tags (was false)\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return -1;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destroySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.subject;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const context = [];\n    const global = support.subject.global;\n    global.context = context;\n    const result = attachDomElements(domMeta, values, support, counts, context, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\nsubject, // could be tag via result.tag\ncounts) {\n    const global = subject.global;\n    const support = global.newest;\n    support.ownerSupport = ownerSupport;\n    const ph = subject.placeholder;\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.context = [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker]]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement]]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem, counts);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingReadyTag } from '../../render/renderExistingTag.function.js';\nimport { getSupportInCycle } from '../getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(function eachCastProp(prop) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, depth);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const global = newest.subject.global;\n        if (!global || global.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest, ownerSupport);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\nexport function safeRenderSupport(newest, ownerSupport) {\n    const subject = newest.subject;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        const result = renderInlineHtml(ownerSupport, newest);\n        return result;\n    }\n    const global = subject.global;\n    global.locked = true;\n    renderExistingReadyTag(global.newest, newest, ownerSupport, subject);\n    delete global.locked;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    config.support = useSupport;\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from '../tag/checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.subject;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n","import { executeWrap } from './executeWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    runBeforeRender(newSupport, prevSupport);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    return reSupport;\n}\nfunction runBeforeRender(newSupport, prevSupport) {\n    const prevState = prevSupport?.state;\n    const config = setUseMemory.stateConfig;\n    if (prevState) {\n        reState(newSupport, prevSupport, setUseMemory.stateConfig, prevState);\n        return;\n    }\n    initState(newSupport, config);\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem, ownerSupport);\n    const result = processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    return result;\n}\n","import { processFirstTagResult, processReplaceTagResult } from './processTagResult.function.js';\nimport { renderWithSupport } from '../../render/renderWithSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag\n    subject, ownerSupport);\n    processReplaceTagResult(support, counts, subject);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag   \n    subject, ownerSupport);\n    processFirstTagResult(support, counts, appendTo);\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processReplaceTagResult(support, counts, contextItem) {\n    const ph = contextItem.placeholder;\n    buildBeforeElement(support, counts, undefined, // element for append child\n    ph);\n    return support;\n}\nexport function processFirstTagResult(support, counts, appendTo) {\n    let appendIndex = paintAppends.length;\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.splice(appendIndex++, 0, [paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.splice(appendIndex++, 0, [paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../tag/checkTagValueChange.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.delete = destroySupportByContextItem;\n        oneRenderFunction.checkValueChange = function renderOnceNeverChanges() {\n            return -1;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.checkValueChange = checkTagValueChange;\n        renderFunction.delete = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from '../render/renderSupport.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContext.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.subject;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.context);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.subject.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.subject.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\n// TODO: This function is being called for 1st time renders WHEN renderCount === 1\nexport function renderExistingReadyTag(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const global = subject.global;\n    const { support, wasLikeTags } = renderWithSupport(newSupport, lastSupport, // renderCount <= 0 ? undefined : lastSupport\n    subject, ownerSupport);\n    if (wasLikeTags) {\n        updateSupportBy(global.oldest, support);\n        return support;\n    }\n    processTag(ownerSupport, subject, { added: 0, removed: 0 });\n    return support;\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { renderExistingReadyTag } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../tag/hasSupportChanged.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(ownerSupport, support);\n        return result;\n    }\n    global.locked = true;\n    const subject = support.subject;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingReadyTag(global.newest, support, ownerSupport, subject);\n    delete global.locked;\n    return tag;\n}\nexport function renderInlineHtml(ownerSupport, support) {\n    const ownGlobal = ownerSupport.subject.global;\n    if (!ownGlobal || ownGlobal.deleted === true) {\n        return support;\n    }\n    // ??? new change\n    const newest = ownGlobal.newest || ownerSupport;\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(ownerSupport, templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (ownerSupport && selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    /*\n    const noLength = nowProps && nowLen === 0 && latestLen === 0\n  \n    if(noLength) {\n      return false\n    }\n    */\n    return nowLen !== latestLen;\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.subject;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.subject;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(ownerSupport, newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.subject.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    const global = support.subject.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function (element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    const component = getSupportWithState(support);\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    const states = component.states; // ?.[0]\n    subjectFunction.states = states;\n    // subjectFunction.states = [...states]\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, states, bindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.subject;\n    const global = subject.global; // tag.subject.global as TagGlobal\n    global.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete global.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.subject.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (isPromise(callbackResult)) {\n        const global0 = last.subject.global;\n        global0.locked = true;\n        return callbackResult.then(() => {\n            if (global.deleted === true) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            const global1 = last.subject.global;\n            delete global1.locked;\n            const tagsToUpdate = getUpTags(last);\n            renderTagUpdateArray(tagsToUpdate);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    for (const block of blocked) {\n        const lastResult = renderSupport(block);\n        global.newest = lastResult;\n    }\n    global.blocked = [];\n    return global.newest;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from '../../render/attributes/processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nconst actions = ['init', 'destroy']; // oninit ondestroy\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    // contextItem.attrName = attrName\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        if (isSpecial && actions.includes(attrName)) {\n            specialAttribute(attrName, value, element, attrName, support, counts);\n            return;\n        }\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial, support, counts);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.subject.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processNameOnlyAttrValue } from '../../render/attributes/processAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateAttribute.function.js';\nexport function processUpdateAttrContext(value, ownerSupport, contextItem, values) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        { added: 0, removed: 0 });\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, { added: 0, removed: 0 });\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { addOneContext } from '../index.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, // all the variables inside html``\nattrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        // how to process value updates\n        contextItem.handler = processUpdateAttrContext;\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, context, howToSet, support, counts, values);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, context, howToSet, support, counts, isSpecial);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special, // string name of special\n        support, counts);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, values) {\n    const startIndex = context.length;\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = context.length;\n            const contextItem = {\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n            };\n            contextItem.handler = (value, newSupport, contextItem, newValues) => {\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            context.push(contextItem);\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, isSpecial) {\n    const contextItem = {\n        isAttr: true,\n        element,\n        attrName,\n        withinOwnerElement: true,\n    };\n    context.push(contextItem);\n    contextItem.handler = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n    contextItem.value = value;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, marker]]);\n    }\n    domProcessContextItem(value, support, contextItem, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { howToSetFirstInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { paintAppend, paintAppendElementString, paintAppends, paintBefore, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nexport const blankHandler = function () {\n    return undefined;\n};\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, context, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        for (const attr of node.at) {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            processAttribute(values, name, domElement, support, howToSetFirstInputValue, context, isSpecial, counts, value);\n        }\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement]]);\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, (elm) => textNode.domElement = elm]]);\n    }\n    else {\n        paintCommands.push([paintBeforeElementString, [insertBefore, string, (elm) => textNode.domElement = elm]]);\n    }\n}\n","import { blankHandler } from \"./dom/attachDomElements.function.js\";\nexport let paintCommands = [];\nexport let paintContent = [];\nexport let setContent = [];\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0\n};\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    for (const [text, textNode] of setContent) {\n        textNode.textContent = text;\n    }\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n    paintReset();\n    for (const content of paintAfters) {\n        content[0](...content[1]);\n    }\n    paintAfters = [];\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n    setContent = [];\n}\nexport function paintRemover(element) {\n    const parentNode = element.parentNode;\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element) {\n    relative.parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst someDiv = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    someDiv.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(someDiv.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    someDiv.innerHTML = text;\n    const textElm = document.createTextNode(someDiv.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    someDiv.innerHTML = text;\n    const textElm = document.createTextNode(someDiv.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","import { paintCommands, paintRemover } from '../../render/paint.function.js';\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nexport function deleteSubContext(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.deleted = true;\n    delete contextItem.subContext;\n    const appendMarker = subscription.appendMarker;\n    if (appendMarker) {\n        paintCommands.push([paintRemover, [appendMarker]]);\n        delete subscription.appendMarker;\n    }\n    delete contextItem.delete;\n    contextItem.handler = tagValueUpdateHandler;\n    if (!subscription.hasEmitted) {\n        return;\n    }\n    const subContextItem = subscription.contextItem;\n    const tagJsVar = subContextItem.tagJsVar;\n    tagJsVar.delete(subContextItem, ownerSupport);\n    return 77;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem, counts);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nfunction processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    counts, appendTo, insertBefore);\n    contextItem.handler = (value, newSupport, contextItem, _values, counts) => {\n        forceUpdateExistingValue(contextItem, value?.outerHTML || value, newSupport, counts);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.checkValueChange = function outerCheckValueChange(newValue, contextItem, counts) {\n        return checkOuterTagValueChange(newValue, contextItem, counts);\n    };\n}\nfunction checkOuterTagValueChange(newValue, contextItem, counts) {\n    return checkTagValueChange(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem, // subContext.contextItem as any,\n    counts);\n}\n/** When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getStringTag, getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nexport function registerTagElement(support, element, global, templater, app, placeholder) {\n    console.debug('🏷️ Building element into tag...', { element, app });\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    console.debug('🏷️ Element Tag DOM built ✅');\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { setUseMemory } from '../index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterRender } from '../render/afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reState } from '../state/state.utils.js';\nexport function renderTagElement(app, global, templater, templater2, element, subject, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        setUseMemory.stateConfig, oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.subject.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest, setUseMemory.stateConfig);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    return renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n}\nfunction getNewSubject(templater, appElement) {\n    const subject = {\n        value: templater,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        tagJsVar: {\n            tagJsType: 'templater',\n            checkValueChange: checkTagValueChange,\n            delete: destroySupportByContextItem,\n            processInit: function appDoNothing() {\n                console.debug('do nothing app function');\n            }\n        }\n    };\n    const global = getNewGlobal(subject);\n    // for click events and such read at a higher level\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\n","import { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/alterProp.function.js\";\n/** Used to call a function that belongs to a calling tag */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        const ownerGlobal = ownerSupport.subject.global;\n        const newestOwner = ownerGlobal.newest;\n        // sync the new states to the old before the old does any processing\n        syncStatesArray(newestOwner.states, ownerSupport.states);\n        const c = callback(...args); // call the latest callback\n        // sync the old states to the new\n        syncStatesArray(ownerSupport.states, newestOwner.states);\n        // now render the owner\n        const newestOwnerOwner = newestOwner.ownerSupport;\n        safeRenderSupport(newestOwner, newestOwnerOwner.subject.global.newest);\n        return c;\n    };\n}\n","import { deleteSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, newSupport, contextItem, _values, counts) {\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport, counts);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    contextItem.subContext = {};\n    contextItem.handler = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, counts, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, counts, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, counts, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        processInit: processInnerHTML,\n        delete: deleteSubContext,\n        checkValueChange: () => console.debug('weird innerHTML check'),\n    };\n}\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { renderTagOnly } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","subject","renderCount","global","RouteQuery","_name","variablePrefix","variableSuffix","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","placeholderRegex","RegExp","getTagVarIndex","value","search","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","length","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","index","textContent","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","pop","attributes","attrMatch","parseAttrString","element","nn","at","ch","push","textNode","pushTo","tc","postProcessTagsInComments","inputString","split","filter","notEmptyStringMapper","part","attrValue","undefined","notEmpty","noValue","lowerName","toLowerCase","fixedName","eventName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","x","forEach","isSpecial","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","strings","values","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","join","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","subscribe","signal","renderOnce","stateRender","version","Date","now","replacePlaceholders","valueCount","currentTail","i","loopTail","attrs","processAttributes","children","innerLoopTail","examineChild","child","textChild","string","secondMatch","wIndex","parseInt","isNaN","varContent","after","splice","v","lastIndex","mapped","tagJsVar","lengthMapper","lastRuns","getDomMeta","stringId","array","map","Number","getStringsId","lastRun","matches","every","isLastRunMatched","domMetaMap","template","interpolation","howToSetInputValue","name","paintContent","howToSetFirstInputValue","setAttribute","removeAttribute","specialAttribute","specialName","support","counts","stagger","added","paintAfters","paintSpecialAttribute","removed","destroys","target","autofocus","autoselect","names","paintStyle","shift","classListAdd","classListRemove","processSpecialClass","Error","smallName","style","setProperty","classList","add","remove","select","focus","isSimpleType","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","isObject","function","isPromise","isFunction","then","object","isArray","Array","deepClone","maxDepth","makeDeepClone","clone","create","getPrototypeOf","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","getSupportInCycle","setUseMemory","stateConfig","getSupportWithState","component","ownerSupport","newest","returnArgs","args","firstStatesHandler","setter","config","states","statesIndex","reStatesHandler","oldStates","prevSupport","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","stateArray","reState","newSupport","prevState","runRestate","StateEchoBack","getStateValue","state","callback","defaultValue","checkValue","getCallbackValue","restate","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","setValue","item","subscription","clones","subscriptions","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","syncStatesArray","from","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","castTextValue","getSimpleTagVar","processInit","processSimpleValueInit","checkValueChange","checkSimpleValueChange","delete","deleteSimpleValue","contextItem","appendTo","insertBefore","castedValue","placeholder","paint","paintBeforeText","simpleValueElm","paintCommands","elm","paintRemover","paintIndex","oldClone","setContent","processUpdateRegularValue","runBeforeDestroy","providers","provider","destroy$","destroyContext","childTags","lastArray","childValue","iSubs","unsubscribeFrom","context","getChildTagsToSoftDestroy","tags","subTags","smartRemoveKids","allPromises","promises","destroyCall","lastPromise","painting","locks","smartRemoveByContext","destroyClones","processContextDestroys","destroy","maybePromise","withinOwnerElement","destroyArray","subGlobal","deleted","oldest","htmlDomMeta","destroyClone","marker","domElement","destroySupport","compareArrayItems","newLength","lessLength","prevContext","destroyArrayItem","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","destroyArrayItemByGlobal","checkArrayValueChange","destroyArrayContextItem","cloneValueArray","cloneTagJsValue","shallowMapper","shallowCompareDepth","deepMapper","props","deepCompareDepth","getBaseSupport","castedProps","baseSupport","appSupport","blocked","upgradeBaseToSupport","propsConfig","castProps","propWatch","PropWatches","IMMUTABLE","latest","SHALLOW","clonePropsBy","createHtmlSupport","createSupport","tagValueUpdateHandler","_values","forceUpdateExistingValue","prepareUpdateToComponent","lastSupport","oldWrapper","wrapper","newWrapper","isSameTag","skipComparing","isLikeTags","oldestSupport","swapTags","hasChanged","newTemplater","latestProps","pastCloneProps","propsChanged","hasPropChanges","hasSupportChanged","newProps","syncFunctionProps","lastPropsConfig","DEEP","locked","updateExistingTagComponent","processFirstSubjectValue","valueToTagJsVar","domProcessContextItem","createAndProcessContextItem","document","createTextNode","paintBefore","paintAppends","paintAppend","processTagArray","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","getArrayTagVar","processArrayInit","getBasicTagVar","processUpdateOneContext","updateSupportBy","olderSupport","newerSupport","newTemplate","tempTag","updateSupportValuesBy","len","processUpdateContext","tryUpdateToTag","valueSupport","handleStillTag","updateToDiffValue","ignoreOrDestroyed","before","processNowRegularValue","checkSubContext","subContext","hasEmitted","valueHandler","onFirstSubContext","guaranteeInsertBefore","appendMarker","setupSubscribe","observable","insertBeforeOriginal","onValue","syncRun","newComponent","newestSupport","setupSubscribeCallbackProcessor","deleteAndUnsubscribe","deleteSubContext","processSubscribe","Observable","processSubscribeWith","withDefault","processSignal","initialValue","Signal","Set","unsub","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","defaultFinally","init","final","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","owner","cm","compareTo","inject","ownerProviders","find","msg","console","warn","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","syncError","createTrigger","finally","callbackStateUpdate","callbackMaker","onInit","onDestroy","debug","support0","support1","templater0","templater1","tag0","tag1","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings1","values0","values1","valuesLengthsMatch","allVarsMatch","isLikeValueSets","isLikeStringTags","checkTagValueChange","isTag","destroySupportByContextItem","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachDomElements","attachHtmlDomMeta","addOneContext","processTag","tagFakeTemplater","processTagInit","newSupportByTemplater","processNewSubjectTag","getTemplaterResult","depth","checkProp","alterProp","already","mem","wrap","toCall","callWith","noCycle","callbackResult","apply","run","safeRenderSupport","callbackPropOwner","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","isInlineHtml","renderInlineHtml","renderExistingReadyTag","executeWrap","useSupport","originalFunction","stateless","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","checkStateMismatch","tagFunction","newStates","error","hint","throwStateMismatch","runAfterRender","renderTagOnly","runBeforeRender","reSupport","processRenderOnceInit","processReplacementComponent","newPropsConfig","renderWithSupport","processReplaceTagResult","processFirstSubjectComponent","appendIndex","processFirstTagResult","processTagComponentInit","tagCount","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","pastProp","obEntries","subItem","objectItemMatches","use","deepPropWatch","route","_routeProps","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","pastValue","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","cGlobal","lastTemplater","lastTag","isLikeTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","lastOwnerSupport","wasLikeTags","inlineHtml","ownGlobal","checkRenderUp","selfPropChange","nowProps","hasPropsToOwnerChanged","handleProviderChanges","tagsWithProvider","memory","cSubject","getTagsWithProvider","mapToSupport","getUpTags","supports","isComponent","continueUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","noData","promiseNoData","bindSubjectCallback","subjectFunction","bindTo","eventHandlerSupport","last","checkAfterCallbackPromise","renderCallbackSupport","afterTagCallback","runTagCallback","actions","processNonDynamicAttr","howToSet","addSupportEventListener","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","parentNode","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","processUpdateAttrContext","isNameOnly","processNameOnlyAttrValue","updateNameOnlyAttrValue","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","createDynamicArrayAttribute","startIndex","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","isAttr","newValues","createDynamicAttribute","processDynamicNameValueAttribute","getTagJsVar","attrPart","processAttribute","nameVar","valueVar","special","paintContentPush","attachDynamicDom","blankHandler","nodes","node","newNode","attachDomText","attachDomElement","createElement","attr","paintAppendElementString","paintBeforeElementString","content","text","removeChild","relative","appendChild","someDiv","toPlainTextElm","innerHTML","textElm","subContextItem","processDomTagInit","getDomTag","setHTML","outerHTML","_innerHTML","oldProcessInit","processOuterDomTagInit","acceptInnerHTML","useTagVar","checkOuterTagValueChange","getStringTag","stringTag","putOneDomDown","newFragment","loadNewBaseSupport","renderTagElement","templater2","isAppFunction","isFirstRender","executeStateWrap","runWrapper","isApp","removeEventListener","toAwait","appElements","createDocumentFragment","domItem","registerTagElement","tagElement","appElmIndex","appElm","getNewSubject","newestOwner","c","handleInnerHTML","realValue","processInnerHTML","checkInnerHTML","getInnerHTML","hmr"],"sourceRoot":""}