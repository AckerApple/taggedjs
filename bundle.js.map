{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/tag/paint.function.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/tag/render/renderSupport.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/tag/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/updateBeforeTemplate.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContext.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/tag/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDomElements.function.ts","webpack://taggedjs/./ts/tag/buildBeforeElement.function.ts","webpack://taggedjs/./ts/alterProp.function.ts","webpack://taggedjs/./ts/tag/executeWrap.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/tag/afterRender.function.ts","webpack://taggedjs/./ts/tag/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/tag/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/tag.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/tag/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/tag/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/tag/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribe.function.ts","webpack://taggedjs/./ts/subject/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/subscribe.function.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/restorePlaceholders.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/interpolations/processSubscriptionUpdate.function.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(subject) {\n    ;\n    subject.renderCount = subject.renderCount || 0;\n    // ;(subject as SupportContextItem).renderCount = 0\n    return subject.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    // subject: 'subject',\n    // tagJsSubject: 'tagJsSubject',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","export let paintRemoves = [];\nexport let paintContent = [];\nexport let setContent = [];\n/** array memory that runs and completes BEFORE paintInsertBefores array */\nexport let paintAppends = [];\n/** array memory that runs and completes AFTER paintAppends array */\nexport let paintInsertBefores = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0\n};\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    for (let index = paintRemoves.length - 1; index >= 0; --index) {\n        const toRemove = paintRemoves[index];\n        const parentNode = toRemove.parentNode;\n        parentNode.removeChild(toRemove);\n    }\n    for (const content of paintContent) {\n        content();\n    }\n    for (const [text, textNode] of setContent) {\n        textNode.textContent = text;\n    }\n    for (const now of paintAppends) {\n        now.relative.appendChild(now.element);\n    }\n    for (const { element, relative } of paintInsertBefores) {\n        relative.parentNode.insertBefore(element, relative);\n    }\n    paintRemoves = [];\n    paintContent = [];\n    paintAppends = [];\n    paintInsertBefores = [];\n    setContent = [];\n    for (const now of paintAfters) {\n        now();\n    }\n    paintAfters = [];\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.subject.global.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter((...args) => {\n        return args;\n    });\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = (..._args) => {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nexport function initState(support, config) {\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.support = support;\n}\nexport function reState(newSupport, prevSupport, config, prevState) {\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nexport function syncStates(from, onto) {\n    let got;\n    from((...x) => {\n        got = x;\n        return x;\n    }, 1);\n    onto(() => {\n        return got;\n    }, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        const oldValues = [];\n        const oldGetCallback = (...args) => {\n            oldValues.push(args);\n            return args;\n        };\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        let getIndex = 0;\n        // This is the \"get\" argument that will be called and all arguments are ignored\n        const newSetCallback = (..._) => {\n            return oldValues[getIndex++];\n        };\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { paintContent } from \"../../tag/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push(() => {\n        howToSetFirstInputValue(element, name, value);\n    });\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintAfters, paintContent } from \"../../tag/paint.function.js\";\n/** handles init, destroy, autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName, support, counts) {\n    switch (specialName) {\n        // case 'oninit' as any:\n        case 'init': {\n            const stagger = counts.added;\n            // run delayed after elements placed down\n            paintAfters.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                value(event); // call init/oninit\n            });\n            return;\n        }\n        case 'destroy': {\n            const stagger = ++counts.removed;\n            const global = support.subject.global;\n            global.destroys = global.destroys || [];\n            global.destroys.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                return value(event); // call destroy/ondestroy\n            });\n            return;\n        }\n        case 'autofocus':\n            paintAfters.push(() => element.focus());\n            return;\n        case 'autoselect':\n            paintAfters.push(() => element.select());\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push(() => element.style[names[1]] = value); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push(() => element.classList.add(name));\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push(() => element.classList.remove(name));\n    }\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.subject;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.subject;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../tag/render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(ownerSupport, newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { deepEqual } from '../../deepFunctions.js';\nimport { renderExistingReadyTag } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../hasSupportChanged.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(ownerSupport, support);\n        return result;\n    }\n    global.locked = true;\n    const subject = support.subject;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingReadyTag(global.newest, support, ownerSupport, subject);\n    delete global.locked;\n    return tag;\n}\nexport function renderInlineHtml(ownerSupport, support) {\n    const ownGlobal = ownerSupport.subject.global;\n    if (!ownGlobal || ownGlobal.deleted === true) {\n        return support;\n    }\n    // ??? new change\n    const newest = ownGlobal.newest || ownerSupport;\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(ownerSupport, templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (ownerSupport && selfPropChange) {\n        return true;\n    }\n    return false;\n}\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    /*\n    const noLength = nowProps && nowLen === 0 && latestLen === 0\n  \n    if(noLength) {\n      return false\n    }\n    */\n    return nowLen !== latestLen;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(x => x.support));\n    }\n    return prosWithChanges;\n}\n","import { paint, painting } from '../../tag/paint.function.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.subject.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    const global = support.subject.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function (element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    const component = getSupportWithState(support);\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    const states = component.states; // ?.[0]\n    subjectFunction.states = states;\n    // subjectFunction.states = [...states]\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, states, bindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.subject;\n    const global = subject.global; // tag.subject.global as TagGlobal\n    global.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete global.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.subject.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (isPromise(callbackResult)) {\n        const global0 = last.subject.global;\n        global0.locked = true;\n        return callbackResult.then(() => {\n            if (global.deleted === true) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            const global1 = last.subject.global;\n            delete global1.locked;\n            const tagsToUpdate = getUpTags(last);\n            renderTagUpdateArray(tagsToUpdate);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    for (const block of blocked) {\n        const lastResult = renderSupport(block);\n        global.newest = lastResult;\n    }\n    global.blocked = [];\n    return global.newest;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nconst actions = ['init', 'destroy']; // oninit ondestroy\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        if (isSpecial && actions.includes(attrName)) {\n            specialAttribute(attrName, value, element, attrName, support, counts);\n            return;\n        }\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial, support, counts);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.subject.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return true;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit': // when read in compile process\n        case 'init': // when read in realtime\n            return 'oninit';\n        case 'ondestroy': // when read in compile process\n        case 'destroy': // when read in realtime\n            return 'destroy';\n    }\n    return false;\n}\n","import { processAttributeEmit } from '../interpolations/attributes/processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../interpolations/attributes/updateAttribute.function.js';\nconst emptyCounts = { added: 0, removed: 0 };\nexport function processUpdateAttrContext(values, value, contextItem, ownerSupport) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        emptyCounts);\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, emptyCounts);\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../tag/paint.function.js';\nimport { isNoDisplayValue, processNameOnlyAttrValue } from './processAttribute.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { isFunction, isObject, isSubjectInstance } from '../../isInstance.js';\nimport { bindSubjectCallback } from './bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../tag/paint.function.js';\nimport { processDynamicNameValueAttribute, processNonDynamicAttr } from './processNameValueAttribute.function.js';\nimport { addOneContext, checkSimpleValueChange, deleteSimpleValue } from '../../tag/index.js';\nimport { processAttributeFunction } from './processAttributeCallback.function.js';\nimport { isSpecialAttr } from './isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from '../../tag/processUpdateAttrContext.function.js';\nimport { blankHandler } from '../optimizers/attachDomElements.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, attrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        // how to process value updates\n        contextItem.handler = (newValue, newValues) => processUpdateAttrContext(newValues, newValue, contextItem, support);\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        const contextItem = {\n            isAttr: true,\n            element,\n            attrName: attrName,\n            checkValueChange: checkSimpleValueChange,\n            delete: deleteSimpleValue,\n            withinOwnerElement: true,\n        };\n        context.push(contextItem);\n        const isSubject = isSubjectInstance(contextItem.value);\n        if (isSubject) {\n            return processNameValueAttributeAttrSubject(attrName, contextItem, element, support, howToSet, isSpecial, counts);\n        }\n        contextItem.handler = (newValue, newValues) => processUpdateAttrContext(newValues, newValue, contextItem, support);\n        /*\n        processNameOnlyAttrValue(\n          values,\n          newValue as any,\n          element as Element,\n          support,\n          howToSet as HowToSet,\n          context,\n          counts,\n        )\n        */\n        processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n        contextItem.value = value;\n        return;\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n/** Processor for flat attributes and object attributes */\nfunction processNameValueAttributeAttrSubject(attrName, contextItem, element, support, howToSet, isSpecial, counts) {\n    if (isSpecial) {\n        paintContent.push(function paintContent() {\n            element.removeAttribute(attrName);\n        });\n    }\n    const contextValueSubject = contextItem.value;\n    if (isSubjectInstance(contextValueSubject)) {\n        contextItem.handler = blankHandler;\n        const callback = function processAttrCallback(newAttrValue) {\n            processAttributeEmit(newAttrValue, attrName, contextItem, element, support, howToSet, isSpecial, counts);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        const global = contextItem.global;\n        const subs = global.subscriptions = global.subscriptions || [];\n        subs.push(sub);\n    }\n    processAttributeEmit(contextItem.value, attrName, contextItem, element, support, howToSet, isSpecial, counts);\n    return;\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special, // string name of special\n        support, counts);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push(function paintContentPush() {\n                element.removeAttribute(attrName);\n            });\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\nexport function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","import { paintInsertBefores } from './tag/paint.function.js';\nimport { empty } from './tag/ValueTypes.enum.js';\n// Function to update the value of x\nexport function updateBeforeTemplate(value, // value should be casted before calling here\nlastFirstChild) {\n    const textNode = document.createTextNode(value); // never innerHTML\n    paintInsertBefores.push({\n        element: textNode,\n        relative: lastFirstChild,\n    });\n    return textNode;\n}\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.subject.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.subject.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nexport function destroyContext(childTags) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            destroyContext(lastArray);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(iSub => iSub.unsubscribe());\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.context;\n        destroyContext(subTags);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.context;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { paint, painting, paintRemoves } from './paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.context;\n    // already set\n    // global.deleted = true\n    const destroys = global.destroys;\n    if (destroys) {\n        return processContextDestroys(destroys, global, allPromises);\n    }\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\n// Elements that have a destroy or ondestroy attribute\nfunction processContextDestroys(destroys, global, allPromises) {\n    const promises = [];\n    destroys.forEach(destroy => {\n        const maybePromise = destroy();\n        const isPromise = maybePromise instanceof Promise;\n        if (isPromise) {\n            promises.push(maybePromise);\n        }\n    });\n    if (promises.length) {\n        const lastPromise = Promise.all(promises)\n            .then(() => {\n            ++painting.locks;\n            // continue to remove\n            smartRemoveByContext(global.context, allPromises);\n            destroyClones(global);\n            --painting.locks;\n            paint();\n        });\n        // run destroy animations\n        allPromises.push(lastPromise);\n        return;\n    }\n    ++painting.locks;\n    smartRemoveByContext(global.context, allPromises);\n    destroyClones(global);\n    --painting.locks;\n    paint();\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.withinOwnerElement) {\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintRemoves.push(elm);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    // const global = subject.global\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    htmlDomMeta.forEach(clone => {\n        const marker = clone.marker;\n        if (marker) {\n            paintRemoves.push(marker);\n        }\n        const dom = clone.domElement;\n        if (!dom) {\n            return;\n        }\n        paintRemoves.push(dom);\n    });\n    // htmlDomMeta.length = 0\n}\n","import { destroyContext } from './destroyContext.function.js';\nimport { smartRemoveKids } from './smartRemoveKids.function.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.subject;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.context;\n    destroyContext(context);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n","import { paintRemoves } from '../paint.function.js';\nimport { destroySupport } from '../destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed, counts) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext, counts);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, counts, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, counts, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext, counts);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item, counts) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n    ++counts.removed;\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n    }\n    else {\n        const element = item.simpleValueElm;\n        delete item.simpleValueElm;\n        paintRemoves.push(element);\n    }\n}\n","// Functions in here are attached as ContextItem.checkValueChange\nimport { processUpdateRegularValue } from './update/processRegularValue.function.js';\nimport { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nimport { paintRemoves } from './paint.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        const lastArray = subject.lastArray;\n        destroyArray(subject, lastArray);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArray(subject, lastArray) {\n    const counts = { added: 0, removed: 0 };\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index], counts);\n    }\n    delete subject.lastArray;\n}\nexport function checkSimpleValueChange(newValue, subject) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, subject);\n        return -1; // no need to destroy, just update display\n    }\n    deleteSimpleValue(subject);\n    return 6; // 'changed-simple-value'\n}\nexport function deleteSimpleValue(subject) {\n    const elm = subject.simpleValueElm;\n    delete subject.simpleValueElm;\n    paintRemoves.push(elm);\n}\n","import { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { setContent } from '../paint.function.js';\nimport { checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    setContent.push([castedValue, oldClone]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, subject) {\n    subject.checkValueChange = checkSimpleValueChange;\n    const before = subject.placeholder;\n    const castedValue = castTextValue(value);\n    // Processing of regular values\n    subject.simpleValueElm = updateBeforeTemplate(castedValue, before);\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function updateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\nexport function prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        processReplacementComponent(templater, contextItem, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { castProps } from '../../alterProp.function.js';\nimport { renderSupport } from '../render/renderSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { PropWatches } from '../tag.function.js';\nimport { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject) {\n    const global = subject.global;\n    const lastSupport = global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = support.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = support.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(lastSupport, support);\n    }\n    else if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(lastSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, support, lastSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (global.locked) {\n        global.blocked.push(support);\n        return;\n    }\n    renderSupport(support);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    if (maxDepth === 0) {\n        throw new Error('before here');\n    }\n    const global = lastSupport.subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.subject.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, lastSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = lastSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return lastSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(subject, templater, // new tag\nownerSupport) {\n    const global = subject.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(subject);\n    const newSupport = processReplacementComponent(templater, subject, ownerSupport, { added: 0, removed: 0 });\n    return newSupport;\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function hasSupportChanged(lastSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = lastSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, lastSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","// taggedjs-no-compile\nimport { paintAppends, paintInsertBefores } from '../paint.function.js';\nimport { checkSimpleValueChange, deleteSimpleValue } from '../checkDestroyPrevious.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode('');\n    const contextItem = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        delete: deleteSimpleValue,\n        withinOwnerElement: false,\n        placeholder: element,\n    };\n    counts.added = counts.added + 1; // index  \n    if (!appendTo) {\n        paintInsertBefores.push({\n            element,\n            relative: insertBefore,\n        });\n    }\n    domProcessContextItem(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push({\n            element,\n            relative: appendTo,\n        });\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { updateExistingValue } from './updateExistingValue.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            // 👁️ COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed, counts);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        updateExistingValue(itemSubject, value, ownerSupport);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n","import { checkArrayValueChange, checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nimport { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nexport function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    if (isArray(value)) {\n        processTagArray(contextItem, value, ownerSupport, counts, appendTo);\n        contextItem.checkValueChange = checkArrayValueChange;\n        return;\n    }\n    processFirstRegularValue(value, contextItem, contextItem.placeholder);\n}\nfunction processFirstRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    const castedValue = castTextValue(value);\n    const clone = updateBeforeTemplate(castedValue, insertBefore);\n    subject.simpleValueElm = clone;\n    subject.checkValueChange = checkSimpleValueChange;\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nimport { updateExistingValue } from \"../../tag/update/updateExistingValue.function.js\";\nexport function domProcessContextItem(value, contextItem, support, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    contextItem.handler = domContextHandler;\n    const global = support.subject.global;\n    global.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    const global2 = support.subject.global;\n    delete global2.locked;\n    contextItem.value = value;\n}\nfunction domContextHandler(newValue, _newValues, newSupport, newContextItem) {\n    return updateExistingValue(newContextItem, newValue, newSupport);\n}\n","// taggedjs-no-compile\nimport { paintAppends, paintInsertBefores } from \"../../tag/paint.function.js\";\nimport { addOneContext } from \"../../tag/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push({\n            relative: appendTo,\n            element: marker,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            relative: insertBefore,\n            element: marker,\n        });\n    }\n    domProcessContextItem(value, contextItem, support, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { howToSetFirstInputValue } from \"../attributes/howToSetInputValue.function.js\";\nimport { paintAppends, paintInsertBefores } from \"../../tag/paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"./attachDynamicDom.function.js\";\nexport const blankHandler = () => undefined;\nconst someDiv = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push({\n            element: insertBefore,\n            relative: appendTo,\n        });\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, context, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        node.at.forEach(attr => {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            processAttribute(values, name, domElement, support, \n            // howToSetInputValue, // maybe more performant for updates but not first renders\n            howToSetFirstInputValue, context, isSpecial, counts, value);\n        });\n    }\n    if (appendTo) {\n        paintAppends.push({\n            element: domElement,\n            relative: appendTo,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            element: domElement,\n            relative: insertBefore,\n        });\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    someDiv.innerHTML = string;\n    const domElement = textNode.domElement = document.createTextNode(someDiv.innerText);\n    if (owner) {\n        paintAppends.push({\n            element: domElement,\n            relative: owner,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            element: domElement,\n            relative: insertBefore,\n        });\n    }\n}\n","import { attachDomElements } from '../interpolations/optimizers/attachDomElements.function.js';\nimport { checkSimpleValueChange, deleteSimpleValue, destorySupportByContextItem } from './index.js';\nimport { getDomMeta } from './domMetaCollector.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.subject;\n    subject.delete = destorySupportByContextItem;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const context = [];\n    const global = support.subject.global;\n    global.context = context;\n    const result = attachDomElements(domMeta, values, support, counts, context, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag; // || templater\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        delete: deleteSimpleValue,\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { isInlineHtml, renderInlineHtml } from './tag/render/renderSupport.function.js';\nimport { renderExistingReadyTag } from './tag/render/renderExistingTag.function.js';\nimport { getSupportInCycle } from './tag/getSupportInCycle.function.js';\nimport { deepCompareDepth } from './tag/hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nimport { setUseMemory } from './state/index.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(prop => alterProp(prop, newSupport.ownerSupport, newSupport, depth));\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        return getPropWrap(value, owner, ownerSupport);\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return wrap.toCall(...args);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n    wrap.toCall = function toCallRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    };\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, owner, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const global = newest.subject.global;\n        // are we in a rendering cycle? then its being called by alterProps\n        /*\n        if(noCycle === false) {\n          const allMatched = global.locked === true\n        \n          if(allMatched) {\n            return callbackResult // owner did not change\n          }\n        }*/\n        if (!global || global.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest, ownerSupport);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\nexport function safeRenderSupport(newest, ownerSupport) {\n    const subject = newest.subject;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        const result = renderInlineHtml(ownerSupport, newest);\n        return result;\n    }\n    const global = subject.global;\n    global.locked = true;\n    renderExistingReadyTag(global.newest, newest, ownerSupport, subject);\n    delete global.locked;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    config.support = useSupport;\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag; // || (support1 as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (tag0.tagJsType) {\n        case ValueTypes.dom: {\n            if (tag1?.tagJsType !== ValueTypes.dom) {\n                return false; // tag0 is not even same type\n            }\n            return isLikeDomTags(tag0, tag1);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(tag0, tag1, support0, support1);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${tag0.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(tag0, tag1) {\n    const domMeta0 = tag0.dom;\n    const domMeta1 = tag1.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(tag0, tag1, support0, // new\nsupport1) {\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.templater.values || tag0.values;\n    const values1 = support1.templater.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nimport { paint, paintAfters } from './paint.function.js';\nexport function checkTagValueChange(newValue, contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        return false;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        return result === true ? -1 : false;\n    }\n    // A subject could have emitted twice in one render cycle\n    if (lastSupport.subject.renderCount === 0) {\n        delete contextItem.global;\n        contextItem.renderCount = 0;\n        paintAfters.push(() => {\n            destroySupport(lastSupport, global);\n            paintAfters.shift(); // prevent endless recursion\n            paint();\n        });\n        return 8; // never rendered\n    }\n    destorySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destorySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n","import { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { paintAppends, paintInsertBefores } from '../paint.function.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    subject.checkValueChange = checkTagValueChange;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push({\n                    element: dom.marker,\n                    relative: appendTo, // ph.parentNode as Element,\n                });\n            }\n            else {\n                paintInsertBefores.push({\n                    element: dom.marker,\n                    relative: insertBefore, // ph.parentNode as Element,\n                });\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push({\n                    element: dom.domElement,\n                    relative: appendTo, // ph.parentNode as Element,\n                });\n            }\n            else {\n                paintInsertBefores.push({\n                    element: dom.domElement,\n                    relative: insertBefore, // ph.parentNode as Element,\n                });\n            }\n        }\n    }\n    return support;\n}\n","import { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { processTag } from './processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    contextItem.checkValueChange = checkTagValueChange;\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem, counts);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nimport { PropWatches } from '../tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from './checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.subject;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n","import { executeWrap } from '../executeWrap.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { runAfterRender } from '../afterRender.function.js';\nimport { initState, reState } from '../../state/state.utils.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    const prevState = prevSupport?.state;\n    const config = setUseMemory.stateConfig;\n    if (prevState) {\n        reState(newSupport, prevSupport, setUseMemory.stateConfig, prevState);\n    }\n    else {\n        initState(newSupport, config);\n    }\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    return reSupport;\n}\n","import { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { oneRenderToSupport } from './oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem, ownerSupport);\n    const result = processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    contextItem.checkValueChange = checkTagValueChange;\n    return result;\n}\n","import { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo) {\n    getNewGlobal(contextItem);\n    contextItem.checkValueChange = checkTagValueChange;\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n","import { processFirstTagResult, processReplaceTagResult } from './processTagResult.function.js';\nimport { renderWithSupport } from '../render/renderWithSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag\n    subject, ownerSupport);\n    processReplaceTagResult(support, counts, subject);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag   \n    subject, ownerSupport);\n    processFirstTagResult(support, counts, appendTo);\n    return support;\n}\n","import { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { paintAppends } from '../paint.function.js';\nimport { checkTagValueChange } from '../index.js';\nexport function processReplaceTagResult(support, counts, contextItem) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const ph = contextItem.placeholder;\n    buildBeforeElement(support, counts, undefined, // element for append child\n    ph);\n    return support;\n}\nexport function processFirstTagResult(support, counts, appendTo) {\n    let appendIndex = paintAppends.length;\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.domElement,\n                relative: appendTo,\n            });\n        }\n        if (dom.marker) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.marker,\n                relative: appendTo,\n            });\n        }\n    }\n    return support;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { tags } from './tag.utils.js';\nimport { getTagWrap } from './getTagWrap.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { processRenderOnceInit } from './update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from './update/processTagComponentInit.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        /*\n            if(!innerTagWrap.parentWrap) {\n              innerTagWrap.parentWrap = parentWrap as TagWrapper<unknown>\n            }\n        */\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\ntag.renderOnce = renderOnceFn;\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n/** @deprecated use tag.use() instead */\n;\ntag.state = tagUseFn;\ntag.use = tagUseFn;\ntag.route = routeFn;\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\n;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.deepPropWatch = tag;\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        ;\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n    },\n});\n// TODO: deprecate this in favor of tag.use\nObject.defineProperty(tag, 'state', {\n    set(renderFunction) {\n        ;\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        ;\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n    },\n});\n","import { castProps } from '../alterProp.function.js';\nimport { syncFunctionProps } from './update/updateExistingTagComponent.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { PropWatches } from './tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { isSkipPropValue } from '../../alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy } from '../destroyContext.function.js';\nimport { getNewGlobal } from '../update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.subject;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.context);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.subject.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(sub => sub.unsubscribe());\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n","import { moveProviders } from '../update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.subject.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","export function processUpdateContext(support, context) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    while (index < len) {\n        processUpdateOneContext(values, index, context, support);\n        ++index;\n    }\n    return context;\n}\n/** returns boolean of did render */\nexport function processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport) {\n    const value = values[index];\n    // is something already there?\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (value === contextItem.value) {\n        return;\n    }\n    const handler = contextItem.handler;\n    handler(value, values, ownerSupport, contextItem);\n    contextItem.value = value;\n}\n","import { paint, painting } from './paint.function.js';\nimport { processUpdateContext } from './processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.subject.global;\n    const context = global.context;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from '../update/processTag.function.js';\nimport { updateSupportBy } from '../updateSupportBy.function.js';\nconst fooCounts = { added: 0, removed: 0 };\n// TODO: This function is being called for 1st time renders WHEN renderCount === 1\nexport function renderExistingReadyTag(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const global = subject.global;\n    const { support, wasLikeTags } = renderWithSupport(newSupport, lastSupport, // renderCount <= 0 ? undefined : lastSupport\n    subject, ownerSupport);\n    if (wasLikeTags) {\n        updateSupportBy(global.oldest, support);\n        return support;\n    }\n    processTag(ownerSupport, subject, fooCounts);\n    return support;\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from './render/renderSupport.function.js';\nimport { PropWatches } from './tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, () => {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { clonePropsBy } from './clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, subject, castedProps) {\n    const baseSupport = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    // baseSupport.appSupport = baseSupport\n    const global = subject.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { cloneTagJsValue } from './cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { PropWatches } from './tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(x => cloneTagJsValue(x, shallowCompareDepth)),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(props => cloneTagJsValue(props, deepCompareDepth)),\n        castProps,\n    };\n}\n","import { createHtmlSupport } from '../createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { processTagInit } from './processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\nsubject, // could be tag via result.tag\ncounts) {\n    const global = subject.global;\n    const support = global.newest;\n    support.ownerSupport = ownerSupport;\n    subject.checkValueChange = checkTagValueChange;\n    const ph = subject.placeholder;\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.context = [];\n    return support;\n}\n","import { getFakeTemplater, newSupportByTemplater, processTag } from './processTag.function.js';\nimport { BasicTypes, ValueTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { prepareUpdateToComponent } from './updateExistingValue.function.js';\nconst fooCounts = { added: 0, removed: 0 };\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const tagJsType = newValue.tagJsType;\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    switch (tagJsType) {\n        case ValueTypes.templater:\n            processTag(ownerSupport, contextItem, fooCounts);\n            return true;\n        // when value was not a Tag before\n        case ValueTypes.tag:\n        case ValueTypes.dom: {\n            updateToTag(newValue, contextItem, ownerSupport);\n            return true;\n        }\n        case ValueTypes.subscribe: {\n            ;\n            newValue.processInit(newValue, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n            contextItem.placeholder);\n            return true;\n        }\n    }\n    return false;\n}\nfunction updateToTag(value, contextItem, ownerSupport) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = getFakeTemplater();\n        tag.templater = templater;\n        templater.tag = tag;\n    }\n    const nowGlobal = (contextItem.global ? contextItem.global : getNewGlobal(contextItem));\n    nowGlobal.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    processTag(ownerSupport, contextItem, fooCounts);\n}\n","import { updateSupportBy } from '../updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(lastSupport, subject, value, ownerSupport) {\n    const templater = value.templater || value;\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = lastSupport.subject;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Have the context check itself (avoid having to detect old value)\n    const ignoreOrDestroyed = contextItem.checkValueChange(newValue, contextItem);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed);\n}\n","import { paint, paintAppends } from '../paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function setupSubscribe(observable, contextItem, ownerSupport, counts, callback, appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode('');\n        paintAppends.push({\n            element: insertBefore,\n            relative: appendTo,\n        });\n        // appendTo = undefined\n    }\n    const setup = setupSubscribeCallbackProcessor(observable, contextItem, ownerSupport, counts, callback, insertBefore);\n    const deleteMe = contextItem.delete = () => {\n        setup.contextItem.delete(setup.contextItem);\n        setup.subscription.unsubscribe();\n        if (appendMarker) {\n            const parentNode = appendMarker.parentNode;\n            parentNode.removeChild(appendMarker);\n        }\n    };\n    contextItem.handler = (value, values, newSupport) => {\n        if (!value || !value.tagJsType || value.tagJsType !== ValueTypes.subscribe) {\n            deleteMe();\n            return 99;\n        }\n        if (!setup.hasEmitted) {\n            return;\n        }\n        setup.callback = value.callback;\n        setup.handler(setup.getLastValue());\n        const newComponent = getSupportWithState(newSupport);\n        setup.states = newComponent.states;\n    };\n}\nexport function setupSubscribeCallbackProcessor(observable, contextItem, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ncallback, insertBefore) {\n    const component = getSupportWithState(ownerSupport);\n    let lastValue = undefined;\n    const getLastValue = () => lastValue;\n    let onValue = function onSubValue(value) {\n        if (memory.callback) {\n            value = memory.callback(value);\n        }\n        memory.hasEmitted = true;\n        memory.contextItem = createAndProcessContextItem(value, ownerSupport, counts, insertBefore);\n        // from now on just run update\n        onValue = function subscriptionUpdate(value) {\n            forceUpdateExistingValue(memory.contextItem, value, ownerSupport);\n            if (!syncRun && !setUseMemory.stateConfig.support) {\n                paint();\n            }\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    const valueChangeHandler = function subValueProcessor(value) {\n        lastValue = value;\n        const newComponent = component.subject.global.newest;\n        syncSupports(newComponent, component);\n        if (memory.callback) {\n            value = memory.callback(value);\n        }\n        onValue(value);\n    };\n    // aka setup\n    const memory = {\n        hasEmitted: false,\n        handler: valueChangeHandler,\n        getLastValue,\n        callback,\n        states: component.states,\n    };\n    let syncRun = true;\n    memory.subscription = observable.subscribe(valueChangeHandler);\n    syncRun = false;\n    return memory;\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    return setupSubscribe(value.Observable, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, // {added:0, removed:0}\nappendTo) {\n    setupSubscribe(value, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { state } from '../state/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                // Notify all subscribers\n                subscribers.forEach(callback => callback(newValue));\n            }\n        },\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.subject.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from '../subject/signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(() => ({ stateDiff: 0, provider: undefined }));\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.subject.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        // find once, return same every time after\n        return state(() => {\n            // const memory = setUse.memory\n            const cm = constructor;\n            const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n            const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n            const providers = [];\n            let owner = {\n                ownerSupport: support.ownerSupport\n            };\n            while (owner.ownerSupport) {\n                const ownGlobal = owner.ownerSupport.subject.global;\n                const ownerProviders = ownGlobal.providers;\n                if (!ownerProviders) {\n                    owner = owner.ownerSupport; // cause reloop checking next parent\n                    continue;\n                }\n                const provider = ownerProviders.find(provider => {\n                    providers.push(provider);\n                    const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                    if (constructorMatch) {\n                        return true;\n                    }\n                });\n                if (provider) {\n                    const global = support.subject.global;\n                    const providers = global.providers = global.providers || [];\n                    providers.push(provider);\n                    provider.children.push(support);\n                    return provider.instance;\n                }\n                owner = owner.ownerSupport; // cause reloop checking next parent\n            }\n            const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n            console.warn(`${msg}. Available providers`, providers);\n            throw new Error(msg);\n        });\n    }\n};\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.subject.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { syncStatesArray } from './syncStates.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.subject.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    syncStatesArray(newestSupport.states, oldStates);\n    // run the callback\n    const maybePromise = callback(...args);\n    // OLDEST UPDATE NEWEST: send the oldest state changes into the newest\n    syncStatesArray(oldStates, newestSupport.states);\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            syncStatesArray(oldStates, newestSupport.states);\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.subject.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nexport function subscribe(Observable, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        Observable,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n    };\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\n","import { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { newSupportByTemplater, processTag, tagFakeTemplater } from './processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, // {added:0, removed:0}\nappendTo, insertBefore) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    contextItem.checkValueChange = checkTagValueChange;\n    return processTag(ownerSupport, contextItem, counts);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    return tag;\n}\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    return tag;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/getDomTag.function.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                textVarMatches.forEach(textContent => {\n                    if (textContent.startsWith(variablePrefix)) {\n                        textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                });\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n            const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n            let attrValue = attrChoice;\n            if (attrName === undefined) {\n                continue;\n            }\n            const notEmpty = attrMatch[2] !== '';\n            const noValue = attrValue === undefined && notEmpty;\n            const lowerName = attrName.toLowerCase();\n            const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n            if (noValue) {\n                const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n                if (standAloneVar) {\n                    const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                    valuePositions.push(['at', valueName]);\n                    attributes.push([valueName]); // the name itself is dynamic\n                    continue;\n                }\n                const startMatched = attrMatch[0].startsWith(attrName);\n                const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n                if (standAloneAttr) {\n                    attributes.push([fixedName]);\n                    continue;\n                }\n                const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                attrValue = valueName;\n            }\n            if (!notEmpty) {\n                attrValue = attrMatch[2];\n            }\n            const attrSet = [fixedName, attrValue];\n            const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n            if (isSpecial) {\n                attrSet.push(isSpecial);\n            }\n            attributes.push(attrSet);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            textVarMatches.forEach(textContent => {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                return pushTextTo(currentElement, elements, textContent);\n            });\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postprocessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\nfunction postprocessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(part => part !== '');\n    return filteredParts;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/getDomTag.function.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nconst fragReplacer = /(^:tagvar\\d+:|:tagvar\\d+:$)/g;\nconst safeVar = '__safeTagVar';\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    htmlInterpolationToPlaceholders(strings, values);\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = sanitizePlaceholders(strings);\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction sanitizePlaceholders(fragments) {\n    return fragments.map(fragment => fragment.replace(fragReplacer, (match, index) => safeVar + index));\n}\nfunction addPlaceholders(strings, values) {\n    const results = strings.map((fragment, index) => {\n        if (index < values.length) {\n            return fragment + variablePrefix + index + variableSuffix;\n        }\n        return fragment;\n    });\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { variableSuffix, variablePrefix } from \"../../tag/getDomTag.function.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nconst placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, ...[{\n                    nn: 'text',\n                    v: wIndex\n                }]);\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    return attributes.map(attrSet => {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [{ tagJsVar: index }];\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [key, { tagJsVar: index }, isSpecial];\n            }\n        }\n        return attrSet;\n    });\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/getDomTag.function.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nexport const safeVar = '__safeTagVar';\nexport function restorePlaceholders(elements) {\n    elements.forEach(traverseAndRestore);\n}\nconst safeReplacer = /__safeTagVar(\\d+)/g;\nfunction traverseAndRestore(element) {\n    if (element.at) {\n        element.at = element.at ? element.at.map(attr => {\n            if (attr.length === 1) {\n                return attr;\n            }\n            const [, value] = attr;\n            if (typeof value === ImmutableTypes.string && value.startsWith(safeVar)) {\n                const index = parseInt(value.replace(safeVar, ''), 10);\n                attr[1] = variablePrefix + index + variableSuffix;\n            }\n            return attr;\n        }) : [];\n    }\n    if (element.ch) {\n        const children = element.ch;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.nn === 'text') {\n                if (typeof child.tc !== ImmutableTypes.string) {\n                    return;\n                }\n                child.tc = child.tc.replace(safeReplacer, (_match, index) => variablePrefix + index + variableSuffix);\n            }\n            traverseAndRestore(child);\n        }\n        // Remove empty children array\n        if (children.length === 0) {\n            delete element.ch;\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { restorePlaceholders } from '../interpolations/optimizers/restorePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    // Restore any sanitized placeholders in text nodes\n    restorePlaceholders(map);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(x => x.length);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { getStringTag, getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from './tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nimport { buildBeforeElement } from './buildBeforeElement.function.js';\nimport { tags } from './tag.utils.js';\nimport { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkTagValueChange, destorySupportByContextItem } from './checkTagValueChange.function.js';\nimport { createSupport } from './createSupport.function.js';\nconst appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.subject.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest, setUseMemory.stateConfig);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const placeholder = document.createTextNode('');\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nfunction registerTagElement(support, element, global, templater, app, placeholder) {\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    return newFragment;\n}\nfunction getNewSubject(templater, appElement) {\n    const subject = {\n        value: templater,\n        checkValueChange: checkTagValueChange,\n        delete: destorySupportByContextItem,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n    };\n    const global = getNewGlobal(subject);\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\nfunction loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        setUseMemory.stateConfig, oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n","import { updateExistingValue } from '../tag/update/updateExistingValue.function.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { paint } from '../tag/paint.function.js';\n/** Used for values that are to subscribe to */\nexport function processSubUpdate(value, // Observable | Subject\ncontextItem, support) {\n    const global = support.subject.global;\n    if (global.deleted) {\n        return; // same value emitted\n    }\n    // checks if same value\n    updateExistingValue(contextItem, value, support);\n    if (!setUseMemory.stateConfig.support) {\n        paint();\n    }\n    return;\n}\n","export * from './tag/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport * from './state/index.js';\nexport { states } from './state/states.function.js';\nexport * from './subject/index.js';\nexport * from './interpolations/index.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './interpolations/attributes/ElementTargetEvent.interface.js';\nimport { renderTagOnly } from './tag/render/renderTagOnly.function.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './tag/paint.function.js';\nexport { tagElement, renderWithSupport, renderSupport, renderTagOnly, paint, };\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","subject","renderCount","global","RouteQuery","_name","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","subscribe","signal","renderOnce","stateRender","version","Date","now","paintRemoves","paintContent","setContent","paintAppends","paintInsertBefores","paintAfters","painting","locks","paint","index","length","toRemove","parentNode","removeChild","content","text","textNode","textContent","relative","appendChild","element","insertBefore","isSimpleType","value","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","isObject","function","isPromise","isFunction","then","object","isArray","Array","getSupportWithState","support","component","ownerSupport","newest","firstStatesHandler","setter","config","setUseMemory","stateConfig","states","statesIndex","args","reStatesHandler","oldStates","prevSupport","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","stateArray","reState","newSupport","prevState","runRestate","StateEchoBack","getStateValue","state","callback","defaultValue","checkValue","getCallbackValue","restate","push","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","values","setValue","x","item","subscription","clones","shift","subscriptions","map","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","splice","removeSubFromArray","valSub","add","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","undefined","getSupportInCycle","syncStatesArray","from","onto","syncStates","got","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","oldGetCallback","stateFromTarget","getIndex","newSetCallback","_","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","cloneValueArray","cloneTagJsValue","howToSetInputValue","name","howToSetFirstInputValue","setAttribute","removeAttribute","specialAttribute","specialName","counts","stagger","added","target","removed","destroys","focus","select","names","split","style","classList","remove","processSpecialClass","Error","handleProviderChanges","appSupport","provider","tagsWithProvider","memory","childTags","children","child","cSubject","getTagsWithProvider","getUpTags","supports","inlineHtml","isInlineHtml","locked","isComponent","continueUp","selfPropChange","nowProps","props","propsConfig","latestProps","latest","hasPropLengthsChanged","propWatch","PropWatches","IMMUTABLE","immutablePropMatch","SHALLOW","shallowPropMatch","deepCompareDepth","hasPropsToOwnerChanged","checkRenderUp","proSupports","providers","prosWithChanges","hasChange","owner","providersChangeCheck","renderTagUpdateArray","forEach","mapTagUpdate","noData","promiseNoData","bindSubjectCallback","subjectFunction","deleted","bindTo","callbackResult","apply","result","eventHandlerSupport","last","checkAfterCallbackPromise","renderCallbackSupport","afterTagCallback","runTagCallback","tagFunction","actions","processNonDynamicAttr","attrName","howToSet","isSpecial","addSupportEventListener","eventName","elm","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","processAttributeFunction","newAttrValue","fun","isSpecialAttr","startsWith","specialAction","isSpecialAction","emptyCounts","processUpdateAttrContext","contextItem","isNameOnly","attrValue","context","isNoDisplayValue","processNameOnlyAttrValue","updateNameOnlyAttrValue","processAttributeEmit","processAttribute","nameVar","getTagJsVar","addOneContext","isAttr","newValues","valueVar","checkValueChange","checkSimpleValueChange","delete","deleteSimpleValue","withinOwnerElement","contextValueSubject","blankHandler","processNameValueAttributeAttrSubject","processTagCallbackFun","processDynamicNameValueAttribute","wrapper","processAttributeSubjectValue","callbackFun","special","attrPart","tagJsVar","updateBeforeTemplate","lastFirstChild","document","createTextNode","castTextValue","runBeforeDestroy","destroy$","destroyContext","lastArray","iSubs","iSub","getChildTagsToSoftDestroy","tags","subTags","smartRemoveKids","allPromises","promises","destroy","maybePromise","lastPromise","smartRemoveByContext","destroyClones","processContextDestroys","destroyArray","simpleValueElm","subGlobal","oldest","htmlDomMeta","marker","domElement","destroySupport","compareArrayItems","newLength","at","lessLength","prevContext","destroyArrayItem","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","destroyArrayItemByGlobal","checkArrayValueChange","castedValue","oldClone","processUpdateRegularValue","createSupport","castedProps","getBaseSupport","upgradeBaseToSupport","updateExistingValue","forceUpdateExistingValue","prepareUpdateToComponent","processReplacementComponent","lastSupport","oldWrapper","newWrapper","isSameTag","skipComparing","isLikeTags","oldestSupport","swapTags","hasChanged","newTemplater","pastCloneProps","propsChanged","hasPropChanges","hasSupportChanged","newProps","syncFunctionProps","castProps","lastPropsConfig","DEEP","shallowCompareDepth","blocked","updateExistingTagComponent","createAndProcessContextItem","appendTo","placeholder","domProcessContextItem","processTagArray","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","array","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","processFirstSubjectValue","processInit","processFirstRegularValue","domContextHandler","_newValues","newContextItem","attachDynamicDom","depth","someDiv","createElement","attachDomElements","nodes","node","v","isNaN","newNode","nn","attachDomText","attachDomElement","ch","attr","tc","innerHTML","innerText","buildBeforeElement","destorySupportByContextItem","domMeta","thisTag","strings","getDomMeta","loadDomMeta","attachHtmlDomMeta","checkProp","alterProp","already","mem","wrap","toCall","callWith","noCycle","run","isInline","renderInlineHtml","renderExistingReadyTag","safeRenderSupport","callbackPropOwner","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","executeWrap","useSupport","originalFunction","stateless","support0","support1","templater0","templater1","tag0","tag1","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings1","every","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","checkTagValueChange","isTag","tryUpdateToTag","processNewSubjectTag","newSupportByTemplater","processTagInit","processTag","getTemplaterResult","oneRenderToSupport","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","checkStateMismatch","newStates","error","console","hint","throwStateMismatch","runAfterRender","renderTagOnly","reSupport","processRenderOnceInit","processTagComponentInit","processResult","newPropsConfig","getCastedProps","renderWithSupport","appendIndex","processFirstTagResult","processFirstSubjectComponent","tagCount","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","tagUseFn","preCastedProps","lastCastProps","processReplaceTagResult","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","cGlobal","lastTemplater","lastTag","isLikeTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","lastOwnerSupport","wasLikeTags","processUpdateOneContext","updateSupportBy","olderSupport","newerSupport","newTemplate","tempTag","updateSupportValuesBy","len","processUpdateContext","use","route","_routeProps","app","_routeTag","deepPropWatch","immutableProps","watchProps","oneRenderFunction","renderFunction","fooCounts","pop","ownGlobal","NONE","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","pastProp","obEntries","subItem","objectItemMatches","pastValue","baseSupport","clonePropsBy","createHtmlSupport","getFakeTemplater","valueSupport","handleStillTag","nowGlobal","updateToTag","updateToDiffValue","ignoreOrDestroyed","before","processNowRegularValue","setupSubscribe","observable","appendMarker","setup","onValue","hasEmitted","syncRun","valueChangeHandler","newComponent","newestSupport","getLastValue","setupSubscribeCallbackProcessor","deleteMe","processSubscribe","Observable","processSignal","initialValue","Signal","Set","unsub","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","defaultFinally","init","final","pastResult","previousValues","defineOnMethod","getWatch","attachTo","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","newWatch","oldestState","constructMethod","stateDiffMemory","stateDiff","oldStateCount","instance","cm","inject","ownerProviders","find","msg","warn","syncError","createTrigger","finally","callbackStateUpdate","callbackMaker","onInit","onDestroy","processDomTagInit","tagFakeTemplater","variablePrefix","variableSuffix","getStringTag","html","getDomTag","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","splitByTagVar","pushTextTo","attributes","attrMatch","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","search","attrSet","pushTo","postprocessTagsInComments","inputString","filter","part","fragReplacer","safeVar","htmlInterpolationToPlaceholders","results","fragment","diff","balanceArrayByArrays","addPlaceholders","placeholderRegex","replacePlaceholders","valueCount","currentTail","loopTail","attrs","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","safeReplacer","traverseAndRestore","_match","lastRuns","stringId","Number","join","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","htmlInterpolationToDomMeta","template","interpolation","stringTag","appElements","tagElement","appElmIndex","appElm","templater2","isApp","loadNewBaseSupport","getNewSubject","isAppFunction","runWrapper","removeEventListener","toAwait","newFragment","createDocumentFragment","domItem","putOneDomDown","registerTagElement","isFirstRender","executeStateWrap","processSubUpdate","hmr"],"sourceRoot":""}