{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/cycles/getSupportInCycle.function.ts","webpack://taggedjs/./ts/render/dom/blankHandler.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/shallowPropMatch.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContexts.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processFunctionAttr.function.ts","webpack://taggedjs/./ts/TagJsTags/processAttributeUpdate.function.ts","webpack://taggedjs/./ts/TagJsTags/processSimpleAttribute.function.ts","webpack://taggedjs/./ts/TagJsTags/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/TagJsTags/getArrayTagJsTag.function.ts","webpack://taggedjs/./ts/TagJsTags/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/render/addOneContext.function.ts","webpack://taggedjs/./ts/tag/update/arrays/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/arrays/processTagArray.ts","webpack://taggedjs/./ts/tag/update/arrays/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/destroyArrayContext.function.ts","webpack://taggedjs/./ts/tag/destroyHtmlDomMeta.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/destroySupportByContextItem.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/render/runAfterRender.function.ts","webpack://taggedjs/./ts/render/callTag.function.ts","webpack://taggedjs/./ts/state/reState.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/render/checkRenderUp.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bubbleEvent.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/render/attributes/processStandAloneAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateNameOnlyAttrValue.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsTag.function.ts","webpack://taggedjs/./ts/render/attributes/processTagJsAttribute.function.ts","webpack://taggedjs/./ts/render/dom/processAttributeArray.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElement.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribeWith.function.ts","webpack://taggedjs/./ts/TagJsTags/processSubscribeAttribute.function.ts","webpack://taggedjs/./ts/TagJsTags/processSubscribeWithAttribute.function.ts","webpack://taggedjs/./ts/TagJsTags/subscribeWith.function.ts","webpack://taggedjs/./ts/tag/update/handleTagTypeChangeFrom.function.ts","webpack://taggedjs/./ts/tag/update/checkStillSubscription.function.ts","webpack://taggedjs/./ts/TagJsTags/subscribe.function.ts","webpack://taggedjs/./ts/tag/update/deleteContextSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/TagJsTags/getInnerHTML.function.ts","webpack://taggedjs/./ts/TagJsTags/pipe.function.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/TagJsTags/host.function.ts","webpack://taggedjs/./ts/tag/update/getOverrideTagVar.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/convertTagToElementManaged.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/onInit.function.ts","webpack://taggedjs/./ts/state/onDestroy.function.ts","webpack://taggedjs/./ts/TagJsTags/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/TagJsTags/tagInject.function.ts","webpack://taggedjs/./ts/state/onRender.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/processUpdateSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSignal.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/promise.function.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/cycles/setContextInCycle.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/elements/attributeCallables.ts","webpack://taggedjs/./ts/elements/elementFunctions.ts","webpack://taggedjs/./ts/elements/elementVarToHtmlString.function.ts","webpack://taggedjs/./ts/elements/destroyDesignElement.function.ts","webpack://taggedjs/./ts/elements/processDesignElementUpdate.function.ts","webpack://taggedjs/./ts/elements/processChildren.function.ts","webpack://taggedjs/./ts/elements/processElementVarFunction.function.ts","webpack://taggedjs/./ts/elements/processElementVar.function.ts","webpack://taggedjs/./ts/elements/processDesignElementInit.function.ts","webpack://taggedjs/./ts/elements/htmlTag.function.ts","webpack://taggedjs/./ts/elements/noElement.function.ts","webpack://taggedjs/./ts/elements/index.ts","webpack://taggedjs/./ts/version.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/** Only used in TagSupport */\nexport function getNewGlobal(contextItem) {\n    // TODO: Not need for basic supports, only tag()\n    contextItem.renderCount = contextItem.renderCount || 0;\n    contextItem.varCounter = 0;\n    // TODO: Not need for basic supports, only tag()\n    contextItem.state = {\n        newer: {\n            state: [],\n            states: [],\n        },\n    };\n    return contextItem.global = {\n        blocked: [],\n    };\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","import { setUseMemory } from '../../state/index.js';\nimport { setContextInCycle } from './setContextInCycle.function.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    setContextInCycle(support.context);\n    return setUseMemory.stateConfig.support = support;\n}\n","export const blankHandler = function blankHandler() {\n    return undefined;\n};\n","import { blankHandler } from \"./dom/blankHandler.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(_promise) {\n    /*\n    if(paintRemoveAwaits.length) {\n      paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push( ...paintRemoves )\n      paintRemoves = []\n    }\n  \n    paintRemoveAwaits.push({promise, paintRemoves})\n    paintRemoves = []\n    */\n}\n// let paintRemoveAwaits: {promise: Promise<any>, paintRemoves: PaintCommand[]}[] = []\nexport let paintCommands = [];\n// export let paintRemoves: PaintCommand[] = []\nexport const paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\n/** you must lock before calling this function */\nexport function paint() {\n    if (painting.locks > 0) {\n        // throw new Error('double paint')\n        return;\n    }\n    runCycles();\n}\nfunction runCycles() {\n    ++painting.locks;\n    runPaintCycles();\n    --painting.locks;\n    runAfterCycle();\n}\n/** Deletes happen last */\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    const removes = paintRemoves.length;\n    runPaintRemoves();\n    // paintRemoves = []\n    paintRemoves.splice(0, removes);\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element, caller) {\n    paintRemoves.push([paintRemover, [element, caller]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element, _caller) {\n    const parentNode = element.parentNode;\n    if (!element) {\n        console.debug('no element by', {\n            _caller, element\n        });\n    }\n    if (!parentNode) {\n        console.debug('no parentNode by', { _caller, element });\n    }\n    parentNode.removeChild(element);\n}\n/** insertBefore. For parent.appendChild() see paintAppend */\nexport function paintBefore(relative, element, _caller) {\n    const parentNode = relative.parentNode;\n    parentNode.insertBefore(element, relative);\n}\n/** parent.appendChild(). For insertBefore see paintBefore */\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler, _caller) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm, _caller);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm, 'paintBeforeElementString');\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n    // TODO: Start using this instead\n    return value instanceof Function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function findStateSupportUpContext(context) {\n    const stateMeta = context.state;\n    if (stateMeta && stateMeta.newest && stateMeta.newest) {\n        return stateMeta.newest;\n    }\n    if (context.parentContext) {\n        return findStateSupportUpContext(context.parentContext);\n    }\n}\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const context = component.context;\n    const stateMeta = context.state;\n    if (!stateMeta) {\n        return component;\n    }\n    return stateMeta.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevContext = prevSupport.context;\n    const stateMeta = prevContext.state;\n    const prevStateMeta = stateMeta.older;\n    // const prevStateMeta = stateMeta.newer as ContextStateSupport\n    // const prevStateMeta = stateMeta.older || stateMeta.newer as ContextStateSupport\n    const prevStates = prevStateMeta.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        oldStates.lastValues = lastValues;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState } from './stateHandlers.js';\nimport { firstStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** To be called before rendering anything with a state */\nexport function initState(context) {\n    setContextInCycle(context);\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    const state = config.state = [];\n    const states = config.states = [];\n    config.statesIndex = 0;\n    const stateMeta = context.state = context.state || {};\n    stateMeta.newer = { state, states };\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.state.length];\n    config.state.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    const context = getContextInCycle();\n    if (!context || !context.state) {\n        const msg = 'State requested but TaggedJs is not currently rendering a tag or host';\n        console.error(msg, {\n            config,\n            context,\n            function: config.support?.templater.wrapper?.original\n        });\n        throw new Error(msg);\n    }\n    const newer = context.state.newer;\n    config.state = newer.state;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.state.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    value;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n        if (arguments.length > 0) {\n            this.value = value;\n        }\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster.\n     * Once called, unsubscribe occurs.\n     * No subscription to manage UNLESS the callback will never occur THEN subscription needs to be closed with result.unsubscribe() */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        // return this 10-2025 remove\n        return subscription;\n    }\n    pipe(...operations) {\n        const args = [];\n        if ('value' in this) {\n            args.push(this.value);\n        }\n        const subject = new Subject(...args);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    _value;\n    constructor(...args) {\n        super(...args);\n        this._value = args[0];\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        state: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","import { removeContextInCycle, setContextInCycle } from './cycles/setContextInCycle.function.js';\nexport function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    for (const context of contexts) {\n        // const context = contexts[index]\n        processUpdateOneContext(values, context, support);\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\ncontextItem, ownerSupport) {\n    if (contextItem.deleted) {\n        return;\n    }\n    // some values, like style, get rearranged and there value appearance may not match context appearance\n    const valueIndex = contextItem.valueIndex;\n    const newValue = values[valueIndex];\n    // Removed, let the TagJsTags do the checking\n    // Do not continue if the value is just the same\n    /*\n    if(newValue === contextItem.value) {\n      return\n    }\n    */\n    const TagJsTag = contextItem.tagJsVar;\n    setContextInCycle(contextItem);\n    TagJsTag.processUpdate(newValue, contextItem, ownerSupport, values);\n    removeContextInCycle();\n    contextItem.value = newValue;\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const contexts = olderSupport.context.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, contexts);\n    --painting.locks;\n    paint();\n}\nfunction updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { isArray } from '../isInstance.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            // cover null and undefined\n            if (!prop && !pastProp) {\n                continue;\n            }\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = support.context.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    // global.deleted = true\n    support.context.destroy$.next();\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContexts(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContexts(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.destroy(child, ownerSupport);\n            child.deleted = true;\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = child.state.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = child.contexts;\n        // recurse\n        destroyContexts(subTags, support);\n        global.deleted = true;\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = child.state.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = child.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\ncontextItem, ownerSupport) {\n    const tagJsType = contextItem.tagJsVar.tagJsType;\n    const processUpdate = tagJsType && ['tag-conversion', 'element'].includes(tagJsType);\n    if (processUpdate) {\n        // calls processDesignElementUpdate\n        contextItem.tagJsVar.processUpdate(newValue, contextItem, ownerSupport, []);\n        contextItem.value = newValue;\n        return 0;\n    }\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    ++contextItem.updateCount;\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\n","import { removeContextInCycle, setContextInCycle } from \"../../tag/cycles/setContextInCycle.function.js\";\nexport function domProcessContextItem(value, support, contextItem, appendTo, insertBefore) {\n    const subject = support.context;\n    subject.locked = 3;\n    contextItem.target = contextItem.target || appendTo;\n    setContextInCycle(contextItem);\n    if (contextItem.inputsHandler) {\n        const props = support.propsConfig;\n        contextItem.inputsHandler(props);\n    }\n    contextItem.tagJsVar.processInit(value, contextItem, support, insertBefore, appendTo);\n    removeContextInCycle();\n    contextItem.value = value;\n    delete subject.locked;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","/** @deprecated - this needs to be replaced with the source attribute defining itself so select.value`1` just sets itself properly\n * Looking for (class | style) followed by a period\n*/\nexport function isSpecialAttr(attrName, tagName // INPUT, DIV\n) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName === 'value' && tagName === 'SELECT') {\n        return 'value'; // requires being set after put down\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n        case 'autoSelect':\n            return 'autoselect';\n        case 'autofocus':\n        case 'autoFocus':\n            return 'autofocus';\n    }\n    return false;\n}\n","import { isObject } from \"../../index.js\";\nimport { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    paintContent.push([setNonFunctionInputValue, [element, name, value]]);\n}\nfunction howToSetInputObjectValue(element, name, value) {\n    if (typeof element[name] !== 'object') {\n        element[name] = {};\n    }\n    // Handle object values by setting properties directly\n    for (const key in value) {\n        const subValue = value[key];\n        paintContent.push([setObjectValue, [element, name, key, subValue]]);\n    }\n    if (element[name].setProperty) {\n        for (const key in value) {\n            const subValue = value[key];\n            paintContent.push([setPropertyValue, [element, name, key, subValue]]);\n        }\n    }\n}\n/* used for <input checked /> */\nexport function howToSetStandAloneAttr(element, name, _value) {\n    element.setAttribute(name, '');\n}\nexport function setNonFunctionInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used for checked, selected, and so on */\nexport function setBooleanAttribute(element, name, value) {\n    if (value) {\n        element[name] = true;\n    }\n    else {\n        element[name] = false;\n    }\n}\nexport function setSimpleAttribute(element, name, value) {\n    // for checked=true\n    ;\n    element[name] = value;\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n    /*\n    paintAfters.push([(element: HTMLInputElement) => {\n      element.value = value as string\n    }, [element]])\n    */\n}\nfunction setPropertyValue(element, name, key, value) {\n    ;\n    element[name].setProperty(key, value);\n}\n/** main processor for things like <div style=${{ maxWidth: '100vw' }}> */\nfunction setObjectValue(element, name, key, value) {\n    ;\n    element[name][key] = value;\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\nimport { setNonFunctionInputValue } from \"./howToSetInputValue.function.js\";\n/** handles autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            // element.setAttribute(\"autofocus\", 'true')\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n        case 'value':\n            setNonFunctionInputValue(element, name, value);\n            paintAfters.push([(element) => {\n                    element.value = value;\n                }, [element]]);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value; // style.backgroundGround\n    element.style.setProperty(smallName, value); // style.background-ground\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { setNonFunctionInputValue } from './howToSetInputValue.function.js';\nimport { processFunctionAttr } from './processFunctionAttr.function.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial) {\n    contextItem.target = element;\n    contextItem.howToSet = howToSet;\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    if (value?.tagJsType) {\n        return processTagJsAttribute(attrName, value, contextItem, support, element);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, contextItem);\n}\nfunction processTagJsAttribute(name, value, contextItem, ownerSupport, element) {\n    value.processInitAttribute(name, value, element, value, contextItem, ownerSupport, setNonFunctionInputValue);\n    contextItem.tagJsVar = value;\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, context) {\n    if (typeof value === 'function') {\n        return processFunctionAttr(value, context, attrName, element, howToSet);\n    }\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n","import { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { Subject, valueToTagJsVar } from '../../index.js';\n/** Used for bolts like div.style(() => {{backgroundColor:}}) */\nexport function processFunctionAttr(value, parentContext, // parent context\nattrName, element, howToSet) {\n    const innerValue = value();\n    const TagJsTagOverride = {\n        component: false,\n        tagJsType: 'dynamic-attr',\n        matchesInjection: (inject) => {\n            const TagJsTag = subContext.tagJsVar;\n            if (TagJsTag.matchesInjection) {\n                const rtn = TagJsTag.matchesInjection(inject, subContext);\n                return rtn;\n            }\n        },\n        hasValueChanged: (_value, _contextItem, ownerSupport) => {\n            const newValue = value();\n            return subContext.tagJsVar.hasValueChanged(newValue, subContext, ownerSupport);\n        },\n        processInit: blankHandler,\n        processInitAttribute: blankHandler,\n        destroy: (_contextItem, ownerSupport) => {\n            subContext.tagJsVar.destroy(subContext, ownerSupport);\n        },\n        processUpdate: (value, contextItem, ownerSupport, values) => {\n            ++contextItem.updateCount;\n            const newValue = value();\n            // const oldValue = subContext.value\n            // const newTagJsTag = valueToTagJsVar(newValue)\n            subContext.tagJsVar.processUpdate(newValue, // newTagJsTag as any,\n            subContext, ownerSupport, values);\n            subContext.value = newValue;\n        }\n    };\n    const subContext = {\n        updateCount: 0,\n        isAttr: true,\n        target: element,\n        parentContext,\n        value: innerValue, // used for new value comparing\n        tagJsVar: valueToTagJsVar(innerValue),\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        // paintCommands: [],\n    };\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        contexts: [subContext],\n        target: element,\n        parentContext,\n        value,\n        tagJsVar: TagJsTagOverride,\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        // paintCommands: [],\n    };\n    subContext.tagJsVar.processInitAttribute(attrName, innerValue, element, subContext.tagJsVar, subContext, {}, howToSet);\n    return contextItem;\n}\n","import { valueToTagJsVar } from \"./valueToTagJsVar.function.js\";\nexport function processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet) {\n    const oldTag = contextItem.tagJsVar; // contextItem.tagJsVar as TagJsTag\n    const tagValue = value;\n    const checkResult = oldTag.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n    ownerSupport);\n    if (checkResult > 0) {\n        oldTag.destroy(contextItem, ownerSupport);\n        element.removeAttribute(name);\n        const newTagVar = valueToTagJsVar(value);\n        newTagVar.isAttr = true;\n        newTagVar.processInitAttribute(name, value, element, newTagVar, contextItem, ownerSupport, howToSet);\n        contextItem.tagJsVar = newTagVar;\n        return;\n    }\n}\n","import { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { checkSimpleValueChange, deleteSimpleAttribute } from \"./getSimpleTagVar.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\n/** init runner */\nexport function processSimpleAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, contextItem, _ownerSupport, howToSet) {\n    // function swapping\n    tagJsVar.destroy = deleteSimpleAttribute;\n    tagJsVar.hasValueChanged = checkSimpleValueChange;\n    tagJsVar.processUpdate = (value, contextItem, ownerSupport) => {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet);\n    };\n    const isSpecial = isSpecialAttr(name, element.tagName);\n    processNonDynamicAttr(name, value, element, howToSet, isSpecial, contextItem);\n    contextItem.tagJsVar = tagJsVar;\n}\n","import { forceUpdateExistingValue } from \"../index.js\";\nimport { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { processSimpleAttribute } from \"./processSimpleAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nexport function deleteSimpleAttribute(contextItem) {\n    const element = contextItem.target;\n    const name = contextItem.attrName;\n    element.removeAttribute(name);\n}\nexport function getSimpleTagVar(value) {\n    return {\n        component: false,\n        tagJsType: 'simple',\n        value,\n        processInitAttribute: processSimpleAttribute,\n        processInit: processSimpleValueInit,\n        destroy: deleteSimpleValue,\n        // TODO: get to using only checkSimpleValueChange\n        hasValueChanged: checkUpdateDeleteSimpleValueChange, // For attributes, this gets switched to checkSimpleValueChange\n        processUpdate: processStringUpdate, // For attributes, this gets switched to processAttributeUpdate\n        // processUpdate: tagValueUpdateHandler, // For attributes, this gets switched to processAttributeUpdate\n    };\n}\nfunction processStringUpdate(newValue, // newValue\ncontextItem, ownerSupport) {\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, insertBefore, _appendTo) {\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processSimpleValueInit']];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(context) {\n    if (!context.simpleValueElm && context.paint) {\n        context.paint[0] = blankHandler;\n        return; // I'm being deleted before my first render even occurred\n    }\n    const elm = context.simpleValueElm;\n    delete context.simpleValueElm;\n    addPaintRemover(elm, 'deleteSimpleValue');\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || newValue === contextItem.value; // !(typeof(newValue) === BasicTypes.object)\n    if (isRegularUpdate) {\n        return 0; // no need to destroy, just update display\n    }\n    return 6; // 'changed-simple-value'\n}\nexport function checkUpdateDeleteSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || !([BasicTypes.object, BasicTypes.function].includes(typeof (newValue)));\n    if (isRegularUpdate) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return 0; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../TagJsTags/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processNowRegularValue']];\n    paintCommands.push(paint);\n}\n","import { isArray } from '../isInstance.js';\nimport { destroyArrayContext } from './destroyArrayContext.function.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContext(subject);\n        return 9; // 'array'\n    }\n    return 0;\n}\n","import { checkArrayValueChange } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/arrays/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroyArrayContext } from '../tag/destroyArrayContext.function.js';\n/** how to process an array */\nexport function getArrayTagVar(value) {\n    return {\n        component: false,\n        tagJsType: 'array',\n        value,\n        processInitAttribute: blankHandler,\n        processInit: processArrayInit,\n        processUpdate: processArrayUpdates,\n        hasValueChanged: checkArrayValueChange,\n        destroy: destroyArrayContext,\n    };\n}\nfunction processArrayUpdates(newValue, contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    if (Array.isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport);\n        return;\n    }\n    const tagUpdateResponse = tagValueUpdateHandler(newValue, contextItem, ownerSupport);\n    if (tagUpdateResponse === 0) {\n        processTagArray(contextItem, newValue, ownerSupport);\n    }\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsTag.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","import { Subject } from '../subject/Subject.class.js';\nimport { valueToTagJsVar } from '../TagJsTags/valueToTagJsVar.function.js';\nexport function getNewContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = {\n        updateCount: 0,\n        value,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        // paintCommands: [],\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n        parentContext,\n        // TODO: remove with html``\n        // valueIndex: contexts?.length || -1, // when -1 its a raw bolt value\n        // valueIndex: contexts.length\n        valueIndex: parentContext.varCounter,\n    };\n    return contextItem;\n}\n/** auto adds onto parent.contexts */\nexport function addOneContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = getNewContext(value, contexts, withinOwnerElement, parentContext);\n    contexts.push(contextItem);\n    ++parentContext.varCounter;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends } from '../../../render/paint.function.js';\nimport { domProcessContextItem } from '../../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../../ValueTypes.enum.js';\nimport { getNewContext } from '../../../render/addOneContext.function.js';\n/** Used by arrays and subcontext creators like subscribe. Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, contexts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = getNewContext(value, contexts, true, ownerSupport.context);\n    contextItem.withinOwnerElement = false;\n    contextItem.placeholder = element;\n    if (!appendTo) {\n        contextItem.placeholder = insertBefore;\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from '../tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(contextItem, value, // arry of Tag classes\nownerSupport, appendTo) {\n    const noLast = contextItem.lastArray === undefined;\n    if (noLast) {\n        contextItem.lastArray = [];\n    }\n    const lastArray = contextItem.lastArray;\n    let runtimeInsertBefore = contextItem.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            // .key() was not used\n            if (item.value === null) {\n                filteredLast.push(item);\n                continue;\n            }\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        contextItem.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, contextItem.lastArray, ownerSupport, runtimeInsertBefore, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\n/** new and old array items processed here */\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\nappendTo) {\n    const item = castArrayItem(array[index]);\n    const previousContext = lastArray[index];\n    if (previousContext) {\n        return reviewPreviousArrayItem(item, previousContext, lastArray, ownerSupport, index, runtimeInsertBefore, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, lastArray, // acts as contexts aka Context[]\n    runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    if (item) {\n        contextItem.arrayValue = item?.arrayValue || contextItem.arrayValue || index;\n    }\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, context, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\nappendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        if (Array.isArray(value)) {\n            context.tagJsVar.processUpdate(value, context, ownerSupport, []);\n            context.value = value;\n            return context;\n        }\n        tagValueUpdateHandler(value, context, ownerSupport);\n        return context;\n    }\n    // NEW REPLACEMENT\n    const contextItem = createAndProcessContextItem(value, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nexport function castArrayItem(item) {\n    const isBasicFun = typeof item === 'function' && item.tagJsType === undefined;\n    if (isBasicFun) {\n        const fun = item;\n        item = fun();\n    }\n    return item;\n}\n","import { destroySupport } from '../../../render/destroySupport.function.js';\nimport { castArrayItem } from './processTagArray.js';\n/** 1 = destroyed, 2 = value changes, 0 = no change */\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    if (prevContext.arrayValue === undefined) {\n        prevContext.arrayValue = index;\n    }\n    // const oldKey = prevArrayValue.arrayValue === undefined ? index : prevArrayValue.arrayValue\n    const oldKey = prevContext.arrayValue; // || prevContext.value.arrayValue\n    const newValueTag = castArrayItem(value[index]);\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const newKey = newValueTag.arrayValue || index;\n    const isDiff = oldKey !== newKey;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(context) {\n    const global = context.global;\n    destroyArrayItemByGlobal(global, context);\n}\nfunction destroyArrayItemByGlobal(global, context) {\n    if (global && context.state?.oldest) {\n        const support = context.state.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    context.tagJsVar.destroy(context, {});\n}\n","import { destroyArrayItem } from './update/arrays/compareArrayItems.function.js';\nexport function destroyArrayContext(context) {\n    ++context.updateCount;\n    const lastArray = context.lastArray;\n    destroyArray(context, lastArray);\n}\n/** Deletes entire array context not just one */\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { addPaintRemover } from '../render/paint.function.js';\n/** Destroy dom elements and dom space markers */\nexport function destroyHtmlDomMeta(htmlDomMeta) {\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker, 'destroyMarker');\n    }\n    const dom = clone.domElement;\n    addPaintRemover(dom, 'destroyClone');\n}\n","import { destroyArray } from './destroyArrayContext.function.js';\nimport { addPaintRemover } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from './destroyHtmlDomMeta.function.js';\nimport { isPromise } from '../index.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(context, allPromises) {\n    const subContexts = context.contexts;\n    smartRemoveByContext(subContexts, allPromises);\n    destroyHtmlDomMeta(context.htmlDomMeta);\n}\nfunction smartRemoveByContext(contexts, allPromises) {\n    for (const context of contexts) {\n        if (context.withinOwnerElement) {\n            const TagJsTag = context.tagJsVar;\n            if (TagJsTag && TagJsTag.tagJsType === 'host') {\n                const newest = context.supportOwner;\n                const hostDestroy = TagJsTag.destroy(context, newest);\n                if (isPromise(hostDestroy)) {\n                    allPromises.push(hostDestroy);\n                }\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = context.lastArray;\n        if (lastArray) {\n            destroyArray(context, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = context.simpleValueElm;\n        if (elm) {\n            delete context.simpleValueElm;\n            addPaintRemover(elm, 'smartRemoveByContext');\n            continue;\n        }\n        const subGlobal = context.global;\n        if (subGlobal === undefined) {\n            continue; // context\n        }\n        subGlobal.deleted = true;\n        const oldest = context.state?.oldest;\n        if (oldest) {\n            smartRemoveKids(context, allPromises);\n            continue;\n        }\n    }\n}\n","import { destroyContexts } from '../tag/destroyContexts.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const context = support.context;\n    global.deleted = true;\n    context.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const subContexts = context.contexts;\n    destroyContexts(subContexts, support);\n    // tag() only destroy\n    if (support.templater.wrapper) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(context, promises);\n    delete context.state;\n    delete context.contexts;\n    delete context.returnValue;\n    delete context.providers;\n    return promises;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\n/** @deprecated */\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { destroySupport } from '../render/destroySupport.function.js';\nexport function destroySupportByContextItem(context) {\n    ++context.updateCount;\n    const global = context.global;\n    const state = context.state;\n    const lastSupport = state.newest;\n    delete context.inputsHandler;\n    delete context.updatesHandler;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    destroySupportContext(context);\n}\nfunction destroySupportContext(context) {\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    delete context.contexts;\n    delete context.state;\n    delete context.global;\n    context.renderCount = 0;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** When return > 0 then its the same tag */\nexport function checkTagValueChange(newValue, contextItem) {\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            return 7; // 'tag-swap'\n        }\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        if (newValue.wrapper?.original === contextItem.value.wrapper?.original) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    // destroySupportByContextItem(contextItem)\n    return 8; // 'no-longer-tag'\n}\n/*\nexport function checkTagValueChangeAndUpdate(\n  newValue: unknown,\n  contextItem: ContextItem,\n) {\n  const checkValue = checkTagValueChange(newValue, contextItem)\n\n  const global = contextItem.global as SupportTagGlobal\n  const lastSupport = contextItem.state?.newest as AnySupport\n  \n  if(checkValue === 7) {\n    destroySupport(lastSupport, global)\n    getNewGlobal(contextItem as SupportContextItem)\n    return 7 // 'tag-swap'\n  }\n  \n  if(checkValue === 8) {\n    destroySupportByContextItem(contextItem)\n    return 8\n  }\n\n  const isValueTag = isStaticTag(newValue)\n  if(isValueTag) {\n    // always cause a redraw of static tags (was false)\n    tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      lastSupport as AnySupport,\n    )\n\n    return 0\n  }\n\n  const isTag = (newValue as any)?.tagJsType\n  if(isTag) {\n    const state = contextItem.state as ContextStateMeta\n    const support = state.newest as AnySupport\n    const ownerSupport = support.ownerSupport as AnySupport\n    const result = tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      ownerSupport,\n    )\n\n    const doNotRedraw = result === true\n\n    if(doNotRedraw) {\n      return 0\n    }\n\n    return 88 // its same tag with new values\n  }\n\n  destroySupportByContextItem(contextItem)\n  return 8\n}\n*/\nexport function checkTagValueChangeAndUpdate(newValue, contextItem) {\n    const global = contextItem.global;\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport);\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const state = contextItem.state;\n        const support = state.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/addOneContext.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, contexts, support, // owner\nparentContext, depth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, contexts, isWithinOwnerElement, parentContext);\n    contextItem.placeholder = marker;\n    contextItem.target = appendTo;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([\n            paintBefore, [insertBefore, marker, 'attachDynamicDom.attachDynamicDom']\n        ]);\n    }\n    domProcessContextItem(value, support, contextItem, appendTo, insertBefore);\n    return contextItem;\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\n/** Called when one tag changes and we need to find other tags that will need to be rendered */\nexport function providersChangeCheck(support) {\n    const context = support.context;\n    const providers = context.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../cycles/getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, currentDepth) {\n    return props;\n    return props.map(function eachCastProp(prop, pos) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, currentDepth, pos);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth, pos // arguments position\n) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth, pos);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, pos, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth, pos);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth, pos);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth, pos) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth, pos // argument position\n) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport, pos) {\n    // restore object to have original function on destroy\n    if (depth <= 0) {\n        return;\n    }\n    const context = newSupport.context;\n    const castedProps = context.value?.props;\n    if (castedProps) {\n        // check for old prop subscription\n        const prop = castedProps[pos][index];\n        if (prop?.subscription) {\n            prop.subscription(); // unsubscribe to prevent this old argument/prop from being called on destroy\n            prop.restore(); // put original value back\n        }\n    }\n    const altPropRestore = () => {\n        newProp[index] = originalValue;\n    };\n    newProp[index].subscription = newSupport.context.destroy$.toCallback(altPropRestore);\n    newProp[index].restore = altPropRestore;\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const ownerContext = ownerSupport.context;\n    const newest = ownerContext.state?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const context = newest.context;\n        const global = context.global;\n        if (context.locked) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        if (!global) {\n            /*\n            context.tagJsVar.processUpdate(\n              context.value,\n              context,\n              ownerSupport,\n              [],\n            )\n      */\n            ownerContext.tagJsVar.processUpdate(ownerContext.value, ownerContext, ownerSupport, []);\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { hasSupportChanged } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = subject.state.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    if (!global || !subject.state.newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    const newest = subject.state.newest;\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const context = oldSupport.context;\n    const global = context.global;\n    let pIndex = -1;\n    const providers = context.providers = context.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = contextItem.state.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    const t = templater;\n    t.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n}\n","import { hasPropChanges } from './hasPropChanges.function.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContexts.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const context = lastSupport.context;\n    const global = context.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(context.contexts);\n    softDestroyOne(context);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(child.context);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(context);\n}\nfunction softDestroyOne(context) {\n    context.global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(context, []);\n    delete context.contexts;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // tag returns another function expected to be called\n        if (typeof (tag) === BasicTypes.function && tag.tagJsType === undefined) {\n            tag = tag();\n        }\n    }\n    const context = useSupport.context;\n    context.returnValue = tag;\n    useSupport.returnValue = tag;\n    tag.templater = templater;\n    templater.tag = tag;\n    context.state.newer = { ...config };\n    if (context.inputsHandler) {\n        context.inputsHandler(castedProps);\n    }\n    removeContextInCycle();\n    return useSupport;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterSupportRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    runAfterRender(support.context);\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n/** run after rendering anything with state */\nexport function runAfterRender(context) {\n    saveState(context);\n    // TODO: prove this is worth having\n    // checkStateMismatch(config, support)\n    clearStateConfig();\n    // setUseMemory.tagClosed$.next(ownerSupport)\n}\nfunction saveState(context) {\n    const config = setUseMemory.stateConfig;\n    const subject = context || config.context;\n    subject.state = subject.state || {};\n    subject.state.newer = { ...config };\n    const support = config.support;\n    subject.state.newest = support;\n}\nexport function clearStateConfig() {\n    const config = setUseMemory.stateConfig;\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.state;\n    delete config.states;\n    removeContextInCycle();\n}\n","import { ValueTypes } from '../tag/index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { runAfterSupportRender } from './runAfterRender.function.js';\nexport function callTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    let reSupport;\n    const templater = newSupport.templater;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, context, ownerSupport, newSupport.appSupport);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, context, prevSupport);\n    }\n    runAfterSupportRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\n","import { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { runRestate } from './stateHandlers.js';\nimport { reStatesHandler } from './states.utils.js';\nexport function reState(context) {\n    setContextInCycle(context);\n    const stateMeta = context.state;\n    return reStateByPrev(stateMeta.newer.state);\n}\nexport function reStateByPrev(prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.state = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    return config;\n}\nexport function reStateSupport(newSupport, prevSupport, prevState) {\n    reStateByPrev(prevState);\n    const config = setUseMemory.stateConfig;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\n","import { initState } from '../state/state.utils.js';\nimport { callTag } from './callTag.function.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { reStateSupport } from '../state/reState.function.js';\nexport function reRenderTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    const stateMeta = context.state;\n    const prevState = stateMeta.older.state;\n    reStateSupport(newSupport, prevSupport, prevState);\n    return callTag(newSupport, prevSupport, context, ownerSupport);\n}\n/** Used during first renders of a support */\nexport function firstTagRender(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    initState(newSupport.context);\n    setSupportInCycle(newSupport);\n    const result = callTag(newSupport, prevSupport, context, ownerSupport);\n    removeContextInCycle();\n    return result;\n}\nexport function getSupportOlderState(support) {\n    const context = support?.context;\n    const stateMeta = context?.state;\n    return stateMeta?.older?.state;\n}\n/*\nexport function getSupportNewerState(support?: AnySupport) {\n  const context = support?.context as SupportContextItem\n  const stateMeta = context?.state\n  return stateMeta?.newer?.state\n}\n*/ \n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { firstTagRender, getSupportOlderState, reRenderTag } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\ncontext) {\n    let reSupport;\n    const olderState = getSupportOlderState(lastSupport);\n    // const olderState = getSupportNewerState(lastSupport)\n    if (olderState) {\n        reSupport = reRenderTag(newSupport, lastSupport, context);\n    }\n    else {\n        reSupport = firstTagRender(newSupport, lastSupport, context);\n    }\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const context = reSupport.context;\n        context.state.oldest = reSupport;\n        context.state.newest = reSupport;\n        // context.state.older = context.state.newer\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && context.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n        // context.state.older = context.state.newer\n        // context.state.newer = context.state.older\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return {\n        support: reSupport,\n        wasLikeTags: isLikeTag\n    };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    if (result.wasLikeTags) {\n        const oldest = subject.state.oldest; // || result.support\n        updateSupportBy(oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject);\n}\n","import { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = 4;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(subject.state.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownContext = ownerSupport.context;\n    const newest = ownContext.state.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch } from '../tag/hasSupportChanged.function.js';\nimport { shallowPropMatch } from '../tag/shallowPropMatch.function.js';\nexport function checkRenderUp(templater, support) {\n    const global = support.context.global;\n    if (global && global.deleted) {\n        return false;\n    }\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { checkRenderUp } from \"../../render/checkRenderUp.function.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const global = support.context.global;\n    if (global && global.deleted === true) {\n        return supports;\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const providers = newSupport.context.providers;\n    if (providers) {\n        const proSupports = providersChangeCheck(newSupport);\n        supports.push(...proSupports);\n    }\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const context = support.context;\n    const global = context.global;\n    if (!global) {\n        context.tagJsVar.processUpdate(context.value, context, support.ownerSupport, []);\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    const stateMeta = context.state;\n    renderSupport(stateMeta.newest);\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nexport function checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const subject = last.context;\n        const global = subject.global;\n        // delete subject.locked\n        if (subject.deleted === true ||\n            global?.deleted === true // this maybe deprecated\n        ) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = 1; // prevent another render from re-rendering this tag\n    // ++painting.locks\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.context.state.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    // --painting.locks\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, last) {\n    const global = last.context.global;\n    if (global?.deleted) {\n        return;\n    }\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","export function bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.originalStopPropagation = event.stopPropagation;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n            event.stopPropagation = event.originalStopPropagation;\n            delete event.originalStopPropagation;\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { bubbleEvent } from './bubbleEvent.function.js';\nexport function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    const replaceEventName = getEventReferenceName(eventName);\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const context = support.context;\n    const eventReg = context.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nexport function getEventReferenceName(eventName) {\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    return '_' + eventName;\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { BasicTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { processAttribute } from './processAttribute.function.js';\n// single/stand alone attributes\nexport function processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    const newContexts = [];\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const isSpecial = isSpecialAttr(name, element.tagName); // only object variables are evaluated for is special attr\n            const value = attrValue[name];\n            const howToSet = setNonFunctionInputValue;\n            const subContext = processAttribute(name, value, values, element, ownerSupport, howToSet, contexts, parentContext, isSpecial);\n            if (subContext !== undefined) {\n                if (Array.isArray(subContext)) {\n                    newContexts.push(...subContext);\n                }\n                else {\n                    newContexts.push(subContext);\n                }\n            }\n        }\n        return newContexts;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processStandAloneAttribute } from '../../render/attributes/processStandAloneAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue) || attrValue === '') {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    const standAloneResult = processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext);\n    if (standAloneResult) {\n        contexts.push(...standAloneResult);\n    }\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateNameOnlyAttrValue.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\n/** Currently universally used for all attributes */\nexport function processUpdateAttrContext(value, contextItem, ownerSupport, values) {\n    const attrContextItem = contextItem;\n    const tagValue = value;\n    if (tagValue?.tagJsType) {\n        const oldValue = contextItem.value;\n        // its now a tagVar value but before was not\n        if (!oldValue?.tagJsType) {\n            tagValue.isAttr = true;\n            setContextInCycle(contextItem);\n            tagValue.processInitAttribute(attrContextItem.attrName, value, attrContextItem.target, tagValue, attrContextItem, ownerSupport, setNonFunctionInputValue);\n            removeContextInCycle();\n            attrContextItem.tagJsVar = tagValue;\n            return;\n        }\n        oldValue.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n        ownerSupport);\n        return;\n    }\n    if (attrContextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, attrContextItem.value, attrContextItem.target, // global.element as Element,\n        ownerSupport, attrContextItem.howToSet, [], // Context, but we dont want to alter current\n        attrContextItem.parentContext);\n        attrContextItem.value = value;\n        return;\n    }\n    const element = attrContextItem.target;\n    processAttributeEmit(value, attrContextItem.attrName, attrContextItem, element, ownerSupport, attrContextItem.howToSet, attrContextItem.isSpecial);\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsTag } from './getTagJsTag.function.js';\nimport { processStandAloneAttribute } from './processStandAloneAttribute.function.js';\nimport { processTagJsTagAttribute } from './processTagJsAttribute.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(attrName, value, values, // all the variables inside html``\nelement, support, howToSet, //  = howToSetInputValue\ncontexts, parentContext, isSpecial) {\n    const varIndex = getTagJsTag(attrName);\n    let isNameVar = varIndex >= 0 || (value === undefined && typeof (attrName) !== 'string');\n    let valueInValues = values[varIndex];\n    // value or name from bolt?\n    if (value?.tagJsType) {\n        valueInValues = value; // the value is a TagJsTag\n    }\n    else if (attrName?.tagJsType) {\n        isNameVar = true;\n        valueInValues = attrName; // the name is a TagJsTag\n        value = attrName;\n    }\n    const tagJsVar = valueInValues;\n    if (tagJsVar?.tagJsType) {\n        return processTagJsTagAttribute(value, [], // contexts,\n        parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar);\n    }\n    if (isNameVar) {\n        // old way of setting by html``\n        if (varIndex === -1 && isNameVar) {\n            valueInValues = attrName; // its a name only value attribute\n        }\n        const contextItem = getNewContext(valueInValues, [], // contexts,\n        true, parentContext);\n        contextItem.valueIndex = varIndex;\n        contextItem.isAttr = true;\n        contextItem.target = element;\n        contextItem.isNameOnly = true;\n        contextItem.howToSet = howToSet;\n        const TagJsTag = contextItem.tagJsVar;\n        TagJsTag.processUpdate = processUpdateAttrContext;\n        // single/stand alone attributes\n        const aloneResult = processStandAloneAttribute(values, valueInValues, element, support, howToSet, contexts, parentContext);\n        if (aloneResult) {\n            contexts.push(...aloneResult);\n        }\n        return contextItem;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, [], // contexts,\n        howToSet, values, support.context);\n    }\n    const valueVar = getTagJsTag(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, [], // contexts,\n        parentContext, howToSet, support, isSpecial, valueVar);\n    }\n    // simple name/value attribute\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, parentContext);\n}\n/** Only used during updates */\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, _subject) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(\n        // subject,\n        newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processTagCallbackFun(\n// subject: AttributeContextItem,\nnewAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    // const TagJsTag = subject.tagJsVar // = valueToTagJsVar(newAttrValue)\n    // TagJsTag.processUpdate = processUpdateAttrContext\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/index.js';\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../TagJsTags/valueToTagJsVar.function.js';\nimport { Subject } from '../../subject/Subject.class.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, contexts, howToSet, //  = howToSetInputValue\nvalues, parentContext) {\n    const startIndex = contexts.length;\n    const createdContexts = [];\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = contexts.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                updateCount: 0,\n                isAttr: true,\n                target: element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n                valueIndex: parentContext.varCounter, // contexts.length,\n                parentContext,\n                destroy$: new Subject(),\n                render$: new Subject(),\n                // paintCommands: [],\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHandler(value, contextItem, newSupport, newValues) {\n                ++contextItem.updateCount;\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            createdContexts.push(contextItem);\n            ++parentContext.varCounter;\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n    return createdContexts;\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, parentContext, howToSet, //  = howToSetInputValue\nsupport, isSpecial, varIndex) {\n    if (typeof (value) === BasicTypes.function) {\n        ++parentContext.varCounter;\n        return processTagCallbackFun(\n        // contextItem,\n        value, support, attrName, element);\n    }\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        target: element,\n        attrName,\n        howToSet,\n        value,\n        withinOwnerElement: true,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        // paintCommands: [],\n        valueIndex: varIndex,\n        parentContext,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial);\n    contextItem.value = value;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsTag(attrPart) {\n    if (isObject(attrPart) && 'TagJsTag' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** adds onto parent.contexts */\nexport function processTagJsTagAttribute(value, contexts, parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar) {\n    // getOneContext\n    const contextItem = getNewContext(value, contexts || [], true, parentContext);\n    contextItem.target = element;\n    contextItem.valueIndex = varIndex;\n    contextItem.isAttr = true;\n    contextItem.isNameOnly = isNameVar;\n    contextItem.stateOwner = getSupportWithState(support);\n    contextItem.supportOwner = support;\n    setContextInCycle(contextItem);\n    tagJsVar.processInitAttribute(attrName, value, // TagJsTag,\n    element, tagJsVar, contextItem, support, setNonFunctionInputValue);\n    removeContextInCycle();\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = tagJsVar;\n    return contextItem;\n}\n","import { howToSetStandAloneAttr, setNonFunctionInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nexport function processAttributeArray(attrs, values, domElement, support, \n// contexts: ContextItem[],\nparentContext) {\n    for (const attr of attrs) {\n        const name = attr[0];\n        const value = attr[1];\n        const isSpecial = attr[2] || false; // isSpecial2\n        let howToSet = attr.length > 1 ? setNonFunctionInputValue : howToSetStandAloneAttr;\n        if (attr[3]) {\n            howToSet = attr[3];\n        }\n        // const contexts = support.context.contexts\n        const contexts = parentContext.contexts;\n        const newContext = processAttribute(name, value, values, domElement, support, howToSet, contexts, parentContext, isSpecial) || undefined;\n        if (typeof newContext === 'object') {\n            contexts.push(newContext);\n            ++parentContext.varCounter;\n        }\n    }\n}\n","import { paintAppends, paintAppend, paintCommands, paintBefore } from \"../paint.function.js\";\nimport { processAttributeArray } from \"./processAttributeArray.function.js\";\nexport function attachDomElement(domElement, node, values, support, parentContext, appendTo, insertBefore) {\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        processAttributeArray(node.at, values, domElement, support, \n        // contexts,\n        parentContext);\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement, 'appendToAttachDomElement']]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement, 'insertBeforeAttachDomElement']]);\n    }\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppendElementString, paintAppends, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nimport { attachDomElement } from \"./attachDomElement.function.js\";\nimport { Subject } from \"../../subject/Subject.class.js\";\nimport { isFunction } from \"../../index.js\";\nexport function attachDomElements(nodes, values, support, parentContext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const context = support.context;\n    const contexts = context.contexts;\n    parentContext = context;\n    // const contexts = parentContext.contexts\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    // loop map of elements that need to be put down on document\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const v = node.v;\n        const isNum = !isNaN(v);\n        if (isNum) {\n            // const valueIndex = context.varCounter // contexts.length\n            // const valueIndex = (parentContext as SupportContextItem).varCounter // contexts.length\n            const valueIndex = Number(v); // (parentContext as SupportContextItem).varCounter // contexts.length\n            const realValue = values[valueIndex];\n            const isSkipFun = isFunction(realValue) && realValue.tagJsType === undefined;\n            if (isSkipFun) {\n                ++parentContext.varCounter;\n                // TODO: I dont think we ever get in here?\n                continue;\n            }\n            const contextItem = attachDynamicDom(realValue, contexts, support, parentContext, depth, appendTo, insertBefore);\n            contextItem.valueIndex = valueIndex;\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        const domElement = newNode.domElement = document.createElement(node.nn);\n        // Create parent context for attributes first\n        const newParentContext = {\n            updateCount: 0,\n            isAttrs: true,\n            target: domElement,\n            parentContext,\n            contexts: [],\n            destroy$: new Subject(),\n            render$: new Subject(),\n            // paintCommands: [],\n            tagJsVar: {\n                tagJsType: 'new-parent-context'\n            },\n            valueIndex: -1,\n            withinOwnerElement: true,\n        };\n        newParentContext.varCounter = 0;\n        // one single html element. This is where attribute processing takes place\n        attachDomElement(domElement, node, values, support, newParentContext, appendTo, insertBefore);\n        // Update parent context with element and attribute contexts\n        newParentContext.target = domElement;\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, newParentContext, \n            // contexts,\n            depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, contexts };\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\n/** @deprecated - this seems no longer needed? */\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    console.debug('EVER GET HERE??????');\n    const isSpecial = isSpecialAttr(lowerName, 'DIV'); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Merges strings & values with dom meta into a html array tree */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, appendTo, insertBefore) {\n    const subject = support.context;\n    // TODO this is only needed for components and not basic tags\n    subject.state = subject.state || {};\n    const stateMeta = subject.state;\n    stateMeta.oldest = support;\n    stateMeta.newest = support;\n    subject.state.older = subject.state.newer;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, support.context, appendTo, insertBefore);\n    subject.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, parentContext, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const context = support.context;\n    parentContext = context;\n    context.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, parentContext, 0, // depth\n    appendTo, insertBefore);\n    return result;\n}\n/** Extracts variables from support in order to merge strings & values with dom meta into a html array tree */\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChangeAndUpdate } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\nimport { blankHandler } from '../dom/blankHandler.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem) {\n    const support = contextItem.state.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        component: false,\n        tagJsType: ValueTypes.templater,\n        processInitAttribute: blankHandler,\n        processInit: processTagInit,\n        processUpdate: blankHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: blankHandler,\n        propWatch: 'shallow', // deprecate\n        key: blankHandler,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    subject.contexts = subject.contexts || [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\nappendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker, 'subMarker']]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement, 'subAppendTo']]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement, 'subInsertBefore']]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.state = {};\n    if (contextItem.inputsHandler) {\n        const props = ownerSupport.propsConfig;\n        contextItem.inputsHandler(props);\n    }\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        component: false,\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processInitAttribute: blankHandler,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        },\n        matchesInjection(inject, context) {\n            if (templater.wrapper === inject) {\n                return context;\n            }\n            if (templater.wrapper?.original === inject?.original) {\n                return context;\n            }\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../TagJsTags/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, subject, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../TagJsTags/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { firstTagRender } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    firstTagRender(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, appendTo, insertBefore);\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribeWith(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    const subContext = setupSubscribe(value, contextItem, ownerSupport, insertBefore, appendTo);\n    if (!subContext.hasEmitted) {\n        emitSubContext(value, subContext);\n    }\n    return subContext;\n}\nexport function emitSubContext(value, subContext) {\n    const observables = value.Observables;\n    const observable = observables[0];\n    if (!subContext.hasEmitted) {\n        if ('withDefault' in value) {\n            subContext.subValueHandler(value.withDefault, 0);\n            return;\n        }\n        if ('value' in observable) {\n            subContext.subValueHandler(observable.value, 0);\n            return;\n        }\n        return; // nothing to emit\n    }\n    const emitValue = subContext.lastValues[0].value;\n    subContext.subValueHandler(emitValue, 0);\n}\n","import { setNonFunctionInputValue } from \"../index.js\";\nimport { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { unsubscribeContext, checkToPaint, setupSubscribeCallbackProcessor } from \"../tag/update/setupSubscribe.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\nexport function processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // same as value\ncontextItem, ownerSupport) {\n    // change how the delete occurs\n    value.destroy = unsubscribeContext;\n    const isSpecial = isSpecialAttr(name, element.tagName);\n    const onOutput = function onSubValue(callbackValue, syncRun) {\n        processNonDynamicAttr(name, callbackValue, element, setNonFunctionInputValue, isSpecial, contextItem);\n        checkToPaint(syncRun);\n    };\n    const subContext = setupSubscribeCallbackProcessor(value.Observables, ownerSupport, onOutput, value, contextItem);\n    contextItem.subContext = subContext;\n    contextItem.value = value;\n    contextItem.tagJsVar = value;\n    value.processUpdate = function processAttributeUpdateWrap(value, contextItem2, ownerSupport) {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, setNonFunctionInputValue);\n    };\n    return { subContext, onOutput };\n}\n","import { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nexport function processSubscribeWithAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // its the same as the value\ncontextItem, ownerSupport) {\n    const { subContext } = processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\n    element, value, contextItem, ownerSupport);\n    if (!subContext.hasEmitted) {\n        emitSubScriptionAsIs(value, subContext);\n    }\n}\nexport function emitSubScriptionAsIs(value, subContext) {\n    const TagJsTag = subContext.tagJsVar;\n    const onOutput = TagJsTag.onOutput; // value.onOutput\n    const observables = value.Observables;\n    let obValue = observables[0]?.value || value.withDefault;\n    // subContext.hasEmitted = true\n    // subContext.lastValues[0] = obValue\n    if (value.callback) {\n        obValue = value.callback(obValue);\n    }\n    onOutput(obValue, true, subContext);\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribeWith.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { processSubscribeWithAttribute } from \"./processSubscribeWithAttribute.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    // const support = getSupportInCycle() as AnySupport\n    // const context = getSupportWithState(support).context\n    /*\n    const context = getContextInCycle() as ContextItem\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        component: false,\n        onOutput: blankHandler, // this gets set within setupSubscribe\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeWithAttribute,\n        processInit: processSubscribeWith,\n        hasValueChanged: checkSubscribeValueChanged,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        // states: newer.states,\n        Observables: [Observable],\n    };\n}\n/** checks is a previous tag var was a subscription but now has changed */\nexport function checkSubscribeValueChanged(value, contextItem) {\n    if (!value?.tagJsType) {\n        return 1; // its not a subscription anymore\n    }\n    const newObserves = value.Observables;\n    if (!newObserves) {\n        return 2; // its not a subscription anymore\n    }\n    const oldValue = contextItem.value;\n    const oldObserves = oldValue.Observables;\n    if (!oldObserves || oldObserves.length !== newObserves.length) {\n        return 3; // not the same subscription\n    }\n    const allMatch = newObserves.every((ob, index) => ob === oldObserves[index]);\n    if (!allMatch) {\n        return 4;\n    }\n    return 0; // still the same\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** used to handle when value was subscribe but now is something else */\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem) {\n    const isDifferent = !newValue || !newValue.tagJsType || newValue.tagJsType !== originalType;\n    if (isDifferent) {\n        const oldTagJsTag = contextItem.tagJsVar;\n        oldTagJsTag.destroy(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, // subSubContext,\n        ownerSupport, 99);\n        return 99;\n    }\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { handleTagTypeChangeFrom } from './handleTagTypeChangeFrom.function.js';\nexport function checkStillSubscription(newValue, contextItem, ownerSupport) {\n    const subContext = contextItem.subContext;\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    if (!subContext || !subContext.hasEmitted) {\n        return 0;\n    }\n    subContext.tagJsVar = newValue;\n    subContext.valuesHandler(subContext.lastValues, 0);\n    return 0;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\nimport { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { checkStillSubscription } from \"../tag/update/checkStillSubscription.function.js\";\nimport { Subject } from \"../index.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        component: false,\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeAttribute,\n        processInit: setupSubscribe,\n        hasValueChanged: checkSubscribeValueChanged,\n        processUpdate: checkStillSubscription,\n        // processUpdate: processUpdateSubscribe,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states,\n        Observables: [Observable],\n    };\n}\nsubscribe.all = subscribeAll;\nfunction subscribeAll(subjects, callback) {\n    return subscribe(Subject.all(subjects), callback);\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteContextSubContext(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subscription = contextItem.subContext;\n    const result = deleteSubContext(subscription, ownerSupport);\n    delete contextItem.subContext;\n    return result;\n}\nexport function deleteSubContext(subContext, ownerSupport) {\n    subContext.deleted = true;\n    const appendMarker = subContext.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker, 'deleteSubContext');\n        delete subContext.appendMarker;\n    }\n    // delete (contextItem as any).destroy\n    if (!subContext.hasEmitted) {\n        return;\n    }\n    const subContextItem = subContext.contextItem;\n    const subTagJsTag = subContextItem.tagJsVar;\n    subTagJsTag.destroy(subContextItem, ownerSupport);\n    return 76;\n}\n","import { createAndProcessContextItem } from './arrays/createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, [], insertBefore);\n}\n","import { deleteContextSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, contextItem, newSupport) {\n    ++contextItem.updateCount;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        component: false,\n        tagJsType: 'innerHTML',\n        hasValueChanged: () => 0, // not expected to do anything\n        processInitAttribute: blankHandler,\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        destroy: deleteContextSubContext,\n    };\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    /*\n    const support = getSupportInCycle() as AnySupport\n    const context = getSupportWithState(support).context\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        component: false,\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: blankHandler,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInit: processPipe,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states: newer.states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: values,\n    };\n    return setupSubscribe(subValue, contextItem, ownerSupport, undefined, appendTo);\n}\n","import { getContextInCycle, paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\nimport { findStateSupportUpContext } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { removeContextInCycle, setContextInCycle } from \"./cycles/setContextInCycle.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const context = getContextInCycle();\n    // const support = getSupportWithState(context)\n    // const parentContext = context?.parentContext\n    if (!context) {\n        throw new Error('output must be used in render sync with a parent context');\n    }\n    const support = findStateSupportUpContext(context);\n    // const support = getSupportInCycle() as AnySupport\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    if (callback.wrapped === true) {\n        return callback;\n    }\n    const newCallback = (...args) => {\n        const ownerSupport = support.ownerSupport;\n        const result = syncWrapCallback(args, callback, ownerSupport.context);\n        return result;\n    };\n    newCallback.wrapped = true;\n    return newCallback;\n}\nexport function syncWrapCallback(args, callback, context) {\n    const newestOwner = undefined;\n    /*\n    const stateMeta = context.state as ContextStateMeta\n    const newerStates = (stateMeta.newer as ContextStateSupport).states\n    const olderStates = stateMeta.older ? (stateMeta.older as ContextStateSupport).states : newerStates\n    const newestOwner = stateMeta.newest as AnySupport\n  \n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newerStates, olderStates)\n    */\n    setContextInCycle(context);\n    const c = callback(...args); // call the latest callback\n    removeContextInCycle();\n    // sync the old states to the new\n    // syncStatesArray(olderStates, newerStates)\n    // now render the owner\n    paintAfters.push([() => {\n            const newGlobal = context.global;\n            // const newGlobal = newestOwner.context.global\n            const ignore = newGlobal === undefined || newGlobal.deleted === true;\n            if (ignore) {\n                ++painting.locks;\n                const targetContext = context; // newestOwner.context\n                targetContext.tagJsVar.processUpdate(targetContext.value, targetContext, newestOwner, []);\n                --painting.locks;\n                paint();\n                return; // its not a tag anymore\n            }\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { initState } from \"../state/state.utils.js\";\nimport { reState } from '../state/reState.function.js';\nimport { runAfterRender } from \"../render/runAfterRender.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/handleTagTypeChangeFrom.function.js\";\nimport { isFunction } from \"../index.js\";\n/** Use to gain access to element\n * @callback called every render\n */\nexport function host(callback, options = {}) {\n    const baseHost = {\n        tagJsType: ValueTypes.host,\n        processInitAttribute: processHostAttribute,\n        // TODO: maybe a host value can change?\n        hasValueChanged: () => 0,\n        processInit: processHost, // This should be a throw error because only attribute is supported\n        processUpdate: processHostUpdate,\n        destroy: deleteHost,\n        options: { callback, ...options },\n        matchesInjection(inject, context) {\n            const options = inject?.options;\n            if (!options) {\n                return false;\n            }\n            const injectCallback = options?.callback;\n            // Check if the inject target is a host with the same callback\n            if (injectCallback === callback) {\n                return context;\n            }\n            return false;\n        },\n    };\n    const returnFunction = (...args) => {\n        const hostValue = {\n            ...returnFunction,\n            options: { arguments: args, ...options, callback },\n        };\n        return hostValue;\n    };\n    Object.assign(returnFunction, baseHost);\n    // returnFunction.options = { callback }\n    return returnFunction;\n}\n// Attach the functions to the host namespace\n;\nhost.onInit = (callback) => {\n    return host(() => { }, { onInit: callback });\n};\nhost.onDestroy = (callback) => {\n    return host(() => { }, { onDestroy: callback });\n};\nfunction processHostUpdate(newValue, contextItem, ownerSupport) {\n    if (isFunction(newValue) && !newValue?.tagJsType) {\n        throw new Error('issue on its way');\n    }\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, \n    // TagJsTag,\n    ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const oldTagJsTag = contextItem.tagJsVar;\n    const oldOptions = oldTagJsTag.options;\n    // const element = (contextItem as any as AttributeContextItem).target as HTMLInputElement\n    const newHost = newValue;\n    reState(contextItem);\n    const args = (newHost.options.arguments || oldOptions.arguments || []);\n    contextItem.returnValue = newHost.options.callback(...args);\n    runAfterRender(contextItem);\n}\nfunction processHostAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, // same as value not needed\ncontextItem) {\n    return processHost(tagJsVar, contextItem);\n}\n/* Only runs on host() init */\nfunction processHost(tagJsVar, contextItem) {\n    const element = contextItem.target;\n    const state = contextItem.state = {};\n    initState(contextItem);\n    processHostTagJsTag(element, tagJsVar, contextItem, state);\n    runAfterRender(contextItem);\n}\n/** first time run */\nfunction processHostTagJsTag(element, tagJsVar, contextItem, state) {\n    const args = tagJsVar.options.arguments || [];\n    const returnValue = tagJsVar.options.callback(...args);\n    // Store the return value for tag.inject to access\n    contextItem.returnValue = returnValue;\n    // DEPRECATED\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        // const element = contextItem.target as HTMLInputElement\n        options.onInit(element, tagJsVar, contextItem, state);\n    }\n    return returnValue;\n}\nfunction deleteHost(contextItem) {\n    ++contextItem.updateCount;\n    const attrContext = contextItem;\n    const TagJsTag = attrContext.tagJsVar;\n    const options = TagJsTag.options;\n    if (attrContext.destroy$.subscribers.length) {\n        // TODO: Not sure if this needed\n        setContextInCycle(contextItem);\n        syncWrapCallback([], attrContext.destroy$.next.bind(attrContext.destroy$), contextItem);\n        // TODO: Not sure if this needed\n        removeContextInCycle();\n    }\n    // DEPRECATED\n    // TODO: remove this code and use tag.onDestroy instead\n    if (options.onDestroy) {\n        const element = attrContext.target;\n        const hostDestroy = function processHostDestroy() {\n            setContextInCycle(contextItem);\n            const result = options.onDestroy(element, TagJsTag, attrContext, attrContext.state);\n            removeContextInCycle();\n            return result;\n        };\n        const stateOwner = contextItem.stateOwner;\n        return syncWrapCallback([], hostDestroy, stateOwner.context);\n    }\n}\n","import { isPromise } from '../../index.js';\nimport { paint } from '../../render/index.js';\nimport { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { makeRealUpdate, afterDestroy } from './processFirstSubjectComponent.function.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used when a tag() does not return html`` */\nexport function getOverrideTagVar(context, newContext, support, subject) {\n    // support.context = subject as SupportContextItem\n    const overrideTagVar = {\n        component: false,\n        tagJsType: 'tag-conversion',\n        // processInitAttribute: newContext.tagJsVar.processInitAttribute,\n        processInitAttribute: blankHandler, // cannot be an attribute ever\n        processInit: (_value, _contextItem, _ownerSupport) => {\n            if (context.inputsHandler) {\n                const props = support.propsConfig;\n                context.inputsHandler(props);\n            }\n            if (newContext.inputsHandler) {\n                const props = support.propsConfig;\n                newContext.inputsHandler(props);\n            }\n            if (_contextItem.inputsHandler) {\n                const props = support.propsConfig;\n                _contextItem.inputsHandler(props);\n            }\n            const renderContent = context.returnValue;\n            return newContext.tagJsVar.processInit(renderContent, newContext, support, subject.placeholder);\n        },\n        processUpdate: (value, context, ownerSupport) => {\n            if (context.locked || context.deleted) {\n                return;\n            }\n            ++context.updateCount;\n            const oldValue = context.value;\n            const oldType = oldValue.tagJsType;\n            const newType = value?.tagJsType;\n            const hasTypeChanged = newType !== oldType;\n            const hasChanged = checkTagValueChange(value, context);\n            // check to see if the tagConversion itself has changed\n            const changed = hasChanged || hasTypeChanged || overrideTagVar.hasValueChanged(value, context, // aka contextItem,\n            support);\n            if (changed) {\n                overrideTagVar.destroy(context, support);\n                updateToDiffValue(value, context, // newContext\n                ownerSupport, 789);\n                return;\n            }\n            context.locked = 467;\n            context.render$.next(); // cause tag.onRender to fire\n            const convertValue = context.returnValue;\n            makeRealUpdate(newContext, value, context, convertValue, support);\n            delete context.locked;\n        },\n        hasValueChanged: (_value, _context, support) => {\n            const newValue = context.returnValue;\n            const checkResult = newContext.tagJsVar.hasValueChanged(newValue, newContext, support);\n            return checkResult;\n        },\n        destroy: (contextItem, ownerSupport) => {\n            ++context.updateCount;\n            context.deleted = true;\n            delete context.returnValue;\n            const result = newContext.tagJsVar.destroy(newContext, support);\n            if (isPromise(result)) {\n                return result.then(() => {\n                    const result = afterDestroy(context, ownerSupport);\n                    paint();\n                    return result;\n                });\n            }\n            context.destroy$.next();\n            return afterDestroy(context, ownerSupport);\n        }\n    };\n    return overrideTagVar;\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { firstTagRender } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { castProps } from '../props/alterProp.function.js';\nimport { convertTagToElementManaged } from './convertTagToElementManaged.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nfunction createSupportWithProps(templater, subject, ownerSupport) {\n    const newSupport = createSupport(templater, subject, ownerSupport, ownerSupport?.appSupport);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const support = firstTagRender(newSupport, subject.state.newest, // existing tag\n    subject);\n    return support;\n}\nexport function processReplacementComponent(templater, context, ownerSupport) {\n    const support = createSupportWithProps(templater, context, ownerSupport);\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, support.ownerSupport, context);\n    }\n    buildBeforeElement(support, undefined, // element for append child\n    context.placeholder);\n    return support;\n}\nexport function makeRealUpdate(newContext, value, context, convertValue, support) {\n    // We need to deprecate this completely (castProps)\n    const castedProps = castProps(value.props, support, // ownerSupport,\n    0);\n    newContext.value.props = castedProps;\n    const propsConfig = support.propsConfig;\n    if (propsConfig) {\n        propsConfig.castProps = castedProps;\n    }\n    // TODO this outer condition may not be needed at all\n    if (value?.tagJsType === 'tagComponent') {\n        newContext.inputsHandler = context.inputsHandler;\n        newContext.updatesHandler = context.updatesHandler;\n        context.value = value;\n        if (context.inputsHandler) {\n            setContextInCycle(context);\n            const inputsHandler = context.inputsHandler;\n            inputsHandler(castedProps); // .inputs()\n            removeContextInCycle();\n        }\n        if (context.updatesHandler) {\n            setContextInCycle(context);\n            const updatesHandler = context.updatesHandler;\n            updatesHandler(castedProps); // .updates()\n            removeContextInCycle();\n        }\n    }\n    newContext.tagJsVar.processUpdate(convertValue, newContext, support, []);\n    newContext.value = convertValue;\n    // paint()\n}\nexport function afterDestroy(context, _ownerSupport) {\n    delete context.returnValue;\n    delete context.global // = {} as any;\n    ;\n    context.contexts = [];\n    ;\n    context.htmlDomMeta = [];\n    delete context.inputsHandler;\n    delete context.updatesHandler;\n    // context.value.destroy(context, ownerSupport)\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, appendTo) {\n    const support = createSupportWithProps(templater, subject, ownerSupport);\n    // DISCOVER IF tag() did NOT return dom|html\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, ownerSupport, subject);\n    }\n    return processFirstTagResult(support, appendTo);\n}\n","import { Subject } from '../../index.js';\nimport { valueToTagJsVar } from '../../TagJsTags/index.js';\nimport { getOverrideTagVar } from './getOverrideTagVar.js';\nexport function convertTagToElementManaged(support, ownerSupport, subject) {\n    const context = support.context;\n    const newValue = support.returnValue; // context.returnValue\n    // EXAMPLE: ['a','b'].map(x=> tag(() => [div,span]).key(x))\n    /*\n    if(Array.isArray(newValue)) {\n      ;(newValue as any).key = (arrayValue: any) => keyTag(arrayValue, newValue)\n    }\n    */\n    const tagJsVar = valueToTagJsVar(newValue);\n    delete context.global;\n    context.contexts = [];\n    const newContext = {\n        updateCount: 0,\n        value: newValue,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        // paintCommands: [],\n        placeholder: context.placeholder,\n        // not important\n        valueIndex: -1,\n        withinOwnerElement: true,\n        parentContext: context,\n        contexts: context.contexts, // share contexts especially so providers properly crawl my available contexts\n        // contexts: subject.contexts, // share contexts especially so providers properly crawl my available contexts\n    };\n    // context.contexts = [ newContext ] as ContextItem[] & SupportContextItem[]\n    const overrideTagVar = getOverrideTagVar(context, newContext, support, subject);\n    context.tagJsVar = overrideTagVar;\n    // TODO: should we be calling this here?\n    tagJsVar.processInit(newValue, newContext, support, subject.placeholder);\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, appendTo) {\n    const result = buildBeforeElement(support, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\n_insertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processFirstSubjectComponent(value, contextItem, ownerSupport, appendTo);\n    }\n    return processReplacementComponent(value, contextItem, ownerSupport);\n}\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { tag } from '../TagJsTags/tag.function.js';\nimport { state } from './state.function.js';\n/** Used for knowing when html elements have arrived on page */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const nowSupport = getSupportInCycle();\n        if (!nowSupport?.context?.global) {\n            return result;\n        }\n        return checkToResolvePromise(result, nowSupport, {\n            resolvePromise,\n            resolveValue,\n        });\n    });\n    return tag;\n}\nfunction resolvePromise(value) {\n    return value;\n}\nfunction resolveValue(value) {\n    return value;\n}\n","import { state } from \"./state.function.js\";\nimport { getContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../TagJsTags/tag.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const context = getContextInCycle();\n        context.destroy$.toCallback(callback);\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { callback, promise, setUseMemory, state } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../tag/checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from '../tag/destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { getContextInCycle, getElement as getTagElement } from '../tag/cycles/setContextInCycle.function.js';\nimport { tagInject } from './tagInject.function.js';\nimport { onInit as tagOnInit } from '../state/onInit.function.js';\nimport { onDestroy as tagOnDestroy } from '../state/onDestroy.function.js';\nimport { onRender as tagOnRender } from '../state/onRender.function.js';\nimport { getInnerHTML as tagGetInnerHTML, output as outputAlias } from '../index.js';\nlet tagCount = 0;\nconst onClick = makeEventListener('click');\nconst onMouseDown = makeEventListener('mousedown');\nfunction makeEventListener(type) {\n    return function eventListener(toBeCalled) {\n        const wrapped = callback(toBeCalled); // should cause render to occur\n        // run one time\n        state(() => {\n            const element = getTagElement();\n            element.addEventListener(type, wrapped);\n        });\n        return wrapped; // this is what you remove\n    };\n}\nconst tagElement = {\n    get: getTagElement,\n    onclick: onClick,\n    click: onClick,\n    onClick,\n    mousedown: onMouseDown,\n    onmousedown: onMouseDown,\n    onMouseDown: onMouseDown,\n};\ndefineGetSet('onclick', onClick);\ndefineGetSet('click', onClick);\ndefineGetSet('onMouseDown', onMouseDown);\ndefineGetSet('onmousedown', onMouseDown);\ndefineGetSet('mousedown', onMouseDown);\nfunction defineGetSet(name, eventFn) {\n    Object.defineProperty(tag, name, {\n        get() {\n            return eventFn;\n        },\n        set(fn) {\n            return eventFn(fn);\n        },\n    });\n}\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    // ): TagJsComponent<any> {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        templater.hasValueChanged = checkTagValueChangeAndUpdate;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    const returnWrap = parentWrap;\n    /* Used for setting arguments as inputs and outputs. Runs every init and update of tag */\n    returnWrap.inputs = (handler) => {\n        const context = getContextInCycle();\n        context.inputsHandler = handler;\n        return true;\n    };\n    // used for argument updates\n    returnWrap.updates = (handler) => {\n        const context = getContextInCycle();\n        context.updatesHandler = handler;\n        return true;\n    };\n    returnWrap.getInnerHTML = tagGetInnerHTML;\n    // returnWrap.tagJsType = 'component'\n    return returnWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n// actually placing of items into tag memory\n;\ntag.element = tagElement;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.inject = tagInject;\ntag.output = outputAlias;\ntag.onInit = tagOnInit;\ntag.onDestroy = tagOnDestroy;\ntag.onRender = tagOnRender;\ntag.getInnerHTML = tagGetInnerHTML;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.destroy = destroySupportByContextItem;\n        oneRenderFunction.hasValueChanged = function renderOnceNeverChanges() {\n            return 0;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.hasValueChanged = checkTagValueChangeAndUpdate;\n        renderFunction.destroy = destroySupportByContextItem;\n    },\n});\nObject.defineProperty(tag, 'promise', {\n    set(target) {\n        promise(target);\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch } from './hasSupportChanged.function.js';\nimport { shallowPropMatch } from './shallowPropMatch.function.js';\nimport { PropWatches } from '../TagJsTags/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nimport { hasPropLengthsChanged } from '../render/checkRenderUp.function.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Inject a parent tag or host into the current context\n * For host functions, returns the value returned by the host callback\n * For tag components, returns the tag instance itself\n */\nexport function tagInject(targetItem) {\n    const context = getContextInCycle();\n    if (!context) {\n        throw new Error('tag.inject can only be called within a tag or host context');\n    }\n    // Search up the context tree for a matching parent\n    let currentContext = context.parentContext;\n    while (currentContext) {\n        // Check if this is an attributes context with child contexts\n        const contexts = currentContext.contexts;\n        if (contexts) {\n            // Search within the attributes contexts\n            for (const attrContext of contexts) {\n                if (attrContext.isAttr && attrContext.tagJsVar?.matchesInjection) {\n                    // Use the matchesInjection method if available\n                    const inContext = attrContext.tagJsVar.matchesInjection(targetItem, attrContext);\n                    if (inContext !== undefined) {\n                        // For host values, return the returnValue from the context\n                        return inContext.returnValue;\n                    }\n                }\n            }\n        }\n        // Check if this context has a TagJsTag with matchesInjection\n        if (currentContext.tagJsVar?.matchesInjection) {\n            if (currentContext.tagJsVar.matchesInjection(targetItem, currentContext)) {\n                // For tag components, return the tag instance\n                return currentContext.returnValue;\n            }\n        }\n        // Move up to the parent context\n        currentContext = currentContext.parentContext;\n    }\n    const message = `Could not find parent context for tag.inject ${targetItem}`;\n    console.error(message, { targetItem, context });\n    throw new Error(message);\n}\n","import { getContextInCycle, removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../TagJsTags/tag.function.js\";\nexport function onRender(callback) {\n    const context = getContextInCycle();\n    const callbackWrap = (_isFirst) => {\n        // remember current context (old)\n        // const oldIndex = setUseMemory.stateConfig.statesIndex\n        const lastContext = getContextInCycle();\n        // set to inner context cycle with previous state position\n        setContextInCycle(context);\n        const result = callback();\n        // restore previous cycle\n        removeContextInCycle();\n        setContextInCycle(lastContext);\n        return result;\n    };\n    const subscription = context.render$.subscribe(() => {\n        callbackWrap();\n    });\n    const result = callbackWrap();\n    tag.onDestroy(() => subscription.unsubscribe());\n    return result;\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../TagJsTags/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    const global = context.global;\n    global.blocked = [];\n    // context.state.newer = context.state.newer || { ...setUseMemory.stateConfig }\n    if (!context.state) {\n        context.state = {\n            newer: {\n                state: [],\n                states: [],\n            }\n        };\n    }\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, // when appSupport not defined then this support becomes appSupport\nappSupport, castedProps) {\n    support.appSupport = appSupport || support;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsubject, ownerSupport, // when not\nappSupport, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport || support;\n    support.ownerSupport.appSupport = appSupport || support.ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        // its html/dom based tag\n        const support = contextItem.state.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    if (contextItem.inputsHandler) {\n        const props = ownerSupport.propsConfig;\n        contextItem.inputsHandler(props);\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, contextItem.placeholder);\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = newValue;\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    // When last value was not a component\n    if (!contextItem.state.newest) {\n        if (contextItem.inputsHandler) {\n            const props = ownerSupport.propsConfig;\n            contextItem.inputsHandler(props);\n        }\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, contextItem, ownerSupport, ownerSupport.appSupport);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value._innerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, subject, ownerSupport, ownerSupport.appSupport);\n    const lastSubject = oldSupport.context;\n    const oldest = lastSubject.state.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './arrays/processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../TagJsTags/getArrayTagJsTag.function.js';\nexport function updateToDiffValue(newValue, context, ownerSupport, ignoreOrDestroyed) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    delete context.deleted;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(context, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(context, newValue, ownerSupport);\n        context.oldTagJsVar = context.tagJsVar;\n        context.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        context.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) { // TODO: is this check really needed?\n        processNowRegularValue(newValue, context);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Have the context check itself (avoid having to detect old value)\n    const TagJsTag = contextItem.tagJsVar;\n    const ignoreOrDestroyed = TagJsTag.hasValueChanged(newValue, contextItem, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === 0) {\n        return ignoreOrDestroyed; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed);\n    return ignoreOrDestroyed;\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { checkStillSubscription } from './checkStillSubscription.function.js';\nimport { emitSubContext } from './processSubscribeWith.function.js';\nexport function processUpdateSubscribe(newValue, contextItem, ownerSupport) {\n    const resultNum = checkStillSubscription(newValue, // subValue,\n    contextItem, ownerSupport);\n    if (contextItem.hasEmitted !== true) {\n        const Observables = contextItem.value.Observables;\n        if (!Observables) {\n            return;\n        }\n        const Observable = Observables[0];\n        // const subValue = Observable.value\n        if (!('value' in Observable)) {\n            return; // its never emitted\n        }\n    }\n    if (resultNum === 0 && newValue.callback) {\n        const subContext = contextItem.subContext;\n        emitSubContext(newValue, subContext);\n    }\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { deleteSubContext } from './deleteContextSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nimport { valueToTagJsVar } from '../../TagJsTags/valueToTagJsVar.function.js';\nimport { processUpdateSubscribe } from './processUpdateSubscribe.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nexport function setupSubscribe(value, contextItem, ownerSupport, insertBeforeOriginal, // optional but will always be made\nappendTo) {\n    const observables = value.Observables;\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    let onOutput = function onSubValue(value, syncRun, subContext) {\n        onFirstSubContext(value, subContext, ownerSupport, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = subContext.tagJsVar.onOutput = function subscriptionUpdate(updateValue, syncRun, subContext) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport);\n            aContext.tagJsVar.processUpdate(updateValue, aContext, ownerSupport, [updateValue]);\n            // processUpdateContext(ownerSupport)\n            aContext.value = updateValue;\n            checkToPaint(syncRun);\n        };\n    };\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, (value, syncRun, subContext) => onOutput(value, syncRun, subContext), value, contextItem);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    value.processUpdate = processUpdateSubscribe;\n    value.onOutput = onOutput;\n    return subContext;\n}\n/** After calling this function you need to set `contextItem.subContext = subContext` */\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\nonOutput, tagJsVar, contextItem) {\n    // const component = getSupportWithState(ownerSupport)\n    // onValue mutates so function below calls original and mutation\n    function subValueHandler(value, index) {\n        subContext.lastValues[index] = {\n            value,\n            tagJsVar: valueToTagJsVar(value),\n            oldTagJsVar: subContext.lastValues[index]?.tagJsVar\n        };\n        valuesHandler(subContext.lastValues, index);\n    }\n    function valuesHandler(newValues, index) {\n        const newestParentTagJsVar = subContext.tagJsVar;\n        const callback = newestParentTagJsVar?.callback;\n        if (callback) {\n            setContextInCycle(contextItem);\n            const responseValue = newestParentTagJsVar.callback(...newValues.map(x => x.value));\n            onOutput(responseValue, syncRun, subContext);\n            removeContextInCycle();\n            return;\n        }\n        const newValue = newValues[index].value;\n        onOutput(newValue, syncRun, subContext);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        subValueHandler,\n        valuesHandler,\n        tagJsVar,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => subValueHandler(value, index)));\n        syncRun = false;\n    });\n    tagJsVar.onOutput = onOutput;\n    return subContext;\n}\nexport function unsubscribeContext(contextItem) {\n    const subscription = contextItem.subContext;\n    if (!subscription) {\n        return; // TODO: wonder why this happens, maybe subscription never emits?\n    }\n    const subscriptions = subscription.subscriptions;\n    subscriptions.forEach(sub => sub.unsubscribe());\n    delete contextItem.subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subContext = contextItem.subContext;\n    unsubscribeContext(contextItem);\n    return deleteSubContext(subContext, ownerSupport);\n}\nexport function checkToPaint(syncRun) {\n    if (syncRun) {\n        return;\n    }\n    if (setUseMemory.stateConfig.support) {\n        return;\n    }\n    paint();\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nexport function processSignal(value, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: [value],\n    };\n    setupSubscribe(subValue, contextItem, ownerSupport, _insertBefore, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSignal.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { checkSubscribeValueChanged } from '../TagJsTags/subscribeWith.function.js';\nimport { processUpdateSubscribe } from '../tag/update/processUpdateSubscribe.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        component: false,\n        tagJsType: ValueTypes.signal,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInitAttribute: blankHandler,\n        processInit: processSignal,\n        processUpdate: processUpdateSubscribe,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        destroy: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { ValueSubject } from '../subject/index.js';\nimport { tag } from '../tag/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\n/** @deprecated -\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback).pastResult;\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup).pastResult;\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const isFun = typeof (currentValues) === 'function';\n    const realValues = isFun ? currentValues() : currentValues;\n    const isFirstRender = previous.values === undefined;\n    let renderCount = 0;\n    if (isFirstRender) {\n        if (typeof (currentValues) === 'function') {\n            tag.onRender(() => {\n                ++renderCount;\n                if (renderCount === 1) {\n                    return; // first run is already performed\n                }\n                const realValues = currentValues();\n                processRealValues(realValues);\n            });\n        }\n    }\n    function processRealValues(realValues) {\n        // First time running watch?\n        if (previous.values === undefined) {\n            if (before && !before(realValues)) {\n                previous.values = realValues;\n                return previous; // do not continue\n            }\n            const castedInit = init || callback;\n            const result = castedInit(realValues, previous.values);\n            previous.pastResult = final(result);\n            previous.values = realValues;\n            return previous;\n        }\n        const allExact = realValues.every((item, index) => item === previous.values[index]);\n        if (allExact) {\n            return previous;\n        }\n        if (before && !before(realValues)) {\n            previous.values = realValues;\n            return previous; // do not continue\n        }\n        const result = callback(realValues, previous.values);\n        previous.pastResult = final(result);\n        previous.values.length = 0;\n        previous.values.push(...realValues);\n        return previous;\n    }\n    return processRealValues(realValues);\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => {\n                return new ValueSubject(undefined);\n            });\n            const oldState = state(() => ({\n                state: setUseMemory.stateConfig.state,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                const handler = (realValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(realValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.state;\n                        const context = firstSupport.context;\n                        const stateMeta = context.state;\n                        const oldestStateSupport = stateMeta.older;\n                        if (oldestStateSupport) {\n                            /*\n                            const oldestState = oldestStateSupport.state\n                            \n                            const newStates = oldState.states\n                            const oldStates = oldestStateSupport.states\n                            \n                            oldSyncStates(\n                              newestState,\n                              oldestState,\n                              newStates,\n                              oldStates,\n                            )\n                            */\n                        }\n                    }\n                    subject.next(setTo);\n                };\n                setupWatch(currentValues, handler, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            state: setUseMemory.stateConfig.state,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    //const nowSupport = getSupportInCycle() as AnySupport\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            /*\n            const context = nowSupport.context as SupportContextItem\n            const stateMeta = context.state as ContextStateMeta\n            const newer = stateMeta.newer as ContextStateSupport\n      \n            oldSyncStates(\n              newer.state,\n              oldestState.state,\n              newer.states,\n              oldestState.states,\n            )\n            */\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        state: setUseMemory.stateConfig.state,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        /*\n        const context = nowSupport.context as SupportContextItem\n        const stateMeta = context.state as ContextStateMeta\n        const newer = stateMeta.newer\n        if (newer) {\n          oldSyncStates(\n            newer.state,\n            oldestState.state,\n            newer.states,\n            oldestState.states,\n          )\n        }\n          */\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** @deprecated - Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.state.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.state.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const context = support.context;\n            // const global = context.global as SupportTagGlobal\n            const providers = context.providers = context.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const context = owner.ownerSupport.context;\n            // const ownGlobal = context.global as SupportTagGlobal\n            const ownerProviders = context.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const context = support.context;\n                const providers = context.providers = context.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { paint } from '../tag/index.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const context = getContextInCycle();\n    const callbackState = state({\n        callback,\n    });\n    // ensure only one trigger instance created and always returned\n    const callbackTrigger = state(() => createTrigger(context, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callbackState));\n    // always update callback to latest in cycle\n    callbackState.callback = callback;\n    return callbackTrigger;\n}\nexport function createTrigger(context, oldState, callbackState) {\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        // ++painting.locks\n        const result = callbackStateUpdate(context, oldStates, callbackState.callback, ...args);\n        // --painting.locks\n        paint();\n        return result;\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nimport { findStateSupportUpContext } from '../interpolations/attributes/getSupportWithState.function.js';\nexport default function callbackStateUpdate(context, _oldStates, callback, ...args) {\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    const newestSupport = findStateSupportUpContext(context);\n    // TODO: This if may not be ever doing anything\n    if (!newestSupport) {\n        return maybePromise;\n    }\n    // context.global && \n    if (newestSupport.context.global) {\n        renderSupport(newestSupport); // TODO: remove with html``\n    }\n    else {\n        const supContext = newestSupport.context;\n        supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n        []);\n    }\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            if (context.global) {\n                renderSupport(newestSupport); // TODO: remove\n            }\n            else {\n                const supContext = newestSupport.context;\n                supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n                []);\n            }\n        });\n    }\n    return maybePromise;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport const callbackMaker = () => {\n    const context = getContextInCycle();\n    // const support = getSupportInCycle()\n    // callback as typeof innerCallback\n    if (!context) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(context, oldState, { callback });\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { createTrigger } from './callback.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nconst emptyCallback = () => undefined;\n/** Attach a promise to the render cycle so resolve triggers a re-render. */\nexport function promise(target) {\n    const context = getContextInCycle();\n    const callbackState = state({ callback: emptyCallback });\n    const promiseState = state({ current: undefined });\n    const trigger = state(() => createTrigger(context, setUseMemory.stateConfig, callbackState));\n    if (promiseState.current !== target) {\n        promiseState.current = target;\n        const currentPromise = target;\n        target.then(() => {\n            if (promiseState.current !== currentPromise) {\n                return;\n            }\n            trigger();\n        });\n    }\n}\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { setUseMemory } from '../../state/index.js';\nexport function getContextInCycle() {\n    return setUseMemory.stateConfig.context;\n}\n/** Gets the current element associated with taggedjs document processing */\nexport function getElement() {\n    const context = getContextInCycle();\n    return context.target;\n}\n// const contextCycles: ContextItem[] = []\nexport function setContextInCycle(context) {\n    // contextCycles.push(context)\n    return setUseMemory.stateConfig.context = context;\n}\nexport function removeContextInCycle() {\n    // contextCycles.pop()\n    delete setUseMemory.stateConfig.context;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { setSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\nimport { removeContextInCycle } from './cycles/setContextInCycle.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\nconst TAG_ELEMENT_MARKER = '__taggedjs_tag_element__';\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, // aka appElement\nprops) {\n    const wasTagged = element[TAG_ELEMENT_MARKER];\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (wasTagged || appElmIndex >= 0) {\n        console.warn('tagElement called multiple times for the same element', { element });\n    }\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n    }\n    ;\n    element[TAG_ELEMENT_MARKER] = true;\n    element.innerHTML = '';\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    const newest = subject.state.newest;\n    initState(newest.context);\n    setSupportInCycle(newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            subject.state.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const result = renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n    removeContextInCycle();\n    return result;\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        component: false,\n        tagJsType: 'templater',\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        processInitAttribute: blankHandler,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const context = {\n        updateCount: 0,\n        value: templater,\n        valueIndex: 0,\n        varCounter: 0,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        // paintCommands: [],\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        state: {},\n        // parentContext: undefined as any,\n        tagJsVar,\n    };\n    // sets new global on context\n    getNewGlobal(context);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    context.events = {};\n    loadNewBaseSupport(templater, context, appElement);\n    return context;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    newSupport.context = subject;\n    // Initialize older/newer with empty state if first render\n    if (!subject.state.oldest) {\n        subject.state.oldest = newSupport;\n        subject.state.older = subject.state.newer;\n    }\n    subject.state.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { processReplacementComponent } from '../tag/update/processFirstSubjectComponent.function.js';\n// Imports used only by the commented-out runWrapper/executeStateWrap functions:\n// import { ContextStateSupport } from '../tag/ContextStateMeta.type.js'\n// import { Wrapper } from '../index.js'\n// import { createSupport } from '../tag/createSupport.function.js'\n// import { runAfterSupportRender } from './runAfterRender.function.js'\n// import { executeWrap } from './executeWrap.function.js'\n// import { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js'\n// import { reStateSupport } from '../state/reState.function.js'\nexport function renderTagElement(app, global, templater, templater2, element, // appElement\ncontext, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    context.placeholder = placeholder;\n    /*\n    const support = runWrapper(\n      templater,\n      placeholder,\n      element,\n      context,\n      isAppFunction,\n    )\n    */\n    global.isApp = true;\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = context.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        context.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    const ownerSupport = {\n        appSupport: {\n            appElement: element,\n            context,\n        },\n        appElement: element,\n        context,\n        isRoot: true,\n    };\n    const support = processReplacementComponent(templater, context, ownerSupport);\n    support.appElement = element;\n    // support.appSupport = support\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    /*\n    const newFragment = registerTagElement(\n      support,\n      element,\n      global,\n      templater,\n      app,\n      placeholder,\n    )\n    */\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\n","function isTemplateStringsArray(value) {\n    return (Array.isArray(value) &&\n        Object.prototype.hasOwnProperty.call(value, 'raw'));\n}\nexport function makeAttrCallable(attrName, attr) {\n    return function (item, stringsOrValue, values) {\n        if (isTemplateStringsArray(stringsOrValue)) {\n            const attrValue = stringsOrValue.reduce((all, chunk, index) => all + chunk + (values[index] ?? ''), '');\n            return attr(item, [attrName, attrValue]);\n        }\n        return attr(item, [attrName, stringsOrValue]);\n    };\n}\n","import { isFunction, isObject } from '../index.js';\nimport { setBooleanAttribute, setNonFunctionInputValue, setSimpleAttribute } from '../interpolations/attributes/howToSetInputValue.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { makeAttrCallable } from './attributeCallables.js';\nfunction callbackWrapper(item, eventName, callback) {\n    const clone = getPushKid(item, item.elementFunctions);\n    return callbackWrapper2(clone, eventName, callback);\n}\nfunction callbackWrapper2(item, eventName, callback) {\n    function wrapCallback(e) {\n        return wrapCallback.toCallback(e);\n    }\n    wrapCallback.toCallback = callback;\n    item.listeners.push([eventName, wrapCallback]);\n    item.allListeners.push([eventName, wrapCallback]);\n    return item;\n}\nfunction attr(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    clone.attributes.push(args);\n    bumpContentId(clone, args[1]);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsTag\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsTag\n    }\n    return clone;\n}\n/** attrs({names: values}) */\nfunction attrs(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    Object.entries(args).map(args => {\n        clone.attributes.push(args);\n        bumpContentId(clone, args[1]);\n        if (isValueForContext(args[0])) {\n            registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsTag\n        }\n        else if (isValueForContext(args[1])) {\n            registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsTag\n        }\n    });\n    return clone;\n}\nconst style = makeAttrCallable('style', attr);\nconst idCallable = makeAttrCallable('id', attr);\nconst classCallable = makeAttrCallable('class', attr);\nconst href = makeAttrCallable('href', attr);\nconst value = makeAttrCallable('value', attr);\nconst placeholder = makeAttrCallable('placeholder', attr);\nconst src = makeAttrCallable('src', attr);\nconst title = makeAttrCallable('title', attr);\nconst type = makeAttrCallable('type', attr);\nconst checked = makeAttrCallable('checked', attr);\nconst disabled = makeAttrCallable('disabled', attr);\nconst selected = makeAttrCallable('selected', attr);\nconst minLength = makeAttrCallable('minLength', attr);\nconst maxLength = makeAttrCallable('maxLength', attr);\nconst open = makeAttrCallable('open', attr); // dialog element\nconst cellPadding = makeAttrCallable('cellpadding', attr);\nconst cellSpacing = makeAttrCallable('cellspacing', attr);\nconst border = makeAttrCallable('border', attr);\nfunction attr2(item, args) {\n    // const clone = getPushKid(item as any, item.elementFunctions)\n    // clone.attributes.push(args as Attribute)\n    item.attributes.push(args);\n    bumpContentId(item, args[1]);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], item); // the attrName is a function or TagJsTag\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], item); // the attrValue is a function or TagJsTag\n    }\n    return item;\n}\nexport function elementFunctions(item) {\n    /** Used for all element callbacks */\n    function makeCallback(eventName) {\n        return function (callback) {\n            return callbackWrapper(item, eventName, callback);\n        };\n    }\n    // TODO: This maybe the old way of doing things (see callables)\n    // This seems to be for supporting div.onClick()\n    const callables_other = {\n        // ...eventCallables,\n        onClose: makeCallback('onclose'),\n        onCancel: makeCallback('oncancel'),\n        onDoubleClick: makeCallback('ondblclick'),\n        onClick: makeCallback('click'),\n        // onclick: makeCallback('click'),\n        // click: makeCallback('click'),\n        onBlur: makeCallback('onblur'),\n        onChange: makeCallback('onchange'),\n        onInput: makeCallback('oninput'),\n        // onchange: makeCallback('onchange'),\n        // change: makeCallback('onchange'),\n        contextMenu: makeCallback('contextmenu'),\n        onMousedown: makeCallback('onmousedown'),\n        onMouseup: makeCallback('onmouseup'),\n        onMouseover: makeCallback('onmouseover'),\n        onMouseout: makeCallback('onmouseout'),\n        onKeydown: makeCallback('onkeydown'),\n        onKeyup: makeCallback('onkeyup'),\n        // onkeyup: makeCallback('onkeyup'),\n        // keyup: makeCallback('onkeyup'),\n        /* apply attribute via attr(name: string, value?: any): **/\n        attr: (...args) => attr(item, args),\n        attrs: (attributes) => attrs(item, attributes),\n        /** Used for setting array index-key value */\n        key: function (arrayValue) {\n            ;\n            this.arrayValue = arrayValue;\n            return this;\n        },\n        /** Use as div.style`border:${border}` or div.style(() => `border:${border}`) */\n        style: makeAttr(style, item),\n        /** Use as div.id`main` or div.id(() => `main-${1}`) */\n        id: makeAttr(idCallable, item),\n        /** Use as div.class`primary` or div.class(() => `primary`) */\n        class: makeAttr(classCallable, item),\n        /** Use as a.href`/path` or a.href(() => `/path`) */\n        href: makeAttr(href, item),\n        /** Use as input.value`text` or input.value(() => `${value}`) */\n        value: makeAttr(value, item),\n        /** Use as input.placeholder`text` or input.placeholder(() => `${value}`) */\n        placeholder: makeAttr(placeholder, item),\n        /** Use as input.src`text` or input.src(() => `${value}`) */\n        src: makeAttr(src, item),\n        /** Use as input.type`text` or input.type(() => `${value}`) */\n        type: makeAttr(type, item),\n        /** Use as input.type`text` or input.type(() => `${value}`) */\n        title: makeAttr(title, item),\n        /** Use as input.checked`boolean` or input.checked(() => `${boolean}`) */\n        checked: makeAttr(checked, item),\n        /** Use as input.checked`boolean` or input.checked(() => `${boolean}`) */\n        disabled: makeAttr(disabled, item),\n        /** Use as input.checked`boolean` or input.checked(() => `${boolean}`) */\n        selected: makeAttr(selected, item),\n        cellSpacing: makeAttr(cellSpacing, item),\n        cellPadding: makeAttr(cellPadding, item),\n        border: makeAttr(border, item),\n        minLength: makeAttr(minLength, item),\n        maxLength: makeAttr(maxLength, item),\n        open: makeAttr(open, item), // html dialog\n    };\n    return callables_other;\n}\nfunction bumpContentId(item, attrValue) {\n    let bump = 1;\n    if (attrValue != null && typeof attrValue !== 'function' && typeof attrValue.length === 'number') {\n        bump += attrValue.length;\n    }\n    item.contentId += bump;\n}\nfunction makeAttr(handler, item) {\n    return ((stringsOrValue, ...values) => {\n        return handler(item, stringsOrValue, values);\n    });\n}\nfunction setClassValue(element, name, value) {\n    if (isObject(value)) {\n        Object.entries(value).forEach(([name, value]) => {\n            if (value) {\n                element.classList.add(name);\n            }\n            else {\n                element.classList.remove(name);\n            }\n        });\n        return; // howToSetInputObjectValue(element, name, value as Record<string, any>)\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used during updates */\nexport function registerMockAttrContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n    ++mockElm.contentId;\n}\nexport function isValueForContext(value) {\n    return Array.isArray(value) || isFunction(value) || value?.tagJsType;\n}\nfunction setupAttr(attrName, howToSet) {\n    return (item, value) => attr2(item, [attrName, value, false, howToSet]);\n}\nfunction makeCallback(eventName) {\n    return (item, callback) => {\n        return callbackWrapper2(item, eventName, callback);\n    };\n}\nconst eventCallables = {\n    onClick: makeCallback('click'),\n    onDoubleClick: makeCallback('ondblclick'),\n    onDblClick: makeCallback('ondblclick'),\n    onBlur: makeCallback('onblur'),\n    onChange: makeCallback('onchange'),\n    onCancel: makeCallback('oncancel'),\n    onClose: makeCallback('onclose'), // dialog\n    onInput: makeCallback('oninput'),\n    onMousedown: makeCallback('onmousedown'),\n    onMouseDown: makeCallback('onmousedown'),\n    onMouseup: makeCallback('onmouseup'),\n    onMouseUp: makeCallback('onmouseup'),\n    onMouseover: makeCallback('onmouseover'),\n    onMouseOver: makeCallback('onmouseup'),\n    onMouseout: makeCallback('onmouseout'),\n    onMouseOut: makeCallback('onmouseout'),\n    onKeyup: makeCallback('onkeyup'),\n    onKeyUp: makeCallback('onkeyup'),\n    onKeydown: makeCallback('onkeydown'),\n    onKeyDown: makeCallback('onkeydown'),\n};\nconst callables = {\n    checked: setupAttr('checked', setBooleanAttribute),\n    disabled: setupAttr('disabled', setBooleanAttribute),\n    selected: setupAttr('selected', setBooleanAttribute),\n    /** element.setAttribute('style', x)  */\n    class: setupAttr('class', setClassValue),\n    ...eventCallables\n};\nexport function loopObjectAttributes(item, object) {\n    const result = Object.entries(object).reduce((all, [name, value]) => {\n        if (name in callables) {\n            return callables[name](item, value);\n        }\n        return attr2(item, [name, value, false, setNonFunctionInputValue]);\n    }, item);\n    return result;\n}\n","export function elementVarToHtmlString(element) {\n    return renderElement(element);\n}\nfunction renderElement(element) {\n    const attributes = renderAttributes(element.attributes);\n    const children = renderChildren(element.innerHTML);\n    return `<${element.tagName}${attributes}>${children}</${element.tagName}>`;\n}\nfunction renderAttributes(attributes) {\n    if (!attributes || attributes.length === 0) {\n        return '';\n    }\n    const parts = [];\n    attributes.forEach(attr => {\n        const name = attr[0];\n        if (typeof name !== 'string' || name.length === 0) {\n            return;\n        }\n        const value = resolveDynamicValue(attr[1]);\n        if (value === true) {\n            parts.push(name);\n            return;\n        }\n        if (value === false || value === undefined || value === null) {\n            return;\n        }\n        parts.push(`${name}=\"${escapeHtml(String(value))}\"`);\n    });\n    return parts.length > 0 ? ` ${parts.join(' ')}` : '';\n}\nfunction renderChildren(children) {\n    if (!children || children.length === 0) {\n        return '';\n    }\n    return children\n        .map(child => {\n        const resolved = resolveDynamicValue(child);\n        if (isElementLike(resolved)) {\n            return renderElement(resolved);\n        }\n        if (Array.isArray(resolved)) {\n            return renderChildren(resolved);\n        }\n        if (resolved === undefined || resolved === null || resolved === false) {\n            return '';\n        }\n        return escapeHtml(String(resolved));\n    })\n        .join('');\n}\nfunction isElementLike(value) {\n    return !!value && typeof value === 'object' && typeof value.tagName === 'string';\n}\nfunction escapeHtml(value) {\n    return value\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;');\n}\nfunction resolveDynamicValue(value) {\n    if (typeof value === 'function') {\n        return value();\n    }\n    return value;\n}\n","import { isPromise } from '../index.js';\nimport { paint, paintCommands, painting } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\nexport function destroyDesignElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (context.paintCommands) {\n        for (let index = paintCommands.length - 1; index >= 0; --index) {\n            const paint = paintCommands[index];\n            const matchIndex = context.paintCommands.indexOf(paint);\n            if (matchIndex >= 0) {\n                paintCommands.splice(index, 1);\n                context.paintCommands.splice(matchIndex, 1);\n                if (context.paintCommands.length === 0) {\n                    break;\n                }\n            }\n        }\n        delete context.paintCommands;\n        afterElementDestroy(context);\n        return; // do not continue\n    }\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            context.deleted = true;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                destroyHtmlDomMeta(htmlDomMeta);\n                afterElementDestroy(context);\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n    destroyHtmlDomMeta(context.htmlDomMeta);\n    afterElementDestroy(context);\n}\nexport function afterElementDestroy(context) {\n    context.htmlDomMeta = [];\n    delete context.contexts;\n    context.deleted = true;\n}\nexport function destroyDesignByContexts(contexts, ownerSupport, promises) {\n    const context = contexts[0];\n    const result = context.tagJsVar.destroy(context, ownerSupport);\n    context.deleted = true;\n    if (isPromise(result)) {\n        return promises.push(result.then(() => {\n            if (contexts.length > 1) {\n                return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n            }\n        }));\n    }\n    if (context.htmlDomMeta) {\n        destroyHtmlDomMeta(context.htmlDomMeta);\n        delete context.htmlDomMeta;\n    }\n    if (contexts.length > 1) {\n        return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n    }\n}\n","import { updateToDiffValue } from '../tag/update/updateToDiffValue.function.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nexport function processDesignElementUpdate(value, context, ownerSupport) {\n    const skip = context.locked || context.deleted === true;\n    if (skip) {\n        return; // something else is running an event\n    }\n    ++context.updateCount;\n    const hasChanged = checkTagElementValueChange(value, context);\n    if (hasChanged) {\n        destroyDesignElement(context, ownerSupport);\n        // delete context.htmlDomMeta // The next value needs to know its not been deleted\n        context.htmlDomMeta = []; // The next value needs to know its not been deleted\n        // context.deleted = true // its not deleted but changed\n        delete context.deleted; // its not deleted but changed\n        updateToDiffValue(value, context, // newContext,\n        ownerSupport, 789);\n        return;\n    }\n    const contexts = context.contexts;\n    const vContexts = value.contexts || [];\n    const ogListeners = context.tagJsVar.allListeners;\n    const allListeners = value.allListeners;\n    allListeners.forEach((newListener, index) => {\n        // ensure the latest callback is always called. Needed for functions within array maps\n        const wrapCallback = ogListeners[index][1];\n        wrapCallback.toCallback = newListener[1].toCallback;\n    });\n    if (contexts.length !== vContexts.length) {\n        console.info('context mismatch', {\n            value,\n            context,\n            conValues: contexts.map(x => x.value),\n            vContexts,\n            deleted: context.deleted\n        });\n        throw new Error('super issue discovered');\n    }\n    context.locked = 79;\n    contexts.forEach((context, index) => {\n        context.tagJsVar.processUpdate(vContexts[index], // context.value,\n        context, ownerSupport);\n    });\n    delete context.locked;\n}\nexport function checkTagElementValueChange(value, context) {\n    const oldValue = context.value;\n    if (oldValue === value) {\n        return 0; // has not changed\n    }\n    // return 1 // it has changed\n    const notElement = !value || value.tagJsType !== 'element';\n    if (notElement) {\n        return 1;\n    }\n    const newContentId = value.contentId;\n    const oldContentId = context.value.contentId;\n    if (newContentId !== oldContentId) {\n        return 1;\n    }\n    const newKidLength = value.innerHTML.length;\n    const oldKidLength = context.value.innerHTML.length;\n    const kidLengthChanged = newKidLength !== oldKidLength;\n    if (kidLengthChanged) {\n        return 1;\n    }\n    return 0;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { getNewContext } from '../render/addOneContext.function.js';\nimport { paintCommands } from '../render/paint.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nimport { processElementVarFunction } from './processElementVarFunction.function.js';\nexport function processChildren(innerHTML, parentContext, ownerSupport, element, // appendTo\npaintBy) {\n    innerHTML.forEach(item => {\n        const type = typeof item;\n        switch (type) {\n            case 'string':\n            case 'boolean':\n            case 'number':\n                return handleSimpleInnerValue(item, element, paintBy);\n            case 'function': {\n                if (item.tagJsType === 'element') {\n                    break; // skip\n                }\n                const result = processElementVarFunction(item, element, parentContext, ownerSupport, paintBy);\n                return result;\n            }\n        }\n        if (item === null || item === undefined) {\n            return handleSimpleInnerValue(item, element, paintBy);\n        }\n        if (item.tagJsType === 'element') {\n            const newElement = processElementVar(item, parentContext, ownerSupport, parentContext.contexts);\n            paintCommands.push([paintBy, [element, newElement]]);\n            const htmlDomMeta = parentContext.htmlDomMeta;\n            htmlDomMeta.push({\n                nn: newElement.tagName,\n                domElement: newElement,\n                // at: newElement.attributes,\n                at: [],\n            });\n            return;\n        }\n        return processNonElement(item, parentContext, element, ownerSupport, paintBy);\n    });\n}\n/** used when a child is not another element and requires init processing */\nexport function processNonElement(item, parentContext, element, ownerSupport, paintBy) {\n    const newContext = getNewContext(item, [], // addedContexts\n    true, parentContext);\n    const contexts = parentContext.contexts;\n    contexts.push(newContext);\n    newContext.target = element;\n    newContext.placeholder = document.createTextNode('');\n    paintCommands.push([paintBy, [element, newContext.placeholder]]);\n    setContextInCycle(newContext);\n    if (newContext.inputsHandler) {\n        const props = ownerSupport.propsConfig;\n        newContext.inputsHandler(props);\n    }\n    newContext.tagJsVar.processInit(item, newContext, // context, // newContext,\n    ownerSupport, newContext.placeholder);\n    removeContextInCycle();\n    return newContext;\n}\nexport function handleSimpleInnerValue(value, element, paintBy) {\n    const castedValue = castTextValue(value);\n    const text = document.createTextNode(castedValue);\n    paintCommands.push([paintBy, [element, text]]);\n    return text;\n}\n","import { isFunction, Subject } from '../index.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processNonElement } from './processChildren.function.js';\nexport function processElementVarFunction(item, element, parentContext, ownerSupport, paintBy) {\n    const subContexts = [];\n    const subContext = {\n        updateCount: 0,\n        parentContext,\n        contexts: subContexts,\n        target: element,\n        value: item,\n        htmlDomMeta: [],\n        tagJsVar: {\n            component: false,\n            tagJsType: 'dynamic-text',\n            hasValueChanged: () => 0,\n            processInit: blankHandler,\n            processInitAttribute: blankHandler,\n            destroy: (_c, ownerSupport) => {\n                ++subContext.updateCount;\n                subContexts.forEach(subSub => subSub.tagJsVar.destroy(subSub, ownerSupport));\n            },\n            processUpdate: (value, contextItem, ownerSupport, values) => {\n                ++subContext.updateCount;\n                setContextInCycle(aSubContext);\n                let newValue = value(aSubContext);\n                const underFunction = subContext.underFunction;\n                delete subContext.underFunction;\n                if (newValue instanceof Function && !newValue.tagJsType) {\n                    if (underFunction && newValue.toString() === underFunction.toString()) {\n                        newValue = aSubContext.value;\n                    }\n                    else {\n                        subContext.underFunction = newValue;\n                        newValue = newValue();\n                    }\n                }\n                const result = aSubContext.tagJsVar.processUpdate(newValue, aSubContext, ownerSupport, values);\n                aSubContext.value = newValue;\n                contextItem.value = value;\n                removeContextInCycle();\n                return result;\n            }\n        },\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        // paintCommands: [],\n    };\n    // addedContexts.push(subContext)\n    setContextInCycle(subContext);\n    let trueValue = item();\n    const isAgainFunc = isFunction(trueValue) && !trueValue.tagJsType;\n    if (isAgainFunc) {\n        ;\n        subContext.underFunction = trueValue;\n        trueValue = trueValue(); // function returns function\n    }\n    const aSubContext = processNonElement(trueValue, subContext, // parentContext,\n    element, ownerSupport, paintBy);\n    const contexts = parentContext.contexts;\n    contexts.push(subContext);\n    removeContextInCycle();\n    return aSubContext;\n}\n","import { isPromise } from '../index.js';\nimport { addSupportEventListener } from '../interpolations/attributes/addSupportEventListener.function.js';\nimport { afterTagCallback } from '../interpolations/attributes/bindSubjectCallback.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nimport { isSpecialAttr } from '../interpolations/attributes/isSpecialAttribute.function.js';\nimport { renderTagUpdateArray } from '../interpolations/attributes/renderTagArray.function.js';\nimport { processAttributeArray } from '../render/dom/processAttributeArray.function.js';\nimport { paint, paintAppend, painting } from '../render/paint.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processChildren } from './processChildren.function.js';\n/** The first and recursive processor for elements */\nexport function processElementVar(value, context, ownerSupport, _addedContexts) {\n    const element = document.createElement(value.tagName);\n    context.target = element;\n    // mark special attributes\n    value.attributes.forEach(x => {\n        const name = x[0];\n        if (typeof (name) !== 'string') {\n            return;\n        }\n        x[2] = isSpecialAttr(name, element.tagName);\n    });\n    processAttributeArray(value.attributes, [], // values,\n    element, ownerSupport, context);\n    /* process children BEFORE attributes for  `<select value=\"1\">` to work */\n    processChildren(value.innerHTML, context, // parentContext\n    ownerSupport, element, paintAppend);\n    value.listeners.forEach((listener, index) => registerListener(value, index, ownerSupport, listener, element));\n    return element;\n}\nfunction registerListener(value, index, ownerSupport, listener, element) {\n    const wrap = (...args) => {\n        const listenScope = value.listeners[index];\n        const toCall = listenScope[1];\n        const stateSupport = getSupportWithState(ownerSupport);\n        const updateCount = stateSupport.context.updateCount;\n        stateSupport.context.locked = 1;\n        ++painting.locks;\n        setContextInCycle(stateSupport.context);\n        const result = toCall(...args);\n        --painting.locks;\n        delete stateSupport.context.locked;\n        removeContextInCycle();\n        const needsRender = updateCount === stateSupport.context.updateCount;\n        if (needsRender) {\n            return afterTagCallback(result, stateSupport);\n        }\n        else {\n            paint();\n        }\n        if (isPromise(result)) {\n            return result.then(() => {\n                const newest = stateSupport.context.state.newest;\n                renderTagUpdateArray([newest]);\n                return 'promise-no-data-ever';\n            });\n        }\n        return 'no-data-ever';\n    };\n    addSupportEventListener(ownerSupport.appSupport, listener[0], // eventName\n    element, wrap);\n}\n","import { paintAfters, paintBefore, paintCommands } from '../render/paint.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nexport function processDesignElementInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    // prevent children from calling a parent function and causing a mid render\n    context.locked = 34;\n    const element = processElementVar(value, context, ownerSupport, context.contexts);\n    delete context.locked;\n    const paintCommand = [\n        paintBefore, [insertBefore, element, 'htmlTag.processInit']\n    ];\n    paintCommands.push(paintCommand);\n    context.paintCommands = [paintCommand];\n    paintAfters.push([() => {\n            delete context.paintCommands;\n        }, []]);\n    const dom = {\n        nn: value.tagName,\n        domElement: element,\n        at: value.attributes, // TODO: most likely does nothing\n    };\n    context.htmlDomMeta = [dom];\n    return element;\n}\n","import { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions, isValueForContext, loopObjectAttributes } from './elementFunctions.js';\nimport { elementVarToHtmlString } from './elementVarToHtmlString.function.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processDesignElementInit } from './processDesignElementInit.function.js';\nexport function htmlTag(tagName) {\n    const element = {\n        component: false,\n        tagJsType: 'element',\n        processInitAttribute: blankHandler,\n        processInit: processDesignElementInit,\n        destroy: destroyDesignElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName,\n        innerHTML: [],\n        attributes: [],\n        contentId: 0,\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = tagName;\n    return pushKid;\n}\nexport function getPushKid(element, _elmFunctions) {\n    const pushKid = (...args) => {\n        const newElement = { ...pushKid };\n        newElement.attributes = [...pushKid.attributes];\n        newElement.listeners = [...pushKid.listeners];\n        newElement.allListeners = [...pushKid.allListeners];\n        if (args.length > 0 &&\n            typeof args[0] === 'object' &&\n            args[0] !== null &&\n            !Array.isArray(args[0]) &&\n            !args[0].tagJsType // TODO: need better attribute detection\n        ) {\n            loopObjectAttributes(newElement, args[0]);\n            args.splice(0, 1);\n        }\n        newElement.innerHTML = args;\n        // review each child for potential to be context\n        args.forEach(arg => {\n            if (!isValueForContext(arg)) {\n                return;\n            }\n            if (arg.tagJsType === 'element') {\n                newElement.allListeners.push(...arg.allListeners);\n                if (arg.contexts) {\n                    // the argument is an element so push up its contexts into mine\n                    if (!newElement.contexts) {\n                        // newElement.contexts = [...arg.contexts]\n                        newElement.contexts = arg.contexts;\n                        ++newElement.contentId;\n                    }\n                    else {\n                        newElement.contexts.push(...arg.contexts);\n                        ++newElement.contentId;\n                    }\n                }\n                return;\n            }\n            registerMockChildContext(arg, newElement);\n        });\n        return newElement;\n    };\n    Object.assign(pushKid, element);\n    Object.assign(pushKid, elementFunctions(pushKid));\n    pushKid.attributes = [...element.attributes];\n    pushKid.listeners = [...element.listeners];\n    pushKid.allListeners = [...element.allListeners];\n    pushKid.toString = function () {\n        return elementVarToHtmlString(this);\n    };\n    return pushKid;\n}\n/** used during updates */\nfunction registerMockChildContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\n","import { paint, paintBefore, painting } from '../render/paint.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions } from './elementFunctions.js';\nimport { destroyDesignByContexts } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processChildren } from './processChildren.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\n/** used when you do NOT have a root element returned for your function */\nexport const noElement = noElementMaker();\nexport function noElementMaker() {\n    const element = {\n        component: false,\n        tagJsType: 'element',\n        processInitAttribute: blankHandler, // its never an attribute\n        processInit: processNoElmInit,\n        destroy: destroyNoElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName: 'no-element',\n        innerHTML: [],\n        attributes: [],\n        contentId: 0,\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = 'no-element';\n    return pushKid;\n}\nfunction processNoElmInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    processChildren(value.innerHTML, context, ownerSupport, insertBefore, paintBefore);\n}\nfunction destroyNoElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                destroyHtmlDomMeta(htmlDomMeta);\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n}\n","import { htmlTag } from './htmlTag.function.js';\nexport { htmlTag };\nexport { noElement } from './noElement.function.js';\nexport { elementVarToHtmlString } from './elementVarToHtmlString.function.js';\nexport const button = htmlTag('button');\nexport const select = htmlTag('select');\nexport const option = htmlTag('option');\nexport const input = htmlTag('input');\nexport const textarea = htmlTag('textarea');\n// HEAD & SUPPORT ELEMENTS\nexport const html = htmlTag('html'); // TODO: get this named to html\nexport const head = htmlTag('head');\nexport const title = htmlTag('title');\nexport const meta = htmlTag('meta');\nexport const link = htmlTag('link');\nexport const style = htmlTag('style');\nexport const body = htmlTag('body');\nexport const script = htmlTag('script');\nexport const noscript = htmlTag('noscript');\n// BLOCK ELEMENTS\nexport const hr = htmlTag('hr');\nexport const h1 = htmlTag('h1');\nexport const h2 = htmlTag('h2');\nexport const h3 = htmlTag('h3');\nexport const h4 = htmlTag('h4');\nexport const h5 = htmlTag('h5');\nexport const h6 = htmlTag('h6');\nexport const ol = htmlTag('ol');\nexport const ul = htmlTag('ul');\nexport const li = htmlTag('li');\nexport const div = htmlTag('div');\nexport const main = htmlTag('main');\nexport const section = htmlTag('section');\nexport const header = htmlTag('header');\nexport const footer = htmlTag('footer');\nexport const form = htmlTag('form');\nexport const fieldset = htmlTag('fieldset');\nexport const legend = htmlTag('legend');\nexport const dialog = htmlTag('dialog');\nexport const pre = htmlTag('pre');\n// TABLE ELEMENTS\nexport const table = htmlTag('table');\nexport const tr = htmlTag('tr');\nexport const td = htmlTag('td');\nexport const th = htmlTag('th');\nexport const thead = htmlTag('thead');\nexport const tbody = htmlTag('tbody');\nexport const tfoot = htmlTag('tfoot');\nexport const iframe = htmlTag('iframe');\n// INLINE ELEMENTS\nexport const a = htmlTag('a');\nexport const u = htmlTag('u');\nexport const img = htmlTag('img');\nexport const br = htmlTag('br');\nexport const label = htmlTag('label');\nexport const p = htmlTag('p');\nexport const small = htmlTag('small');\nexport const span = htmlTag('span');\nexport const strong = htmlTag('strong');\nexport const b = htmlTag('b');\nexport const sup = htmlTag('sup');\nexport const nav = htmlTag(\"nav\");\nexport const figure = htmlTag(\"figure\");\nexport const figcaption = htmlTag(\"figcaption\");\nexport const code = htmlTag(\"code\");\n// OTHER\nexport const canvas = htmlTag('canvas');\nexport const svg = htmlTag('svg');\nexport const path = htmlTag('path');\nexport const polygon = htmlTag('polygon');\nexport const rect = htmlTag('rect');\nexport const details = htmlTag('details');\nexport const summary = htmlTag('summary');\n","export const version = \"3.1.10\";\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './TagJsTags/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { firstTagRender, reRenderTag } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport * from './deepFunctions.js';\nexport * from './elements/index.js';\nexport { version } from './version.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    firstTagRender, reRenderTag, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","varCounter","state","newer","states","global","blocked","RouteQuery","_name","getSupportInCycle","setUseMemory","stateConfig","support","setSupportInCycle","setContextInCycle","context","addPaintRemoveAwait","_promise","paintCommands","paintRemoves","paintContent","paintAppends","paintAfters","painting","locks","removeLocks","setContent","text","textNode","textContent","paint","removes","length","content","runPaintRemoves","splice","runPaintCycles","nowPaintAfters","runAfterCycle","addPaintRemover","element","caller","push","paintRemover","_caller","parentNode","console","debug","removeChild","paintBefore","relative","insertBefore","paintAppend","appendChild","contentCleaner","document","createElement","toPlainTextElm","innerHTML","createTextNode","paintBeforeText","callback","textElm","paintBeforeElementString","paintAppendElementString","empty","ImmutableTypes","BasicTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","isSimpleType","value","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","findStateSupportUpContext","stateMeta","newest","parentContext","getSupportWithState","component","ownerSupport","returnArgs","args","firstStatesHandler","setter","config","statesIndex","reStatesHandler","oldStates","prevSupport","older","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","StateEchoBack","getStateValue","defaultValue","checkValue","getCallbackValue","runRestate","restate","getContextInCycle","msg","error","wrapper","original","Error","initValue","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","values","setValue","x","index","item","subscription","clones","shift","subscriptions","map","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","add","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","arguments","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","undefined","processUpdateOneContext","deleted","valueIndex","TagJsTag","tagJsVar","processUpdate","removeContextInCycle","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","processUpdateContext","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","cloneValueArray","cloneTagJsValue","shallowPropMatch","props","pastCloneProps","len","pastProp","obEntries","entries","subItem","objectItemMatches","name","pastValue","runBeforeDestroy","providers","provider","children","destroy$","destroyContexts","childTags","child","lastArray","childValue","destroy","iSubs","forEach","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","from","tagValueUpdateHandler","updateCount","forceUpdateExistingValue","domProcessContextItem","appendTo","locked","target","inputsHandler","propsConfig","processInit","castTextValue","isSpecialAttr","attrName","tagName","startsWith","specialAction","isSpecialAction","howToSetInputValue","howToSetInputObjectValue","setNonFunctionInputValue","subValue","setObjectValue","setProperty","setPropertyValue","howToSetStandAloneAttr","setAttribute","setSimpleAttribute","setBooleanAttribute","removeAttribute","specialAttribute","specialName","autofocus","autoselect","names","split","paintStyle","classListAdd","classListRemove","processSpecialClass","smallName","style","classList","remove","select","focus","processDynamicNameValueAttribute","howToSet","isSpecial","processInitAttribute","processTagJsAttribute","processNonDynamicAttr","innerValue","TagJsTagOverride","matchesInjection","inject","subContext","hasValueChanged","_contextItem","isAttr","valueToTagJsVar","withinOwnerElement","render$","processFunctionAttr","processAttributeUpdate","oldTag","tagValue","newTagVar","processSimpleAttribute","_ownerSupport","deleteSimpleAttribute","checkSimpleValueChange","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkUpdateDeleteSimpleValueChange","processStringUpdate","_appendTo","castedValue","placeholder","simpleValueElm","elm","oldClone","processUpdateRegularValue","checkArrayValueChange","destroyArrayContext","getArrayTagVar","processArrayInit","processArrayUpdates","processTagArray","_insertBefore","getBasicTagVar","getNewContext","createAndProcessContextItem","noLast","runtimeInsertBefore","removed","filteredLast","newRemoved","compareArrayItems","reviewArrayItem","array","castArrayItem","previousContext","couldBeSame","reviewPreviousArrayItem","arrayValue","newLength","at","lessLength","prevContext","destroyArrayItem","result","oldKey","newValueTag","newKey","isDiff","runArrayItemDiff","oldest","destroySupport","destroyArrayItemByGlobal","destroyArray","destroyHtmlDomMeta","htmlDomMeta","destroyClone","marker","domElement","smartRemoveKids","allPromises","supportOwner","hostDestroy","subGlobal","smartRemoveByContext","promises","returnValue","isLikeTags","newSupport","oldSupport","isLike","isLikeBaseTags","_innerHTML","outerHTML","templater0","templater1","newTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","every","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","destroySupportByContextItem","lastSupport","updatesHandler","destroySupportContext","checkTagValueChange","isTag","tryUpdateToTag","attachDynamicDom","depth","addOneContext","handleProviderChanges","appSupport","tagsWithProvider","memory","cSubject","getTagsWithProvider","mapToSupport","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","castProps","currentDepth","isSkipPropValue","syncPriorPropFunction","priorProp","mem","oldProp","updateExistingArray","hasSetter","getOwnPropertyDescriptor","updateExistingObject","updateExistingTagComponent","oldWrapper","newWrapper","isSameTag","skipComparing","t","swapTags","hasChanged","newTemplater","latestProps","latest","propsChanged","hasPropChanges","propWatch","hasSupportChanged","renderSupport","softDestroySupport","softDestroyOne","executeWrap","useSupport","castedProps","originalFunction","stateless","runAfterRender","saveState","clearStateConfig","callTag","reSupport","createSupport","runAfterSupportRender","reStateByPrev","prevState","reRenderTag","reStateSupport","firstTagRender","getSupportOlderState","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","processTag","inlineHtml","pop","checkRenderUp","selfPropChange","nowProps","hasPropLengthsChanged","PropWatches","IMMUTABLE","immutablePropMatch","SHALLOW","deepCompareDepth","hasPropsToOwnerChanged","getUpTags","supports","isComponent","continueUp","proSupports","prosWithChanges","hasChange","owner","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","checkToResolvePromise","callbackResult","last","resolvePromise","resolveValue","thenResolveBy","bindSubjectCallback","subjectFunction","bindTo","apply","afterTagCallback","runTagCallback","tagFunction","noData","promiseNoData","bubbleEvent","event","replaceEventName","stopped","originalStopPropagation","stopPropagation","defaultPrevented","addSupportEventListener","eventName","appElement","getEventReferenceName","eventReg","events","listener","addEventListener","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","attrValue","processStandAloneAttribute","newContexts","processAttribute","processUpdateAttrContext","attrContextItem","oldValue","isNameOnly","standAloneResult","updateNameOnlyAttrValue","_subject","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","variablePrefix","variableSuffix","placeholderRegex","getTagVarIndex","search","createDynamicArrayAttribute","startIndex","createdContexts","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","join","newValues","getTagJsTag","attrPart","varIndex","isNameVar","valueInValues","stateOwner","oldTagJsVar","processTagJsTagAttribute","aloneResult","valueVar","createDynamicAttribute","special","paintContentPush","processAttributeArray","attrs","attr","newContext","attachDomElement","node","attachDomElements","nodes","v","isNaN","Number","realValue","newNode","nn","attachDomText","newParentContext","isAttrs","ch","tc","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","attributes","attrMatch","parseAttrString","pushTo","postProcessTagsInComments","inputString","filter","notEmptyStringMapper","part","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","replacePlaceholders","valueCount","currentTail","loopTail","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","mapped","lengthMapper","lastRuns","getDomMeta","stringId","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","template","interpolation","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachHtmlDomMeta","ph","newSupportByTemplater","createHtmlSupport","processNewSubjectTag","getTemplaterResult","getCastedProps","DEEP","shallowCompareDepth","preCastedProps","lastPropsConfig","lastCastProps","newPropsArray","priorPropsArray","newArray","syncFunctionProps","oneRenderToSupport","wrap","processRenderOnceInit","processSubscribeWith","setupSubscribe","hasEmitted","emitSubContext","observable","Observables","subValueHandler","withDefault","emitValue","processSubscribeAttribute","_tagJsVar","unsubscribeContext","onOutput","callbackValue","syncRun","checkToPaint","setupSubscribeCallbackProcessor","contextItem2","processSubscribeWithAttribute","observables","obValue","emitSubScriptionAsIs","Observable","checkSubscribeValueChanged","deleteAndUnsubscribe","newObserves","oldObserves","ob","handleTagTypeChangeFrom","originalType","updateToDiffValue","checkStillSubscription","valuesHandler","deleteContextSubContext","deleteSubContext","appendMarker","subContextItem","onFirstSubContext","handleInnerHTML","oldProcessInit","processInnerHTML","insertBeforeOriginal","guaranteeInsertBefore","checkInnerHTML","getInnerHTML","processPipe","wrapped","newCallback","syncWrapCallback","newestOwner","c","newGlobal","targetContext","options","baseHost","processHostAttribute","processHost","processHostUpdate","deleteHost","injectCallback","returnFunction","assign","oldOptions","newHost","onInit","processHostTagJsTag","attrContext","onDestroy","getOverrideTagVar","overrideTagVar","renderContent","oldType","newType","hasTypeChanged","convertValue","makeRealUpdate","_context","afterDestroy","convertTagToElementManaged","createSupportWithProps","newPropsConfig","processReplacementComponent","processFirstSubjectComponent","processFirstTagResult","processTagComponentInit","nowSupport","tagCount","onClick","makeEventListener","onMouseDown","type","toBeCalled","tagElement","onclick","click","mousedown","onmousedown","defineGetSet","eventFn","fn","parentWrap","innerTagWrap","getTagWrap","setUse","ValueTypes","tagIndex","returnWrap","inputs","updates","NONE","castedPastProps","allFunctionsMatch","compare","subCastedProps","subCompareProps","matched","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","use","deepPropWatch","route","_routeProps","targetItem","currentContext","inContext","message","onRender","callbackWrap","_isFirst","lastContext","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","promise","shallowMapper","deepMapper","getBaseSupport","baseSupport","upgradeBaseToSupport","clonePropsBy","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","ignoreOrDestroyed","before","processNowRegularValue","processUpdateSubscribe","resultNum","updateValue","aContext","newestParentTagJsVar","responseValue","processSignal","initialValue","Signal","Set","unsub","delete","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","pastResult","defaultFinally","init","final","previous","realValues","isFirstRender","processRealValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","previousValues","setTo","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","constructMethod","stateDiffMemory","oldStateCount","instance","cm","ownerProviders","find","warn","TagError","details","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","callbackState","callbackTrigger","createTrigger","_oldStates","maybePromise","newestSupport","supContext","finally","callbackStateUpdate","callbackMaker","syncError","emptyCallback","promiseState","current","trigger","currentPromise","firstSignal","sig","editors","readers","resignal","Proxy","action","getElement","taggedJs","appElements","TAG_ELEMENT_MARKER","wasTagged","appElmIndex","appElm","templater2","isApp","loadNewBaseSupport","getNewSubject","isAppFunction","removeEventListener","toAwait","newFragment","createDocumentFragment","isRoot","renderTagElement","makeAttrCallable","stringsOrValue","isTemplateStringsArray","chunk","callbackWrapper2","wrapCallback","e","listeners","allListeners","getPushKid","elementFunctions","bumpContentId","isValueForContext","registerMockAttrContext","idCallable","classCallable","href","src","title","checked","disabled","selected","minLength","maxLength","cellPadding","cellSpacing","border","attr2","makeCallback","callbackWrapper","onClose","onCancel","onDoubleClick","onBlur","onChange","onInput","contextMenu","onMousedown","onMouseup","onMouseover","onMouseout","onKeydown","onKeyup","makeAttr","id","class","open","bump","contentId","mockElm","setupAttr","eventCallables","onDblClick","onMouseUp","onMouseOver","onMouseOut","onKeyUp","onKeyDown","callables","elementVarToHtmlString","renderElement","parts","resolveDynamicValue","escapeHtml","String","renderAttributes","renderChildren","resolved","isElementLike","destroyDesignElement","matchIndex","indexOf","afterElementDestroy","destroyDesignByContexts","processDesignElementUpdate","checkTagElementValueChange","vContexts","ogListeners","newListener","info","conValues","processChildren","paintBy","handleSimpleInnerValue","subContexts","_c","subSub","aSubContext","underFunction","Function","trueValue","processNonElement","processElementVarFunction","newElement","processElementVar","_addedContexts","toCall","stateSupport","registerListener","processDesignElementInit","paintCommand","htmlTag","pushKid","_elmFunctions","loopObjectAttributes","registerMockChildContext","noElement","processNoElmInit","destroyNoElement","noElementMaker","input","head","meta","body","script","noscript","hr","h1","h2","h3","h4","h5","h6","ol","ul","li","div","main","section","header","footer","fieldset","legend","dialog","pre","table","tr","td","th","thead","tbody","tfoot","iframe","a","u","img","br","label","p","small","span","strong","b","sup","nav","figure","figcaption","code","canvas","svg","path","polygon","rect","summary","hmr"],"sourceRoot":""}