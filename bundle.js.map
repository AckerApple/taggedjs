{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/cycles/getSupportInCycle.function.ts","webpack://taggedjs/./ts/render/dom/blankHandler.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/shallowPropMatch.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContexts.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processFunctionAttr.function.ts","webpack://taggedjs/./ts/tagJsVars/processAttributeUpdate.function.ts","webpack://taggedjs/./ts/tagJsVars/processSimpleAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/render/addOneContext.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/arrays/processTagArray.ts","webpack://taggedjs/./ts/tag/update/arrays/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/destroyArrayContext.function.ts","webpack://taggedjs/./ts/tag/destroyHtmlDomMeta.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/destroySupportByContextItem.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/render/runAfterRender.function.ts","webpack://taggedjs/./ts/render/callTag.function.ts","webpack://taggedjs/./ts/state/reState.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/render/checkRenderUp.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bubbleEvent.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/render/attributes/processStandAloneAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateNameOnlyAttrValue.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/render/attributes/processTagJsAttribute.function.ts","webpack://taggedjs/./ts/render/dom/processAttributeArray.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElement.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribeWith.function.ts","webpack://taggedjs/./ts/tagJsVars/processSubscribeAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/processSubscribeWithAttribute.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribeWith.function.ts","webpack://taggedjs/./ts/tag/update/handleTagTypeChangeFrom.function.ts","webpack://taggedjs/./ts/tag/update/checkStillSubscription.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/tag/update/deleteContextSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/tagJsVars/pipe.function.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/host.function.ts","webpack://taggedjs/./ts/tag/update/getOverrideTagVar.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/convertTagToElementManaged.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/onInit.function.ts","webpack://taggedjs/./ts/state/onDestroy.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tagJsVars/tagInject.function.ts","webpack://taggedjs/./ts/state/onRender.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/processUpdateSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSignal.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/cycles/setContextInCycle.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/processOuterDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/elements/attributeCallables.ts","webpack://taggedjs/./ts/elements/elementFunctions.ts","webpack://taggedjs/./ts/elements/destroyDesignElement.function.ts","webpack://taggedjs/./ts/elements/processDesignElementUpdate.function.ts","webpack://taggedjs/./ts/elements/processChildren.function.ts","webpack://taggedjs/./ts/elements/processElementVarFunction.function.ts","webpack://taggedjs/./ts/elements/processElementVar.function.ts","webpack://taggedjs/./ts/elements/processDesignElementInit.function.ts","webpack://taggedjs/./ts/elements/htmlTag.function.ts","webpack://taggedjs/./ts/elements/noElement.function.ts","webpack://taggedjs/./ts/elements/index.ts","webpack://taggedjs/./ts/version.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/** Only used in TagSupport */\nexport function getNewGlobal(contextItem) {\n    // TODO: Not need for basic supports, only tag()\n    contextItem.renderCount = contextItem.renderCount || 0;\n    contextItem.varCounter = 0;\n    // TODO: Not need for basic supports, only tag()\n    contextItem.state = {\n        newer: {\n            state: [],\n            states: [],\n        },\n    };\n    return contextItem.global = {\n        blocked: [],\n    };\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","import { setUseMemory } from '../../state/index.js';\nimport { setContextInCycle } from './setContextInCycle.function.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    setContextInCycle(support.context);\n    return setUseMemory.stateConfig.support = support;\n}\n","export const blankHandler = function blankHandler() {\n    return undefined;\n};\n","import { blankHandler } from \"./dom/blankHandler.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(_promise) {\n    /*\n    if(paintRemoveAwaits.length) {\n      paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push( ...paintRemoves )\n      paintRemoves = []\n    }\n  \n    paintRemoveAwaits.push({promise, paintRemoves})\n    paintRemoves = []\n    */\n}\n// let paintRemoveAwaits: {promise: Promise<any>, paintRemoves: PaintCommand[]}[] = []\nexport let paintCommands = [];\n// export let paintRemoves: PaintCommand[] = []\nexport const paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\n/** you must lock before calling this function */\nexport function paint() {\n    if (painting.locks > 0) {\n        // throw new Error('double paint')\n        return;\n    }\n    runCycles();\n}\nfunction runCycles() {\n    ++painting.locks;\n    runPaintCycles();\n    --painting.locks;\n    runAfterCycle();\n}\n/** Deletes happen last */\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    const removes = paintRemoves.length;\n    runPaintRemoves();\n    // paintRemoves = []\n    paintRemoves.splice(0, removes);\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element, caller) {\n    paintRemoves.push([paintRemover, [element, caller]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element, _caller) {\n    const parentNode = element.parentNode;\n    /*\n    if(!element) {\n      console.debug('no element by', _caller)\n    }\n    if(!parentNode) {\n      console.debug('no parentNode by', _caller)\n    }\n    */\n    parentNode.removeChild(element);\n}\n/** insertBefore. For parent.appendChild() see paintAppend */\nexport function paintBefore(relative, element, _caller) {\n    const parentNode = relative.parentNode;\n    parentNode.insertBefore(element, relative);\n}\n/** parent.appendChild(). For insertBefore see paintBefore */\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler, _caller) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm, _caller);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm, 'paintBeforeElementString');\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n    // TODO: Start using this instead\n    return value instanceof Function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function findStateSupportUpContext(context) {\n    const stateMeta = context.state;\n    if (stateMeta && stateMeta.newest && stateMeta.newest) {\n        return stateMeta.newest;\n    }\n    if (context.parentContext) {\n        return findStateSupportUpContext(context.parentContext);\n    }\n}\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const context = component.context;\n    const stateMeta = context.state;\n    if (!stateMeta) {\n        return component;\n    }\n    return stateMeta.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevContext = prevSupport.context;\n    const stateMeta = prevContext.state;\n    const prevStateMeta = stateMeta.older;\n    // const prevStateMeta = stateMeta.newer as ContextStateSupport\n    // const prevStateMeta = stateMeta.older || stateMeta.newer as ContextStateSupport\n    const prevStates = prevStateMeta.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        oldStates.lastValues = lastValues;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState } from './stateHandlers.js';\nimport { firstStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** To be called before rendering anything with a state */\nexport function initState(context) {\n    setContextInCycle(context);\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    const state = config.state = [];\n    const states = config.states = [];\n    config.statesIndex = 0;\n    const stateMeta = context.state = context.state || {};\n    stateMeta.newer = { state, states };\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.state.length];\n    config.state.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    const context = getContextInCycle();\n    if (!context || !context.state) {\n        const msg = 'State requested but TaggedJs is not currently rendering a tag or host';\n        console.error(msg, { config, context });\n        throw new Error(msg);\n    }\n    const newer = context.state.newer;\n    config.state = newer.state;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.state.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    value;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n        if (arguments.length > 0) {\n            this.value = value;\n        }\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster.\n     * Once called, unsubscribe occurs.\n     * No subscription to manage UNLESS the callback will never occur THEN subscription needs to be closed with result.unsubscribe() */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        // return this 10-2025 remove\n        return subscription;\n    }\n    pipe(...operations) {\n        const args = [];\n        if ('value' in this) {\n            args.push(this.value);\n        }\n        const subject = new Subject(...args);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    _value;\n    constructor(...args) {\n        super(...args);\n        this._value = args[0];\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        state: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","import { removeContextInCycle, setContextInCycle } from './cycles/setContextInCycle.function.js';\nexport function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    for (const context of contexts) {\n        // const context = contexts[index]\n        processUpdateOneContext(values, context, support);\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\ncontextItem, ownerSupport) {\n    if (contextItem.deleted) {\n        return;\n    }\n    // some values, like style, get rearranged and there value appearance may not match context appearance\n    const valueIndex = contextItem.valueIndex;\n    const newValue = values[valueIndex];\n    // Removed, let the tagJsVars do the checking\n    // Do not continue if the value is just the same\n    /*\n    if(newValue === contextItem.value) {\n      return\n    }\n    */\n    const tagJsVar = contextItem.tagJsVar;\n    setContextInCycle(contextItem);\n    tagJsVar.processUpdate(newValue, contextItem, ownerSupport, values);\n    removeContextInCycle();\n    contextItem.value = newValue;\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const contexts = olderSupport.context.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, contexts);\n    --painting.locks;\n    paint();\n}\nfunction updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { isArray } from '../isInstance.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            // cover null and undefined\n            if (!prop && !pastProp) {\n                continue;\n            }\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = support.context.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    // global.deleted = true\n    support.context.destroy$.next();\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContexts(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContexts(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.destroy(child, ownerSupport);\n            child.deleted = true;\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = child.state.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = child.contexts;\n        // recurse\n        destroyContexts(subTags, support);\n        global.deleted = true;\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = child.state.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = child.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\ncontextItem, ownerSupport) {\n    const tagJsType = contextItem.tagJsVar.tagJsType;\n    const processUpdate = tagJsType && ['tag-conversion', 'element'].includes(tagJsType);\n    if (processUpdate) {\n        // calls processDesignElementUpdate\n        contextItem.tagJsVar.processUpdate(newValue, contextItem, ownerSupport, []);\n        contextItem.value = newValue;\n        return 0;\n    }\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    ++contextItem.updateCount;\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\n","import { removeContextInCycle, setContextInCycle } from \"../../tag/cycles/setContextInCycle.function.js\";\nexport function domProcessContextItem(value, support, contextItem, appendTo, insertBefore) {\n    const subject = support.context;\n    subject.locked = 3;\n    contextItem.target = contextItem.target || appendTo;\n    setContextInCycle(contextItem);\n    contextItem.tagJsVar.processInit(value, contextItem, support, insertBefore, appendTo);\n    removeContextInCycle();\n    contextItem.value = value;\n    delete subject.locked;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n        case 'autoSelect':\n            return 'autoselect';\n        case 'autofocus':\n        case 'autoFocus':\n            return 'autofocus';\n    }\n    return false;\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            // element.setAttribute(\"autofocus\", 'true')\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value; // style.backgroundGround\n    element.style.setProperty(smallName, value); // style.background-ground\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\n","import { isObject } from \"../../index.js\";\nimport { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    paintContent.push([setNonFunctionInputValue, [element, name, value]]);\n}\nfunction howToSetInputObjectValue(element, name, value) {\n    if (typeof element[name] !== 'object') {\n        element[name] = {};\n    }\n    // Handle object values by setting properties directly\n    for (const key in value) {\n        const subValue = value[key];\n        paintContent.push([setObjectValue, [element, name, key, subValue]]);\n    }\n    if (element[name].setProperty) {\n        for (const key in value) {\n            const subValue = value[key];\n            paintContent.push([setPropertyValue, [element, name, key, subValue]]);\n        }\n    }\n}\nexport function howToSetStandAloneAttr(element, name, _value) {\n    element.setAttribute(name, '');\n}\nexport function setNonFunctionInputValue(element, name, value) {\n    if (isObject(value)) {\n        return howToSetInputObjectValue(element, name, value);\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used for checked, selected, and so on */\nexport function setBooleanAttribute(element, name, value) {\n    if (value) {\n        element[name] = true;\n    }\n    else {\n        element[name] = false;\n    }\n}\nexport function setSimpleAttribute(element, name, value) {\n    // for checked=true\n    ;\n    element[name] = value;\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\nfunction setPropertyValue(element, name, key, value) {\n    ;\n    element[name].setProperty(key, value);\n}\n/** main processor for things like <div style=${{ maxWidth: '100vw' }}> */\nfunction setObjectValue(element, name, key, value) {\n    ;\n    element[name][key] = value;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { setNonFunctionInputValue } from './howToSetInputValue.function.js';\nimport { processFunctionAttr } from './processFunctionAttr.function.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial) {\n    contextItem.target = element;\n    contextItem.howToSet = howToSet;\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    if (value?.tagJsType) {\n        return processTagJsAttribute(attrName, value, contextItem, support, element);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, contextItem);\n}\nfunction processTagJsAttribute(name, value, contextItem, ownerSupport, element) {\n    value.processInitAttribute(name, value, element, value, contextItem, ownerSupport, setNonFunctionInputValue);\n    contextItem.tagJsVar = value;\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, context) {\n    if (typeof value === 'function') {\n        return processFunctionAttr(value, context, attrName, element, howToSet);\n    }\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n","import { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { Subject, valueToTagJsVar } from '../../index.js';\n/** Used for bolts like div.style(() => {{backgroundColor:}}) */\nexport function processFunctionAttr(value, parentContext, // parent context\nattrName, element, howToSet) {\n    const innerValue = value();\n    const tagJsVarOverride = {\n        tagJsType: 'dynamic-attr',\n        matchesInjection: (inject) => {\n            const tagJsVar = subContext.tagJsVar;\n            if (tagJsVar.matchesInjection) {\n                const rtn = tagJsVar.matchesInjection(inject, subContext);\n                return rtn;\n            }\n        },\n        hasValueChanged: (_value, _contextItem, ownerSupport) => {\n            const newValue = value();\n            return subContext.tagJsVar.hasValueChanged(newValue, subContext, ownerSupport);\n        },\n        processInit: blankHandler,\n        processInitAttribute: blankHandler,\n        destroy: (_contextItem, ownerSupport) => {\n            subContext.tagJsVar.destroy(subContext, ownerSupport);\n        },\n        processUpdate: (value, contextItem, ownerSupport, values) => {\n            ++contextItem.updateCount;\n            const newValue = value();\n            // const oldValue = subContext.value\n            // const newTagJsVar = valueToTagJsVar(newValue)\n            subContext.tagJsVar.processUpdate(newValue, // newTagJsVar as any,\n            subContext, ownerSupport, values);\n            subContext.value = newValue;\n        }\n    };\n    const subContext = {\n        updateCount: 0,\n        isAttr: true,\n        target: element,\n        parentContext,\n        value: innerValue, // used for new value comparing\n        tagJsVar: valueToTagJsVar(innerValue),\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        contexts: [subContext],\n        target: element,\n        parentContext,\n        value,\n        tagJsVar: tagJsVarOverride,\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    subContext.tagJsVar.processInitAttribute(attrName, innerValue, element, subContext.tagJsVar, subContext, {}, howToSet);\n    return contextItem;\n}\n","import { valueToTagJsVar } from \"./valueToTagJsVar.function.js\";\nexport function processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet) {\n    const oldTag = contextItem.tagJsVar; // contextItem.tagJsVar as TagJsVar\n    const tagValue = value;\n    const checkResult = oldTag.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n    ownerSupport);\n    if (checkResult > 0) {\n        oldTag.destroy(contextItem, ownerSupport);\n        element.removeAttribute(name);\n        const newTagVar = valueToTagJsVar(value);\n        newTagVar.isAttr = true;\n        newTagVar.processInitAttribute(name, value, element, newTagVar, contextItem, ownerSupport, howToSet);\n        contextItem.tagJsVar = newTagVar;\n        return;\n    }\n}\n","import { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { checkSimpleValueChange, deleteSimpleAttribute } from \"./getSimpleTagVar.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\n/** init runner */\nexport function processSimpleAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, contextItem, _ownerSupport, howToSet) {\n    // function swapping\n    tagJsVar.destroy = deleteSimpleAttribute;\n    tagJsVar.hasValueChanged = checkSimpleValueChange;\n    tagJsVar.processUpdate = (value, contextItem, ownerSupport) => {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, howToSet);\n    };\n    const isSpecial = isSpecialAttr(name);\n    processNonDynamicAttr(name, value, element, howToSet, isSpecial, contextItem);\n    contextItem.tagJsVar = tagJsVar;\n}\n","import { forceUpdateExistingValue } from \"../index.js\";\nimport { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { processSimpleAttribute } from \"./processSimpleAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nexport function deleteSimpleAttribute(contextItem) {\n    const element = contextItem.target;\n    const name = contextItem.attrName;\n    element.removeAttribute(name);\n}\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInitAttribute: processSimpleAttribute,\n        processInit: processSimpleValueInit,\n        destroy: deleteSimpleValue,\n        // TODO: get to using only checkSimpleValueChange\n        hasValueChanged: checkUpdateDeleteSimpleValueChange, // For attributes, this gets switched to checkSimpleValueChange\n        processUpdate: processStringUpdate, // For attributes, this gets switched to processAttributeUpdate\n        // processUpdate: tagValueUpdateHandler, // For attributes, this gets switched to processAttributeUpdate\n    };\n}\nfunction processStringUpdate(newValue, // newValue\ncontextItem, ownerSupport) {\n    if (newValue === contextItem.value) {\n        return 0;\n    }\n    return forceUpdateExistingValue(contextItem, newValue, ownerSupport);\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, insertBefore, _appendTo) {\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processSimpleValueInit']];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(context) {\n    if (!context.simpleValueElm && context.paint) {\n        context.paint[0] = blankHandler;\n        return; // I'm being deleted before my first render even occurred\n    }\n    const elm = context.simpleValueElm;\n    delete context.simpleValueElm;\n    addPaintRemover(elm, 'deleteSimpleValue');\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || newValue === contextItem.value; // !(typeof(newValue) === BasicTypes.object)\n    if (isRegularUpdate) {\n        return 0; // no need to destroy, just update display\n    }\n    return 6; // 'changed-simple-value'\n}\nexport function checkUpdateDeleteSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || !(typeof (newValue) === BasicTypes.object);\n    if (isRegularUpdate) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return 0; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }, 'processNowRegularValue']];\n    paintCommands.push(paint);\n}\n","import { isArray } from '../isInstance.js';\nimport { destroyArrayContext } from './destroyArrayContext.function.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContext(subject);\n        return 9; // 'array'\n    }\n    return 0;\n}\n","import { checkArrayValueChange } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/arrays/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroyArrayContext } from '../tag/destroyArrayContext.function.js';\n/** how to process an array */\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInitAttribute: blankHandler,\n        processInit: processArrayInit,\n        processUpdate: processArrayUpdates,\n        hasValueChanged: checkArrayValueChange,\n        destroy: destroyArrayContext,\n    };\n}\nfunction processArrayUpdates(newValue, contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    if (Array.isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport);\n        return;\n    }\n    const tagUpdateResponse = tagValueUpdateHandler(newValue, contextItem, ownerSupport);\n    if (tagUpdateResponse === 0) {\n        processTagArray(contextItem, newValue, ownerSupport);\n    }\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","import { Subject } from '../subject/Subject.class.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\nexport function getNewContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = {\n        updateCount: 0,\n        value,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n        parentContext,\n        // TODO: remove with html``\n        // valueIndex: contexts?.length || -1, // when -1 its a raw bolt value\n        // valueIndex: contexts.length\n        valueIndex: parentContext.varCounter,\n    };\n    return contextItem;\n}\n/** auto adds onto parent.contexts */\nexport function addOneContext(value, contexts, withinOwnerElement, parentContext) {\n    const contextItem = getNewContext(value, contexts, withinOwnerElement, parentContext);\n    contexts.push(contextItem);\n    ++parentContext.varCounter;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { getNewContext } from '../../render/addOneContext.function.js';\n/** Used by arrays and subcontext creators like subscribe. Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, contexts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = getNewContext(value, contexts, true, ownerSupport.context);\n    contextItem.withinOwnerElement = false;\n    contextItem.placeholder = element;\n    if (!appendTo) {\n        contextItem.placeholder = insertBefore;\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from '../tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from '../createAndProcessContextItem.function.js';\nexport function processTagArray(contextItem, value, // arry of Tag classes\nownerSupport, appendTo) {\n    const noLast = contextItem.lastArray === undefined;\n    if (noLast) {\n        contextItem.lastArray = [];\n    }\n    const lastArray = contextItem.lastArray;\n    let runtimeInsertBefore = contextItem.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        contextItem.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, contextItem.lastArray, ownerSupport, runtimeInsertBefore, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\n/** new and old array items processed here */\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\nappendTo) {\n    const item = castArrayItem(array[index]);\n    const previousContext = lastArray[index];\n    if (previousContext) {\n        return reviewPreviousArrayItem(item, previousContext, lastArray, ownerSupport, index, runtimeInsertBefore, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, context, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\nappendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        if (Array.isArray(value)) {\n            context.tagJsVar.processUpdate(value, context, ownerSupport, []);\n            context.value = value;\n            return context;\n        }\n        tagValueUpdateHandler(value, context, ownerSupport);\n        return context;\n    }\n    // NEW REPLACEMENT\n    const contextItem = createAndProcessContextItem(value, ownerSupport, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nexport function castArrayItem(item) {\n    const isBasicFun = typeof item === 'function' && item.tagJsType === undefined;\n    if (isBasicFun) {\n        const fun = item;\n        item = fun();\n    }\n    return item;\n}\n","import { destroySupport } from '../../../render/destroySupport.function.js';\nimport { castArrayItem } from './processTagArray.js';\n/** 1 = destroyed, 2 = value changes, 0 = no change */\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = castArrayItem(value[index]);\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(context) {\n    const global = context.global;\n    destroyArrayItemByGlobal(global, context);\n}\nfunction destroyArrayItemByGlobal(global, context) {\n    if (global && context.state?.oldest) {\n        const support = context.state.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    context.tagJsVar.destroy(context, {});\n}\n","import { destroyArrayItem } from './update/arrays/compareArrayItems.function.js';\nexport function destroyArrayContext(context) {\n    ++context.updateCount;\n    const lastArray = context.lastArray;\n    destroyArray(context, lastArray);\n}\n/** Deletes entire array context not just one */\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { addPaintRemover } from '../render/paint.function.js';\n/** Destroy dom elements and dom space markers */\nexport function destroyHtmlDomMeta(htmlDomMeta) {\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker, 'destroyMarker');\n    }\n    const dom = clone.domElement;\n    addPaintRemover(dom, 'destroyClone');\n}\n","import { destroyArray } from './destroyArrayContext.function.js';\nimport { addPaintRemover } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from './destroyHtmlDomMeta.function.js';\nimport { isPromise } from '../index.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(context, allPromises) {\n    const subContexts = context.contexts;\n    smartRemoveByContext(subContexts, allPromises);\n    destroyContextHtml(context);\n}\nexport function destroyContextHtml(context) {\n    destroyHtmlDomMeta(context.htmlDomMeta);\n}\nfunction smartRemoveByContext(contexts, allPromises) {\n    for (const context of contexts) {\n        if (context.withinOwnerElement) {\n            const tagJsVar = context.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = context.supportOwner;\n                const hostDestroy = tagJsVar.destroy(context, newest);\n                if (isPromise(hostDestroy)) {\n                    allPromises.push(hostDestroy);\n                }\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = context.lastArray;\n        if (lastArray) {\n            destroyArray(context, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = context.simpleValueElm;\n        if (elm) {\n            delete context.simpleValueElm;\n            addPaintRemover(elm, 'smartRemoveByContext');\n            continue;\n        }\n        const subGlobal = context.global;\n        if (subGlobal === undefined) {\n            continue; // context\n        }\n        subGlobal.deleted = true;\n        const oldest = context.state?.oldest;\n        if (oldest) {\n            smartRemoveKids(context, allPromises);\n            continue;\n        }\n    }\n}\n","import { destroyContexts } from '../tag/destroyContexts.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const context = support.context;\n    global.deleted = true;\n    context.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const subContexts = context.contexts;\n    destroyContexts(subContexts, support);\n    // tag() only destroy\n    if (support.templater.wrapper) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(context, promises);\n    delete context.state;\n    delete context.contexts;\n    delete context.returnValue;\n    delete context.providers;\n    return promises;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { destroySupport } from '../render/destroySupport.function.js';\nexport function destroySupportByContextItem(context) {\n    ++context.updateCount;\n    const global = context.global;\n    const state = context.state;\n    const lastSupport = state.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    destroySupportContext(context);\n}\nfunction destroySupportContext(context) {\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    delete context.contexts;\n    delete context.state;\n    delete context.global;\n    context.renderCount = 0;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** When return > 0 then its the same tag */\nexport function checkTagValueChange(newValue, contextItem) {\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            return 7; // 'tag-swap'\n        }\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        if (newValue.wrapper?.original === contextItem.value.wrapper?.original) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    // destroySupportByContextItem(contextItem)\n    return 8; // 'no-longer-tag'\n}\n/*\nexport function checkTagValueChangeAndUpdate(\n  newValue: unknown,\n  contextItem: ContextItem,\n) {\n  const checkValue = checkTagValueChange(newValue, contextItem)\n\n  const global = contextItem.global as SupportTagGlobal\n  const lastSupport = contextItem.state?.newest as AnySupport\n  \n  if(checkValue === 7) {\n    destroySupport(lastSupport, global)\n    getNewGlobal(contextItem as SupportContextItem)\n    return 7 // 'tag-swap'\n  }\n  \n  if(checkValue === 8) {\n    destroySupportByContextItem(contextItem)\n    return 8\n  }\n\n  const isValueTag = isStaticTag(newValue)\n  if(isValueTag) {\n    // always cause a redraw of static tags (was false)\n    tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      lastSupport as AnySupport,\n    )\n\n    return 0\n  }\n\n  const isTag = (newValue as any)?.tagJsType\n  if(isTag) {\n    const state = contextItem.state as ContextStateMeta\n    const support = state.newest as AnySupport\n    const ownerSupport = support.ownerSupport as AnySupport\n    const result = tryUpdateToTag(\n      contextItem,\n      newValue as TemplaterResult,\n      ownerSupport,\n    )\n\n    const doNotRedraw = result === true\n\n    if(doNotRedraw) {\n      return 0\n    }\n\n    return 88 // its same tag with new values\n  }\n\n  destroySupportByContextItem(contextItem)\n  return 8\n}\n*/\nexport function checkTagValueChangeAndUpdate(newValue, contextItem) {\n    const global = contextItem.global;\n    const lastSupport = contextItem.state?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport);\n        return 0;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const state = contextItem.state;\n        const support = state.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return 0;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/addOneContext.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, contexts, support, // owner\nparentContext, depth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, contexts, isWithinOwnerElement, parentContext);\n    contextItem.placeholder = marker;\n    contextItem.target = appendTo;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([\n            paintBefore, [insertBefore, marker, 'attachDynamicDom.attachDynamicDom']\n        ]);\n    }\n    domProcessContextItem(value, support, contextItem, appendTo, insertBefore);\n    return contextItem;\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\n/** Called when one tag changes and we need to find other tags that will need to be rendered */\nexport function providersChangeCheck(support) {\n    const context = support.context;\n    const providers = context.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../cycles/getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, currentDepth) {\n    return props;\n    return props.map(function eachCastProp(prop, pos) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, currentDepth, pos);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth, pos // arguments position\n) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth, pos);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, pos, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth, pos);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth, pos);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth, pos) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth, pos // argument position\n) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, pos, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport, pos);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport, pos) {\n    // restore object to have original function on destroy\n    if (depth <= 0) {\n        return;\n    }\n    const context = newSupport.context;\n    const castedProps = context.value?.props;\n    if (castedProps) {\n        // check for old prop subscription\n        const prop = castedProps[pos][index];\n        if (prop?.subscription) {\n            prop.subscription(); // unsubscribe to prevent this old argument/prop from being called on destroy\n            prop.restore(); // put original value back\n        }\n    }\n    const altPropRestore = () => {\n        newProp[index] = originalValue;\n    };\n    newProp[index].subscription = newSupport.context.destroy$.toCallback(altPropRestore);\n    newProp[index].restore = altPropRestore;\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const ownerContext = ownerSupport.context;\n    const newest = ownerContext.state?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const context = newest.context;\n        const global = context.global;\n        if (context.locked) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        if (!global) {\n            /*\n            context.tagJsVar.processUpdate(\n              context.value,\n              context,\n              ownerSupport,\n              [],\n            )\n      */\n            ownerContext.tagJsVar.processUpdate(ownerContext.value, ownerContext, ownerSupport, []);\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = subject.state.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    if (!global || !subject.state.newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    const newest = subject.state.newest;\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const context = oldSupport.context;\n    const global = context.global;\n    let pIndex = -1;\n    const providers = context.providers = context.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = contextItem.state.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n}\n","import { hasPropChanges } from './hasPropChanges.function.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContexts.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const context = lastSupport.context;\n    const global = context.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(context.contexts);\n    softDestroyOne(context);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(child.context);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(context);\n}\nfunction softDestroyOne(context) {\n    context.global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(context, []);\n    delete context.contexts;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // tag returns another function expected to be called\n        if (typeof (tag) === BasicTypes.function && tag.tagJsType === undefined) {\n            tag = tag();\n        }\n    }\n    useSupport.context.returnValue = tag;\n    useSupport.returnValue = tag;\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.context.state.newer = { ...config };\n    removeContextInCycle();\n    return useSupport;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterSupportRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    runAfterRender(support.context);\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n/** run after rendering anything with state */\nexport function runAfterRender(context) {\n    saveState(context);\n    // TODO: prove this is worth having\n    // checkStateMismatch(config, support)\n    clearStateConfig();\n    // setUseMemory.tagClosed$.next(ownerSupport)\n}\nfunction saveState(context) {\n    const config = setUseMemory.stateConfig;\n    const subject = context || config.context;\n    subject.state = subject.state || {};\n    subject.state.newer = { ...config };\n    const support = config.support;\n    subject.state.newest = support;\n}\nexport function clearStateConfig() {\n    const config = setUseMemory.stateConfig;\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.state;\n    delete config.states;\n    removeContextInCycle();\n}\n","import { ValueTypes } from '../tag/index.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { runAfterSupportRender } from './runAfterRender.function.js';\nexport function callTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    let reSupport;\n    const templater = newSupport.templater;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, context, ownerSupport, newSupport.appSupport);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, context, prevSupport);\n    }\n    runAfterSupportRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\n","import { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { runRestate } from './stateHandlers.js';\nimport { reStatesHandler } from './states.utils.js';\nexport function reState(context) {\n    setContextInCycle(context);\n    const stateMeta = context.state;\n    return reStateByPrev(stateMeta.newer.state);\n}\nexport function reStateByPrev(prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.state = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    return config;\n}\nexport function reStateSupport(newSupport, prevSupport, prevState) {\n    reStateByPrev(prevState);\n    const config = setUseMemory.stateConfig;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\n","import { initState } from '../state/state.utils.js';\nimport { callTag } from './callTag.function.js';\nimport { setSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { removeContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { reStateSupport } from '../state/reState.function.js';\nexport function reRenderTag(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    const stateMeta = context.state;\n    const prevState = stateMeta.older.state;\n    reStateSupport(newSupport, prevSupport, prevState);\n    return callTag(newSupport, prevSupport, context, ownerSupport);\n}\n/** Used during first renders of a support */\nexport function firstTagRender(newSupport, prevSupport, // causes restate\ncontext, ownerSupport) {\n    initState(newSupport.context);\n    setSupportInCycle(newSupport);\n    const result = callTag(newSupport, prevSupport, context, ownerSupport);\n    removeContextInCycle();\n    return result;\n}\nexport function getSupportOlderState(support) {\n    const context = support?.context;\n    const stateMeta = context?.state;\n    return stateMeta?.older?.state;\n}\n/*\nexport function getSupportNewerState(support?: AnySupport) {\n  const context = support?.context as SupportContextItem\n  const stateMeta = context?.state\n  return stateMeta?.newer?.state\n}\n*/ \n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { firstTagRender, getSupportOlderState, reRenderTag } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\ncontext) {\n    let reSupport;\n    const olderState = getSupportOlderState(lastSupport);\n    // const olderState = getSupportNewerState(lastSupport)\n    if (olderState) {\n        reSupport = reRenderTag(newSupport, lastSupport, context);\n    }\n    else {\n        reSupport = firstTagRender(newSupport, lastSupport, context);\n    }\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const context = reSupport.context;\n        context.state.oldest = reSupport;\n        context.state.newest = reSupport;\n        // context.state.older = context.state.newer\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && context.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n        // context.state.older = context.state.newer\n        // context.state.newer = context.state.older\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return {\n        support: reSupport,\n        wasLikeTags: isLikeTag\n    };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    if (result.wasLikeTags) {\n        const oldest = subject.state.oldest; // || result.support\n        updateSupportBy(oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject);\n}\n","import { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = 4;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(subject.state.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownContext = ownerSupport.context;\n    const newest = ownContext.state.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch } from '../tag/hasSupportChanged.function.js';\nimport { shallowPropMatch } from '../tag/shallowPropMatch.function.js';\nexport function checkRenderUp(templater, support) {\n    const global = support.context.global;\n    if (global && global.deleted) {\n        return false;\n    }\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { checkRenderUp } from \"../../render/checkRenderUp.function.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const global = support.context.global;\n    if (global && global.deleted === true) {\n        return supports;\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const providers = newSupport.context.providers;\n    if (providers) {\n        const proSupports = providersChangeCheck(newSupport);\n        supports.push(...proSupports);\n    }\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const context = support.context;\n    const global = context.global;\n    if (!global) {\n        context.tagJsVar.processUpdate(context.value, context, support.ownerSupport, []);\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    const stateMeta = context.state;\n    renderSupport(stateMeta.newest);\n}\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    const stateMeta = support.context.state;\n    const newestStateMeta = newestSupport.context.state;\n    const fromStates = stateMeta.newer.states;\n    const toStates = newestStateMeta.newer.states;\n    return syncStatesArray(fromStates, toStates);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        subject.locked = 2;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const subject = last.context;\n        const global = subject.global;\n        delete subject.locked;\n        if (subject.deleted === true || global?.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, subject.state.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = 1; // prevent another render from re-rendering this tag\n    // ++painting.locks\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.context.state.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    // --painting.locks\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, last) {\n    const global = last.context.global;\n    if (global?.deleted) {\n        return;\n    }\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","export function bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.originalStopPropagation = event.stopPropagation;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n            event.stopPropagation = event.originalStopPropagation;\n            delete event.originalStopPropagation;\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { bubbleEvent } from './bubbleEvent.function.js';\nexport function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    const replaceEventName = getEventReferenceName(eventName);\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const context = support.context;\n    const eventReg = context.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nexport function getEventReferenceName(eventName) {\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    return '_' + eventName;\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { BasicTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { processAttribute } from './processAttribute.function.js';\n// single/stand alone attributes\nexport function processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    const newContexts = [];\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const isSpecial = isSpecialAttr(name); // only object variables are evaluated for is special attr\n            const value = attrValue[name];\n            const howToSet = setNonFunctionInputValue;\n            const subContext = processAttribute(name, value, values, element, ownerSupport, howToSet, contexts, parentContext, isSpecial);\n            if (subContext !== undefined) {\n                if (Array.isArray(subContext)) {\n                    newContexts.push(...subContext);\n                }\n                else {\n                    newContexts.push(subContext);\n                }\n            }\n        }\n        return newContexts;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processStandAloneAttribute } from '../../render/attributes/processStandAloneAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, contexts, parentContext) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue) || attrValue === '') {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    const standAloneResult = processStandAloneAttribute(values, attrValue, element, ownerSupport, howToSet, contexts, parentContext);\n    if (standAloneResult) {\n        contexts.push(...standAloneResult);\n    }\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateNameOnlyAttrValue.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\n/** Currently universally used for all attributes */\nexport function processUpdateAttrContext(value, contextItem, ownerSupport, values) {\n    const attrContextItem = contextItem;\n    const tagValue = value;\n    if (tagValue?.tagJsType) {\n        const oldValue = contextItem.value;\n        // its now a tagVar value but before was not\n        if (!oldValue?.tagJsType) {\n            tagValue.isAttr = true;\n            setContextInCycle(contextItem);\n            tagValue.processInitAttribute(attrContextItem.attrName, value, attrContextItem.target, tagValue, attrContextItem, ownerSupport, setNonFunctionInputValue);\n            removeContextInCycle();\n            attrContextItem.tagJsVar = tagValue;\n            return;\n        }\n        oldValue.hasValueChanged(tagValue, contextItem, // todo: weird typing should just be ContextItem\n        ownerSupport);\n        return;\n    }\n    if (attrContextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, attrContextItem.value, attrContextItem.target, // global.element as Element,\n        ownerSupport, attrContextItem.howToSet, [], // Context, but we dont want to alter current\n        attrContextItem.parentContext);\n        attrContextItem.value = value;\n        return;\n    }\n    const element = attrContextItem.target;\n    processAttributeEmit(value, attrContextItem.attrName, attrContextItem, element, ownerSupport, attrContextItem.howToSet, attrContextItem.isSpecial);\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { processStandAloneAttribute } from './processStandAloneAttribute.function.js';\nimport { processTagJsVarAttribute } from './processTagJsAttribute.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(attrName, value, values, // all the variables inside html``\nelement, support, howToSet, //  = howToSetInputValue\ncontexts, parentContext, isSpecial) {\n    const varIndex = getTagJsVar(attrName);\n    let isNameVar = varIndex >= 0 || (value === undefined && typeof (attrName) !== 'string');\n    let valueInValues = values[varIndex];\n    // value or name from bolt?\n    if (value?.tagJsType) {\n        valueInValues = value; // the value is a tagJsVar\n    }\n    else if (attrName?.tagJsType) {\n        isNameVar = true;\n        valueInValues = attrName; // the name is a tagJsVar\n        value = attrName;\n    }\n    const tagJsVar = valueInValues;\n    if (tagJsVar?.tagJsType) {\n        return processTagJsVarAttribute(value, [], // contexts,\n        parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar);\n    }\n    if (isNameVar) {\n        // old way of setting by html``\n        if (varIndex === -1 && isNameVar) {\n            valueInValues = attrName; // its a name only value attribute\n        }\n        const contextItem = getNewContext(valueInValues, [], // contexts,\n        true, parentContext);\n        contextItem.valueIndex = varIndex;\n        contextItem.isAttr = true;\n        contextItem.target = element;\n        contextItem.isNameOnly = true;\n        contextItem.howToSet = howToSet;\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // single/stand alone attributes\n        const aloneResult = processStandAloneAttribute(values, valueInValues, element, support, howToSet, contexts, parentContext);\n        if (aloneResult) {\n            contexts.push(...aloneResult);\n        }\n        return contextItem;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, [], // contexts,\n        howToSet, values, support.context);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, [], // contexts,\n        parentContext, howToSet, support, isSpecial, valueVar);\n    }\n    // simple name/value attribute\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial, parentContext);\n}\n/** Only used during updates */\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, _subject) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(\n        // subject,\n        newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processTagCallbackFun(\n// subject: AttributeContextItem,\nnewAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    // const tagJsVar = subject.tagJsVar // = valueToTagJsVar(newAttrValue)\n    // tagJsVar.processUpdate = processUpdateAttrContext\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/index.js';\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { Subject } from '../../subject/Subject.class.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, contexts, howToSet, //  = howToSetInputValue\nvalues, parentContext) {\n    const startIndex = contexts.length;\n    const createdContexts = [];\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = contexts.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                updateCount: 0,\n                isAttr: true,\n                target: element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n                valueIndex: parentContext.varCounter, // contexts.length,\n                parentContext,\n                destroy$: new Subject(),\n                render$: new Subject(),\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHandler(value, contextItem, newSupport, newValues) {\n                ++contextItem.updateCount;\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            createdContexts.push(contextItem);\n            ++parentContext.varCounter;\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n    return createdContexts;\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, parentContext, howToSet, //  = howToSetInputValue\nsupport, isSpecial, varIndex) {\n    if (typeof (value) === BasicTypes.function) {\n        ++parentContext.varCounter;\n        return processTagCallbackFun(\n        // contextItem,\n        value, support, attrName, element);\n    }\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        updateCount: 0,\n        isAttr: true,\n        target: element,\n        attrName,\n        howToSet,\n        value,\n        withinOwnerElement: true,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        valueIndex: varIndex,\n        parentContext,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial);\n    contextItem.value = value;\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { setNonFunctionInputValue } from '../../interpolations/attributes/howToSetInputValue.function.js';\nimport { getNewContext } from '../addOneContext.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../../tag/cycles/setContextInCycle.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** adds onto parent.contexts */\nexport function processTagJsVarAttribute(value, contexts, parentContext, tagJsVar, varIndex, support, attrName, element, isNameVar) {\n    // getOneContext\n    const contextItem = getNewContext(value, contexts || [], true, parentContext);\n    contextItem.target = element;\n    contextItem.valueIndex = varIndex;\n    contextItem.isAttr = true;\n    contextItem.isNameOnly = isNameVar;\n    contextItem.stateOwner = getSupportWithState(support);\n    contextItem.supportOwner = support;\n    setContextInCycle(contextItem);\n    tagJsVar.processInitAttribute(attrName, value, // tagJsVar,\n    element, tagJsVar, contextItem, support, setNonFunctionInputValue);\n    removeContextInCycle();\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = tagJsVar;\n    return contextItem;\n}\n","import { howToSetStandAloneAttr, setNonFunctionInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nexport function processAttributeArray(attrs, values, domElement, support, \n// contexts: ContextItem[],\nparentContext) {\n    for (const attr of attrs) {\n        const name = attr[0];\n        const value = attr[1];\n        // const isSpecial2 = !value?.tagJsVar && (typeof(name) === 'string' && isSpecialAttr(name))\n        const isSpecial = attr[2] || false; // isSpecial2\n        let howToSet = attr.length > 1 ? setNonFunctionInputValue : howToSetStandAloneAttr;\n        if (attr[3]) {\n            howToSet = attr[3];\n        }\n        // const contexts = support.context.contexts\n        const contexts = parentContext.contexts;\n        const newContext = processAttribute(name, value, values, domElement, support, howToSet, contexts, parentContext, isSpecial) || undefined;\n        if (typeof newContext === 'object') {\n            contexts.push(newContext);\n            ++parentContext.varCounter;\n        }\n    }\n}\n","import { paintAppends, paintAppend, paintCommands, paintBefore } from \"../paint.function.js\";\nimport { processAttributeArray } from \"./processAttributeArray.function.js\";\nexport function attachDomElement(domElement, node, values, support, parentContext, appendTo, insertBefore) {\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        processAttributeArray(node.at, values, domElement, support, \n        // contexts,\n        parentContext);\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement, 'appendToAttachDomElement']]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement, 'insertBeforeAttachDomElement']]);\n    }\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppendElementString, paintAppends, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nimport { attachDomElement } from \"./attachDomElement.function.js\";\nimport { Subject } from \"../../subject/Subject.class.js\";\nimport { isFunction } from \"../../index.js\";\nexport function attachDomElements(nodes, values, support, parentContext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const context = support.context;\n    const contexts = context.contexts;\n    parentContext = context;\n    // const contexts = parentContext.contexts\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    // loop map of elements that need to be put down on document\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const v = node.v;\n        const isNum = !isNaN(v);\n        if (isNum) {\n            // const valueIndex = context.varCounter // contexts.length\n            // const valueIndex = (parentContext as SupportContextItem).varCounter // contexts.length\n            const valueIndex = Number(v); // (parentContext as SupportContextItem).varCounter // contexts.length\n            const realValue = values[valueIndex];\n            const isSkipFun = isFunction(realValue) && realValue.tagJsType === undefined;\n            if (isSkipFun) {\n                ++parentContext.varCounter;\n                // TODO: I dont think we ever get in here?\n                continue;\n            }\n            const contextItem = attachDynamicDom(realValue, contexts, support, parentContext, depth, appendTo, insertBefore);\n            contextItem.valueIndex = valueIndex;\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        const domElement = newNode.domElement = document.createElement(node.nn);\n        // Create parent context for attributes first\n        const newParentContext = {\n            updateCount: 0,\n            isAttrs: true,\n            target: domElement,\n            parentContext,\n            contexts: [],\n            destroy$: new Subject(),\n            render$: new Subject(),\n            tagJsVar: {\n                tagJsType: 'new-parent-context'\n            },\n            valueIndex: -1,\n            withinOwnerElement: true,\n        };\n        newParentContext.varCounter = 0;\n        // one single html element. This is where attribute processing takes place\n        attachDomElement(domElement, node, values, support, newParentContext, appendTo, insertBefore);\n        // Update parent context with element and attribute contexts\n        newParentContext.target = domElement;\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, newParentContext, \n            // contexts,\n            depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, contexts };\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Merges strings & values with dom meta into a html array tree */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, appendTo, insertBefore) {\n    const subject = support.context;\n    // TODO this is only needed for components and not basic tags\n    subject.state = subject.state || {};\n    const stateMeta = subject.state;\n    stateMeta.oldest = support;\n    stateMeta.newest = support;\n    subject.state.older = subject.state.newer;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, support.context, appendTo, insertBefore);\n    subject.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, parentContext, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const context = support.context;\n    parentContext = context;\n    context.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, parentContext, 0, // depth\n    appendTo, insertBefore);\n    return result;\n}\n/** Extracts variables from support in order to merge strings & values with dom meta into a html array tree */\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChangeAndUpdate } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\nimport { blankHandler } from '../dom/blankHandler.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem) {\n    const support = contextItem.state.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInitAttribute: blankHandler,\n        processInit: processTagInit,\n        processUpdate: blankHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: blankHandler,\n        propWatch: 'shallow', // deprecate\n        key: blankHandler,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    subject.contexts = subject.contexts || [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\nappendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker, 'subMarker']]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement, 'subAppendTo']]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement, 'subInsertBefore']]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.state = {};\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processInitAttribute: blankHandler,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        },\n        matchesInjection(inject, context) {\n            if (templater.wrapper === inject) {\n                return context;\n            }\n            if (templater.wrapper?.original === inject?.original) {\n                return context;\n            }\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, subject, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { firstTagRender } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    firstTagRender(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, appendTo, insertBefore);\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribeWith(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    const subContext = setupSubscribe(value, contextItem, ownerSupport, insertBefore, appendTo);\n    if (!subContext.hasEmitted) {\n        emitSubContext(value, subContext);\n    }\n    return subContext;\n}\nexport function emitSubContext(value, subContext) {\n    const observables = value.Observables;\n    const observable = observables[0];\n    if (!subContext.hasEmitted) {\n        if ('withDefault' in value) {\n            subContext.subValueHandler(value.withDefault, 0);\n            return;\n        }\n        if ('value' in observable) {\n            subContext.subValueHandler(observable.value, 0);\n            return;\n        }\n        return; // nothing to emit\n    }\n    const emitValue = subContext.lastValues[0].value;\n    subContext.subValueHandler(emitValue, 0);\n}\n","import { setNonFunctionInputValue } from \"../index.js\";\nimport { isSpecialAttr } from \"../interpolations/attributes/isSpecialAttribute.function.js\";\nimport { processNonDynamicAttr } from \"../interpolations/attributes/processNameValueAttribute.function.js\";\nimport { unsubscribeContext, checkToPaint, setupSubscribeCallbackProcessor } from \"../tag/update/setupSubscribe.function.js\";\nimport { processAttributeUpdate } from \"./processAttributeUpdate.function.js\";\nexport function processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // same as value\ncontextItem, ownerSupport) {\n    // change how the delete occurs\n    value.destroy = unsubscribeContext;\n    const isSpecial = isSpecialAttr(name);\n    const onOutput = function onSubValue(callbackValue, syncRun) {\n        processNonDynamicAttr(name, callbackValue, element, setNonFunctionInputValue, isSpecial, contextItem);\n        checkToPaint(syncRun);\n    };\n    const subContext = setupSubscribeCallbackProcessor(value.Observables, ownerSupport, onOutput, value, contextItem);\n    contextItem.subContext = subContext;\n    contextItem.value = value;\n    contextItem.tagJsVar = value;\n    value.processUpdate = function processAttributeUpdateWrap(value, contextItem2, ownerSupport) {\n        return processAttributeUpdate(value, contextItem, ownerSupport, element, name, setNonFunctionInputValue);\n    };\n    return { subContext, onOutput };\n}\n","import { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nexport function processSubscribeWithAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, _tagJsVar, // its the same as the value\ncontextItem, ownerSupport) {\n    const { subContext } = processSubscribeAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\n    element, value, contextItem, ownerSupport);\n    if (!subContext.hasEmitted) {\n        emitSubScriptionAsIs(value, subContext);\n    }\n}\nexport function emitSubScriptionAsIs(value, subContext) {\n    const tagJsVar = subContext.tagJsVar;\n    const onOutput = tagJsVar.onOutput; // value.onOutput\n    const observables = value.Observables;\n    let obValue = observables[0]?.value || value.withDefault;\n    // subContext.hasEmitted = true\n    // subContext.lastValues[0] = obValue\n    if (value.callback) {\n        obValue = value.callback(obValue);\n    }\n    onOutput(obValue, true, subContext);\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribeWith.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { processSubscribeWithAttribute } from \"./processSubscribeWithAttribute.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    // const support = getSupportInCycle() as AnySupport\n    // const context = getSupportWithState(support).context\n    /*\n    const context = getContextInCycle() as ContextItem\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        onOutput: blankHandler, // this gets set within setupSubscribe\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeWithAttribute,\n        processInit: processSubscribeWith,\n        hasValueChanged: checkSubscribeValueChanged,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        // states: newer.states,\n        Observables: [Observable],\n    };\n}\n/** checks is a previous tag var was a subscription but now has changed */\nexport function checkSubscribeValueChanged(value, contextItem) {\n    if (!value?.tagJsType) {\n        return 1; // its not a subscription anymore\n    }\n    const newObserves = value.Observables;\n    if (!newObserves) {\n        return 2; // its not a subscription anymore\n    }\n    const oldValue = contextItem.value;\n    const oldObserves = oldValue.Observables;\n    if (!oldObserves || oldObserves.length !== newObserves.length) {\n        return 3; // not the same subscription\n    }\n    const allMatch = newObserves.every((ob, index) => ob === oldObserves[index]);\n    if (!allMatch) {\n        return 4;\n    }\n    return 0; // still the same\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** used to handle when value was subscribe but now is something else */\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem) {\n    const isDifferent = !newValue || !newValue.tagJsType || newValue.tagJsType !== originalType;\n    if (isDifferent) {\n        const oldTagJsVar = contextItem.tagJsVar;\n        oldTagJsVar.destroy(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, // subSubContext,\n        ownerSupport, 99);\n        return 99;\n    }\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { handleTagTypeChangeFrom } from './handleTagTypeChangeFrom.function.js';\nexport function checkStillSubscription(newValue, contextItem, ownerSupport) {\n    const subContext = contextItem.subContext;\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    if (!subContext || !subContext.hasEmitted) {\n        return 0;\n    }\n    subContext.tagJsVar = newValue;\n    subContext.valuesHandler(subContext.lastValues, 0);\n    return 0;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\nimport { processSubscribeAttribute } from \"./processSubscribeAttribute.function.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { checkStillSubscription } from \"../tag/update/checkStillSubscription.function.js\";\nimport { Subject } from \"../index.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    return {\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: processSubscribeAttribute,\n        processInit: setupSubscribe,\n        hasValueChanged: checkSubscribeValueChanged,\n        processUpdate: checkStillSubscription,\n        // processUpdate: processUpdateSubscribe,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states,\n        Observables: [Observable],\n    };\n}\nsubscribe.all = subscribeAll;\nfunction subscribeAll(subjects, callback) {\n    return subscribe(Subject.all(subjects), callback);\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteContextSubContext(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subscription = contextItem.subContext;\n    const result = deleteSubContext(subscription, ownerSupport);\n    delete contextItem.subContext;\n    return result;\n}\nexport function deleteSubContext(subContext, ownerSupport) {\n    subContext.deleted = true;\n    const appendMarker = subContext.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker, 'deleteSubContext');\n        delete subContext.appendMarker;\n    }\n    // delete (contextItem as any).destroy\n    if (!subContext.hasEmitted) {\n        return;\n    }\n    const subContextItem = subContext.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.destroy(subContextItem, ownerSupport);\n    return 76;\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, [], insertBefore);\n}\n","import { deleteContextSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, contextItem, newSupport) {\n    ++contextItem.updateCount;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, insertBefore, appendTo) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        hasValueChanged: () => 0, // not expected to do anything\n        processInitAttribute: blankHandler,\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        destroy: deleteContextSubContext,\n    };\n}\n","import { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\nimport { checkSubscribeValueChanged } from \"./subscribeWith.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    /*\n    const support = getSupportInCycle() as AnySupport\n    const context = getSupportWithState(support).context\n    const stateMeta = context.state as ContextStateMeta\n    const newer = stateMeta.newer as ContextStateSupport\n    */\n    return {\n        onOutput: blankHandler, // gets set within setupSubscribe()\n        tagJsType: ValueTypes.subscribe,\n        processInitAttribute: blankHandler,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInit: processPipe,\n        processUpdate: blankHandler,\n        destroy: deleteAndUnsubscribe,\n        callback,\n        // states: newer.states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: values,\n    };\n    return setupSubscribe(subValue, contextItem, ownerSupport, undefined, appendTo);\n}\n","import { getContextInCycle, paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/blankHandler.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\nimport { findStateSupportUpContext } from \"../interpolations/attributes/getSupportWithState.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const context = getContextInCycle();\n    // const support = getSupportWithState(context)\n    // const parentContext = context?.parentContext\n    if (!context) {\n        throw new Error('output must be used in render sync with a parent context');\n    }\n    const support = findStateSupportUpContext(context);\n    // const support = getSupportInCycle() as AnySupport\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    if (callback.wrapped === true) {\n        return callback;\n    }\n    const newCallback = (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport.context);\n    };\n    newCallback.wrapped = true;\n    return newCallback;\n}\nexport function syncWrapCallback(args, callback, context) {\n    const stateMeta = context.state;\n    const newerStates = stateMeta.newer.states;\n    const olderStates = stateMeta.older ? stateMeta.older.states : newerStates;\n    const newestOwner = stateMeta.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newerStates, olderStates);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(olderStates, newerStates);\n    // now render the owner\n    paintAfters.push([() => {\n            const newGlobal = newestOwner.context.global;\n            const ignore = newGlobal === undefined || newGlobal.deleted === true;\n            if (ignore) {\n                ++painting.locks;\n                newestOwner.context.tagJsVar.processUpdate(newestOwner.context.value, newestOwner.context, newestOwner, []);\n                --painting.locks;\n                paint();\n                return; // its not a tag anymore\n            }\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { initState } from \"../state/state.utils.js\";\nimport { reState } from '../state/reState.function.js';\nimport { runAfterRender } from \"../render/runAfterRender.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/handleTagTypeChangeFrom.function.js\";\nimport { isFunction } from \"../index.js\";\n/** Use to gain access to element\n * @callback called every render\n */\nexport function host(callback, options = {}) {\n    const baseHost = {\n        tagJsType: ValueTypes.host,\n        processInitAttribute: processHostAttribute,\n        // TODO: maybe a host value can change?\n        hasValueChanged: () => 0,\n        processInit: processHost, // This should be a throw error because only attribute is supported\n        processUpdate: processHostUpdate,\n        destroy: deleteHost,\n        options: { callback, ...options },\n        matchesInjection(inject, context) {\n            const options = inject?.options;\n            if (!options) {\n                return false;\n            }\n            const injectCallback = options?.callback;\n            // Check if the inject target is a host with the same callback\n            if (injectCallback === callback) {\n                return context;\n            }\n            return false;\n        },\n    };\n    const returnFunction = (...args) => {\n        const hostValue = {\n            ...returnFunction,\n            options: { arguments: args, ...options, callback },\n        };\n        return hostValue;\n    };\n    Object.assign(returnFunction, baseHost);\n    // returnFunction.options = { callback }\n    return returnFunction;\n}\n// Attach the functions to the host namespace\n;\nhost.onInit = (callback) => {\n    return host(() => { }, { onInit: callback });\n};\nhost.onDestroy = (callback) => {\n    return host(() => { }, { onDestroy: callback });\n};\nfunction processHostUpdate(newValue, contextItem, ownerSupport) {\n    if (isFunction(newValue) && !newValue?.tagJsType) {\n        throw new Error('issue on its way');\n    }\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, \n    // tagJsVar,\n    ownerSupport, contextItem);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const oldTagJsVar = contextItem.tagJsVar;\n    const oldOptions = oldTagJsVar.options;\n    // const element = (contextItem as any as AttributeContextItem).target as HTMLInputElement\n    const newHost = newValue;\n    reState(contextItem);\n    const args = (newHost.options.arguments || oldOptions.arguments || []);\n    contextItem.returnValue = newHost.options.callback(...args);\n    runAfterRender(contextItem);\n}\nfunction processHostAttribute(name, value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\nelement, tagJsVar, // same as value not needed\ncontextItem) {\n    return processHost(tagJsVar, contextItem);\n}\n/* Only runs on host() init */\nfunction processHost(tagJsVar, contextItem) {\n    const element = contextItem.target;\n    const state = contextItem.state = {};\n    initState(contextItem);\n    processHostTagJsVar(element, tagJsVar, contextItem, state);\n    runAfterRender(contextItem);\n}\n/** first time run */\nfunction processHostTagJsVar(element, tagJsVar, contextItem, state) {\n    const args = tagJsVar.options.arguments || [];\n    const returnValue = tagJsVar.options.callback(...args);\n    // Store the return value for tag.inject to access\n    contextItem.returnValue = returnValue;\n    // DEPRECATED\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        // const element = contextItem.target as HTMLInputElement\n        options.onInit(element, tagJsVar, contextItem, state);\n    }\n    return returnValue;\n}\nfunction deleteHost(contextItem) {\n    ++contextItem.updateCount;\n    const attrContext = contextItem;\n    const tagJsVar = attrContext.tagJsVar;\n    const options = tagJsVar.options;\n    if (attrContext.destroy$.subscribers.length) {\n        // TODO: Not sure if this needed\n        setContextInCycle(contextItem);\n        syncWrapCallback([], attrContext.destroy$.next.bind(attrContext.destroy$), contextItem);\n        // TODO: Not sure if this needed\n        removeContextInCycle();\n    }\n    // DEPRECATED\n    // TODO: remove this code and use tag.onDestroy instead\n    if (options.onDestroy) {\n        const element = attrContext.target;\n        const hostDestroy = function processHostDestroy() {\n            setContextInCycle(contextItem);\n            const result = options.onDestroy(element, tagJsVar, attrContext, attrContext.state);\n            removeContextInCycle();\n            return result;\n        };\n        const stateOwner = contextItem.stateOwner;\n        return syncWrapCallback([], hostDestroy, stateOwner.context);\n    }\n}\n","import { isPromise } from '../../index.js';\nimport { paint } from '../../render/index.js';\nimport { blankHandler } from '../../render/dom/blankHandler.function.js';\nimport { checkTagValueChange } from '../checkTagValueChange.function.js';\nimport { makeRealUpdate, afterDestroy } from './processFirstSubjectComponent.function.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used when a tag() does not return html`` */\nexport function getOverrideTagVar(context, newContext, support, subject) {\n    // support.context = subject as SupportContextItem\n    const overrideTagVar = {\n        tagJsType: 'tag-conversion',\n        // processInitAttribute: newContext.tagJsVar.processInitAttribute,\n        processInitAttribute: blankHandler, // cannot be an attribute ever\n        processInit: (_value, _contextItem, _ownerSupport) => {\n            const renderContent = context.returnValue;\n            return newContext.tagJsVar.processInit(renderContent, newContext, support, subject.placeholder);\n        },\n        processUpdate: (value, context, ownerSupport) => {\n            if (context.locked || context.deleted) {\n                return;\n            }\n            ++context.updateCount;\n            const oldValue = context.value;\n            const oldType = oldValue.tagJsType;\n            const newType = value?.tagJsType;\n            const hasTypeChanged = newType !== oldType;\n            const hasChanged = checkTagValueChange(value, context);\n            // check to see if the tagConversion itself has changed\n            const changed = hasChanged || hasTypeChanged || overrideTagVar.hasValueChanged(value, context, // aka contextItem,\n            support);\n            if (changed) {\n                overrideTagVar.destroy(context, support);\n                updateToDiffValue(value, context, // newContext\n                ownerSupport, 789);\n                return;\n            }\n            context.locked = 467;\n            context.render$.next(); // cause tag.onRender to fire\n            const convertValue = context.returnValue;\n            makeRealUpdate(newContext, value, context, convertValue, support);\n            delete context.locked;\n        },\n        hasValueChanged: (_value, _context, support) => {\n            const newValue = context.returnValue;\n            const checkResult = newContext.tagJsVar.hasValueChanged(newValue, newContext, support);\n            return checkResult;\n        },\n        destroy: (contextItem, ownerSupport) => {\n            ++context.updateCount;\n            context.deleted = true;\n            delete context.returnValue;\n            const result = newContext.tagJsVar.destroy(newContext, support);\n            if (isPromise(result)) {\n                return result.then(() => {\n                    const result = afterDestroy(context, ownerSupport);\n                    paint();\n                    return result;\n                });\n            }\n            context.destroy$.next();\n            return afterDestroy(context, ownerSupport);\n        }\n    };\n    return overrideTagVar;\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { firstTagRender } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { castProps } from '../props/alterProp.function.js';\nimport { convertTagToElementManaged } from './convertTagToElementManaged.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nfunction createSupportWithProps(templater, subject, ownerSupport) {\n    const newSupport = createSupport(templater, subject, ownerSupport, ownerSupport?.appSupport);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const support = firstTagRender(newSupport, subject.state.newest, // existing tag\n    subject);\n    return support;\n}\nexport function processReplacementComponent(templater, context, ownerSupport) {\n    const support = createSupportWithProps(templater, context, ownerSupport);\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, support.ownerSupport, context);\n    }\n    buildBeforeElement(support, undefined, // element for append child\n    context.placeholder);\n    return support;\n}\nexport function makeRealUpdate(newContext, value, context, convertValue, support) {\n    const castedProps = castProps(value.props, support, // ownerSupport,\n    0);\n    newContext.value.props = castedProps;\n    const propsConfig = support.propsConfig;\n    if (propsConfig) {\n        propsConfig.castProps = castedProps;\n    }\n    ;\n    newContext.updatesHandler = context.updatesHandler;\n    if (context.updatesHandler) {\n        setContextInCycle(context);\n        const updatesHandler = context.updatesHandler;\n        updatesHandler(castedProps); // updates()\n        removeContextInCycle();\n    }\n    newContext.tagJsVar.processUpdate(convertValue, newContext, support, []);\n    newContext.value = convertValue;\n}\nexport function afterDestroy(context, _ownerSupport) {\n    delete context.returnValue;\n    delete context.global // = {} as any;\n    ;\n    context.contexts = [];\n    ;\n    context.htmlDomMeta = [];\n    delete context.updatesHandler;\n    // context.value.destroy(context, ownerSupport)\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, appendTo) {\n    const support = createSupportWithProps(templater, subject, ownerSupport);\n    // DISCOVER IF tag() did NOT return dom|html\n    const tag = support.templater.tag;\n    if (!['dom', 'html'].includes(tag.tagJsType)) {\n        return convertTagToElementManaged(support, ownerSupport, subject);\n    }\n    return processFirstTagResult(support, appendTo);\n}\n","import { Subject } from '../../index.js';\nimport { valueToTagJsVar } from '../../tagJsVars/index.js';\nimport { getOverrideTagVar } from './getOverrideTagVar.js';\nexport function convertTagToElementManaged(support, ownerSupport, subject) {\n    const context = support.context;\n    const newValue = support.returnValue; // context.returnValue\n    // EXAMPLE: ['a','b'].map(x=> tag(() => [div,span]).key(x))\n    /*\n    if(Array.isArray(newValue)) {\n      ;(newValue as any).key = (arrayValue: any) => keyTag(arrayValue, newValue)\n    }\n    */\n    const tagJsVar = valueToTagJsVar(newValue);\n    delete context.global;\n    context.contexts = [];\n    const newContext = {\n        updateCount: 0,\n        value: newValue,\n        tagJsVar,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        placeholder: context.placeholder,\n        // not important\n        valueIndex: -1,\n        withinOwnerElement: true,\n        parentContext: context,\n        contexts: context.contexts, // share contexts especially so providers properly crawl my available contexts\n        // contexts: subject.contexts, // share contexts especially so providers properly crawl my available contexts\n    };\n    // context.contexts = [ newContext ] as ContextItem[] & SupportContextItem[]\n    const overrideTagVar = getOverrideTagVar(context, newContext, support, subject);\n    context.tagJsVar = overrideTagVar;\n    // TODO: should we be calling this here?\n    tagJsVar.processInit(newValue, newContext, support, subject.placeholder);\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, appendTo) {\n    const result = buildBeforeElement(support, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\n_insertBefore, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processFirstSubjectComponent(value, contextItem, ownerSupport, appendTo);\n    }\n    return processReplacementComponent(value, contextItem, ownerSupport);\n}\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { tag } from '../index.js';\nimport { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const context = getContextInCycle();\n        if (context.global) {\n            const nowSupport = getSupportInCycle();\n            return checkToResolvePromise(result, nowSupport, { resolvePromise, resolveValue });\n        }\n    });\n    return tag;\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n","import { state } from \"./state.function.js\";\nimport { getContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const context = getContextInCycle();\n        context.destroy$.toCallback(callback);\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { callback, setUseMemory, state } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../tag/checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from '../tag/destroySupportByContextItem.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nimport { getContextInCycle, getElement as getTagElement } from '../tag/cycles/setContextInCycle.function.js';\nimport { tagInject } from './tagInject.function.js';\nimport { onInit as tagOnInit } from '../state/onInit.function.js';\nimport { onDestroy as tagOnDestroy } from '../state/onDestroy.function.js';\nimport { onRender as tagOnRender } from '../state/onRender.function.js';\nimport { getInnerHTML as tagGetInnerHTML } from '../index.js';\nlet tagCount = 0;\nconst onClick = makeEventListener('click');\nconst onMouseDown = makeEventListener('mousedown');\nfunction makeEventListener(type) {\n    return function eventListener(toBeCalled) {\n        const wrapped = callback(toBeCalled); // should cause render to occur\n        // run one time\n        state(() => {\n            const element = getTagElement();\n            element.addEventListener(type, wrapped);\n        });\n        return wrapped; // this is what you remove\n    };\n}\nconst tagElement = {\n    get: getTagElement,\n    onclick: onClick,\n    click: onClick,\n    onClick,\n    mousedown: onMouseDown,\n    onmousedown: onMouseDown,\n    onMouseDown: onMouseDown,\n};\ndefineGetSet('onclick', onClick);\ndefineGetSet('click', onClick);\ndefineGetSet('onMouseDown', onMouseDown);\ndefineGetSet('onmousedown', onMouseDown);\ndefineGetSet('mousedown', onMouseDown);\nfunction defineGetSet(name, eventFn) {\n    Object.defineProperty(tag, name, {\n        get() {\n            return eventFn;\n        },\n        set(fn) {\n            return eventFn(fn);\n        },\n    });\n}\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        templater.hasValueChanged = checkTagValueChangeAndUpdate;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    const returnWrap = parentWrap;\n    // used for argument updates\n    returnWrap.updates = (handler) => {\n        const context = getContextInCycle();\n        context.updatesHandler = handler;\n        return true;\n    };\n    returnWrap.getInnerHTML = tagGetInnerHTML;\n    return returnWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n// actually placing of items into tag memory\n;\ntag.element = tagElement;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.inject = tagInject;\ntag.onInit = tagOnInit;\ntag.onDestroy = tagOnDestroy;\ntag.onRender = tagOnRender;\ntag.getInnerHTML = tagGetInnerHTML;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.destroy = destroySupportByContextItem;\n        oneRenderFunction.hasValueChanged = function renderOnceNeverChanges() {\n            return 0;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.hasValueChanged = checkTagValueChangeAndUpdate;\n        renderFunction.destroy = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch } from './hasSupportChanged.function.js';\nimport { shallowPropMatch } from './shallowPropMatch.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nimport { hasPropLengthsChanged } from '../render/checkRenderUp.function.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Inject a parent tag or host into the current context\n * For host functions, returns the value returned by the host callback\n * For tag components, returns the tag instance itself\n */\nexport function tagInject(targetItem) {\n    const context = getContextInCycle();\n    if (!context) {\n        throw new Error('tag.inject can only be called within a tag or host context');\n    }\n    // Search up the context tree for a matching parent\n    let currentContext = context.parentContext;\n    while (currentContext) {\n        // Check if this is an attributes context with child contexts\n        const contexts = currentContext.contexts;\n        if (contexts) {\n            // Search within the attributes contexts\n            for (const attrContext of contexts) {\n                if (attrContext.isAttr && attrContext.tagJsVar?.matchesInjection) {\n                    // Use the matchesInjection method if available\n                    const inContext = attrContext.tagJsVar.matchesInjection(targetItem, attrContext);\n                    if (inContext !== undefined) {\n                        // For host values, return the returnValue from the context\n                        return inContext.returnValue;\n                    }\n                }\n            }\n        }\n        // Check if this context has a tagJsVar with matchesInjection\n        if (currentContext.tagJsVar?.matchesInjection) {\n            if (currentContext.tagJsVar.matchesInjection(targetItem, currentContext)) {\n                // For tag components, return the tag instance\n                return currentContext.returnValue;\n            }\n        }\n        // Move up to the parent context\n        currentContext = currentContext.parentContext;\n    }\n    const message = `Could not find parent context for tag.inject ${targetItem}`;\n    console.error(message, { targetItem, context });\n    throw new Error(message);\n}\n","import { getContextInCycle, removeContextInCycle, setContextInCycle } from \"../tag/cycles/setContextInCycle.function.js\";\nimport { tag } from \"../tagJsVars/tag.function.js\";\nexport function onRender(callback) {\n    const context = getContextInCycle();\n    const callbackWrap = (_isFirst) => {\n        // remember current context (old)\n        // const oldIndex = setUseMemory.stateConfig.statesIndex\n        const lastContext = getContextInCycle();\n        // set to inner context cycle with previous state position\n        setContextInCycle(context);\n        const result = callback();\n        // restore previous cycle\n        removeContextInCycle();\n        setContextInCycle(lastContext);\n        return result;\n    };\n    const subscription = context.render$.subscribe(() => callbackWrap());\n    const result = callbackWrap();\n    tag.onDestroy(() => subscription.unsubscribe());\n    return result;\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    const global = context.global;\n    global.blocked = [];\n    // context.state.newer = context.state.newer || { ...setUseMemory.stateConfig }\n    if (!context.state) {\n        context.state = {\n            newer: {\n                state: [],\n                states: [],\n            }\n        };\n    }\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, // when appSupport not defined then this support becomes appSupport\nappSupport, castedProps) {\n    support.appSupport = appSupport || support;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsubject, ownerSupport, // when not\nappSupport, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport || support;\n    support.ownerSupport.appSupport = appSupport || support.ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport) {\n    const isComp = isTagComponent(newValue);\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        contextItem.oldTagJsVar = contextItem.tagJsVar;\n        contextItem.tagJsVar = newValue;\n        // its html/dom based tag\n        const support = contextItem.state.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, contextItem.placeholder);\n    contextItem.oldTagJsVar = contextItem.tagJsVar;\n    contextItem.tagJsVar = newValue;\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    // When last value was not a component\n    if (!contextItem.state.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, contextItem, ownerSupport, ownerSupport.appSupport);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, subject, ownerSupport, ownerSupport.appSupport);\n    const lastSubject = oldSupport.context;\n    const oldest = lastSubject.state.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './arrays/processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, context, ownerSupport, ignoreOrDestroyed) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    delete context.deleted;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(context, newValue, ownerSupport);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(context, newValue, ownerSupport);\n        context.oldTagJsVar = context.tagJsVar;\n        context.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        context.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) { // TODO: is this check really needed?\n        processNowRegularValue(newValue, context);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.hasValueChanged(newValue, contextItem, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === 0) {\n        return ignoreOrDestroyed; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed);\n    return ignoreOrDestroyed;\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { checkStillSubscription } from './checkStillSubscription.function.js';\nimport { emitSubContext } from './processSubscribeWith.function.js';\nexport function processUpdateSubscribe(newValue, contextItem, ownerSupport) {\n    const resultNum = checkStillSubscription(newValue, // subValue,\n    contextItem, ownerSupport);\n    if (contextItem.hasEmitted !== true) {\n        const Observables = contextItem.value.Observables;\n        if (!Observables) {\n            return;\n        }\n        const Observable = Observables[0];\n        // const subValue = Observable.value\n        if (!('value' in Observable)) {\n            return; // its never emitted\n        }\n    }\n    if (resultNum === 0 && newValue.callback) {\n        const subContext = contextItem.subContext;\n        emitSubContext(newValue, subContext);\n    }\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { deleteSubContext } from './deleteContextSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nimport { processUpdateSubscribe } from './processUpdateSubscribe.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../cycles/setContextInCycle.function.js';\nexport function setupSubscribe(value, contextItem, ownerSupport, insertBeforeOriginal, // optional but will always be made\nappendTo) {\n    const observables = value.Observables;\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    let onOutput = function onSubValue(value, syncRun, subContext) {\n        onFirstSubContext(value, subContext, ownerSupport, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = subContext.tagJsVar.onOutput = function subscriptionUpdate(updateValue, syncRun, subContext) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport);\n            aContext.tagJsVar.processUpdate(updateValue, aContext, ownerSupport, [updateValue]);\n            // processUpdateContext(ownerSupport)\n            aContext.value = updateValue;\n            checkToPaint(syncRun);\n        };\n    };\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, (value, syncRun, subContext) => onOutput(value, syncRun, subContext), value, contextItem);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    value.processUpdate = processUpdateSubscribe;\n    value.onOutput = onOutput;\n    return subContext;\n}\n/** After calling this function you need to set `contextItem.subContext = subContext` */\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\nonOutput, tagJsVar, contextItem) {\n    // const component = getSupportWithState(ownerSupport)\n    // onValue mutates so function below calls original and mutation\n    function subValueHandler(value, index) {\n        subContext.lastValues[index] = {\n            value,\n            tagJsVar: valueToTagJsVar(value),\n            oldTagJsVar: subContext.lastValues[index]?.tagJsVar\n        };\n        valuesHandler(subContext.lastValues, index);\n    }\n    function valuesHandler(newValues, index) {\n        const newestParentTagJsVar = subContext.tagJsVar;\n        const callback = newestParentTagJsVar?.callback;\n        if (callback) {\n            setContextInCycle(contextItem);\n            const responseValue = newestParentTagJsVar.callback(...newValues.map(x => x.value));\n            onOutput(responseValue, syncRun, subContext);\n            removeContextInCycle();\n            return;\n        }\n        const newValue = newValues[index].value;\n        onOutput(newValue, syncRun, subContext);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        subValueHandler,\n        valuesHandler,\n        tagJsVar,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => subValueHandler(value, index)));\n        syncRun = false;\n    });\n    tagJsVar.onOutput = onOutput;\n    return subContext;\n}\nexport function unsubscribeContext(contextItem) {\n    const subscription = contextItem.subContext;\n    if (!subscription) {\n        return; // TODO: wonder why this happens, maybe subscription never emits?\n    }\n    const subscriptions = subscription.subscriptions;\n    subscriptions.forEach(sub => sub.unsubscribe());\n    delete contextItem.subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    ++contextItem.updateCount;\n    const subContext = contextItem.subContext;\n    unsubscribeContext(contextItem);\n    return deleteSubContext(subContext, ownerSupport);\n}\nexport function checkToPaint(syncRun) {\n    if (syncRun) {\n        return;\n    }\n    if (setUseMemory.stateConfig.support) {\n        return;\n    }\n    paint();\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nexport function processSignal(value, contextItem, ownerSupport, _insertBefore, appendTo) {\n    const subValue = {\n        tagJsType: ValueTypes.subscribe,\n        states: [],\n        Observables: [value],\n    };\n    setupSubscribe(subValue, contextItem, ownerSupport, _insertBefore, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSignal.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { checkSubscribeValueChanged } from '../tagJsVars/subscribeWith.function.js';\nimport { processUpdateSubscribe } from '../tag/update/processUpdateSubscribe.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        tagJsType: ValueTypes.signal,\n        hasValueChanged: checkSubscribeValueChanged,\n        processInitAttribute: blankHandler,\n        processInit: processSignal,\n        processUpdate: processUpdateSubscribe,\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        destroy: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { ValueSubject } from '../subject/index.js';\nimport { tag } from '../tag/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback).pastResult;\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup).pastResult;\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const isFun = typeof (currentValues) === 'function';\n    const realValues = isFun ? currentValues() : currentValues;\n    const isFirstRender = previous.values === undefined;\n    let renderCount = 0;\n    if (isFirstRender) {\n        if (typeof (currentValues) === 'function') {\n            tag.onRender(() => {\n                ++renderCount;\n                if (renderCount === 1) {\n                    return; // first run is already performed\n                }\n                const realValues = currentValues();\n                processRealValues(realValues);\n            });\n        }\n    }\n    function processRealValues(realValues) {\n        // First time running watch?\n        if (previous.values === undefined) {\n            if (before && !before(realValues)) {\n                previous.values = realValues;\n                return previous; // do not continue\n            }\n            const castedInit = init || callback;\n            const result = castedInit(realValues, previous.values);\n            previous.pastResult = final(result);\n            previous.values = realValues;\n            return previous;\n        }\n        const allExact = realValues.every((item, index) => item === previous.values[index]);\n        if (allExact) {\n            return previous;\n        }\n        if (before && !before(realValues)) {\n            previous.values = realValues;\n            return previous; // do not continue\n        }\n        const result = callback(realValues, previous.values);\n        previous.pastResult = final(result);\n        previous.values.length = 0;\n        previous.values.push(...realValues);\n        return previous;\n    }\n    return processRealValues(realValues);\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => {\n                return new ValueSubject(undefined);\n            });\n            const oldState = state(() => ({\n                state: setUseMemory.stateConfig.state,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                const handler = (realValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(realValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.state;\n                        const context = firstSupport.context;\n                        const stateMeta = context.state;\n                        const oldestStateSupport = stateMeta.older;\n                        if (oldestStateSupport) {\n                            const oldestState = oldestStateSupport.state;\n                            const newStates = oldState.states;\n                            const oldStates = oldestStateSupport.states;\n                            oldSyncStates(newestState, oldestState, newStates, oldStates);\n                        }\n                    }\n                    subject.next(setTo);\n                };\n                setupWatch(currentValues, handler, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            state: setUseMemory.stateConfig.state,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            const context = nowSupport.context;\n            const stateMeta = context.state;\n            const newer = stateMeta.newer;\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        state: setUseMemory.stateConfig.state,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        const context = nowSupport.context;\n        const stateMeta = context.state;\n        const newer = stateMeta.newer;\n        if (newer) {\n            oldSyncStates(newer.state, oldestState.state, newer.states, oldestState.states);\n        }\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.state.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.state.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const context = support.context;\n            // const global = context.global as SupportTagGlobal\n            const providers = context.providers = context.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const context = owner.ownerSupport.context;\n            // const ownGlobal = context.global as SupportTagGlobal\n            const ownerProviders = context.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const context = support.context;\n                const providers = context.providers = context.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { paint } from '../tag/index.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const context = getContextInCycle();\n    const callbackState = state({\n        callback,\n    });\n    // ensure only one trigger instance created and always returned\n    const callbackTrigger = state(() => createTrigger(context, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callbackState));\n    // always update callback to latest in cycle\n    callbackState.callback = callback;\n    return callbackTrigger;\n}\nexport function createTrigger(context, oldState, callbackState) {\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        // ++painting.locks\n        const result = callbackStateUpdate(context, oldStates, callbackState.callback, ...args);\n        // --painting.locks\n        paint();\n        return result;\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nimport { findStateSupportUpContext } from '../interpolations/attributes/getSupportWithState.function.js';\nexport default function callbackStateUpdate(context, _oldStates, callback, ...args) {\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    const newestSupport = findStateSupportUpContext(context);\n    // TODO: This if may not be ever doing anything\n    if (!newestSupport) {\n        return maybePromise;\n    }\n    // context.global && \n    if (newestSupport.context.global) {\n        renderSupport(newestSupport); // TODO: remove with html``\n    }\n    else {\n        const supContext = newestSupport.context;\n        supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n        []);\n    }\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            if (context.global) {\n                renderSupport(newestSupport); // TODO: remove\n            }\n            else {\n                const supContext = newestSupport.context;\n                supContext.tagJsVar.processUpdate(supContext.value, supContext, newestSupport.ownerSupport, // ownerSupport,\n                []);\n            }\n        });\n    }\n    return maybePromise;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nimport { getContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nexport const callbackMaker = () => {\n    const context = getContextInCycle();\n    // const support = getSupportInCycle()\n    // callback as typeof innerCallback\n    if (!context) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(context, oldState, { callback });\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/cycles/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { setUseMemory } from '../../state/index.js';\nexport function getContextInCycle() {\n    return setUseMemory.stateConfig.context;\n}\n/** Gets the current element associated with taggedjs document processing */\nexport function getElement() {\n    const context = getContextInCycle();\n    return context.target;\n}\n// const contextCycles: ContextItem[] = []\nexport function setContextInCycle(context) {\n    // contextCycles.push(context)\n    return setUseMemory.stateConfig.context = context;\n}\nexport function removeContextInCycle() {\n    // contextCycles.pop()\n    delete setUseMemory.stateConfig.context;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, appendTo, insertBefore);\n    }\n    const stateMeta = contextItem.state = contextItem.state || {};\n    stateMeta.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ninsertBefore, appendTo) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    insertBefore, appendTo);\n    // contextItem.handler = function outDomTagHanlder(\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate = function outDomTagHanlder(value, contextItem2, newSupport) {\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.hasValueChanged = checkOuterTagValueChange;\n}\nfunction checkOuterTagValueChange(newValue, contextItem) {\n    return checkTagValueChangeAndUpdate(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem);\n}\n/** tag(html``) When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInitAttribute: blankHandler,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            return keyTag(arrayValue, tag);\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\nexport function keyTag(arrayValue, tag) {\n    keyTag(arrayValue, tag);\n    tag.arrayValue = arrayValue;\n    return tag;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChangeAndUpdate } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInitAttribute: blankHandler,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChangeAndUpdate } from './checkTagValueChange.function.js';\nimport { destroySupportByContextItem } from './destroySupportByContextItem.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { setSupportInCycle } from './cycles/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\nimport { removeContextInCycle } from './cycles/setContextInCycle.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, // aka appElement\nprops) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    const newest = subject.state.newest;\n    initState(newest.context);\n    setSupportInCycle(newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            subject.state.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const result = renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n    removeContextInCycle();\n    return result;\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        hasValueChanged: checkTagValueChangeAndUpdate,\n        destroy: destroySupportByContextItem,\n        processInitAttribute: blankHandler,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const context = {\n        updateCount: 0,\n        value: templater,\n        valueIndex: 0,\n        varCounter: 0,\n        destroy$: new Subject(),\n        render$: new Subject(),\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        state: {},\n        // parentContext: undefined as any,\n        tagJsVar,\n    };\n    // sets new global on context\n    getNewGlobal(context);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    context.events = {};\n    loadNewBaseSupport(templater, context, appElement);\n    return context;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    // Initialize older/newer with empty state if first render\n    if (!subject.state.oldest) {\n        subject.state.oldest = newSupport;\n        subject.state.older = subject.state.newer;\n    }\n    subject.state.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { processReplacementComponent } from '../tag/update/processFirstSubjectComponent.function.js';\n// Imports used only by the commented-out runWrapper/executeStateWrap functions:\n// import { ContextStateSupport } from '../tag/ContextStateMeta.type.js'\n// import { Wrapper } from '../index.js'\n// import { createSupport } from '../tag/createSupport.function.js'\n// import { runAfterSupportRender } from './runAfterRender.function.js'\n// import { executeWrap } from './executeWrap.function.js'\n// import { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js'\n// import { reStateSupport } from '../state/reState.function.js'\nexport function renderTagElement(app, global, templater, templater2, element, // appElement\ncontext, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    context.placeholder = placeholder;\n    /*\n    const support = runWrapper(\n      templater,\n      placeholder,\n      element,\n      context,\n      isAppFunction,\n    )\n    */\n    global.isApp = true;\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = context.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        context.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    const ownerSupport = {\n        appSupport: {\n            appElement: element,\n            context,\n        },\n        appElement: element\n    };\n    const support = processReplacementComponent(templater, context, ownerSupport);\n    support.appElement = element;\n    // support.appSupport = support\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    /*\n    const newFragment = registerTagElement(\n      support,\n      element,\n      global,\n      templater,\n      app,\n      placeholder,\n    )\n    */\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\n","function isTemplateStringsArray(value) {\n    return (Array.isArray(value) &&\n        Object.prototype.hasOwnProperty.call(value, 'raw'));\n}\nexport function makeAttrCallable(attrName, attr) {\n    return function (item, stringsOrValue, values) {\n        if (isTemplateStringsArray(stringsOrValue)) {\n            const attrValue = stringsOrValue.reduce((all, chunk, index) => all + chunk + (values[index] ?? ''), '');\n            return attr(item, [attrName, attrValue]);\n        }\n        return attr(item, [attrName, stringsOrValue]);\n    };\n}\n","import { isFunction, isObject } from '../index.js';\nimport { setBooleanAttribute, setNonFunctionInputValue, setSimpleAttribute } from '../interpolations/attributes/howToSetInputValue.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { makeAttrCallable } from './attributeCallables.js';\nfunction callbackWrapper(item, eventName, callback) {\n    const clone = getPushKid(item, item.elementFunctions);\n    return callbackWrapper2(clone, eventName, callback);\n}\nfunction callbackWrapper2(item, eventName, callback) {\n    function wrapCallback(e) {\n        return wrapCallback.toCallback(e);\n    }\n    wrapCallback.toCallback = callback;\n    item.listeners.push([eventName, wrapCallback]);\n    item.allListeners.push([eventName, wrapCallback]);\n    return item;\n}\nfunction attr(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    clone.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsVar\n    }\n    return clone;\n}\n/** attrs({names: values}) */\nfunction attrs(item, args) {\n    const clone = getPushKid(item, item.elementFunctions);\n    Object.entries(args).map(args => {\n        clone.attributes.push(args);\n        if (isValueForContext(args[0])) {\n            registerMockAttrContext(args[0], clone); // the attrName is a function or TagJsVar\n        }\n        else if (isValueForContext(args[1])) {\n            registerMockAttrContext(args[1], clone); // the attrValue is a function or TagJsVar\n        }\n    });\n    return clone;\n}\nconst styleCallable = makeAttrCallable('style', attr);\nconst idCallable = makeAttrCallable('id', attr);\nconst classCallable = makeAttrCallable('class', attr);\nconst hrefCallable = makeAttrCallable('href', attr);\nconst valueCallable = makeAttrCallable('value', attr);\nconst placeholderCallable = makeAttrCallable('placeholder', attr);\nconst typeCallable = makeAttrCallable('type', attr);\nfunction attr2(item, args) {\n    // const clone = getPushKid(item as any, item.elementFunctions)\n    // clone.attributes.push(args as Attribute)\n    item.attributes.push(args);\n    if (isValueForContext(args[0])) {\n        registerMockAttrContext(args[0], item); // the attrName is a function or TagJsVar\n    }\n    else if (isValueForContext(args[1])) {\n        registerMockAttrContext(args[1], item); // the attrValue is a function or TagJsVar\n    }\n    return item;\n}\nexport function elementFunctions(item) {\n    /** Used for all element callbacks */\n    function makeCallback(eventName) {\n        return function (callback) {\n            return callbackWrapper(item, eventName, callback);\n        };\n    }\n    // TODO: This maybe the old way of doing things (see callables)\n    const callables_other = {\n        // ...eventCallables,\n        onClose: makeCallback('onclose'),\n        onDoubleClick: makeCallback('ondblclick'),\n        onClick: makeCallback('click'),\n        // onclick: makeCallback('click'),\n        // click: makeCallback('click'),\n        onBlur: makeCallback('onblur'),\n        onChange: makeCallback('onchange'),\n        onInput: makeCallback('oninput'),\n        // onchange: makeCallback('onchange'),\n        // change: makeCallback('onchange'),\n        onMousedown: makeCallback('onmousedown'),\n        onMouseup: makeCallback('onmouseup'),\n        onMouseover: makeCallback('onmouseover'),\n        onMouseout: makeCallback('onmouseout'),\n        onKeydown: makeCallback('onkeydown'),\n        onKeyup: makeCallback('onkeyup'),\n        // onkeyup: makeCallback('onkeyup'),\n        // keyup: makeCallback('onkeyup'),\n        /* apply attribute via attr(name: string, value?: any): **/\n        attr: (...args) => attr(item, args),\n        attrs: (attributes) => attrs(item, attributes),\n        /** Used for setting array index-key value */\n        key: function (arrayValue) {\n            ;\n            this.arrayValue = arrayValue;\n            return this;\n        },\n        /** Use as div.style`border:${border}` or div.style(() => `border:${border}`) */\n        style: ((stringsOrValue, ...values) => {\n            return styleCallable(item, stringsOrValue, values);\n        }),\n        /** Use as div.id`main` or div.id(() => `main-${1}`) */\n        id: ((stringsOrValue, ...values) => {\n            return idCallable(item, stringsOrValue, values);\n        }),\n        /** Use as div.class`primary` or div.class(() => `primary`) */\n        class: ((stringsOrValue, ...values) => {\n            return classCallable(item, stringsOrValue, values);\n        }),\n        /** Use as a.href`/path` or a.href(() => `/path`) */\n        href: ((stringsOrValue, ...values) => {\n            return hrefCallable(item, stringsOrValue, values);\n        }),\n        /** Use as input.value`text` or input.value(() => `${value}`) */\n        value: ((stringsOrValue, ...values) => {\n            return valueCallable(item, stringsOrValue, values);\n        }),\n        /** Use as input.placeholder`text` or input.placeholder(() => `${value}`) */\n        placeholder: ((stringsOrValue, ...values) => {\n            return placeholderCallable(item, stringsOrValue, values);\n        }),\n        /** Use as input.type`text` or input.type(() => `${value}`) */\n        type: ((stringsOrValue, ...values) => {\n            return typeCallable(item, stringsOrValue, values);\n        }),\n    };\n    return callables_other;\n}\nfunction setClassValue(element, name, value) {\n    if (isObject(value)) {\n        Object.entries(value).forEach(([name, value]) => {\n            if (value) {\n                element.classList.add(name);\n            }\n            else {\n                element.classList.remove(name);\n            }\n        });\n        return; // howToSetInputObjectValue(element, name, value as Record<string, any>)\n    }\n    setSimpleAttribute(element, name, value);\n}\n/** used during updates */\nexport function registerMockAttrContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\nexport function isValueForContext(value) {\n    return Array.isArray(value) || isFunction(value) || value?.tagJsType;\n}\nfunction setupAttr(attrName, howToSet) {\n    return (item, value) => attr2(item, [attrName, value, false, howToSet]);\n}\nfunction makeCallback(eventName) {\n    return (item, callback) => {\n        return callbackWrapper2(item, eventName, callback);\n    };\n}\nconst eventCallables = {\n    onClose: makeCallback('onclose'),\n    onClick: makeCallback('click'),\n    onDoubleClick: makeCallback('ondblclick'),\n    onDblClick: makeCallback('ondblclick'),\n    onBlur: makeCallback('onblur'),\n    onChange: makeCallback('onchange'),\n    onInput: makeCallback('oninput'),\n    onMousedown: makeCallback('onmousedown'),\n    onMouseDown: makeCallback('onmousedown'),\n    onMouseup: makeCallback('onmouseup'),\n    onMouseUp: makeCallback('onmouseup'),\n    onMouseover: makeCallback('onmouseover'),\n    onMouseOver: makeCallback('onmouseup'),\n    onMouseout: makeCallback('onmouseout'),\n    onMouseOut: makeCallback('onmouseout'),\n    onKeyup: makeCallback('onkeyup'),\n    onKeyUp: makeCallback('onkeyup'),\n    onKeydown: makeCallback('onkeydown'),\n    onKeyDown: makeCallback('onkeydown'),\n};\nconst callables = {\n    checked: setupAttr('checked', setBooleanAttribute),\n    selected: setupAttr('selected', setBooleanAttribute),\n    /** element.setAttribute('style', x)  */\n    class: setupAttr('class', setClassValue),\n    ...eventCallables\n};\nexport function loopObjectAttributes(item, object) {\n    const result = Object.entries(object).reduce((all, [name, value]) => {\n        if (name in callables) {\n            return callables[name](item, value);\n        }\n        return attr2(item, [name, value, false, setNonFunctionInputValue]);\n    }, item);\n    return result;\n}\n","import { isPromise } from '../index.js';\nimport { paint, painting } from '../render/paint.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\nimport { destroyContextHtml } from '../tag/smartRemoveKids.function.js';\nexport function destroyDesignElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            context.deleted = true;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                // destroyContextHtml(context)\n                destroyHtmlDomMeta(htmlDomMeta);\n                // delete context.htmlDomMeta\n                context.htmlDomMeta = [];\n                // context.deleted = true\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n    destroyContextHtml(context);\n    // delete context.htmlDomMeta\n    context.htmlDomMeta = [];\n    // context.deleted = true\n    delete context.contexts;\n    context.deleted = true;\n}\nexport function destroyDesignByContexts(contexts, ownerSupport, promises) {\n    const context = contexts[0];\n    const result = context.tagJsVar.destroy(context, ownerSupport);\n    context.deleted = true;\n    if (isPromise(result)) {\n        return promises.push(result.then(() => {\n            if (contexts.length > 1) {\n                return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n            }\n        }));\n    }\n    if (context.htmlDomMeta) {\n        destroyContextHtml(context);\n        delete context.htmlDomMeta;\n    }\n    if (contexts.length > 1) {\n        return destroyDesignByContexts(contexts.slice(1, contexts.length), ownerSupport, promises);\n    }\n}\n","import { updateToDiffValue } from '../tag/update/updateToDiffValue.function.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nexport function processDesignElementUpdate(value, context, ownerSupport) {\n    const skip = context.locked || context.deleted === true;\n    if (skip) {\n        return; // something else is running an event\n    }\n    ++context.updateCount;\n    const hasChanged = checkTagElementValueChange(value, context);\n    if (hasChanged) {\n        destroyDesignElement(context, ownerSupport);\n        // delete context.htmlDomMeta // The next value needs to know its not been deleted\n        context.htmlDomMeta = []; // The next value needs to know its not been deleted\n        // context.deleted = true // its not deleted but changed\n        delete context.deleted; // its not deleted but changed\n        updateToDiffValue(value, context, // newContext,\n        ownerSupport, 789);\n        return;\n    }\n    const contexts = context.contexts;\n    const vContexts = value.contexts || [];\n    const ogListeners = context.tagJsVar.allListeners;\n    const allListeners = value.allListeners;\n    allListeners.forEach((newListener, index) => {\n        // ensure the latest callback is always called. Needed for functions within array maps\n        const wrapCallback = ogListeners[index][1];\n        wrapCallback.toCallback = newListener[1].toCallback;\n    });\n    if (contexts.length !== vContexts.length) {\n        console.info('context mismatch', {\n            value,\n            context,\n            conValues: contexts.map(x => x.value),\n            vContexts,\n            deleted: context.deleted\n        });\n        throw new Error('super issue discovered');\n    }\n    context.locked = 79;\n    contexts.forEach((context, index) => {\n        context.tagJsVar.processUpdate(vContexts[index], // context.value,\n        context, ownerSupport);\n    });\n    delete context.locked;\n}\nexport function checkTagElementValueChange(value, context) {\n    const oldValue = context.value;\n    if (oldValue === value) {\n        return 0; // has not changed\n    }\n    // return 1 // it has changed\n    const notElement = !value || value.tagJsType !== 'element';\n    if (notElement) {\n        return 1;\n    }\n    const newKidLength = value.innerHTML.length;\n    const oldKidLength = context.value.innerHTML.length;\n    const kidLengthChanged = newKidLength !== oldKidLength;\n    if (kidLengthChanged) {\n        return 1;\n    }\n    const newAttrLength = value.attributes.length;\n    const oldAttrLength = context.value.attributes.length;\n    const kidAttrChanged = newAttrLength !== oldAttrLength;\n    if (kidAttrChanged) {\n        return 1;\n    }\n    return 0;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { getNewContext } from '../render/addOneContext.function.js';\nimport { paintCommands } from '../render/paint.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nimport { processElementVarFunction } from './processElementVarFunction.function.js';\nexport function processChildren(innerHTML, parentContext, ownerSupport, element, // appendTo\npaintBy) {\n    innerHTML.forEach(item => {\n        const type = typeof item;\n        switch (type) {\n            case 'string':\n            case 'boolean':\n            case 'number':\n                return handleSimpleInnerValue(item, element, paintBy);\n            case 'function': {\n                if (item.tagJsType === 'element') {\n                    break; // skip\n                }\n                const result = processElementVarFunction(item, element, parentContext, ownerSupport, paintBy);\n                return result;\n            }\n        }\n        if (item === null || item === undefined) {\n            return handleSimpleInnerValue(item, element, paintBy);\n        }\n        if (item.tagJsType === 'element') {\n            const newElement = processElementVar(item, parentContext, ownerSupport, parentContext.contexts);\n            paintCommands.push([paintBy, [element, newElement]]);\n            const htmlDomMeta = parentContext.htmlDomMeta;\n            htmlDomMeta.push({\n                nn: newElement.tagName,\n                domElement: newElement,\n                // at: newElement.attributes,\n                at: [],\n            });\n            return;\n        }\n        return processNonElement(item, parentContext, element, ownerSupport, paintBy);\n    });\n}\n/** used when a child is not another element and requires init processing */\nexport function processNonElement(item, parentContext, element, ownerSupport, paintBy) {\n    const newContext = getNewContext(item, [], // addedContexts\n    true, parentContext);\n    const contexts = parentContext.contexts;\n    contexts.push(newContext);\n    newContext.target = element;\n    newContext.placeholder = document.createTextNode('');\n    paintCommands.push([paintBy, [element, newContext.placeholder]]);\n    setContextInCycle(newContext);\n    newContext.tagJsVar.processInit(item, newContext, // context, // newContext,\n    ownerSupport, newContext.placeholder);\n    removeContextInCycle();\n    return newContext;\n}\nexport function handleSimpleInnerValue(value, element, paintBy) {\n    const castedValue = castTextValue(value);\n    const text = document.createTextNode(castedValue);\n    paintCommands.push([paintBy, [element, text]]);\n    return text;\n}\n","import { isFunction, Subject } from '../index.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { removeContextInCycle, setContextInCycle } from '../tag/cycles/setContextInCycle.function.js';\nimport { processNonElement } from './processChildren.function.js';\nexport function processElementVarFunction(item, element, parentContext, ownerSupport, paintBy) {\n    const subContexts = [];\n    const subContext = {\n        updateCount: 0,\n        parentContext,\n        contexts: subContexts,\n        target: element,\n        value: item,\n        htmlDomMeta: [],\n        tagJsVar: {\n            tagJsType: 'dynamic-text',\n            hasValueChanged: () => 0,\n            processInit: blankHandler,\n            processInitAttribute: blankHandler,\n            destroy: (_c, ownerSupport) => {\n                ++subContext.updateCount;\n                subContexts.forEach(subSub => subSub.tagJsVar.destroy(subSub, ownerSupport));\n            },\n            processUpdate: (value, contextItem, ownerSupport, values) => {\n                ++subContext.updateCount;\n                setContextInCycle(aSubContext);\n                let newValue = value(aSubContext);\n                const underFunction = subContext.underFunction;\n                delete subContext.underFunction;\n                if (newValue instanceof Function && !newValue.tagJsType) {\n                    if (underFunction && newValue.toString() === underFunction.toString()) {\n                        newValue = aSubContext.value;\n                    }\n                    else {\n                        subContext.underFunction = newValue;\n                        newValue = newValue();\n                    }\n                }\n                const result = aSubContext.tagJsVar.processUpdate(newValue, aSubContext, ownerSupport, values);\n                aSubContext.value = newValue;\n                contextItem.value = value;\n                removeContextInCycle();\n                return result;\n            }\n        },\n        // TODO: Not needed\n        valueIndex: -1,\n        withinOwnerElement: true,\n        destroy$: new Subject(),\n        render$: new Subject(),\n    };\n    // addedContexts.push(subContext)\n    setContextInCycle(subContext);\n    let trueValue = item();\n    const isAgainFunc = isFunction(trueValue) && !trueValue.tagJsType;\n    if (isAgainFunc) {\n        ;\n        subContext.underFunction = trueValue;\n        trueValue = trueValue(); // function returns function\n    }\n    const aSubContext = processNonElement(trueValue, subContext, // parentContext,\n    element, ownerSupport, paintBy);\n    const contexts = parentContext.contexts;\n    contexts.push(subContext);\n    removeContextInCycle();\n    return aSubContext;\n}\n","import { isPromise } from '../index.js';\nimport { addSupportEventListener } from '../interpolations/attributes/addSupportEventListener.function.js';\nimport { afterTagCallback } from '../interpolations/attributes/bindSubjectCallback.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nimport { isSpecialAttr } from '../interpolations/attributes/isSpecialAttribute.function.js';\nimport { renderTagUpdateArray } from '../interpolations/attributes/renderTagArray.function.js';\nimport { processAttributeArray } from '../render/dom/processAttributeArray.function.js';\nimport { paint, paintAppend, painting } from '../render/paint.function.js';\nimport { processChildren } from './processChildren.function.js';\n/** The first and recursive processor for elements */\nexport function processElementVar(value, context, ownerSupport, _addedContexts) {\n    const element = document.createElement(value.tagName);\n    context.target = element;\n    // mark special attributes\n    value.attributes.forEach(x => {\n        const name = x[0];\n        if (typeof (name) !== 'string') {\n            return;\n        }\n        x[2] = isSpecialAttr(name);\n    });\n    processAttributeArray(value.attributes, [], // values,\n    element, ownerSupport, context);\n    /*\n    value.listeners.forEach((listener, index) =>\n      registerListener(value, index, ownerSupport, listener, element)\n    )*/\n    processChildren(value.innerHTML, context, // parentContext\n    ownerSupport, element, paintAppend);\n    value.listeners.forEach((listener, index) => registerListener(value, index, ownerSupport, listener, element));\n    return element;\n}\nfunction registerListener(value, index, ownerSupport, listener, element) {\n    const wrap = (...args) => {\n        const listenScope = value.listeners[index];\n        const toCall = listenScope[1];\n        const stateSupport = getSupportWithState(ownerSupport);\n        const updateCount = stateSupport.context.updateCount;\n        stateSupport.context.locked = 1;\n        ++painting.locks;\n        const result = toCall(...args);\n        --painting.locks;\n        delete stateSupport.context.locked;\n        const needsRender = updateCount === stateSupport.context.updateCount;\n        if (needsRender) {\n            return afterTagCallback(result, stateSupport);\n        }\n        else {\n            paint();\n        }\n        if (isPromise(result)) {\n            return result.then(() => {\n                const newest = stateSupport.context.state.newest;\n                renderTagUpdateArray([newest]);\n                return 'promise-no-data-ever';\n            });\n        }\n        return 'no-data-ever';\n    };\n    addSupportEventListener(ownerSupport.appSupport, listener[0], // eventName\n    element, wrap);\n}\n","import { paintBefore, paintCommands } from '../render/paint.function.js';\nimport { processElementVar } from './processElementVar.function.js';\nexport function processDesignElementInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    // prevent children from calling a parent function and causing a mid render\n    context.locked = 34;\n    const element = processElementVar(value, context, ownerSupport, context.contexts);\n    delete context.locked;\n    paintCommands.push([paintBefore, [insertBefore, element, 'htmlTag.processInit']]);\n    const dom = {\n        nn: value.tagName,\n        domElement: element,\n        at: value.attributes, // TODO: most likely does nothing\n    };\n    context.htmlDomMeta = [dom];\n    return element;\n}\n","import { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions, isValueForContext, loopObjectAttributes } from './elementFunctions.js';\nimport { destroyDesignElement } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processDesignElementInit } from './processDesignElementInit.function.js';\nexport function htmlTag(tagName) {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler,\n        processInit: processDesignElementInit,\n        destroy: destroyDesignElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName,\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = tagName;\n    return pushKid;\n}\nexport function getPushKid(element, _elmFunctions) {\n    const pushKid = (...args) => {\n        const newElement = { ...pushKid };\n        newElement.attributes = [...pushKid.attributes];\n        newElement.listeners = [...pushKid.listeners];\n        newElement.allListeners = [...pushKid.allListeners];\n        if (args.length > 0 &&\n            typeof args[0] === 'object' &&\n            !Array.isArray(args[0]) &&\n            !args[0].tagJsType // TODO: need better attribute detection\n        ) {\n            loopObjectAttributes(newElement, args[0]);\n            args.splice(0, 1);\n        }\n        newElement.innerHTML = args;\n        // review each child for potential to be context\n        args.forEach(arg => {\n            if (!isValueForContext(arg)) {\n                return;\n            }\n            if (arg.tagJsType === 'element') {\n                newElement.allListeners.push(...arg.allListeners);\n                if (arg.contexts) {\n                    // the argument is an element so push up its contexts into mine\n                    if (!newElement.contexts) {\n                        // newElement.contexts = [...arg.contexts]\n                        newElement.contexts = arg.contexts;\n                    }\n                    else {\n                        newElement.contexts.push(...arg.contexts);\n                    }\n                }\n                return;\n            }\n            registerMockChildContext(arg, newElement);\n        });\n        return newElement;\n    };\n    Object.assign(pushKid, element);\n    Object.assign(pushKid, elementFunctions(pushKid));\n    pushKid.attributes = [...element.attributes];\n    pushKid.listeners = [...element.listeners];\n    pushKid.allListeners = [...element.allListeners];\n    return pushKid;\n}\n/** used during updates */\nfunction registerMockChildContext(value, mockElm) {\n    if (!mockElm.contexts) {\n        mockElm.contexts = [];\n    }\n    mockElm.contexts.push(value);\n}\n","import { paint, paintBefore, painting } from '../render/paint.function.js';\nimport { blankHandler } from '../render/dom/blankHandler.function.js';\nimport { elementFunctions } from './elementFunctions.js';\nimport { destroyDesignByContexts } from './destroyDesignElement.function.js';\nimport { processDesignElementUpdate, checkTagElementValueChange } from './processDesignElementUpdate.function.js';\nimport { processChildren } from './processChildren.function.js';\nimport { getPushKid } from './htmlTag.function.js';\nimport { destroyHtmlDomMeta } from '../tag/destroyHtmlDomMeta.function.js';\n/** used when you do NOT have a root element returned for your function */\nexport const noElement = noElementMaker();\nexport function noElementMaker() {\n    const element = {\n        tagJsType: 'element',\n        processInitAttribute: blankHandler, // its never an attribute\n        processInit: processNoElmInit,\n        destroy: destroyNoElement,\n        processUpdate: processDesignElementUpdate,\n        hasValueChanged: checkTagElementValueChange,\n        tagName: 'no-element',\n        innerHTML: [],\n        attributes: [],\n        listeners: [],\n        allListeners: [],\n        elementFunctions,\n    };\n    const pushKid = getPushKid(element, elementFunctions);\n    pushKid.tagName = 'no-element';\n    return pushKid;\n}\nfunction processNoElmInit(value, context, ownerSupport, insertBefore) {\n    context.contexts = context.contexts || []; // added contexts\n    context.htmlDomMeta = [];\n    processChildren(value.innerHTML, context, ownerSupport, insertBefore, paintBefore);\n}\nfunction destroyNoElement(context, ownerSupport) {\n    ++context.updateCount;\n    const contexts = context.contexts;\n    const promises = [];\n    if (contexts.length) {\n        destroyDesignByContexts(contexts, ownerSupport, promises);\n        contexts.length = 0;\n        if (promises.length) {\n            const htmlDomMeta = context.htmlDomMeta;\n            return Promise.all(promises).then(() => {\n                ++painting.locks;\n                destroyHtmlDomMeta(htmlDomMeta);\n                --painting.locks;\n                paint();\n            });\n        }\n    }\n}\n","import { htmlTag } from './htmlTag.function.js';\nexport { htmlTag };\nexport { noElement } from './noElement.function.js';\nexport const button = htmlTag('button');\nexport const select = htmlTag('select');\nexport const option = htmlTag('option');\nexport const input = htmlTag('input');\nexport const textarea = htmlTag('textarea');\n// HEAD & SUPPORT ELEMENTS\nexport const htmlDoc = htmlTag('html'); // TODO: get this named to html\nexport const head = htmlTag('head');\nexport const title = htmlTag('title');\nexport const meta = htmlTag('meta');\nexport const link = htmlTag('link');\nexport const style = htmlTag('style');\nexport const body = htmlTag('body');\nexport const noscript = htmlTag('noscript');\n// BLOCK ELEMENTS\nexport const hr = htmlTag('hr');\nexport const h1 = htmlTag('h1');\nexport const h2 = htmlTag('h2');\nexport const h3 = htmlTag('h3');\nexport const h4 = htmlTag('h4');\nexport const h5 = htmlTag('h5');\nexport const h6 = htmlTag('h6');\nexport const ol = htmlTag('ol');\nexport const ul = htmlTag('ul');\nexport const li = htmlTag('li');\nexport const div = htmlTag('div');\nexport const main = htmlTag('main');\nexport const section = htmlTag('section');\nexport const header = htmlTag('header');\nexport const footer = htmlTag('footer');\nexport const fieldset = htmlTag('fieldset');\nexport const legend = htmlTag('legend');\nexport const dialog = htmlTag('dialog');\nexport const pre = htmlTag('pre');\n// TABLE ELEMENTS\nexport const table = htmlTag('table');\nexport const tr = htmlTag('tr');\nexport const td = htmlTag('td');\nexport const th = htmlTag('th');\nexport const thead = htmlTag('thead');\nexport const tbody = htmlTag('tbody');\nexport const tfoot = htmlTag('tfoot');\n// INLINE ELEMENTS\nexport const a = htmlTag('a');\nexport const br = htmlTag('br');\nexport const label = htmlTag('label');\nexport const p = htmlTag('p');\nexport const small = htmlTag('small');\nexport const span = htmlTag('span');\nexport const strong = htmlTag('strong');\nexport const b = htmlTag('b');\nexport const sup = htmlTag('sup');\nexport const nav = htmlTag(\"nav\");\nexport const figure = htmlTag(\"figure\");\nexport const figcaption = htmlTag(\"figcaption\");\nexport const code = htmlTag(\"code\");\n","export const version = \"3.1.1\";\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { firstTagRender, reRenderTag } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport * from './deepFunctions.js';\nexport * from './elements/index.js';\nexport { version } from './version.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    firstTagRender, reRenderTag, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","varCounter","state","newer","states","global","blocked","RouteQuery","_name","setUseMemory","stateConfig","support","setSupportInCycle","setContextInCycle","context","addPaintRemoveAwait","_promise","paintCommands","paintRemoves","paintContent","paintAppends","paintAfters","painting","locks","removeLocks","setContent","text","textNode","textContent","paint","removes","length","content","runPaintRemoves","splice","runPaintCycles","nowPaintAfters","runAfterCycle","addPaintRemover","element","caller","push","paintRemover","_caller","parentNode","removeChild","paintBefore","relative","insertBefore","paintAppend","appendChild","contentCleaner","document","createElement","toPlainTextElm","innerHTML","createTextNode","paintBeforeText","callback","textElm","paintBeforeElementString","paintAppendElementString","empty","ImmutableTypes","BasicTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","isSimpleType","value","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","findStateSupportUpContext","stateMeta","newest","parentContext","getSupportWithState","component","ownerSupport","returnArgs","args","firstStatesHandler","setter","config","statesIndex","reStatesHandler","oldStates","prevSupport","older","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","StateEchoBack","getStateValue","defaultValue","checkValue","getCallbackValue","runRestate","restate","getContextInCycle","msg","console","error","Error","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","values","setValue","x","index","item","subscription","clones","shift","subscriptions","map","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","add","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","arguments","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","undefined","processUpdateOneContext","deleted","valueIndex","tagJsVar","processUpdate","removeContextInCycle","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","processUpdateContext","deepClone","maxDepth","makeDeepClone","RegExp","clone","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","cloneValueArray","cloneTagJsValue","shallowPropMatch","props","pastCloneProps","len","pastProp","obEntries","entries","subItem","objectItemMatches","name","pastValue","runBeforeDestroy","providers","provider","children","destroy$","destroyContexts","childTags","child","lastArray","childValue","destroy","iSubs","forEach","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","from","updateCount","forceUpdateExistingValue","domProcessContextItem","appendTo","locked","target","processInit","castTextValue","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","specialAttribute","specialName","autofocus","autoselect","names","split","paintStyle","classListAdd","classListRemove","processSpecialClass","smallName","style","setProperty","classList","remove","select","focus","howToSetInputValue","howToSetInputObjectValue","setNonFunctionInputValue","subValue","setObjectValue","setPropertyValue","howToSetStandAloneAttr","setAttribute","setSimpleAttribute","setBooleanAttribute","removeAttribute","processDynamicNameValueAttribute","howToSet","isSpecial","processInitAttribute","processTagJsAttribute","processNonDynamicAttr","innerValue","tagJsVarOverride","matchesInjection","inject","subContext","hasValueChanged","_contextItem","isAttr","valueToTagJsVar","withinOwnerElement","render$","processFunctionAttr","processAttributeUpdate","oldTag","tagValue","newTagVar","processSimpleAttribute","_ownerSupport","deleteSimpleAttribute","checkSimpleValueChange","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkUpdateDeleteSimpleValueChange","processStringUpdate","_appendTo","castedValue","placeholder","simpleValueElm","elm","oldClone","processUpdateRegularValue","checkArrayValueChange","destroyArrayContext","getArrayTagVar","processArrayInit","processArrayUpdates","processTagArray","_insertBefore","getBasicTagVar","getNewContext","createAndProcessContextItem","noLast","runtimeInsertBefore","removed","filteredLast","newRemoved","compareArrayItems","reviewArrayItem","array","castArrayItem","previousContext","couldBeSame","reviewPreviousArrayItem","newLength","at","lessLength","prevContext","destroyArrayItem","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","oldest","destroySupport","destroyArrayItemByGlobal","destroyArray","destroyHtmlDomMeta","htmlDomMeta","destroyClone","marker","domElement","smartRemoveKids","allPromises","supportOwner","hostDestroy","subGlobal","smartRemoveByContext","destroyContextHtml","promises","wrapper","returnValue","isLikeTags","newSupport","oldSupport","isLike","isLikeBaseTags","_innerHTML","outerHTML","templater0","templater1","newTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings","strings1","every","values0","values1","valuesLengthsMatch","allVarsMatch","compareTo","isLikeValueSets","isLikeStringTags","destroySupportContext","checkTagValueChange","lastSupport","isTag","tryUpdateToTag","attachDynamicDom","depth","addOneContext","handleProviderChanges","appSupport","tagsWithProvider","memory","cSubject","getTagsWithProvider","mapToSupport","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","castProps","currentDepth","isSkipPropValue","syncPriorPropFunction","priorProp","mem","oldProp","updateExistingArray","hasSetter","getOwnPropertyDescriptor","updateExistingObject","updateExistingTagComponent","oldWrapper","newWrapper","isSameTag","skipComparing","swapTags","hasChanged","newTemplater","latestProps","propsConfig","latest","propsChanged","hasPropChanges","propWatch","hasSupportChanged","renderSupport","newProps","castedProps","syncFunctionProps","lastPropsConfig","syncSupports","PropWatches","DEEP","deepCompareDepth","shallowCompareDepth","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","executeWrap","useSupport","originalFunction","stateless","runAfterRender","saveState","clearStateConfig","callTag","reSupport","createSupport","runAfterSupportRender","reStateByPrev","prevState","reRenderTag","reStateSupport","firstTagRender","getSupportOlderState","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","processTag","inlineHtml","pop","checkRenderUp","selfPropChange","nowProps","hasPropLengthsChanged","IMMUTABLE","immutablePropMatch","SHALLOW","hasPropsToOwnerChanged","getUpTags","supports","isComponent","continueUp","proSupports","prosWithChanges","hasChange","owner","providersChangeCheck","renderTagUpdateArray","mapTagUpdate","syncStatesArray","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","checkToResolvePromise","callbackResult","last","resolvePromise","resolveValue","newestSupport","newestStateMeta","thenResolveBy","bindSubjectCallback","subjectFunction","bindTo","apply","afterTagCallback","runTagCallback","tagFunction","noData","promiseNoData","bubbleEvent","event","replaceEventName","stopped","originalStopPropagation","stopPropagation","defaultPrevented","addSupportEventListener","eventName","appElement","getEventReferenceName","eventReg","events","listener","addEventListener","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","attrValue","processStandAloneAttribute","newContexts","processAttribute","processUpdateAttrContext","attrContextItem","oldValue","isNameOnly","standAloneResult","updateNameOnlyAttrValue","_subject","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","variablePrefix","variableSuffix","placeholderRegex","getTagVarIndex","search","createDynamicArrayAttribute","startIndex","createdContexts","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","join","newValues","getTagJsVar","attrPart","varIndex","isNameVar","valueInValues","stateOwner","oldTagJsVar","processTagJsVarAttribute","aloneResult","valueVar","createDynamicAttribute","special","paintContentPush","processAttributeArray","attrs","attr","newContext","attachDomElement","node","attachDomElements","nodes","v","isNaN","Number","realValue","newNode","nn","attachDomText","newParentContext","isAttrs","ch","tc","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","attributes","attrMatch","parseAttrString","pushTo","inputString","filter","notEmptyStringMapper","part","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","replacePlaceholders","valueCount","currentTail","loopTail","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","mapped","lengthMapper","lastRuns","getDomMeta","stringId","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","template","interpolation","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachHtmlDomMeta","ph","tagFakeTemplater","processTagInit","newSupportByTemplater","createHtmlSupport","processNewSubjectTag","getTemplaterResult","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","wrap","processRenderOnceInit","processSubscribeWith","setupSubscribe","hasEmitted","emitSubContext","observable","Observables","subValueHandler","withDefault","emitValue","processSubscribeAttribute","_tagJsVar","unsubscribeContext","onOutput","callbackValue","syncRun","checkToPaint","setupSubscribeCallbackProcessor","contextItem2","processSubscribeWithAttribute","observables","obValue","emitSubScriptionAsIs","Observable","checkSubscribeValueChanged","deleteAndUnsubscribe","newObserves","oldObserves","ob","handleTagTypeChangeFrom","originalType","updateToDiffValue","checkStillSubscription","valuesHandler","deleteContextSubContext","deleteSubContext","appendMarker","subContextItem","onFirstSubContext","handleInnerHTML","oldProcessInit","processInnerHTML","insertBeforeOriginal","guaranteeInsertBefore","checkInnerHTML","getInnerHTML","processPipe","wrapped","newCallback","syncWrapCallback","newerStates","olderStates","newestOwner","c","newGlobal","options","baseHost","processHostAttribute","processHost","processHostUpdate","deleteHost","injectCallback","returnFunction","assign","oldOptions","newHost","onInit","processHostTagJsVar","attrContext","onDestroy","getOverrideTagVar","overrideTagVar","renderContent","oldType","newType","hasTypeChanged","convertValue","updatesHandler","makeRealUpdate","_context","afterDestroy","convertTagToElementManaged","createSupportWithProps","newPropsConfig","processReplacementComponent","processFirstSubjectComponent","processFirstTagResult","processTagComponentInit","tagCount","onClick","makeEventListener","onMouseDown","type","toBeCalled","tagElement","onclick","click","mousedown","onmousedown","defineGetSet","eventFn","fn","parentWrap","innerTagWrap","getTagWrap","setUse","ValueTypes","tagIndex","returnWrap","updates","NONE","castedPastProps","compare","subCastedProps","subCompareProps","matched","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","use","deepPropWatch","route","_routeProps","targetItem","currentContext","inContext","message","onRender","callbackWrap","_isFirst","lastContext","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","shallowMapper","deepMapper","getBaseSupport","baseSupport","upgradeBaseToSupport","clonePropsBy","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","ignoreOrDestroyed","before","processNowRegularValue","processUpdateSubscribe","resultNum","updateValue","aContext","newestParentTagJsVar","responseValue","processSignal","initialValue","Signal","Set","unsub","delete","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","pastResult","defaultFinally","init","final","previous","realValues","isFirstRender","processRealValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","previousValues","nowSupport","setTo","newestState","oldestStateSupport","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","cm","ownerProviders","find","warn","TagError","details","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","callbackState","callbackTrigger","createTrigger","_oldStates","maybePromise","supContext","finally","callbackStateUpdate","callbackMaker","syncError","firstSignal","sig","editors","readers","resignal","Proxy","action","getElement","processOuterDomTagInit","checkOuterTagValueChange","getDomTag","setHTML","acceptInnerHTML","useTagVar","taggedJs","appElements","appElmIndex","appElm","templater2","isApp","debug","loadNewBaseSupport","getNewSubject","isAppFunction","removeEventListener","toAwait","newFragment","createDocumentFragment","renderTagElement","makeAttrCallable","stringsOrValue","chunk","callbackWrapper2","wrapCallback","e","listeners","allListeners","getPushKid","elementFunctions","isValueForContext","registerMockAttrContext","styleCallable","idCallable","classCallable","hrefCallable","valueCallable","placeholderCallable","typeCallable","attr2","makeCallback","callbackWrapper","onClose","onDoubleClick","onBlur","onChange","onInput","onMousedown","onMouseup","onMouseover","onMouseout","onKeydown","onKeyup","id","class","href","mockElm","setupAttr","eventCallables","onDblClick","onMouseUp","onMouseOver","onMouseOut","onKeyUp","onKeyDown","callables","checked","selected","destroyDesignElement","destroyDesignByContexts","processDesignElementUpdate","checkTagElementValueChange","vContexts","ogListeners","newListener","info","conValues","processChildren","paintBy","handleSimpleInnerValue","subContexts","_c","subSub","aSubContext","underFunction","Function","trueValue","processNonElement","processElementVarFunction","newElement","processElementVar","_addedContexts","toCall","stateSupport","registerListener","processDesignElementInit","htmlTag","pushKid","_elmFunctions","registerMockChildContext","noElement","processNoElmInit","destroyNoElement","noElementMaker","input","htmlDoc","head","title","meta","body","noscript","hr","h1","h2","h3","h4","h5","h6","ol","ul","li","div","main","section","header","footer","fieldset","legend","dialog","pre","table","tr","td","th","thead","tbody","tfoot","a","br","label","p","small","span","strong","b","sup","nav","figure","figcaption","code","hmr"],"sourceRoot":""}