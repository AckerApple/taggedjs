{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/tag/Tag.class.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/restorePlaceholders.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/state/setUse.function.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/letState.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/tag/destroyTag.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/getValueType.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/destroy.support.ts","webpack://taggedjs/./ts/tag/kidsToTagArraySubject.function.ts","webpack://taggedjs/./ts/tag/TemplaterResult.class.ts","webpack://taggedjs/./ts/tag/update/TagJsSubject.class.ts","webpack://taggedjs/./ts/tag/update/processNewValue.function.ts","webpack://taggedjs/./ts/tag/textNode.ts","webpack://taggedjs/./ts/interpolations/specialAttribute.ts","webpack://taggedjs/./ts/interpolations/interpolateAttributes.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/interpolations/interpolateTemplate.ts","webpack://taggedjs/./ts/interpolations/elementInitCheck.ts","webpack://taggedjs/./ts/tag/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/render/renderSubjectComponent.function.ts","webpack://taggedjs/./ts/alterProp.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/interpolations/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/processAttribute.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/updateBeforeTemplate.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/tag/setTagPlaceholder.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingValue.function.ts","webpack://taggedjs/./ts/interpolations/subscribeToTemplate.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/metaAttachDomElements.function.ts","webpack://taggedjs/./ts/tag/Support.class.ts","webpack://taggedjs/./ts/tag/update/updateContextItem.function.ts","webpack://taggedjs/./ts/tag/elementDestroyCheck.function.ts","webpack://taggedjs/./ts/tag/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/tag/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/tag/render/destroyUnlikeTags.function.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/tag/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/tag/render/renderSupport.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/children.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/tag.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export class RouteQuery {\n    get(name) {\n        return 'todo';\n    }\n}\n","export const empty = '';\nexport var ValueTypes;\n(function (ValueTypes) {\n    ValueTypes[\"unknown\"] = \"unknown\";\n    ValueTypes[\"tag\"] = \"tag\";\n    ValueTypes[\"dom\"] = \"dom\";\n    ValueTypes[\"templater\"] = \"templater\";\n    ValueTypes[\"tagComponent\"] = \"tag-component\";\n    ValueTypes[\"object\"] = \"object\";\n    ValueTypes[\"tagArray\"] = \"tag-array\";\n    ValueTypes[\"subject\"] = \"subject\";\n    ValueTypes[\"tagJsSubject\"] = \"tagJsSubject\";\n    ValueTypes[\"oneRender\"] = \"oneRender\";\n    ValueTypes[\"date\"] = \"date\";\n    ValueTypes[\"string\"] = \"string\";\n    ValueTypes[\"number\"] = \"number\";\n    ValueTypes[\"boolean\"] = \"boolean\";\n    ValueTypes[\"function\"] = \"function\";\n    ValueTypes[\"undefined\"] = \"undefined\";\n})(ValueTypes || (ValueTypes = {}));\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\nexport const escapeVariable = '--' + variablePrefix + '--';\nexport const escapeSearch = new RegExp(escapeVariable, 'g');\nexport class BaseTag {\n    values;\n    tagJsType;\n    // present only when an array. Populated by Tag.key()\n    arrayValue;\n    templater;\n    constructor(values) {\n        this.values = values;\n    }\n    /** Used for array, such as array.map(), calls aka array.map(x => html``.key(x)) */\n    key(arrayValue) {\n        this.arrayValue = arrayValue;\n        return this;\n    }\n}\nexport class Tag extends BaseTag {\n    strings;\n    values;\n    tagJsType = ValueTypes.tag;\n    children;\n    constructor(strings, values) {\n        super(values);\n        this.strings = strings;\n        this.values = values;\n    }\n    html(strings, ...values) {\n        this.children = { strings, values };\n        return this;\n    }\n}\nexport class Dom extends BaseTag {\n    dom;\n    values;\n    tagJsType = ValueTypes.dom;\n    children;\n    constructor(dom, values) {\n        super(values);\n        this.dom = dom;\n        this.values = values;\n    }\n    html = {\n        // $this: this,\n        dom: (dom, ...values) => {\n            this.children = { dom, values };\n            return this;\n        }\n    };\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/Tag.class.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function replacePlaceholders(elements, values) {\n    // const rtnElements: (ObjectElement | ObjectText)[] = []\n    for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        // const element = {...elements[i]} // ???\n        // rtnElements.push(element)\n        // TODO: We most likely do not need to replace attributes\n        if ('attributes' in element) {\n            element.attributes = processAttributes(element.attributes, values);\n        }\n        if ('children' in element) {\n            // const children = [...element.children as ObjectChildren];\n            const children = element.children;\n            replacePlaceholders(children, values);\n            element.children = children;\n            // Remove empty children array\n            if (element.children.length === 0) {\n                delete element.children;\n            }\n        }\n        i = examineChild(element, values, elements, i);\n    }\n}\nfunction examineChild(child, values, children, index) {\n    if (child.nodeName !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.textContent;\n    if (typeof textContent !== 'string') {\n        return index;\n    }\n    const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const wIndex = parseInt(match[1], 10);\n        const examine = !isNaN(wIndex) && wIndex < values.length;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const before = textContent.slice(0, match.index);\n            const after = textContent.slice(match.index + varContent.length);\n            let value = values[wIndex];\n            if (value instanceof Array) {\n                value = value.map((x, index) => {\n                    if (x?.tagJsType === ValueTypes.dom) {\n                        const domClone = [...x.dom];\n                        const elements = replacePlaceholders(domClone, x.values);\n                        return domClone;\n                    }\n                    return x;\n                });\n            }\n            // TODO: I don't think we need three adds?\n            children.splice(index, 1, {\n                nodeName: 'text',\n                textContent: before\n            }, {\n                nodeName: 'text',\n                textContent: '',\n                value,\n            }, {\n                nodeName: 'text',\n                textContent: after\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n            index += 2; // Skip the newly inserted elements\n        }\n    }\n    textChild.textContent = textContent;\n    return index;\n}\nfunction processAttributes(attributes, values) {\n    return attributes.map(([key, value]) => {\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < values.length) {\n                return [values[index]]; // the name is the value\n            }\n        }\n        if (typeof value === 'string' && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < values.length) {\n                value = values[index];\n            }\n        }\n        return [key, value];\n    });\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/Tag.class.js\";\nexport const safeVar = '__safeTagVar';\nexport function restorePlaceholders(elements) {\n    elements.forEach(traverseAndRestore);\n}\nconst safeReplacer = /__safeTagVar(\\d+)/g;\nfunction traverseAndRestore(element) {\n    if ('attributes' in element) {\n        element.attributes = element.attributes.map(attr => {\n            if (attr.length === 1) {\n                return attr;\n            }\n            let [key, value] = attr;\n            if (typeof value === 'string' && value.startsWith(safeVar)) {\n                const index = parseInt(value.replace(safeVar, ''), 10);\n                value = variablePrefix + index + variableSuffix;\n            }\n            return [key, value];\n        });\n    }\n    if ('children' in element) {\n        const children = element.children;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.nodeName === 'text') {\n                if (typeof child.textContent !== 'string') {\n                    return;\n                }\n                child.textContent = child.textContent.replace(safeReplacer, (match, index) => variablePrefix + index + variableSuffix);\n            }\n            traverseAndRestore(child);\n        }\n        // Remove empty children array\n        if (children.length === 0) {\n            delete element.children;\n        }\n    }\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/Tag.class.js\";\nimport { replacePlaceholders } from \"./replacePlaceholders.function.js\";\nimport { restorePlaceholders } from \"./restorePlaceholders.function.js\";\nconst fragReplacer = /(^:tagvar\\d+:|:tagvar\\d+:$)/g;\nconst safeVar = '__safeTagVar';\nconst regexAttr = /([:_a-zA-Z0-9\\-\\.]+)(?:=\"([^\"]*)\"|=(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9\\-]+)([^>]*)>/;\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = sanitizePlaceholders(strings);\n    // Add placeholders to the fragments\n    const fragmentsWithPlaceholders = addPlaceholders(sanitizedFragments, values);\n    // Parse the modified fragments\n    const htmlString = fragmentsWithPlaceholders.join('');\n    const parsedElements = parseHTML(htmlString);\n    return parsedElements;\n}\nexport function exchangeParsedForValues(parsedElements, values) {\n    // Replace placeholders with actual dynamic values\n    replacePlaceholders(parsedElements, values);\n    // Restore any sanitized placeholders in text nodes\n    restorePlaceholders(parsedElements);\n    return parsedElements;\n}\nfunction sanitizePlaceholders(fragments) {\n    return fragments.map(fragment => fragment.replace(fragReplacer, (match, index) => safeVar + index));\n}\nfunction addPlaceholders(strings, values) {\n    const results = strings.map((fragment, index) => {\n        if (index < values.length) {\n            return fragment + variablePrefix + index + variableSuffix;\n        }\n        return fragment;\n    });\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nfunction parseHTML(html) {\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = 0;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textNode = {\n                    nodeName: 'text',\n                    textContent // : textContent.trim() ??? new removed\n                };\n                if (currentElement) {\n                    if (!currentElement.children) {\n                        currentElement.children = [];\n                    }\n                    currentElement.children.push(textNode);\n                }\n                else {\n                    elements.push(textNode);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const element = {\n            nodeName: tagName,\n            attributes: []\n        };\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            let [_, attrName, attrValueQuoted, attrValueUnquoted] = attrMatch;\n            let attrValue = attrValueQuoted || attrValueUnquoted;\n            if (attrValue === undefined) {\n                const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n                if (standAloneVar) {\n                    element.attributes.push([attrName]); // the name itself is dynamic\n                    continue;\n                }\n                attrValue = variablePrefix + (valueIndex++) + variableSuffix;\n            }\n            element.attributes.push([attrName.toLowerCase(), attrValue]);\n        }\n        if (currentElement) {\n            if (!currentElement.children) {\n                currentElement.children = [];\n            }\n            currentElement.children.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textNode = {\n                nodeName: 'text',\n                textContent: textContent.trim()\n            };\n            if (currentElement) {\n                if (!currentElement.children) {\n                    currentElement.children = [];\n                }\n                currentElement.children.push(textNode);\n            }\n            else {\n                elements.push(textNode);\n            }\n        }\n    }\n    return elements;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","import { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings, values);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    let domMeta;\n    if (matches) {\n        domMeta = lastRun.domMeta;\n        return domMeta;\n    }\n    domMeta = htmlInterpolationToDomMeta(strings, values);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMeta,\n    };\n    lastRuns[stringId] = template;\n    return domMeta;\n}\n","export function getStringsId(strings, values) {\n    const array = strings.map(x => x.length);\n    array.push(strings.length);\n    // array.push(values.length)\n    return Number(array.join(''));\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isStaticTag(value) {\n    return [\n        ValueTypes.dom,\n        ValueTypes.tag,\n        ValueTypes.templater,\n    ].includes(value?.tagJsType);\n}\nexport function isTagTemplater(value) {\n    return value?.tagJsType === ValueTypes.templater;\n}\n// TODO: whats the difference between isTagClass and isTagComponent\nexport function isTagComponent(value) {\n    return value?.tagJsType === ValueTypes.tagComponent;\n}\nexport function isTagClass(value) {\n    const tagJsType = value?.tagJsType;\n    return tagJsType && [ValueTypes.tag, ValueTypes.dom].includes(tagJsType);\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    const isSubject = subject?.isSubject === true;\n    return (isSubject || subject?.subscribe) ? true : false; // subject?.isSubject === true || \n}\nexport function isTagArray(value) {\n    return value instanceof Array && value.every(x => [\n        ValueTypes.tag,\n        ValueTypes.templater,\n        ValueTypes.dom,\n        ValueTypes.tagComponent\n    ].includes(x?.tagJsType));\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (let index = valuesSeen.length - 1; index >= 0; --index) {\n                if (!valuesSeen[index]) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject._value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    Subject.globalSubCount$.next(Subject.globalSubCount$._value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (let index = subscriptions.length - 1; index >= 0; --index) {\n        subscriptions[index].unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    set = this.next;\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (let index = 0; index < subs.length; ++index) {\n            const sub = subs[index];\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, _subscription) => {\n            subscription.unsubscribe();\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this._value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        defineValueOn(this);\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUse } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUse.memory.stateConfig.support;\n}\n","const tagUse = [];\nexport function setUse(use) {\n    // must provide defaults\n    const useMe = {\n        beforeRender: use.beforeRender || (() => undefined),\n        beforeRedraw: use.beforeRedraw || (() => undefined),\n        afterRender: use.afterRender || (() => undefined),\n        beforeDestroy: use.beforeDestroy || (() => undefined),\n    };\n    setUse.tagUse.push(useMe);\n}\nsetUse.tagUse = tagUse;\nsetUse.memory = {};\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { StateMismatchError } from '../errors.js';\nimport { setUse } from './setUse.function.js';\nconst badLetState = 'letState function incorrectly used. Second item in array is not setting expected value.\\n\\n' +\n    'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n    'For \"const\" state use `const name = state(default)()`\\n\\n' +\n    'Problem state:\\n';\nsetUse.memory.stateConfig = {\n    array: [], // state memory on the first render\n    // rearray: [] as State,\n};\nconst beforeRender = (support) => initState(support);\nsetUse({\n    beforeRender,\n    beforeRedraw: beforeRender,\n    afterRender: (support) => {\n        const state = support.state;\n        const config = setUse.memory.stateConfig;\n        const rearray = config.rearray;\n        if (rearray.length) {\n            if (rearray.length !== config.array.length) {\n                const message = `States lengths have changed ${rearray.length} !== ${config.array.length}. State tracking requires the same amount of function calls every render. Typically this errors is thrown when a state like function call occurs only for certain conditions or when a function is intended to be wrapped with a tag() call`;\n                const wrapper = support.templater?.wrapper;\n                const details = {\n                    oldStates: config.array,\n                    newStates: config.rearray,\n                    tagFunction: wrapper.parentWrap.original,\n                };\n                const error = new StateMismatchError(message, details);\n                console.warn(message, details);\n                throw error;\n            }\n        }\n        delete config.rearray; // clean up any previous runs\n        delete config.support;\n        state.length = 0;\n        state.push(...config.array);\n        for (let index = state.length - 1; index >= 0; --index) {\n            const item = state[index];\n            item.lastValue = getStateValue(item); // set last values\n        }\n        config.array = [];\n    }\n});\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value, checkValue] = getCallbackValue(callback);\n    if (checkValue !== StateEchoBack) {\n        const message = badLetState + (callback ? callback.toString() : JSON.stringify(state)) + '\\n';\n        console.error(message, { state, callback, value, checkValue });\n        throw new Error(message);\n    }\n    return value;\n}\nexport class StateEchoBack {\n}\nfunction initState(support) {\n    const state = support.state;\n    const config = setUse.memory.stateConfig;\n    config.rearray = [];\n    const stateLength = state?.length;\n    if (stateLength) {\n        for (let index = 0; index < stateLength; ++index) {\n            getStateValue(state[index]);\n        }\n        config.rearray.push(...state);\n    }\n    config.support = support;\n}\nexport function getCallbackValue(callback) {\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [value] = oldState;\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","export function syncStates(stateFrom, stateTo) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const state = stateFrom[index];\n        const fromValue = state.get();\n        const callback = stateTo[index].callback;\n        if (callback) {\n            callback(fromValue); // set the value\n        }\n        stateTo[index].lastValue = fromValue; // record the value\n    }\n}\n","import { setUse } from './setUse.function.js';\nimport { getStateValue } from './state.utils.js';\nimport { syncStates } from './syncStates.function.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    let getSetMethod;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return oldValue;\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    // the state is actually intended to be a function\n    if (initValue instanceof Function) {\n        const oldState = config.array;\n        const support = config.support;\n        const original = initValue;\n        initValue = ((...args) => {\n            const global = support.subject.global;\n            const newest = global.newest;\n            const newState = newest.state;\n            syncStates(newState, oldState);\n            const result = original(...args);\n            syncStates(oldState, newState);\n            return result;\n        });\n        initValue.original = original;\n    }\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUse } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered. Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before = () => true, final = defaultFinally, } = {}) => {\n    let previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (!before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (!before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = setUse.memory.stateConfig.array;\n                        syncStates(newestState, firstSupport.state);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUse } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(value, onSubscription) {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return state(() => {\n        const subject = new Subject(value, onSubscription).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n}\nsubject._value = (value) => {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return state(() => {\n        const subject = new ValueSubject(value).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        syncStates(nowSupport.state, oldestState);\n        return x;\n    });\n}\nsubject.all = all;\n","import { getStateValue } from './state.utils.js';\nimport { setUse } from './setUse.function.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function letState(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    const rearray = config.rearray;\n    let getSetMethod;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return makeStateResult(oldValue, push);\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return makeStateResult(initValue, push);\n}\nfunction makeStateResult(initValue, push) {\n    // return initValue\n    const result = (y) => {\n        push.callback = y || (x => [initValue, initValue = x]);\n        return initValue;\n    };\n    return result;\n}\n","import { letState } from './letState.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(prop) {\n    return getSetProp => {\n        let myProp = letState(prop)(getSetProp);\n        watch([prop], () => getSetProp(myProp = prop));\n        getSetProp(myProp); // always reset to my value and right await so that the old prop value never slips through\n        return myProp;\n    };\n}\n","import { ValueTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, 0);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\ndepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== ValueTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (depth === 15) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Register the cloned object to avoid cyclic references\n    // visited.set(obj, clone)\n    // Clone each property or element of the object or array\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            // clone[i] = makeDeepClone(obj[i], visited)\n            clone[i] = makeDeepClone(obj[i], depth + 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                // clone[key] = makeDeepClone(obj[key], visited)\n                clone[key] = makeDeepClone(obj[key], depth + 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2) {\n    // return isDeepEqual(obj1, obj2, new WeakMap())\n    return isDeepEqual(obj1, obj2, 0);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\ndepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (depth === 15) {\n        return true;\n    }\n    if (typeof obj1 === ValueTypes.object && typeof obj2 === ValueTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (Array.isArray(obj1) && Array.isArray(obj2)) {\n            // return isArrayDeepEqual(obj1, obj2, visited)\n            return isArrayDeepEqual(obj1, obj2, depth + 1);\n        }\n        else if (Array.isArray(obj1) || Array.isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, depth + 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\ndepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], depth + 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\ndepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        // if (!isDeepEqual(obj1[i], obj2[i], visited)) {\n        if (!isDeepEqual(obj1[i], obj2[i], depth + 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = fn0 instanceof Function && fn1 instanceof Function;\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { setUse } from './setUse.function.js';\nimport { state } from './state.function.js';\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(() => ({ stateDiff: 0, provider: undefined }));\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            for (let x = stateDiffMemory.stateDiff; x > 0; --x) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const memory = setUse.memory;\n            const stateConfig = memory.stateConfig;\n            const oldStateCount = stateConfig.array.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = 'prototype' in constructMethod ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.array.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                clone: deepClone(instance),\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            support.subject.global.providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        // const compareTo = cm.compareTo = cm.compareTo || cm.toString()\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        // find once, return same every time after\n        return state(() => {\n            const memory = setUse.memory;\n            const cm = constructor;\n            const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n            const support = memory.stateConfig.support;\n            const providers = [];\n            let owner = {\n                ownerSupport: support.ownerSupport\n            };\n            while (owner.ownerSupport) {\n                const ownerProviders = owner.ownerSupport.subject.global.providers;\n                const provider = ownerProviders.find(provider => {\n                    providers.push(provider);\n                    const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                    if (constructorMatch) {\n                        return true;\n                    }\n                });\n                if (provider) {\n                    provider.clone = deepClone(provider.instance); // keep a copy of the latest before any change occur\n                    const support = memory.stateConfig.support;\n                    support.subject.global.providers.push(provider);\n                    provider.children.push(support);\n                    return provider.instance;\n                }\n                owner = owner.ownerSupport; // cause reloop checking next parent\n            }\n            const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n            console.warn(`${msg}. Available providers`, providers);\n            throw new Error(msg);\n        });\n    }\n};\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { deepEqual } from '../deepFunctions.js';\nexport function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    // TODO: turn this on\n    /*\n    if(templater0 === templater1) {\n      return true\n    }\n    */\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag;\n    if (tag0.tagJsType !== tag1.tagJsType) {\n        return false;\n    }\n    if (tag0.tagJsType === ValueTypes.dom) {\n        return isLikeDomTags(tag0, tag1, support0, support1);\n    }\n    return isLikeStringTags(tag0, tag1, support0, support1);\n}\nfunction isLikeDomTags(tag0, tag1, support0, // new\nsupport1) {\n    const dom0 = tag0.dom;\n    const dom1 = tag1.dom;\n    if (dom0 !== dom1) {\n        const equal = deepEqual(tag0.dom, tag1.dom);\n        if (!equal) {\n            return false;\n        }\n    }\n    const values0 = support0.values || tag0.values;\n    const values1 = support1.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nfunction isLikeStringTags(tag0, tag1, support0, // new\nsupport1) {\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings || support1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    // strings1[index] === string // slower\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.values || tag0.values;\n    const values1 = support1.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = value instanceof Function && compareTo instanceof Function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true; // deepEqual(value, compareTo)\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { setUse } from '../state/index.js';\nimport { Subject } from '../subject/index.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nsetUse.memory.tagClosed$ = new Subject(undefined, subscription => {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n// Life cycle 1\nexport function runBeforeRender(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeRender(support, ownerSupport);\n    }\n}\n// Life cycle 2\nexport function runAfterRender(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].afterRender(support, ownerSupport);\n    }\n    setUse.memory.tagClosed$.next(ownerSupport);\n}\n// Life cycle 3\nexport function runBeforeRedraw(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeRedraw(support, ownerSupport);\n    }\n}\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeDestroy(support, ownerSupport);\n    }\n    support.subject.global.deleted = true;\n    support.hasLiveElements = false;\n    // remove me from my parents\n    if (ownerSupport) {\n        ownerSupport.subject.global.childTags = ownerSupport.subject.global.childTags.filter(child => child !== support.subject.global.oldest);\n        const global = support.subject.global;\n        global.providers.forEach(provider => provider.children.forEach((child, index) => {\n            if (child.subject.global === global) {\n                provider.children.splice(index, 1);\n            }\n        }));\n    }\n}\n","import { runBeforeRedraw, runBeforeRender } from '../tagRunner.js';\nimport { runAfterRender } from '../tagRunner.js';\nexport function renderTagOnly(newSupport, prevSupport, subject, ownerSupport) {\n    const oldRenderCount = subject.global.renderCount;\n    beforeWithRender(newSupport, ownerSupport, prevSupport);\n    const templater = newSupport.templater;\n    // NEW TAG CREATED HERE\n    const wrapper = templater.wrapper;\n    let reSupport = wrapper(newSupport, subject, prevSupport);\n    /* AFTER */\n    runAfterRender(newSupport, ownerSupport);\n    subject.global.newest = reSupport;\n    if (!prevSupport && ownerSupport) {\n        ownerSupport.subject.global.childTags.push(reSupport);\n    }\n    // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n    if (subject.global.renderCount > oldRenderCount + 1) {\n        return subject.global.newest;\n    }\n    return reSupport;\n}\nfunction beforeWithRender(support, // new\nparentSupport, prevSupport) {\n    const lastOwnerSupport = prevSupport?.ownerSupport;\n    const runtimeOwnerSupport = lastOwnerSupport || parentSupport;\n    if (prevSupport) {\n        if (prevSupport !== support) {\n            const lastState = prevSupport.state;\n            support.subject.global = prevSupport.subject.global;\n            support.state.length = 0;\n            support.state.push(...lastState);\n        }\n        return runBeforeRedraw(support, prevSupport);\n    }\n    // first time render\n    return runBeforeRender(support, runtimeOwnerSupport);\n}\n","export function destroyTagMemory(oldSupport) {\n    const global = oldSupport.subject.global;\n    // must destroy oldest which is tag with elements on stage\n    const oldest = global.oldest;\n    oldest.destroy();\n    oldSupport.subject.global.context = [];\n}\n","import { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { destroyTagMemory } from './destroyTag.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function checkDestroyPrevious(subject, // existing.value is the old value\nnewValue, valueType) {\n    const displaySubject = subject;\n    const hasLastValue = 'lastValue' in displaySubject;\n    const lastValue = displaySubject.lastValue; // TODO: we maybe able to use displaySubject.value and remove concept of lastValue\n    // was simple value but now something bigger\n    if (hasLastValue && lastValue !== newValue) {\n        // below is faster than using getValueType\n        const newType = typeof (newValue);\n        if (isSimpleType(newType) && typeof (lastValue) === newType) {\n            return false;\n        }\n        if (newValue instanceof Function && lastValue instanceof Function) {\n            return false;\n        }\n        destroySimpleValue(displaySubject);\n        return 'changed-simple-value';\n    }\n    const arraySubject = subject;\n    const wasArray = arraySubject.lastArray;\n    // no longer an array\n    if (wasArray && valueType !== ValueTypes.tagArray) {\n        delete arraySubject.lastArray;\n        for (let index = wasArray.array.length - 1; index >= 0; --index) {\n            const { support } = wasArray.array[index];\n            destroyArrayTag(support, { added: 0, removed: 0 });\n        }\n        return 'array';\n    }\n    const tagSubject = subject;\n    const lastSupport = tagSubject.support;\n    // no longer tag or component?\n    if (lastSupport) {\n        const isValueTag = isStaticTag(newValue);\n        const isSubjectTag = isStaticTag(subject._value);\n        const newTag = newValue;\n        if (isSubjectTag && isValueTag) {\n            // its a different tag now\n            const likeTags = isLikeTags(newTag, lastSupport);\n            if (!likeTags) {\n                // put template back down\n                destroyTagMemory(lastSupport);\n                return 2;\n            }\n            return false;\n        }\n        if (valueType === ValueTypes.tagComponent) {\n            return false; // its still a tag component\n        }\n        if (newValue && newValue.oneRender) {\n            return false;\n        }\n        // destroy old component, value is not a component\n        destroyTagMemory(lastSupport);\n        // delete lastSupport.global.deleted // ???\n        return 'different-tag';\n    }\n    return false;\n}\nexport function isSimpleType(value) {\n    return [\n        ValueTypes.string,\n        ValueTypes.number,\n        ValueTypes.boolean,\n    ].includes(value);\n}\nexport function destroyArrayTag(support, counts) {\n    support.destroy({\n        stagger: counts.removed++,\n    });\n}\nfunction destroySimpleValue(subject) {\n    delete subject.lastValue;\n}\n","import { isSimpleType } from './checkDestroyPrevious.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isSubjectInstance, isTagArray } from '../isInstance.js';\nexport function getValueType(value) {\n    if (value === undefined || value === null) {\n        return ValueTypes.undefined;\n    }\n    const type = typeof (value);\n    if (value instanceof Function) {\n        return ValueTypes.function;\n    }\n    if (isSimpleType(type)) {\n        return type;\n    }\n    if (type === ValueTypes.object) {\n        if (value instanceof Date) {\n            return ValueTypes.date;\n        }\n        const tagJsType = value.tagJsType;\n        if (tagJsType) {\n            return tagJsType;\n            /*\n            const included = [\n              ValueTypes.tagComponent,\n              ValueTypes.templater,\n              ValueTypes.tag,\n              ValueTypes.dom,\n            ].includes(tagJsType)\n        \n            if(included) {\n              return tagJsType\n            }\n            */\n        }\n        if (isTagArray(value)) {\n            return ValueTypes.tagArray;\n        }\n        if (isSubjectInstance(value)) {\n            return ValueTypes.subject;\n        }\n    }\n    return ValueTypes.unknown;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getValueType } from './getValueType.function.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\nexport function cloneTagJsValue(value) {\n    const tag = value;\n    switch (getValueType(value)) {\n        case ValueTypes.tagComponent:\n            const tagComponent = value;\n            return deepClone(tagComponent.props);\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return cloneValueArray(tag.values);\n        case ValueTypes.tagArray:\n            return cloneValueArray(tag);\n    }\n    return deepClone(value);\n}\n","export function getChildTagsToDestroy(childTags, allTags = []) {\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const cTag = childTags[index];\n        allTags.push(cTag);\n        getChildTagsToDestroy(cTag.subject.global.childTags, allTags);\n    }\n    return allTags;\n}\n","import { isSubjectInstance, isTagArray } from '../isInstance.js';\nimport { ValueSubject } from '../subject/ValueSubject.js';\nexport function kidsToTagArraySubject(children, templaterResult) {\n    if (isSubjectInstance(children)) {\n        return children;\n    }\n    const kidArray = children;\n    if (isTagArray(kidArray)) {\n        templaterResult.madeChildIntoSubject = true; // was converted into a subject\n        return new ValueSubject(children);\n    }\n    const kid = children;\n    if (kid) {\n        templaterResult.madeChildIntoSubject = true; // was converted into a subject\n        kid.arrayValue = 0;\n        return new ValueSubject([kid]);\n    }\n    templaterResult.madeChildIntoSubject = true; // was converted into a subject\n    return new ValueSubject([]);\n}\n","import { Tag, Dom } from './Tag.class.js';\nimport { ValueSubject } from '../subject/index.js';\nimport { kidsToTagArraySubject } from './kidsToTagArraySubject.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport class TemplaterResult {\n    props;\n    tagJsType = ValueTypes.templater;\n    tagged;\n    wrapper;\n    madeChildIntoSubject;\n    tag;\n    children = new ValueSubject([]);\n    arrayValue; // used for tag components used in arrays\n    constructor(props) {\n        this.props = props;\n        this.html.dom = this.dom.bind(this);\n    }\n    key(arrayValue) {\n        this.arrayValue = arrayValue;\n        return this;\n    }\n    /** children */\n    html(strings, ...values) {\n        const children = new Tag(strings, values);\n        const childSubject = kidsToTagArraySubject(children, this);\n        this.children = childSubject;\n        return this;\n    }\n    /** children */\n    dom(strings, ...values) {\n        const children = new Dom(strings, values);\n        const childSubject = kidsToTagArraySubject(children, this);\n        this.children = childSubject;\n        return this;\n    }\n}\n","import { Subject } from '../../subject/Subject.class.js';\nimport { ValueSubject } from '../../subject/ValueSubject.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nexport class TagJsSubject extends ValueSubject {\n    tagJsType = ValueTypes.tagJsSubject;\n    // travels with all renderings\n    global = getNewGlobal();\n}\nexport function getNewGlobal() {\n    return {\n        destroy$: new Subject(),\n        context: [], // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n        providers: [],\n        /** Indicator of re-rending. Saves from double rending something already rendered */\n        renderCount: 0,\n        subscriptions: [],\n        oldest: undefined, // TODO: This needs to addressed\n        blocked: [], // renders that did not occur because an event was processing\n        childTags: [], // tags on me\n        clones: [], // elements on document. Needed at destroy process to know what to destroy\n    };\n}\n","import { TemplaterResult } from '../TemplaterResult.class.js';\nimport { Support } from '../Support.class.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getValueType } from '../getValueType.function.js';\nimport { TagJsSubject, getNewGlobal } from './TagJsSubject.class.js';\nexport function processNewValue(value, ownerSupport) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.tagComponent:\n            return new TagJsSubject(value); // ownerSupport.global.value\n        case ValueTypes.templater:\n            const templater = value;\n            const tag = templater.tag;\n            return processNewTag(tag, ownerSupport);\n        case ValueTypes.tag:\n        case ValueTypes.dom:\n            return processNewTag(value, ownerSupport);\n        case ValueTypes.subject:\n            value.global = getNewGlobal();\n            return value;\n    }\n    return new TagJsSubject(value);\n}\nfunction processNewTag(value, ownerSupport) {\n    const tag = value;\n    let templater = tag.templater;\n    // TODO: Can this ever happen?\n    if (!templater) {\n        templater = new TemplaterResult([]);\n        templater.tag = tag;\n        tag.templater = templater;\n    }\n    const subject = new TagJsSubject(templater);\n    subject.support = new Support(templater, ownerSupport, subject);\n    subject.global.oldest = subject.support;\n    ownerSupport.subject.global.childTags.push(subject.support);\n    return subject;\n}\n","import { empty } from \"./ValueTypes.enum.js\";\nexport const textNode = typeof document === 'undefined' ? getTestTextNode() : document.createTextNode(empty);\nfunction getTestTextNode() {\n    return {\n        textContent: empty,\n        cloneNode: (_children) => getTestTextNode()\n    };\n}\n","const style = 'style';\nconst classS = 'class';\nexport function specialAttribute(name, value, element) {\n    const names = name.split('.');\n    // style.position = \"absolute\"\n    if (names[0] === style) {\n        element.style[names[1]] = value;\n    }\n    // Example: class.width-full = \"true\"\n    if (names[0] === classS) {\n        names.shift();\n        if (value) {\n            for (let index = 0; index < names.length; ++index) {\n                element.classList.add(names[index]);\n            }\n        }\n        else {\n            for (let index = 0; index < names.length; ++index) {\n                element.classList.remove(names[index]);\n            }\n        }\n    }\n}\n","import { processAttribute } from './processAttribute.function.js';\nfunction howToSetAttribute(element, name, value) {\n    element.setAttribute(name, value);\n}\nexport function howToSetInputValue(element, name, value) {\n    element.setAttribute(name, value);\n}\nexport function interpolateAttributes(element, scope, ownerSupport) {\n    const attrNames = element.getAttributeNames();\n    let howToSet = howToSetAttribute;\n    for (let index = 0; index < attrNames.length; ++index) {\n        const attrName = attrNames[index];\n        const value = element.getAttribute(attrName);\n        processAttribute([attrName, value], element, scope, ownerSupport, howToSet);\n    }\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps) {\n    /*\n    const isCommonEqual = props === undefined && props === compareToProps\n    if(isCommonEqual) {\n      return false\n    }\n    */\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    // check all prop functions match\n    if (typeof (props) === ValueTypes.object) {\n        if (!pastCloneProps) {\n            return 3;\n        }\n        castedProps = [...props];\n        castedPastProps = [...(pastCloneProps || [])];\n        const allFunctionsMatch = castedProps.every((value, index) => {\n            let compare = castedPastProps[index];\n            if (value && typeof (value) === ValueTypes.object) {\n                const subCastedProps = { ...value };\n                const subCompareProps = { ...compare || {} };\n                const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n                    delete subCastedProps[key]; // its a function and not needed to be compared\n                    delete subCompareProps[key]; // its a function and not needed to be compared\n                }));\n                return matched;\n            }\n            return compareProps(value, compare, () => {\n                castedProps.splice(index, 1);\n                castedPastProps.splice(index, 1);\n            });\n        });\n        if (!allFunctionsMatch) {\n            return 'functions-changed'; // a change has been detected by function comparisons\n        }\n    }\n    // const isEqual = deepEqual(castedPastProps, castedProps)\n    // return isEqual ? false : 7 // if equal then no changes\n    return false;\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(value instanceof Function)) {\n        return deepEqual(value, compare) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(compareFn instanceof Function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 3; // both are function the same\n    }\n    onDelete();\n    return 5;\n}\n","/** checks if previous support exists on subject or as a last global support. If first render, calls builder. Otherwise calls support.updateBy() */\nexport function processTagResult(support, subject, // used for recording past and current value\n{ counts, }, fragment) {\n    // *if appears we already have seen\n    const subjectTag = subject;\n    const lastSupport = subjectTag.support;\n    const prevSupport = lastSupport?.subject.global.oldest || undefined;\n    const justUpdate = prevSupport;\n    if (prevSupport && justUpdate) {\n        return processTagResultUpdate(support, subjectTag, prevSupport);\n    }\n    const newFragment = support.buildBeforeElement(undefined, { counts });\n    //if(fragment) {\n    //  fragment.appendChild(newFragment)\n    //} else {\n    const placeholder = subject.global.placeholder;\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(newFragment, placeholder);\n    //}\n    return support;\n}\nfunction processTagResultUpdate(support, subject, // used for recording past and current value\nprevSupport) {\n    // components\n    if (subject instanceof Function) {\n        const newSupport = subject(prevSupport);\n        prevSupport.updateBy(newSupport);\n        subject.support = newSupport;\n        return newSupport;\n    }\n    // ??? - new removed\n    // prevSupport.updateBy(support)\n    subject.global.oldest.updateBy(support);\n    subject.support = support;\n    return support;\n}\n","import { elementInitCheck } from './elementInitCheck.js';\n/** This is the function that enhances elements such as [class.something] and [style.color] OR it fixes elements that alter innerHTML */\nexport function afterElmBuild(elm, options, context, ownerSupport) {\n    if (!elm.getAttribute) {\n        return;\n    }\n    let diff = options.counts.added;\n    diff = elementInitCheck(elm, options.counts) - diff;\n    const hasFocusFun = elm.focus;\n    if (hasFocusFun) {\n        if (elm.hasAttribute('autofocus')) {\n            elm.focus();\n        }\n        if (elm.hasAttribute('autoselect')) {\n            elm.select();\n        }\n    }\n    const children = elm.children;\n    if (children) {\n        for (let index = children.length - 1; index >= 0; --index) {\n            const child = children[index];\n            const subOptions = {\n                ...options,\n                counts: options.counts,\n            };\n            afterElmBuild(child, subOptions, context, ownerSupport);\n        }\n    }\n}\n","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n","import { afterElmBuild } from '../../interpolations/interpolateTemplate.js';\nimport { Support } from '../Support.class.js';\nimport { ValueSubject } from '../../subject/index.js';\n/** When first time render, adds to owner childTags */\nexport function processTag(templater, ownerSupport, // owner\nsubject) {\n    let support = subject.support;\n    // first time seeing this tag?\n    if (!support) {\n        support = newSupportByTemplater(templater, ownerSupport, subject);\n    }\n    subject.support = support;\n    support.ownerSupport = ownerSupport;\n    const newFragment = support.buildBeforeElement(undefined, { counts: { added: 0, removed: 0 } });\n    const children = [...newFragment.children];\n    const placeholder = subject.global.placeholder;\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(newFragment, placeholder);\n    afterChildrenBuilt(children, subject, ownerSupport);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        children: new ValueSubject([]), // no children\n        // props: {} as Props,\n        props: [],\n        isTag: true,\n        tagJsType: 'templater',\n        tagged: false,\n        html: () => fake,\n        dom: () => fake,\n        key: () => fake,\n    };\n    return fake;\n}\n/** Create Support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = new Support(templater, ownerSupport, subject);\n    setupNewSupport(support, ownerSupport, subject);\n    ownerSupport.subject.global.childTags.push(support);\n    return support;\n}\nexport function setupNewSupport(support, ownerSupport, subject) {\n    support.subject = subject;\n    subject.global.oldest = support;\n    subject.global.newest = support;\n    // asking me to render will cause my parent to render\n    support.ownerSupport = ownerSupport;\n}\nexport function afterChildrenBuilt(children, subject, ownerSupport) {\n    children.forEach(x => afterElmBuild(x, { counts: { added: 0, removed: 0 } }, subject.global.context, ownerSupport));\n}\n","import { processTagResult } from './processTagResult.function.js';\nimport { Support } from '../Support.class.js';\nimport { renderSubjectComponent } from '../render/renderSubjectComponent.function.js';\nimport { setupNewSupport } from './processTag.function.js';\n/** create new support, connects globals to old support if one, and  */\nexport function processSubjectComponent(templater, subject, insertBefore, ownerSupport, options, fragment) {\n    // Check if function component is wrapped in a tag() call\n    // TODO: This below check not needed in production mode\n    if (templater.tagged !== true) {\n        const wrapper = templater.wrapper;\n        const original = wrapper.parentWrap.original;\n        let name = original.name || original.constructor?.name;\n        if (name === 'Function') {\n            name = undefined;\n        }\n        const label = name || original.toString().substring(0, 120);\n        const error = new Error(`Not a tag component. Wrap your function with tag(). Example tag(props => html\\`\\`) on component:\\n\\n${label}\\n\\n`);\n        throw error;\n    }\n    const support = new Support(templater, ownerSupport, subject);\n    let reSupport = subject.support;\n    setupNewSupport(support, ownerSupport, subject);\n    const global = support.subject.global = reSupport?.subject.global || support.subject.global;\n    global.oldest = support;\n    global.insertBefore = insertBefore;\n    const isRender = !reSupport;\n    if (isRender) {\n        const mySupport = reSupport || support;\n        reSupport = renderSubjectComponent(subject, mySupport, ownerSupport);\n    }\n    const newSupport = processTagResult(reSupport, subject, // The element set here will be removed from document. Also result.tag will be added in here\n    options, fragment);\n    // subject.support = newSupport\n    ownerSupport.subject.global.childTags.push(newSupport);\n    return reSupport;\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nexport function renderSubjectComponent(subject, reSupport, ownerSupport) {\n    const ownGlobal = ownerSupport.subject.global;\n    const preClones = ownGlobal.clones.map(clone => clone);\n    reSupport = renderWithSupport(reSupport, subject.support, // existing tag\n    subject, ownerSupport);\n    const reGlobal = reSupport.subject.global;\n    if (ownGlobal.clones.length > preClones.length) {\n        const myClones = ownGlobal.clones.filter(fClone => !preClones.find(clone => clone === fClone));\n        reGlobal.clones.push(...myClones);\n    }\n    return reSupport;\n}\n","import { deepEqual } from './deepFunctions.js';\nimport { isStaticTag } from './isInstance.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { setUse } from './state/index.js';\nimport { getSupportInCycle } from './tag/getSupportInCycle.function.js';\nimport { runBlocked } from './interpolations/bindSubjectCallback.function.js';\nimport { cloneTagJsValue } from './tag/cloneValueArray.function.js';\nexport function castProps(props, newSupport, stateArray, depth) {\n    return props.map(prop => alterProp(prop, newSupport.ownerSupport, stateArray, newSupport, depth));\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProp(prop, ownerSupport, stateArray, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, stateArray, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, stateArray, newSupport, depth, index, newProp) {\n    if (value instanceof Function) {\n        return getPropWrap(value, ownerSupport, stateArray);\n    }\n    // if(seen.includes(value)) {\n    if (depth === 15) {\n        return value;\n    }\n    // seen.push(value)\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (value instanceof Array) {\n        for (let index = value.length - 1; index >= 0; --index) {\n            const subValue = value[index];\n            value[index] = checkProp(subValue, ownerSupport, stateArray, newSupport, depth + 1, index, value);\n            if (subValue instanceof Function) {\n                if (subValue.toCall) {\n                    continue;\n                }\n                afterCheckProp(depth + 1, index, subValue, value, newSupport);\n            }\n        }\n        return value;\n    }\n    // for(const name in value){\n    // ??? new we want below\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, stateArray, newSupport, depth + 1, name, value);\n        if (value[name] === result) {\n            continue; // ??? new\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (result instanceof Function) {\n            if (subValue.toCall) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    if (originalValue?.toCall) {\n        throw new Error('meg');\n        return; // already been done\n    }\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(() => {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, ownerSupport, stateArray) {\n    const toCall = value.toCall;\n    // already previously converted by a parent?\n    if (toCall) {\n        return value;\n    }\n    const wrap = (...args) => wrap.toCall(...args); // what gets called can switch over parent state changes\n    // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n    wrap.toCall = (...args) => {\n        return callbackPropOwner(wrap.mem.prop, args, ownerSupport);\n    };\n    wrap.original = value;\n    wrap.mem = {\n        prop: value,\n        // stateArray: stateArray\n    };\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global.newest;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    if (supportInCycle) {\n        supportInCycle.subject.global.locked = true;\n    }\n    const callbackResult = toCall(...callWith);\n    if (supportInCycle) {\n        const blocked = supportInCycle?.subject.global.blocked;\n        if (supportInCycle && blocked?.length) {\n            setUse.memory.tagClosed$.toCallback(() => {\n                let lastResult = supportInCycle;\n                // throw new Error('cycles ready')\n                // syncStates(supportInCycle.state, (supportInCycle.subject.global.newest as Support).state)\n                delete supportInCycle.subject.global.locked;\n                lastResult = runBlocked(supportInCycle, supportInCycle.state, supportInCycle);\n                // syncStates((supportInCycle.subject.global.newest as Support).state, supportInCycle.state)\n                // delete supportInCycle.subject.global.locked\n                renderSupport(lastResult, false);\n            });\n            return callbackResult;\n        }\n        delete supportInCycle.subject.global.locked;\n    }\n    const run = () => {\n        // are we in a rendering cycle? then its being called by alterProps\n        if (noCycle === false) {\n            // appears a prop function was called sync/immediately so lets see if owner changed state\n            const allMatched = newest.state.every(state => {\n                const lastValue = state.lastValue;\n                const get = state.get();\n                const equal = deepEqual(cloneTagJsValue(lastValue), get);\n                return equal;\n            });\n            if (allMatched) {\n                return callbackResult; // owner did not change\n            }\n        }\n        renderSupport(newest, true);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUse.memory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== 'object' || !value; // || isSubjectInstance(value)\n}\n","import { hasSupportChanged } from '../hasSupportChanged.function.js';\nimport { processSubjectComponent } from './processSubjectComponent.function.js';\nimport { destroyTagMemory } from '../destroyTag.function.js';\nimport { renderSupport } from '../render/renderSupport.function.js';\nimport { castProps, isSkipPropValue } from '../../alterProp.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { afterChildrenBuilt } from './processTag.function.js';\nimport { softDestroySupport } from '../render/softDestroySupport.function.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject, insertBefore, renderUp = false) {\n    let lastSupport = subject.global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.parentWrap.original;\n        const newFunction = newWrapper.parentWrap.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        const oldestSupport = subject.global.oldest;\n        destroyTagMemory(oldestSupport);\n        const newSupport = processSubjectComponent(templater, subject, insertBefore, ownerSupport, {\n            counts: { added: 0, removed: 0 },\n        });\n        return newSupport;\n    }\n    const hasChanged = hasSupportChanged(lastSupport, support, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        // update function refs to use latest references\n        const newProps = templater.props;\n        const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps);\n        // When new support actually makes call to real function, use these pre casted props\n        support.propsConfig.castProps = castedProps;\n        // update support to think it has different cloned props\n        lastSupport.propsConfig.latestCloned = support.propsConfig.latestCloned;\n        lastSupport.propsConfig.lastClonedKidValues = support.propsConfig.lastClonedKidValues;\n        return lastSupport; // its the same tag component\n    }\n    const oldest = subject.global.oldest;\n    if (subject.global.locked) {\n        subject.global.blocked.push(support);\n        return support;\n    }\n    const previous = subject.global.newest;\n    const newSupport = renderSupport(support, renderUp);\n    return afterTagRender(subject, oldest, templater, previous, newSupport, isSameTag);\n}\nfunction afterTagRender(subject, oldest, templater, previous, newSupport, isSameTag) {\n    let lastSupport = subject.support;\n    if (oldest && templater.children._value.length) {\n        const oldKidsSub = oldest.templater.children;\n        oldKidsSub.next(templater.children._value);\n    }\n    // detect if both the function is the same and the return is the same\n    const isLikeTag = isSameTag && isLikeTags(previous, newSupport);\n    if (isLikeTag) {\n        const oldestTag = subject.global.oldest;\n        subject.support = newSupport;\n        oldestTag.updateBy(newSupport);\n        return newSupport;\n    }\n    // Although function looked the same it returned a different html result\n    if (isSameTag && lastSupport) {\n        const preGlobal = previous.subject.global;\n        if (!preGlobal.deleted) {\n            softDestroySupport(previous);\n        }\n    }\n    return buildNewTag(newSupport, subject);\n}\nfunction buildNewTag(newSupport, subject) {\n    const fragment = newSupport.buildBeforeElement(undefined, {\n        counts: { added: 0, removed: 0 },\n    });\n    // TODO, do we need to clone?\n    const children = [...fragment.children];\n    const placeholder = subject.global.placeholder;\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(fragment, placeholder);\n    afterChildrenBuilt(children, subject, newSupport);\n    subject.global.oldest = newSupport;\n    subject.global.newest = newSupport;\n    subject.support = newSupport;\n    newSupport.ownerSupport.subject.global.childTags.push(newSupport);\n    return newSupport;\n}\nexport function syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray, // templater.props\ndepth = -1) {\n    const newest = lastSupport.subject.global.newest;\n    if (!newest) {\n        const state = ownerSupport.state;\n        newPropsArray.length = 0;\n        const castedProps = castProps(newPropsArray, newSupport, state, depth);\n        newPropsArray.push(...castedProps);\n        newSupport.propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, depth + 1, index);\n        newArray.push(newValue);\n    }\n    newSupport.propsConfig.castProps = newArray;\n    return newArray;\n}\nfunction syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, depth, index) {\n    if (priorProp instanceof Function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem.prop = prop.mem.prop;\n            priorProp.mem.stateArray = prop.mem.stateArray;\n            return prop;\n        }\n        const ownerGlobal = ownerSupport.subject.global;\n        const oldOwnerState = ownerGlobal.newest.state;\n        priorProp.mem.prop = prop;\n        priorProp.stateArray = oldOwnerState;\n        return priorProp;\n    }\n    // prevent infinite recursion\n    // if(seen.includes(prop)) {\n    if (depth === 15) {\n        return prop;\n    }\n    // seen.push(prop)\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (prop instanceof Array) {\n        for (let index = prop.length - 1; index >= 0; --index) {\n            const x = prop[index];\n            prop[index] = syncPriorPropFunction(priorProp[index], x, newSupport, ownerSupport, depth + 1, index);\n        }\n        return prop;\n    }\n    if (priorProp === undefined) {\n        return prop;\n    }\n    const keys = Object.keys(prop);\n    // for(const name in prop){\n    for (const name of keys) {\n        const subValue = prop[name];\n        const result = syncPriorPropFunction(priorProp[name], subValue, newSupport, ownerSupport, depth + 1, name);\n        if (prop[name] === result) {\n            continue; // ??? new\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    global.providers.forEach(provider => {\n        provider.children.forEach((child, index) => {\n            const wasSameGlobals = global.destroy$ === child.subject.global.destroy$;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        });\n    });\n}\n","import { hasPropChanges } from './hasPropChanges.function.js';\nexport function hasSupportChanged(lastSupport, newSupport, newTemplater) {\n    const latestProps = newTemplater.props; // newSupport.propsConfig.latest\n    const pastCloneProps = lastSupport.propsConfig.latestCloned;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps);\n    // if no changes detected, no need to continue to rendering further tags\n    if (propsChanged) {\n        return propsChanged;\n    }\n    const propsChanged2 = hasPropChanges(lastSupport.propsConfig.latestCloned, newSupport.propsConfig.latestCloned);\n    if (propsChanged2) {\n        return propsChanged2;\n    }\n    const kidsChanged = hasKidsChanged(lastSupport, newSupport);\n    // we already know props didn't change and if kids didn't either, than don't render\n    return kidsChanged;\n}\nexport function hasKidsChanged(oldSupport, newSupport) {\n    const oldCloneKidValues = oldSupport.propsConfig.lastClonedKidValues;\n    const newClonedKidValues = newSupport.propsConfig.lastClonedKidValues;\n    const everySame = oldCloneKidValues.every((set, index) => {\n        const x = newClonedKidValues[index];\n        return set.every((item, index) => item === x[index]);\n    });\n    return everySame ? false : 9;\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { syncStates } from '../state/syncStates.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { updateExistingTagComponent } from '../tag/update/updateExistingTagComponent.function.js';\nconst useLocks = true;\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    // Is this children? No override needed\n    if (value.isChildOverride) {\n        return value;\n    }\n    // const state = setUse.memory.stateConfig.support?.state as State\n    const state = support.state;\n    const subjectFunction = (element, args) => runTagCallback(value, support, element, args, state);\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, bindTo, args, state) {\n    const tag = findTagToCallback(support);\n    const global = tag.subject.global;\n    /*\n    if(global.deleted) {\n      return noData\n    }\n    */\n    const newest = global.newest;\n    const newState = newest.state;\n    if (newState.length === state.length) {\n        syncStates(newState, state);\n    }\n    // syncStates(newState, tag.state)\n    const method = value.bind(bindTo);\n    tag.subject.global.locked = useLocks; // prevent another render from re-rendering this tag\n    const callbackResult = method(...args);\n    return afterTagCallback(tag, callbackResult, state);\n}\nexport function afterTagCallback(tag, callbackResult, state) {\n    const global = tag.subject.global;\n    delete global.locked;\n    const blocked = global.blocked;\n    // // syncStates(state, newState)\n    if (blocked.length) {\n        // syncStates(tag.state, (global.newest as Support).state)\n        let lastResult;\n        lastResult = runBlocked(tag, state, lastResult);\n        // return lastResult\n        return checkAfterCallbackPromise(callbackResult, lastResult, global);\n    }\n    const result = renderCallbackSupport(global.newest, callbackResult, global);\n    return result;\n}\nexport function findTagToCallback(support) {\n    // If we are NOT a component than we need to render my owner instead\n    if (support.templater.tagJsType === ValueTypes.templater) {\n        const owner = support.ownerSupport;\n        return findTagToCallback(owner);\n    }\n    return support;\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    if (global.deleted) {\n        return noData; // || last.global.deleted\n    }\n    renderSupport(last, true);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (callbackResult instanceof Promise) {\n        last.subject.global.locked = useLocks;\n        return callbackResult.then(() => {\n            delete last.subject.global.locked;\n            if (global.deleted) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            delete last.subject.global.locked;\n            renderSupport(global.newest, true);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag, state, lastResult) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    while (blocked.length > 0) {\n        const block = blocked[0];\n        blocked.splice(0, 1);\n        lastResult = updateExistingTagComponent(block.ownerSupport, block, block.subject, block.subject.global.insertBefore, true);\n        global.newest = lastResult;\n    }\n    global.blocked.length = 0;\n    // global.oldest.updateBy( lastResult as Support )\n    /*\n    if(lastResult) {\n      const newState = lastResult.state\n      syncStates(state, newState)\n  \n      const newest = renderSupport(\n        lastResult,\n        true,\n      )\n      \n      global.newest = newest\n      global.oldest.updateBy( lastResult as Support )\n      syncStates(newState, state)\n    }\n      */\n    return lastResult;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { isSubjectInstance } from '../isInstance.js';\nimport { howToSetInputValue } from './interpolateAttributes.js';\nimport { bindSubjectCallback } from './bindSubjectCallback.function.js';\nimport { ValueTypes, empty } from '../tag/ValueTypes.enum.js';\nimport { TagJsSubject } from '../tag/update/TagJsSubject.class.js';\nconst INPUT = 'INPUT';\nconst valueS = 'value';\nconst ondoubleclick = 'ondoubleclick';\n/** Sets attribute value, subscribes to value updates  */\nexport function processAttribute(attrs, element, scope, support, howToSet = howToSetInputValue) {\n    const attrName = attrs[0];\n    const value = attrs[1];\n    if (element.nodeName === INPUT && attrName === valueS) {\n        howToSet = howToSetInputValue;\n    }\n    const isNameVar = attrs.length === 1; // isTagVar(attrName)\n    if (isNameVar) {\n        const contextValueSubject = attrName; // getContextValueByVarString(scope, attrName)\n        let lastValue;\n        // the above callback gets called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe((value) => {\n            if (value === lastValue) {\n                return; // value did not change\n            }\n            processNameOnlyAttr(value, lastValue, element, support, howToSet);\n            lastValue = value;\n        });\n        support.subject.global.subscriptions.push(sub); // this is where unsubscribe is picked up\n        element.removeAttribute(attrName);\n        return;\n    }\n    const isSubject = value && isSubjectInstance(value);\n    // const isSubject = isTagVar(value)\n    if (isSubject) {\n        return processNameValueAttr(attrName, value, element, support, howToSet);\n    }\n    // Non dynamic\n    const isSpecial = isSpecialAttr(attrName);\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element);\n    }\n    howToSet(element, attrName, value);\n}\nfunction processNameOnlyAttr(attrValue, lastValue, child, ownerSupport, howToSet) {\n    // check to remove previous attribute(s)\n    if (lastValue && lastValue != attrValue) {\n        if (typeof (lastValue) === ValueTypes.string) {\n            child.removeAttribute(lastValue);\n        }\n        else if (lastValue instanceof Object) {\n            for (const name in lastValue) {\n                child.removeAttribute(name);\n            }\n        }\n    }\n    // regular attributes\n    if (typeof (attrValue) === ValueTypes.string) {\n        if (!attrValue.length) {\n            return;\n        }\n        processNameValueAttr(attrValue, // name\n        new TagJsSubject(empty), child, ownerSupport, howToSet);\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (attrValue instanceof Object) {\n        for (const name in attrValue) {\n            processNameValueAttr(name, attrValue[name], child, ownerSupport, howToSet);\n        }\n    }\n}\n/** Processor for flat attributes and object attributes */\nfunction processNameValueAttr(attrName, result, child, support, howToSet) {\n    // Most every variable comes in here since everything is made a ValueSubject\n    if (isSubjectInstance(result)) {\n        const isSpecial = isSpecialAttr(attrName);\n        child.removeAttribute(attrName);\n        let lastValue;\n        const callback = (newAttrValue) => {\n            // should the function be wrapped so every time its called we re-render?\n            if (newAttrValue instanceof Function) {\n                return callbackFun(support, newAttrValue, child, attrName, isSpecial, howToSet);\n            }\n            // TODO: we maybe able to block higher before instance of check\n            if (lastValue === newAttrValue) {\n                return lastValue;\n            }\n            lastValue = newAttrValue;\n            return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = result.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        support.subject.global.subscriptions.push(sub);\n        return;\n    }\n    howToSet(child, attrName, result._value);\n    return;\n}\nfunction processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet) {\n    if (newAttrValue instanceof Function) {\n        const fun = function (...args) {\n            return newAttrValue(child, args);\n        };\n        // access to original function\n        fun.tagFunction = newAttrValue;\n        if (attrName === ondoubleclick) {\n            attrName = 'ondblclick';\n        }\n        ;\n        child[attrName] = fun;\n        return;\n    }\n    if (isSpecial) {\n        specialAttribute(attrName, newAttrValue, child);\n        return;\n    }\n    if (newAttrValue) {\n        howToSet(child, attrName, newAttrValue);\n        return;\n    }\n    const isDeadValue = [undefined, false, null].includes(newAttrValue);\n    if (isDeadValue) {\n        child.removeAttribute(attrName);\n        return;\n    }\n    // value is 0\n    howToSet(child, attrName, newAttrValue);\n}\n/** Looking for (class | style) followed by a period */\nfunction isSpecialAttr(attrName) {\n    return attrName.search(/^(class|style)(\\.)/) >= 0;\n}\nfunction callbackFun(support, newAttrValue, child, attrName, isSpecial, howToSet) {\n    const wrapper = support.templater.wrapper;\n    const parentWrap = wrapper?.parentWrap;\n    const oneRender = parentWrap?.oneRender;\n    if (!oneRender) {\n        newAttrValue = bindSubjectCallback(newAttrValue, support);\n    }\n    return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n}\n","// taggedjs-no-compile\nimport { ArrayNoKeyError } from '../../errors.js';\nimport { destroyArrayTag } from '../checkDestroyPrevious.function.js';\nimport { newSupportByTemplater, setupNewSupport, tagFakeTemplater } from './processTag.function.js';\nimport { Support } from '../Support.class.js';\nimport { isTagClass } from '../../isInstance.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { TagJsSubject } from './TagJsSubject.class.js';\nimport { afterChildrenBuilt } from './processTag.function.js';\nimport { textNode } from '../textNode.js';\nexport function processTagArray(subject, value, // arry of Tag classes\ninsertBefore, // <template end interpolate />\nownerSupport, options, fragment) {\n    const clones = ownerSupport.subject.global.clones; // []\n    let lastArray = subject.lastArray = subject.lastArray || { array: [] };\n    if (!subject.global.placeholder) {\n        setPlaceholderElm(insertBefore, subject);\n    }\n    const runtimeInsertBefore = subject.global.placeholder;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    lastArray.array = lastArray.array.filter((item, index) => {\n        const newLength = value.length - 1;\n        const at = index - removed;\n        const lessLength = newLength < at;\n        if (lessLength) {\n            destroyArrayItem(lastArray.array, index, options);\n            ++removed;\n            return false;\n        }\n        const subTag = value[index - removed];\n        const tagClass = isTagClass(subTag);\n        let tag = subTag;\n        let templater = subTag.templater;\n        let prevArrayValue;\n        if (tagClass) {\n            prevArrayValue = tag.arrayValue;\n        }\n        else {\n            templater = subTag;\n            tag = templater.tag;\n            prevArrayValue = templater.arrayValue;\n        }\n        // const tag = subTag?.templater.tag as Tag\n        const lastTag = item.support.templater.tag;\n        const lastArrayValue = lastTag.arrayValue;\n        const destroyItem = !areLikeValues(prevArrayValue, lastArrayValue);\n        if (destroyItem) {\n            destroyArrayItem(lastArray.array, index, options);\n            ++removed;\n            return false;\n        }\n        return true;\n    });\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const item = value[index];\n        const previous = lastArray.array[index];\n        const previousSupport = previous?.support;\n        const subTag = item;\n        const tagClass = isTagClass(subTag);\n        const itemSubject = previousSupport?.subject || new TagJsSubject(undefined);\n        let templater = subTag.templater;\n        let support;\n        if (tagClass) {\n            if (!templater) {\n                templater = tagFakeTemplater(subTag);\n            }\n            support = new Support(templater, ownerSupport, itemSubject);\n        }\n        else {\n            templater = subTag;\n            support = setupNewTemplater(templater, ownerSupport, itemSubject);\n        }\n        // share global between old and new\n        if (previousSupport) {\n            const prevSubject = previousSupport.subject;\n            const global = prevSubject.global;\n            setupNewSupport(support, ownerSupport, prevSubject);\n            support.subject.global = global;\n            global.newest = support;\n        }\n        else {\n            setupNewSupport(support, ownerSupport, itemSubject);\n        }\n        // check for html``.key()\n        const tag = templater.tag || subTag;\n        const keySet = 'arrayValue' in tag;\n        if (!keySet) {\n            const details = {\n                // template: support.getTemplate().string,\n                array: value,\n            };\n            const message = 'Use html`...`.key(item) instead of html`...` to template an Array';\n            console.error(message, details);\n            const err = new ArrayNoKeyError(message, details);\n            throw err;\n        }\n        const couldBeSame = lastArray.array.length > index;\n        if (couldBeSame) {\n            const prevSupport = previous.support;\n            const prevGlobal = prevSupport.subject.global;\n            const oldest = prevGlobal.oldest;\n            oldest.updateBy(support);\n            continue;\n        }\n        processAddTagArrayItem(runtimeInsertBefore, support, index, options, lastArray.array, fragment);\n        ownerSupport.subject.global.childTags.push(support);\n    }\n    return clones;\n}\nfunction setPlaceholderElm(insertBefore, subject) {\n    const placeholder = subject.global.placeholder = textNode.cloneNode(false);\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n}\nfunction processAddTagArrayItem(before, support, index, options, lastArray, fragment) {\n    const lastValue = {\n        support, index\n    };\n    // Added to previous array\n    lastArray.push(lastValue);\n    const counts = {\n        added: options.counts.added + index,\n        removed: options.counts.removed,\n    };\n    // TODO: This might be causing double clones delete issues because all array items share same placeholder\n    support.subject.global.placeholder = before; // newTempElm\n    const newFragment = support.buildBeforeElement(undefined, { counts });\n    const children = [...newFragment.children];\n    const placeholder = before; // subject.global.placeholder as Text\n    const parentNode = placeholder.parentNode;\n    parentNode.insertBefore(newFragment, placeholder);\n    afterChildrenBuilt(children, support.subject, support);\n}\n/** compare two values. If both values are arrays then the items will be compared */\nfunction areLikeValues(valueA, valueB) {\n    if (valueA === valueB) {\n        return true;\n    }\n    const bothArrays = valueA instanceof Array && valueB instanceof Array;\n    const matchLengths = bothArrays && valueA.length == valueB.length;\n    if (matchLengths) {\n        return valueA.every((item, index) => item === valueB[index]);\n    }\n    return false;\n}\nfunction setupNewTemplater(templater, ownerSupport, itemSubject) {\n    const support = newSupportByTemplater(templater, ownerSupport, itemSubject);\n    renderTagOnly(support, support, itemSubject, ownerSupport);\n    return support;\n}\nfunction destroyArrayItem(lastArray, index, options) {\n    const last = lastArray[index];\n    const support = last.support;\n    destroyArrayTag(support, options.counts);\n    last.deleted = true;\n    ++options.counts.removed;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\n// Function to update the value of x\nexport function updateBeforeTemplate(value, // value should be casted before calling here\nlastFirstChild) {\n    const parent = lastFirstChild.parentNode;\n    // Insert the new value (never use innerHTML here)\n    const textNode = document.createTextNode(value); // never innerHTML\n    parent.insertBefore(textNode, lastFirstChild);\n    /* remove existing nodes */\n    parent.removeChild(lastFirstChild);\n    return textNode;\n}\nexport function castTextValue(value) {\n    // mimic React skipping to display EXCEPT for true does display on page\n    if ([undefined, false, null].includes(value)) { // || value === true\n        return empty;\n    }\n    return value;\n}\n","import { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nexport function processRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.global.insertBefore = insertBefore;\n    const before = subject.global.placeholder || insertBefore; // Either the template is on the doc OR its the first element we last put on doc\n    // matches but also was defined at some point\n    if (subject.lastValue === value && 'lastValue' in subject) {\n        return; // no need to update display, its the same\n    }\n    subject.lastValue = value;\n    const castedValue = castTextValue(value);\n    // replace existing string?\n    const oldClone = subject.global.placeholder;\n    if (oldClone) {\n        oldClone.textContent = castedValue;\n        return;\n    }\n    // Processing of regular values\n    const clone = updateBeforeTemplate(castedValue, before);\n    subject.global.placeholder = clone; // remember single element put down, for future updates\n}\nexport function processFirstRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.lastValue = value;\n    const castedValue = castTextValue(value);\n    // Processing of regular values\n    const clone = updateBeforeTemplate(castedValue, insertBefore);\n    subject.global.placeholder = clone; // remember single element put down, for future updates \n}\n","import { TemplaterResult } from '../TemplaterResult.class.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = new TemplaterResult([]);\n    templater.tagJsType = ValueTypes.oneRender;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    const wrap = () => {\n        templater.tag = tag || (wrapper());\n        return support;\n    };\n    templater.wrapper = wrap;\n    wrap.parentWrap = wrap;\n    wrap.oneRender = true;\n    wrap.parentWrap.original = wrapper;\n    return support;\n}\n","import { processSubjectComponent } from './processSubjectComponent.function.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processFirstRegularValue } from './processRegularValue.function.js';\nimport { processTag, tagFakeTemplater } from './processTag.function.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { oneRenderToSupport } from './oneRenderToSupport.function.js';\nimport { getValueType } from '../getValueType.function.js';\nexport function processFirstSubjectValue(value, subject, // could be tag via result.tag\ninsertBefore, // <template end interpolate /> (will be removed)\nownerSupport, // owner\noptions, // {added:0, removed:0}\nfragment) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.templater:\n            processTag(value, ownerSupport, subject);\n            return;\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = tagFakeTemplater(tag);\n            }\n            processTag(templater, ownerSupport, subject);\n            return;\n        case ValueTypes.tagArray:\n            return processTagArray(subject, value, insertBefore, ownerSupport, options, fragment);\n        case ValueTypes.tagComponent:\n            const newSupport = processSubjectComponent(value, subject, insertBefore, ownerSupport, options, fragment);\n            return newSupport;\n        case ValueTypes.function:\n            const v = value;\n            if (v.oneRender) {\n                const support = oneRenderToSupport(v, subject, ownerSupport);\n                renderTagOnly(support, support, subject, ownerSupport);\n                processTag(support.templater, ownerSupport, subject);\n                return;\n            }\n            break;\n    }\n    processFirstRegularValue(value, subject, subject.global.placeholder || insertBefore);\n}\n","import { textNode } from './textNode.js';\nexport function setTagPlaceholder(global) {\n    const insertBefore = global.insertBefore;\n    return global.placeholder = swapInsertBefore(insertBefore);\n}\nexport function swapInsertBefore(insertBefore) {\n    const placeholder = textNode.cloneNode(false);\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n    return placeholder;\n}\n","import { Support } from '../Support.class.js';\nimport { TemplaterResult } from '../TemplaterResult.class.js';\nimport { isTagClass, isTagTemplater } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function.js';\nimport { processRegularValue } from './processRegularValue.function.js';\nimport { checkDestroyPrevious } from '../checkDestroyPrevious.function.js';\nimport { processSubjectComponent } from './processSubjectComponent.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { getFakeTemplater, processTag, setupNewSupport } from './processTag.function.js';\nimport { swapInsertBefore } from '../setTagPlaceholder.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getValueType } from '../getValueType.function.js';\nexport function updateExistingValue(subject, value, ownerSupport, insertBefore) {\n    const valueType = getValueType(value);\n    checkDestroyPrevious(subject, value, valueType);\n    // handle already seen tag components\n    if (valueType === ValueTypes.tagComponent) {\n        return prepareUpdateToComponent(value, subject, insertBefore, ownerSupport);\n    }\n    // was component but no longer\n    const support = subject.support;\n    if (support) {\n        if (valueType === ValueTypes.function) {\n            return subject; // its a oneRender tag\n        }\n        handleStillTag(subject, value, ownerSupport);\n        return subject;\n    }\n    switch (valueType) {\n        case ValueTypes.tagArray:\n            processTagArray(subject, value, insertBefore, // oldInsertBefore as InsertBefore,\n            ownerSupport, { counts: {\n                    added: 0,\n                    removed: 0,\n                } });\n            return subject;\n        case ValueTypes.templater:\n            processTag(value, ownerSupport, subject);\n            return subject;\n        case ValueTypes.tag:\n        case ValueTypes.dom:\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = getFakeTemplater();\n                tag.templater = templater;\n                templater.tag = tag;\n            }\n            processTag(templater, ownerSupport, subject);\n            return subject;\n        case ValueTypes.subject:\n            return value;\n        // now its a useless function (we don't automatically call functions)\n        case ValueTypes.function:\n            if (!subject.global.placeholder) {\n                subject.global.placeholder = swapInsertBefore(insertBefore);\n            }\n            return subject;\n    }\n    // This will cause all other values to render\n    processRegularValue(value, subject, insertBefore);\n    return subject;\n}\nfunction handleStillTag(subject, value, ownerSupport) {\n    const lastSupport = subject.support;\n    let templater = value;\n    const isClass = isTagClass(value);\n    if (isClass) {\n        const tag = value;\n        templater = tag.templater;\n        if (!templater) {\n            templater = new TemplaterResult([]);\n            templater.tag = tag;\n            tag.templater = templater;\n        }\n    }\n    const valueSupport = new Support(templater, ownerSupport, subject);\n    const isSameTag = value && isLikeTags(lastSupport, valueSupport);\n    if (isTagTemplater(value)) {\n        setupNewSupport(valueSupport, ownerSupport, subject);\n    }\n    if (isSameTag) {\n        // lastSupport.updateBy(valueSupport)\n        // ??? recently changed from above\n        lastSupport.subject.global.oldest.updateBy(valueSupport);\n        return;\n    }\n    if (isSameTag) {\n        return processTag(templater, ownerSupport, subject);\n    }\n    return processRegularValue(value, subject, subject.global.insertBefore);\n}\nfunction prepareUpdateToComponent(templater, subjectTag, insertBefore, ownerSupport) {\n    // When last value was not a component\n    if (!subjectTag.support) {\n        processSubjectComponent(templater, subjectTag, insertBefore, ownerSupport, {\n            counts: { added: 0, removed: 0 },\n        });\n        return subjectTag;\n    }\n    const support = new Support(templater, ownerSupport, subjectTag);\n    const subjectSup = subjectTag.support;\n    const prevSupport = subjectSup.subject.global.newest;\n    if (prevSupport) {\n        const newestState = prevSupport.state;\n        support.state.length = 0;\n        support.state.push(...newestState);\n    }\n    else {\n        processSubjectComponent(templater, subjectTag, insertBefore, ownerSupport, { counts: { added: 0, removed: 0 } });\n        return subjectTag;\n    }\n    subjectTag.global = subjectSup.subject.global;\n    subjectTag.support = support;\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    subjectTag, insertBefore);\n    return subjectTag;\n}\n","import { processFirstSubjectValue } from '../tag/update/processFirstSubjectValue.function.js';\nimport { updateExistingValue } from '../tag/update/updateExistingValue.function.js';\nimport { swapInsertBefore } from '../tag/setTagPlaceholder.function.js';\nexport function subscribeToTemplate(fragment, insertBefore, subject, support, counts) {\n    let called = false;\n    const onValue = (value) => {\n        if (called) {\n            updateExistingValue(subject, value, support, insertBefore);\n            return;\n        }\n        const templater = value;\n        processFirstSubjectValue(templater, subject, insertBefore, support, {\n            counts: { ...counts },\n        }, syncRun ? fragment : undefined);\n        called = true;\n    };\n    // TODO: may noy be needed\n    // leave no template tag\n    if (!subject.global.placeholder) {\n        subject.global.placeholder = swapInsertBefore(insertBefore);\n    }\n    const callback = (value) => onValue(value);\n    let syncRun = true;\n    const sub = subject.subscribe(callback);\n    syncRun = false;\n    support.subject.global.subscriptions.push(sub);\n}\n","import { textNode } from \"../../tag/textNode.js\";\nimport { processAttribute } from \"../processAttribute.function.js\";\nimport { subscribeToTemplate } from \"../subscribeToTemplate.function.js\";\nexport function attachDomElement(nodes, scope, support, fragment, counts, // used for animation stagger computing\nowner) {\n    nodes.forEach((node, index) => {\n        const marker = node.marker = textNode.cloneNode(false);\n        // marker.textContent = `_<${index}>_`\n        const subject = node.value;\n        if (subject) {\n            owner.appendChild(marker);\n            subject.global.placeholder = marker;\n            subscribeToTemplate(owner, marker, subject, support, // ownerSupport,\n            counts);\n            return;\n        }\n        if (node.nodeName === 'text') {\n            const string = node.textContent;\n            // parse things like &nbsp;\n            const text = new DOMParser().parseFromString(string, 'text/html');\n            const openingSpace = string.replace(/(^\\s+)?.+/g, '$1');\n            const newString = openingSpace + text.documentElement.textContent;\n            owner.appendChild(marker);\n            node.domElement = document.createTextNode(newString);\n            owner.appendChild(node.domElement);\n            return;\n        }\n        node = node;\n        const domElement = node.domElement = document.createElement(node.nodeName);\n        owner.appendChild(domElement);\n        owner.appendChild(marker);\n        if (node.attributes) {\n            node.attributes.forEach(attr => {\n                processAttribute(attr, domElement, scope, support);\n            });\n        }\n        if (node.children) {\n            attachDomElement(node.children, scope, support, fragment, counts, domElement);\n        }\n    });\n    return nodes;\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { deepClone } from '../deepFunctions.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { cloneTagJsValue, cloneValueArray } from './cloneValueArray.function.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { getChildTagsToDestroy } from './destroy.support.js';\nimport { elementDestroyCheck } from './elementDestroyCheck.function.js';\nimport { updateContextItem } from './update/updateContextItem.function.js';\nimport { processNewValue } from './update/processNewValue.function.js';\nimport { exchangeParsedForValues } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { attachDomElement } from '../interpolations/optimizers/metaAttachDomElements.function.js';\nimport { getDomMeta } from './domMetaCollector.js';\n/** used only for apps, otherwise use Support */\n// TODO: We need to split Support and simple tag support apart\nexport class BaseSupport {\n    templater;\n    subject;\n    isApp = true;\n    appElement; // only seen on this.getAppSupport().appElement\n    strings;\n    dom;\n    values;\n    propsConfig;\n    // stays with current render\n    state = [];\n    hasLiveElements = false;\n    constructor(templater, subject, castedProps) {\n        this.templater = templater;\n        this.subject = subject;\n        const props = templater.props; // natural props\n        this.propsConfig = this.clonePropsBy(props, castedProps);\n    }\n    clonePropsBy(props, castedProps) {\n        const children = this.templater.children; // children tags passed in as arguments\n        const kidValue = children.value;\n        const latestCloned = props.map(props => cloneTagJsValue(props)\n        // deepClone(props)\n        );\n        return this.propsConfig = {\n            latest: props,\n            latestCloned, // assume its HTML children and then detect\n            castProps: castedProps,\n            lastClonedKidValues: kidValue.map(kid => {\n                const cloneValues = cloneValueArray(kid.values);\n                return cloneValues;\n            })\n        };\n    }\n    getHtmlDomMeta(fragment, options = {\n        counts: { added: 0, removed: 0 },\n    }) {\n        const thisTag = this.templater.tag;\n        const context = this.update();\n        let orgDomMeta;\n        if (thisTag.tagJsType === ValueTypes.dom) {\n            orgDomMeta = thisTag.dom;\n        }\n        else {\n            orgDomMeta = getDomMeta(thisTag.strings, thisTag.values);\n        }\n        const domMeta = deepClone(orgDomMeta);\n        exchangeParsedForValues(domMeta, context);\n        attachDomElement(domMeta, context, this, fragment, options.counts, fragment);\n        return domMeta;\n    }\n    /** Function that kicks off actually putting tags down as HTML elements */\n    buildBeforeElement(fragment = document.createDocumentFragment(), options) {\n        const subject = this.subject;\n        const global = this.subject.global;\n        global.oldest = this;\n        global.newest = this;\n        subject.support = this;\n        this.hasLiveElements = true;\n        const htmlDomMeta = this.getHtmlDomMeta(fragment, options);\n        attachClonesToSupport(htmlDomMeta, this.subject.global.clones);\n        return fragment;\n    }\n    updateBy(support) {\n        const tempTag = support.templater.tag;\n        this.updateConfig(tempTag, tempTag.values);\n    }\n    /** triggers values to render */\n    updateConfig(tag, values) {\n        if (tag.tagJsType === ValueTypes.dom) {\n            this.dom = tag.dom;\n        }\n        else {\n            this.strings = tag.strings;\n        }\n        this.updateValues(values);\n    }\n    updateValues(values) {\n        this.values = values;\n        return this.updateContext(this.subject.global.context);\n    }\n    update() {\n        return this.updateContext(this.subject.global.context);\n    }\n    updateContext(context) {\n        const thisTag = this.templater.tag;\n        // const strings = this.strings || thisTag.strings\n        const values = this.values || thisTag.values;\n        // TODO: loop specific number of times instead of building an array\n        const array = 'x,'.repeat(values.length).split(','); // strings\n        array.forEach((_string, index) => updateOneContext(values, index, context, this));\n        return context;\n    }\n    destroy(options = {\n        stagger: 0,\n    }) {\n        const global = this.subject.global;\n        const childTags = options.byParent ? [] : getChildTagsToDestroy(this.subject.global.childTags); // .toReversed()\n        if (isTagComponent(this.templater)) {\n            global.destroy$.next();\n            runBeforeDestroy(this, this);\n        }\n        this.destroySubscriptions();\n        // signify immediately child has been deleted (looked for during event processing)\n        for (let index = childTags.length - 1; index >= 0; --index) {\n            const child = childTags[index];\n            const subGlobal = child.subject.global;\n            delete subGlobal.newest;\n            subGlobal.deleted = true;\n            if (isTagComponent(child.templater)) {\n                runBeforeDestroy(child, child);\n            }\n            child.destroySubscriptions();\n            // resetSupport(this)\n        }\n        resetSupport(this);\n        // let mainPromise: Promise<number | (number | void | undefined)[]> | undefined    \n        // first paint\n        const { stagger, promises } = this.smartRemoveKids(options);\n        options.stagger = stagger;\n        if (promises.length) {\n            return Promise.all(promises).then(() => options.stagger);\n        }\n        return options.stagger;\n    }\n    smartRemoveKids(options = {\n        stagger: 0,\n    }) {\n        const startStagger = options.stagger;\n        const promises = [];\n        const myClones = this.subject.global.clones;\n        this.subject.global.childTags.forEach(childTag => {\n            const clones = childTag.subject.global.clones;\n            let cloneOne = clones[0];\n            if (cloneOne === undefined) {\n                const { stagger, promises: newPromises } = childTag.smartRemoveKids(options);\n                options.stagger = options.stagger + stagger;\n                promises.push(...newPromises);\n                return { promise: Promise.all(promises), stagger: options.stagger };\n            }\n            let count = 0;\n            // let deleted = false\n            while (cloneOne.parentNode && count < 5) {\n                if (myClones.includes(cloneOne)) {\n                    return; // no need to delete, they live within me\n                }\n                cloneOne = cloneOne.parentNode;\n                ++count;\n            }\n            // recurse\n            const { stagger, promises: newPromises } = childTag.smartRemoveKids(options);\n            options.stagger = options.stagger + stagger;\n            promises.push(...newPromises);\n        });\n        const promise = this.destroyClones({ stagger: startStagger }).promise;\n        this.subject.global.clones.length = 0;\n        this.subject.global.childTags.length = 0;\n        if (promise) {\n            promises.unshift(promise);\n        }\n        return { promises, stagger: options.stagger };\n    }\n    destroyClones(options = {\n        stagger: 0,\n    }) {\n        const oldClones = this.subject.global.clones; // .toReversed()\n        // check subjects that may have clones attached to them\n        const promises = oldClones.map(clone => this.checkCloneRemoval(clone, options.stagger)).filter(x => x); // only return promises\n        if (promises.length) {\n            return { promise: Promise.all(promises), stagger: options.stagger };\n        }\n        return { stagger: options.stagger };\n    }\n    /** Reviews elements for the presences of ondestroy */\n    checkCloneRemoval(clone, stagger) {\n        let promise;\n        const customElm = clone;\n        if (customElm.ondestroy) {\n            promise = elementDestroyCheck(customElm, stagger);\n        }\n        if (promise instanceof Promise) {\n            return promise.then(() => {\n                const parentNode = clone.parentNode;\n                // TODO: we need to remove this IF\n                if (parentNode) {\n                    parentNode.removeChild(clone);\n                }\n            });\n        }\n        const parentNode = clone.parentNode;\n        if (parentNode) {\n            parentNode.removeChild(clone);\n        }\n        const ownerSupport = this.ownerSupport;\n        if (ownerSupport) {\n            const clones = ownerSupport.subject.global.clones;\n            const index = clones.indexOf(clone);\n            if (index >= 0) {\n                clones.splice(index, 1);\n            }\n        }\n        return promise;\n    }\n    destroySubscriptions() {\n        const subs = this.subject.global.subscriptions;\n        for (let index = subs.length - 1; index >= 0; --index) {\n            subs[index].unsubscribe();\n        }\n        subs.length = 0;\n    }\n}\nexport class Support extends BaseSupport {\n    templater;\n    ownerSupport;\n    subject;\n    version;\n    isApp = false;\n    constructor(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\n    ownerSupport, subject, castedProps, version = 0) {\n        super(templater, subject, castedProps);\n        this.templater = templater;\n        this.ownerSupport = ownerSupport;\n        this.subject = subject;\n        this.version = version;\n    }\n    getAppSupport() {\n        let tag = this;\n        while (tag.ownerSupport) {\n            tag = tag.ownerSupport;\n        }\n        return tag;\n    }\n}\nexport function resetSupport(support) {\n    const global = support.subject.global;\n    // TODO: We maybe able to replace with: global.context.length = 0\n    global.context = [];\n    delete global.oldest; // may not be needed\n    delete global.newest;\n    const subject = support.subject;\n    delete subject.support;\n}\nfunction updateOneContext(values, index, context, support) {\n    const hasValue = values.length > index;\n    if (!hasValue) {\n        return;\n    }\n    const value = values[index];\n    // is something already there?\n    const exists = context.length > index;\n    if (exists) {\n        if (support.subject.global.deleted) {\n            const valueSupport = (value && value.support);\n            if (valueSupport) {\n                valueSupport.destroy();\n                return context; // item was deleted, no need to emit\n            }\n        }\n        return updateContextItem(context, index, value);\n    }\n    // 🆕 First time values below\n    context[index] = processNewValue(value, support);\n}\nfunction attachClonesToSupport(htmlDomMeta, clones) {\n    htmlDomMeta.forEach(meta => {\n        if (meta.domElement) {\n            clones.push(meta.domElement);\n        }\n        clones.push(meta.marker);\n        if ('children' in meta) {\n            const children = meta.children;\n            attachClonesToSupport(children, clones);\n        }\n    });\n}\n","import { isSubjectInstance } from '../../isInstance.js';\nexport function updateContextItem(context, index, value) {\n    const subject = context[index];\n    const isSub = isSubjectInstance(value);\n    if (isSub) {\n        return; // emits on its own\n    }\n    // listeners will evaluate updated values to possibly update display(s)\n    subject.next(value);\n    return;\n}\n","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    if (!onDestroyDoubleWrap) {\n        return;\n    }\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    if (!onDestroy) {\n        return;\n    }\n    const event = { target: nextSibling, stagger };\n    return onDestroy(event);\n}\n","import { resetSupport } from '../Support.class.js';\nimport { getChildTagsToDestroy } from '../destroy.support.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport, options = { byParent: false, stagger: 0 }) {\n    const global = lastSupport.subject.global;\n    global.deleted = true;\n    // global.context = {}\n    global.context = [];\n    const childTags = getChildTagsToDestroy(global.childTags);\n    lastSupport.destroySubscriptions();\n    childTags.forEach(child => {\n        const subGlobal = child.subject.global;\n        delete subGlobal.newest;\n        subGlobal.deleted = true;\n    });\n    lastSupport.smartRemoveKids();\n    lastSupport.subject.global.clones.length = 0; // tag maybe used for something else\n    lastSupport.subject.global.childTags.length = 0; // tag maybe used for something else\n    resetSupport(lastSupport);\n    childTags.forEach(child => softDestroySupport(child, { byParent: true, stagger: 0 }));\n}\n","import { isLikeTags } from '../isLikeTags.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { destroyUnlikeTags } from './destroyUnlikeTags.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { deepEqual } from '../../deepFunctions.js';\nexport function renderWithSupport(newSupport, lastSupport, // previous\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        destroyUnlikeTags(lastSupport, reSupport, subject);\n    }\n    else if (lastSupport) {\n        const tag = reSupport.templater.tag;\n        if (tag) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return reSupport;\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (!deepEqual(lastDom, newDom)) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        if (lastTag.tagJsType === ValueTypes.dom) {\n            throw new Error('check here');\n        }\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { softDestroySupport } from './softDestroySupport.function.js';\nimport { moveProviders } from '../update/updateExistingTagComponent.function.js';\nexport function destroyUnlikeTags(lastSupport, // old\nreSupport, // new\nsubject) {\n    // when a tag is destroyed, disconnect the globals\n    const global = reSupport.subject.global; // = {...oldGlobal} // break memory references\n    moveProviders(lastSupport, reSupport);\n    softDestroySupport(lastSupport);\n    delete global.deleted;\n    global.oldest = reSupport;\n    global.newest = reSupport;\n    subject.support = reSupport;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { renderSupport } from '../tag/render/renderSupport.function.js';\nexport function handleProviderChanges(appSupport, provider) {\n    let hadChanged = false;\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    for (let index = tagsWithProvider.length - 1; index >= 0; --index) {\n        const { support, renderCount, provider } = tagsWithProvider[index];\n        if (support.subject.global.deleted) {\n            continue; // i was deleted after another tag processed\n        }\n        const notRendered = renderCount === support.subject.global.renderCount;\n        if (notRendered) {\n            hadChanged = true;\n            provider.clone = deepClone(provider.instance);\n            renderSupport(support.subject.global.newest, // support, // support.subject.global.newest as Support,\n            false);\n            continue;\n        }\n    }\n    return hadChanged;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    memory.push({\n        support,\n        renderCount: support.subject.global.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        memory.push({\n            support: childTags[index],\n            renderCount: childTags[index].subject.global.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { isLikeTags } from '../isLikeTags.function.js';\nimport { renderWithSupport } from './renderWithSupport.function.js';\nimport { providersChangeCheck } from '../../state/providersChangeCheck.function.js';\n/** Returns true when rendering owner is not needed. Returns false when rendering owner should occur */\nexport function renderExistingTag(oldestSupport, // oldest with elements on html\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const lastSupport = subject.support; // todo maybe not needed?\n    const global = subject.global;\n    // share point between renders\n    newSupport.subject.global = global;\n    const preRenderCount = global.renderCount;\n    providersChangeCheck(oldestSupport);\n    // When the providers were checked, a render to myself occurred and I do not need to re-render again\n    const prevSupport = global.newest;\n    const justUpdate = preRenderCount !== global.renderCount;\n    if (justUpdate) {\n        oldestSupport.subject.global.oldest.updateBy(prevSupport);\n        return prevSupport; // already rendered during triggered events\n    }\n    const toRedrawTag = prevSupport || lastSupport || global.oldest;\n    const reSupport = renderWithSupport(newSupport, toRedrawTag, subject, ownerSupport);\n    const oldest = global.oldest || oldestSupport;\n    const isLikeTag = isLikeTags(prevSupport, reSupport);\n    if (isLikeTag) {\n        subject.support = reSupport;\n        oldest.updateBy(reSupport);\n    }\n    // ??? new - added but then removed\n    // global.newest = reSupport\n    return reSupport;\n}\n","import { deepClone, deepEqual } from '../deepFunctions.js';\nimport { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providersWithChanges = global.providers.filter(provider => !deepEqual(provider.instance, provider.clone));\n    let hadChanged = false;\n    // reset clones\n    for (let index = providersWithChanges.length - 1; index >= 0; --index) {\n        const provider = providersWithChanges[index];\n        const owner = provider.owner;\n        if (handleProviderChanges(owner, provider)) {\n            hadChanged = true;\n        }\n        provider.clone = deepClone(provider.instance);\n    }\n    return hadChanged;\n}\n","import { deepEqual } from '../../deepFunctions.js';\nimport { renderExistingTag } from './renderExistingTag.function.js';\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support, // must be latest/newest state render\nrenderUp) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    // is it just a vanilla tag, not component?\n    if (!templater.wrapper) { // || isTagTemplater(templater) \n        const ownerTag = support.ownerSupport;\n        ++global.renderCount;\n        if (ownerTag.subject.global.deleted) {\n            return support;\n        }\n        return renderSupport(ownerTag.subject.global.newest, true);\n    }\n    if (support.subject.global.locked) {\n        support.subject.global.blocked.push(support);\n        return support;\n    }\n    const subject = support.subject;\n    const oldest = support.subject.global.oldest;\n    let ownerSupport;\n    let selfPropChange = false;\n    const shouldRenderUp = renderUp && support;\n    if (shouldRenderUp) {\n        ownerSupport = support.ownerSupport;\n        if (ownerSupport) {\n            const nowProps = templater.props;\n            const latestProps = support.propsConfig.latestCloned;\n            selfPropChange = !deepEqual(nowProps, latestProps);\n        }\n    }\n    const tag = renderExistingTag(oldest, support, ownerSupport, // useSupport,\n    subject);\n    if (ownerSupport && selfPropChange) {\n        const myOwnerSupport = ownerSupport.subject.global.newest;\n        renderSupport(myOwnerSupport, true);\n        return tag;\n    }\n    return tag;\n}\n","import { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { syncStates } from './syncStates.function.js';\nexport default function callbackStateUpdate(support, callback, oldState, ...args) {\n    const state = support.state;\n    // ensure that the oldest has the latest values first\n    syncStates(state, oldState);\n    // run the callback\n    const maybePromise = callback(...args);\n    // send the oldest state changes into the newest\n    syncStates(oldState, state);\n    renderSupport(support, // support.global.newest as Support,\n    false);\n    if (maybePromise instanceof Promise) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            syncStates(oldState, state);\n            renderSupport(support, // support.global.newest as Support,\n            false);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { setUse } from './setUse.function.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport callbackStateUpdate from './callbackStateUpdate.function.js';\nlet innerCallback = (callback) => (a, b, c, d, e, f) => {\n    throw new SyncCallbackError('Callback function was called immediately in sync and must instead be call async');\n};\nexport const callbackMaker = () => innerCallback;\nconst originalGetter = innerCallback; // callbackMaker\nsetUse({\n    beforeRender: support => initMemory(support),\n    beforeRedraw: support => initMemory(support),\n    afterRender: support => {\n        support.subject.global.callbackMaker = true;\n        innerCallback = originalGetter; // prevent crossing callbacks with another tag\n    },\n});\nconst syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUse.memory.stateConfig.array;\n    const trigger = (...args) => {\n        const callbackMaker = support.subject.global.callbackMaker;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, callback, oldState, ...args);\n        }\n        return callback(...args);\n    };\n    return trigger;\n}\nfunction initMemory(support) {\n    const oldState = setUse.memory.stateConfig.array;\n    innerCallback = (callback) => {\n        const trigger = (...args) => {\n            const callbackMaker = support.subject.global.callbackMaker;\n            if (callbackMaker) {\n                return callbackStateUpdate(support, callback, oldState, ...args);\n            }\n            return callback(...args);\n        };\n        return trigger;\n    };\n}\n","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(() => {\n        const support = getSupportInCycle();\n        support?.subject.global.destroy$.toCallback(callback);\n    });\n}\n","import { setUse } from './setUse.function.js';\nfunction setCurrentSupport(support) {\n    setUse.memory.childrenCurrentSupport = support;\n}\nexport function children() {\n    const support = setUse.memory.childrenCurrentSupport;\n    const children = support.templater.children;\n    return children;\n}\nsetUse({\n    beforeRender: support => setCurrentSupport(support),\n    beforeRedraw: support => setCurrentSupport(support),\n});\n","export const tags = [];\n","import { Tag, Dom } from './Tag.class.js';\nexport function html(strings, ...values) {\n    return new Tag(strings, values);\n}\nhtml.dom = function (dom, ...values) {\n    return new Dom(dom, values);\n};\n","import { runTagCallback } from '../interpolations/bindSubjectCallback.function.js';\nimport { Support } from './Support.class.js';\nimport { castProps } from '../alterProp.function.js';\nimport { setUse } from '../state/setUse.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { html } from './html.js';\nimport { syncFunctionProps } from './update/updateExistingTagComponent.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    const stateArray = setUse.memory.stateConfig.array;\n    // this function gets called by taggedjs\n    const wrapper = (newSupport, subject, lastSupport) => executeWrap(stateArray, templater, result, newSupport, subject, lastSupport);\n    return wrapper;\n}\nfunction executeWrap(stateArray, templater, result, newSupport, subject, lastSupport) {\n    const global = newSupport.subject.global;\n    ++global.renderCount;\n    const childSubject = templater.children;\n    const lastArray = global.oldest?.templater.children.lastArray;\n    if (lastArray) {\n        childSubject.lastArray = lastArray;\n    }\n    // result.original\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    let props = templater.props;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = newSupport.propsConfig.castProps;\n    const lastCastProps = lastSupport?.propsConfig.castProps;\n    if (lastCastProps) {\n        newSupport.propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, stateArray, 0);\n    // CALL ORIGINAL COMPONENT FUNCTION\n    let tag = originalFunction(...castedProps);\n    if (tag instanceof Function) {\n        tag = tag();\n    }\n    const unknown = !tag || (tag.tagJsType && ![ValueTypes.tag, ValueTypes.dom].includes(tag.tagJsType));\n    if (unknown) {\n        tag = html `${tag}`; // component returned a non-component value\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    tag.arrayValue = templater.arrayValue; // tag component could have been used in array.map\n    const support = new Support(templater, newSupport.ownerSupport, subject, castedProps, global.renderCount);\n    support.subject.global = global;\n    // ??? this should be set by outside?\n    global.oldest = global.oldest || support;\n    // ??? new - removed\n    // global.newest = support\n    const nowState = setUse.memory.stateConfig.array;\n    support.state.push(...nowState);\n    if (templater.madeChildIntoSubject) {\n        const value = childSubject.value;\n        for (let index = value.length - 1; index >= 0; --index) {\n            const kid = value[index];\n            const values = kid.values;\n            for (let index = values.length - 1; index >= 0; --index) {\n                const value = values[index];\n                if (!(value instanceof Function)) {\n                    continue;\n                }\n                const valuesValue = kid.values[index];\n                if (valuesValue.isChildOverride) {\n                    continue; // already overwritten\n                }\n                // all functions need to report to me\n                kid.values[index] = function (...args) {\n                    return runTagCallback(value, // callback\n                    support.ownerSupport, this, // bindTo\n                    args, support.state);\n                };\n                valuesValue.isChildOverride = true;\n            }\n        }\n    }\n    return support;\n}\n","// taggedjs-no-compile\nimport { setUse } from '../state/index.js';\nimport { TemplaterResult } from './TemplaterResult.class.js';\nimport { tags } from './tag.utils.js';\nimport { getTagWrap } from './getTagWrap.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nlet tagCount = 0;\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent) {\n    /** function developer triggers */\n    const parentWrap = (function tagWrapper(...props) {\n        const templater = new TemplaterResult(props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        if (!innerTagWrap.parentWrap) {\n            innerTagWrap.parentWrap = parentWrap;\n        }\n        templater.tagged = true;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }) // we override the function provided and pretend original is what's returned\n    ;\n    parentWrap.original = tagComponent;\n    parentWrap.compareTo = tagComponent.toString();\n    const tag = tagComponent;\n    parentWrap.isTag = true;\n    parentWrap.original = tag;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUse;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Used to create a tag component that renders once and has no addition rendering cycles */\ntag.oneRender = (...props) => {\n    throw new Error('Do not call function tag.oneRender but instead set it as: `(props) => tag.oneRender = (state) => html`` `');\n};\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.route = (routeProps) => {\n    throw new Error('Do not call function tag.route but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.app = (routeTag) => {\n    throw new Error('Do not call function tag.route but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\nObject.defineProperty(tag, 'oneRender', {\n    set(oneRenderFunction) {\n        oneRenderFunction.oneRender = true;\n    },\n});\n","import { BaseSupport } from './Support.class.js';\nimport { runAfterRender, runBeforeRender } from './tagRunner.js';\nimport { TagJsSubject } from './update/TagJsSubject.class.js';\nimport { afterChildrenBuilt } from './update/processTag.function.js';\nimport { textNode } from './textNode.js';\nconst appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, // (...args: unknown[]) => TemplaterResult,\nelement, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        appElements[appElmIndex].support.destroy();\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    const wrapper = app(props);\n    // const fragment = document.createDocumentFragment()\n    const template = document.createElement('template');\n    const placeholder = textNode.cloneNode(false);\n    const support = runWrapper(wrapper, template, placeholder);\n    const global = support.subject.global;\n    support.appElement = element;\n    support.isApp = true;\n    global.isApp = true;\n    element.destroy = () => {\n        support.destroy(); // never return anything here\n    };\n    global.insertBefore = placeholder // template\n    ;\n    global.placeholder = placeholder;\n    const newFragment = support.buildBeforeElement(undefined);\n    const children = [...newFragment.children];\n    support.subject.global.oldest = support;\n    support.subject.global.newest = support;\n    element.setUse = app.original.setUse;\n    appElements.push({ element, support });\n    element.appendChild(newFragment);\n    afterChildrenBuilt(children, support.subject, support);\n    return {\n        support,\n        tags: app.original.tags,\n    };\n}\nexport function runWrapper(templater, insertBefore, placeholder) {\n    let newSupport = {};\n    // TODO: A fake subject may become a problem\n    const subject = new TagJsSubject(newSupport);\n    newSupport = new BaseSupport(templater, subject);\n    subject.global.insertBefore = insertBefore;\n    subject.global.placeholder = placeholder;\n    subject.global.oldest = subject.global.oldest || newSupport;\n    subject.next(templater);\n    subject.support = newSupport;\n    runBeforeRender(newSupport, undefined);\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const support = wrapper(newSupport, subject);\n    runAfterRender(newSupport, support);\n    return support;\n}\n","export * from './tag/index.js';\nexport * from './errors.js';\nexport * from './subject.types.js';\nexport * from './isInstance.js';\nexport * from './state/index.js';\nexport * from './subject/index.js';\nexport * from './tag/Support.class.js';\nexport * from './interpolations/ElementTargetEvent.interface.js';\nexport * from './interpolations/InsertBefore.type.js';\nexport { tagElement } from './tag/tagElement.js';\nexport { Tag, variablePrefix } from './tag/Tag.class.js';\nexport { runBeforeRender } from './tag/tagRunner.js';\nexport { renderSupport } from './tag/render/renderSupport.function.js';\nexport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nexport { isLikeValueSets } from './tag/isLikeTags.function.js';\nimport { renderTagOnly } from './tag/render/renderTagOnly.function.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","RouteQuery","name","empty","ValueTypes","variablePrefix","variableSuffix","escapeVariable","escapeSearch","RegExp","BaseTag","values","tagJsType","arrayValue","templater","constructor","this","Tag","strings","tag","children","super","html","Dom","dom","replacePlaceholders","elements","i","length","element","attributes","processAttributes","examineChild","child","index","nodeName","textChild","textContent","placeholderRegex","match","exec","wIndex","parseInt","isNaN","varContent","before","slice","after","value","Array","map","x","domClone","splice","lastIndex","startsWith","replace","safeVar","safeReplacer","traverseAndRestore","attr","fragReplacer","regexAttr","regexTagOrg","htmlInterpolationToDomMeta","fragmentsWithPlaceholders","results","fragment","diff","push","balanceArrayByArrays","addPlaceholders","parsedElements","stack","currentElement","valueIndex","position","regexTag","tagMatch","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","trim","textNode","pop","attrMatch","_","attrName","attrValueQuoted","attrValueUnquoted","attrValue","undefined","toLowerCase","parseHTML","join","exchangeParsedForValues","forEach","lastRuns","getDomMeta","stringId","array","Number","getStringsId","lastRun","matches","every","string","isLastRunMatched","domMeta","template","interpolation","isStaticTag","includes","isTagTemplater","isTagComponent","tagComponent","isTagClass","isSubjectInstance","subject","isSubject","subscribe","isTagArray","combineLatest","subjects","output","Subject","subscribeWith","callback","valuesSeen","setValue","subscription","clones","shift","subscriptions","getSubscription","subscribers","countSubject","globalSubCount$","next","_value","unsubscribe","findIndex","sub","removeSubFromArray","add","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","handler","methodResponse","setHandler","onSubscription","defineValueOn","orgCallback","lastValue","emit","set","subs","toPromise","Promise","res","toCallback","_subscription","pipe","operations","setMethods","all","args","arg","static","ValueSubject","willCallback","utils","willPromise","then","willSubscribe","getSupportInCycle","setUse","memory","stateConfig","support","use","useMe","beforeRender","beforeRedraw","afterRender","beforeDestroy","tagUse","TagError","Error","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","badLetState","state","config","rearray","stateLength","getStateValue","initState","defaultValue","checkValue","oldState","StateEchoBack","getCallbackValue","toString","JSON","stringify","console","error","wrapper","oldStates","newStates","tagFunction","parentWrap","original","warn","item","syncStates","stateFrom","stateTo","fromValue","getSetMethod","restate","oldValue","initValue","Function","newState","global","newest","result","watch","currentValues","setupWatch","defaultFinally","init","final","previous","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","method","nowSupport","setTo","oldestState","letState","makeStateResult","y","letProp","getSetProp","myProp","deepClone","makeDeepClone","depth","object","Date","clone","isArray","create","getPrototypeOf","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","getTime","isArrayDeepEqual","keys1","keys","keys2","isObjectDeepEqual","newWatch","providers","constructMethod","stateDiffMemory","stateDiff","provider","oldStateCount","instance","owner","cm","compareTo","inject","ownerSupport","find","msg","isLikeTags","support0","support1","templater0","templater1","tag0","tag1","dom0","dom1","values0","values1","isLikeValueSets","isLikeDomTags","strings0","strings1","isLikeStringTags","runBeforeRender","runAfterRender","tagClosed$","runBeforeDestroy","deleted","hasLiveElements","childTags","filter","oldest","renderTagOnly","newSupport","prevSupport","oldRenderCount","renderCount","parentSupport","lastOwnerSupport","runtimeOwnerSupport","lastState","runBeforeRedraw","beforeWithRender","reSupport","destroyTagMemory","oldSupport","destroy","context","isSimpleType","number","boolean","destroyArrayTag","counts","stagger","removed","getValueType","type","function","date","tagArray","unknown","cloneValueArray","cloneTagJsValue","props","getChildTagsToDestroy","allTags","cTag","kidsToTagArraySubject","templaterResult","madeChildIntoSubject","kid","TemplaterResult","tagged","bind","childSubject","TagJsSubject","tagJsSubject","getNewGlobal","destroy$","blocked","processNewTag","Support","document","getTestTextNode","cloneNode","_children","createTextNode","style","classS","specialAttribute","names","split","classList","remove","howToSetInputValue","setAttribute","hasPropChanges","pastCloneProps","castedProps","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onDelete","compareOriginal","processTagResult","subjectTag","lastSupport","updateBy","processTagResultUpdate","newFragment","buildBeforeElement","placeholder","parentNode","insertBefore","afterElmBuild","elm","options","getAttribute","added","nextSibling","onInitDoubleWrap","oninit","onInitWrap","onInit","target","elementInitCheck","focus","hasAttribute","select","processTag","newSupportByTemplater","afterChildrenBuilt","tagFakeTemplater","getFakeTemplater","fake","isTag","setupNewSupport","processSubjectComponent","label","substring","ownGlobal","preClones","reGlobal","renderWithSupport","myClones","fClone","renderSubjectComponent","castProps","stateArray","checkProp","alterProp","newProp","toCall","wrap","callWith","supportInCycle","noCycle","locked","callbackResult","lastResult","runBlocked","renderSupport","run","allMatched","callbackPropOwner","mem","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","getset","getOwnPropertyDescriptor","originalValue","updateExistingTagComponent","renderUp","oldWrapper","newWrapper","isSameTag","hasChanged","newTemplater","propsChanged","propsConfig","latestCloned","propsChanged2","kidsChanged","oldCloneKidValues","lastClonedKidValues","newClonedKidValues","hasKidsChanged","hasSupportChanged","syncFunctionProps","isLikeTag","oldestTag","softDestroySupport","buildNewTag","afterTagRender","newPropsArray","priorPropsArray","newArray","syncPriorPropFunction","priorProp","oldOwnerState","hasSetter","useLocks","noData","promiseNoData","runTagCallback","bindTo","findTagToCallback","checkAfterCallbackPromise","last","renderCallbackSupport","afterTagCallback","block","INPUT","valueS","ondoubleclick","attrs","scope","howToSet","removeAttribute","processNameValueAttr","processNameOnlyAttr","isSpecialAttr","isSpecial","newAttrValue","oneRender","isChildOverride","subjectFunction","bindSubjectCallback","processAttributeSubjectValue","callbackFun","fun","search","processTagArray","lastArray","removeChild","setPlaceholderElm","runtimeInsertBefore","destroyArrayItem","subTag","tagClass","prevArrayValue","destroyItem","valueA","valueB","areLikeValues","previousSupport","itemSubject","setupNewTemplater","prevSubject","processAddTagArrayItem","updateBeforeTemplate","lastFirstChild","parent","castTextValue","processRegularValue","castedValue","oldClone","oneRenderToSupport","processFirstSubjectValue","v","processFirstRegularValue","swapInsertBefore","updateExistingValue","valueType","displaySubject","hasLastValue","newType","destroySimpleValue","arraySubject","wasArray","isValueTag","checkDestroyPrevious","subjectSup","newestState","prepareUpdateToComponent","isClass","valueSupport","handleStillTag","subscribeToTemplate","called","syncRun","onValue","attachDomElement","nodes","node","marker","appendChild","text","DOMParser","parseFromString","newString","documentElement","domElement","createElement","BaseSupport","isApp","appElement","clonePropsBy","kidValue","latest","getHtmlDomMeta","thisTag","update","orgDomMeta","createDocumentFragment","attachClonesToSupport","tempTag","updateConfig","updateValues","updateContext","repeat","_string","hasValue","exists","updateContextItem","processNewValue","updateOneContext","byParent","destroySubscriptions","subGlobal","resetSupport","promises","smartRemoveKids","startStagger","childTag","cloneOne","newPromises","promise","count","destroyClones","unshift","checkCloneRemoval","customElm","ondestroy","onDestroyDoubleWrap","onDestroyWrap","onDestroy","elementDestroyCheck","indexOf","version","getAppSupport","htmlDomMeta","meta","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","moveProviders","destroyUnlikeTags","handleProviderChanges","appSupport","hadChanged","tagsWithProvider","getTagsWithProvider","renderExistingTag","oldestSupport","preRenderCount","providersWithChanges","providersChangeCheck","ownerTag","selfPropChange","callbackStateUpdate","maybePromise","finally","innerCallback","a","b","c","d","e","f","callbackMaker","originalGetter","initMemory","syncError","setCurrentSupport","childrenCurrentSupport","tags","getTagWrap","originalFunction","preCastedProps","lastCastProps","nowState","valuesValue","executeWrap","tagCount","innerTagWrap","tagIndex","route","routeProps","app","routeTag","oneRenderFunction","appElements","tagElement","appElmIndex","appElm","runWrapper","hmr"],"sourceRoot":""}