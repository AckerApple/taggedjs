{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContext.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/checkSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribe.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/render/afterRender.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/update/deleteSubContext.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/processOuterDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/render/registerNewTagElement.function.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/tagJsVars/pipe.function.ts","webpack://taggedjs/./ts/tagJsVars/host.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribeWith.function.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(contextItem) {\n    ;\n    contextItem.renderCount = contextItem.renderCount || 0;\n    return contextItem.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n    }\n    return false;\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push([howToSetFirstInputValue, [element, name, value]]);\n}\nexport function howToSetStandAloneAttr(element, name, _value) {\n    element.setAttribute(name, '');\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintContent } from \"../../render/paint.function.js\";\n/** handles autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'autofocus':\n            paintContent.push([autofocus, [element]]);\n            return;\n        case 'autoselect':\n            paintContent.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value;\n    element.style.setProperty(smallName, value);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.context.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    return setUseMemory.stateConfig.support = support;\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.context.global.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function initState(support) {\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    setSupportInCycle(support);\n}\nexport function reState(newSupport, prevSupport, prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","export function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    const counts = { added: 0, removed: 0 };\n    while (index < len) {\n        processUpdateOneContext(values, index, contexts, support, counts);\n        ++index;\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport, counts) {\n    const contextItem = context[index];\n    // some values, like style, get rearranged and there value appearance may not match context appearance\n    const valueIndex = contextItem.valueIndex;\n    const newValue = values[valueIndex];\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate(newValue, ownerSupport, contextItem, counts, values);\n    contextItem.value = newValue;\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.context.global;\n    const context = global.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    // const global = context.global || getNewGlobal(context)\n    const global = context.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    // global.oldest = global.oldest || baseSupport as AnySupport\n    // global.oldest = baseSupport as AnySupport\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport, counts) {\n    const isComp = isTagComponent(newValue);\n    contextItem.tagJsVar = newValue;\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport, counts);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, counts, undefined, // appendTo,\n    contextItem.placeholder);\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport, counts) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, counts, undefined, // appendTo,\n        contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = global.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    if (!global || !global.newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    const newest = global.newest;\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const global = oldSupport.context.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n    contextItem.placeholder);\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = oldSupport.context;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\nownerSupport, contextItem, counts) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport, counts);\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContext(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContext(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.delete(child, ownerSupport);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.contexts;\n        // recurse\n        destroyContext(subTags, support);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContextItem(subject);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArrayContextItem(subject) {\n    const lastArray = subject.lastArray;\n    destroyArray(subject, lastArray);\n}\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { addPaintRemover } from '../render/paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.contexts;\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.locked) {\n            continue;\n        }\n        if (subject.withinOwnerElement) {\n            const tagJsVar = subject.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = subject.supportOwner;\n                tagJsVar.delete(subject, newest);\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            addPaintRemover(elm);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker);\n    }\n    const dom = clone.domElement;\n    if (!dom) {\n        return;\n    }\n    addPaintRemover(dom);\n}\n","import { destroyContext } from '../tag/destroyContext.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.context;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.contexts;\n    destroyContext(context, support);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nimport { destroySupport } from '../../render/destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    const element = item.simpleValueElm;\n    delete item.simpleValueElm;\n    addPaintRemover(element);\n}\n","export function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    // const tagJsVar = valueToTagJsVar(value)\n    // contextItem.tagJsVar = tagJsVar\n    const tagJsVar = contextItem.tagJsVar;\n    return tagJsVar.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nexport function domProcessContextItem(value, support, contextItem, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    // contextItem.handler = tagValueUpdateHandler\n    const subject = support.context;\n    subject.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    delete subject.locked;\n    contextItem.value = value;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { tagValueUpdateHandler } from \"../tag/update/tagValueUpdateHandler.function.js\";\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInit: processSimpleValueInit,\n        delete: deleteSimpleValue,\n        // TODO: get down to only one\n        checkValueChange: checkSimpleValueChange,\n        processUpdate: tagValueUpdateHandler,\n    };\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo, insertBefore) {\n    // value = value.value\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(contextItem) {\n    const elm = contextItem.simpleValueElm;\n    delete contextItem.simpleValueElm;\n    addPaintRemover(elm);\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || !(typeof (newValue) === BasicTypes.object);\n    if (isRegularUpdate) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return -1; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\n","import { checkArrayValueChange, destroyArrayContextItem } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInit: processArrayInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkArrayValueChange,\n        delete: destroyArrayContextItem,\n    };\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, counts, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, contexts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = {\n        value,\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement: false,\n        placeholder: element,\n        valueIndex: contexts.length,\n        valueIndexSetBy: 'createAndProcessContextItem',\n    };\n    if (!appendTo) {\n        paintCommands.push([paintBefore, [insertBefore, element]]);\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            // 👁️ COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, ownerSupport, itemSubject, counts);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, lastArray, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    contextItem.tagJsVar = valueToTagJsVar(newValue);\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, counts);\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport, counts) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.checkValueChange(newValue, contextItem, counts, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nexport function checkSubContext(newValue, ownerSupport, contextItem, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const subscription = contextItem.subContext;\n    if (!subscription || !subscription.hasEmitted) {\n        return -1;\n    }\n    subscription.callback = newValue.callback;\n    subscription.valuesHandler(subscription.lastValues);\n    return -1;\n}\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem, counts) {\n    if (!newValue || !newValue.tagJsType || newValue.tagJsType !== originalType) {\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.delete(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, ownerSupport, 99, counts);\n        return 99;\n    }\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, counts, [], insertBefore);\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { deleteSubContext } from './deleteSubContext.function.js';\nimport { checkSubContext } from './checkSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nexport function setupSubscribe(observables, contextItem, ownerSupport, counts, callback, appendTo, insertBeforeOriginal) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, counts, insertBefore, callback);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    // contextItem.handler = checkSubContext\n    contextItem.tagJsVar.processUpdate = checkSubContext;\n    return subContext;\n}\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore, callback) {\n    const component = getSupportWithState(ownerSupport);\n    let onOutput = function onSubValue(value) {\n        onFirstSubContext(value, subContext, ownerSupport, counts, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = function subscriptionUpdate(updateValue) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport, { added: 0, removed: 0 });\n            checkToPaint(syncRun);\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    function valueHandler(value, index) {\n        subContext.lastValues[index] = value;\n        valuesHandler(subContext.lastValues);\n    }\n    function valuesHandler(values) {\n        const newComponent = component.context.global.newest;\n        syncSupports(newComponent, component);\n        if (subContext.callback) {\n            const responseValue = subContext.callback(...values);\n            onOutput(responseValue);\n            return;\n        }\n        onOutput(values[0]);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        valueHandler,\n        valuesHandler,\n        callback,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => valueHandler(value, index)));\n        syncRun = false;\n    });\n    return subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.subscriptions.forEach(sub => sub.unsubscribe());\n    return deleteSubContext(contextItem, ownerSupport);\n}\nfunction checkToPaint(syncRun) {\n    if (!syncRun && !setUseMemory.stateConfig.support) {\n        paint();\n    }\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    return setupSubscribe(value.Observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSubscribeWith(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    const observables = value.Observables;\n    const subscription = setupSubscribe(observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n    if (!subscription.hasEmitted) {\n        const obValue = observables[0]?.value;\n        subscription.valueHandler((obValue || value.withDefault), 0);\n    }\n    return subscription;\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, appendTo) {\n    setupSubscribe([value], contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { handleTagTypeChangeFrom } from '../tag/update/checkSubContext.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        processUpdate: (newValue, ownerSupport, contextItem, counts) => handleTagTypeChangeFrom(ValueTypes.signal, newValue, ownerSupport, contextItem, counts),\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        delete: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.context.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.context.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const ownGlobal = owner.ownerSupport.context.global;\n            const ownerProviders = ownGlobal.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const global = support.context.global;\n                const providers = global.providers = global.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.context.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.context.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.context.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, global, mode, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        subject.locked = true;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const global = last.context.global;\n        //clearTimeout(timeout)\n        if (global.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        const subject = last.context;\n        const global1 = last.context.global;\n        delete subject.locked;\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, global1.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","import { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const nowSupport = getSupportInCycle();\n        return checkToResolvePromise(result, nowSupport, nowSupport.context.global, 'onInit', { resolvePromise, resolveValue });\n    });\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.context.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nexport function checkTagValueChange(newValue, contextItem, counts) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport, counts);\n        return -1;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return -1;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destroySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.context;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const global = support.context.global;\n    global.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, counts, contexts, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        valueIndex: context.length,\n        valueIndexSetBy: 'addOneContext',\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem, // could be tag via result.tag\ncounts) {\n    const global = contextItem.global;\n    const support = global.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.contexts = [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker]]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement]]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem, counts);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(function eachCastProp(prop) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, depth);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.context.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const global = ownerSupport.context.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const subject = newest.context;\n        const global = subject.global;\n        if (!global || subject.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from '../tag/checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n","import { executeWrap } from './executeWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    runBeforeRender(newSupport, prevSupport);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\nfunction runBeforeRender(newSupport, prevSupport) {\n    const prevState = prevSupport?.state;\n    if (prevState) {\n        reState(newSupport, prevSupport, prevState);\n        return;\n    }\n    initState(newSupport);\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { renderTagOnly } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    buildBeforeElement(support, counts, undefined, // element for append child\n    subject.placeholder);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    return processFirstTagResult(support, counts, appendTo);\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, counts, appendTo) {\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../tag/checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.delete = destroySupportByContextItem;\n        oneRenderFunction.checkValueChange = function renderOnceNeverChanges() {\n            return -1;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.checkValueChange = checkTagValueChange;\n        renderFunction.delete = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from '../render/renderSupport.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContext.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.context;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.contexts);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject) {\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.context.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return {\n        support: reSupport,\n        wasLikeTags: isLikeTag\n    };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    const global = subject.global;\n    // lastSupport !== newSupport && \n    if (result.wasLikeTags) {\n        updateSupportBy(global.oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject, { added: 0, removed: 0 });\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../tag/hasSupportChanged.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = true;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(global.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownGlobal = ownerSupport.context.global;\n    const newest = ownGlobal.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.context.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, global, 'bind', { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from '../../render/attributes/processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.context.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processNameOnlyAttrValue } from '../../render/attributes/processAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateAttribute.function.js';\nexport function processUpdateAttrContext(value, ownerSupport, contextItem, _counts, values) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        { added: 0, removed: 0 });\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, { added: 0, removed: 0 });\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { addOneContext } from '../index.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, // all the variables inside html``\nattrName, element, support, howToSet, //  = howToSetInputValue\ncontexts, isSpecial, counts, value) {\n    const varIndex = getTagJsVar(attrName);\n    const isNameVar = varIndex >= 0;\n    if (isNameVar) {\n        const value = values[varIndex];\n        const contextItem = addOneContext(value, contexts, true);\n        contextItem.valueIndex = varIndex;\n        contextItem.valueIndexSetBy = 'processAttribute';\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.isNameOnly = true;\n        if (value.tagJsType) {\n            contextItem.tagJsVar = value;\n            contextItem.stateOwner = getSupportWithState(support);\n            contextItem.supportOwner = support;\n            return processHost(element, value, contextItem);\n        }\n        contextItem.howToSet = howToSet;\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // single/stand alone attributes\n        processNameOnlyAttrValue(values, value, element, support, howToSet, contexts, counts);\n        return;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, contexts, howToSet, support, counts, values, varIndex);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, contexts, howToSet, support, counts, isSpecial, valueVar);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nfunction processHost(element, hostVar, contextItem) {\n    hostVar.processInit(element, hostVar, contextItem);\n    return;\n}\n// single/stand alone attributes\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, _counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    const tagJsVar = subject.tagJsVar; // = valueToTagJsVar(newAttrValue)\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, values, varNumber) {\n    const startIndex = context.length;\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = context.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n                valueIndex: context.length,\n                valueIndexSetBy: 'createDynamicArrayAttribute',\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHanlder(value, newSupport, contextItem, counts, newValues) {\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            context.push(contextItem);\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, isSpecial, varIndex) {\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        isAttr: true,\n        element,\n        attrName,\n        withinOwnerElement: true,\n        tagJsVar,\n        valueIndex: varIndex,\n        valueIndexSetBy: 'createDynamicAttribute',\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n    contextItem.value = value;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, marker]]);\n    }\n    domProcessContextItem(value, support, contextItem, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { howToSetFirstInputValue, howToSetStandAloneAttr } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { paintAppend, paintAppendElementString, paintAppends, paintBefore, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nexport const blankHandler = function blankHandler() {\n    return undefined;\n};\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontexts, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = contexts.length;\n            const value = values[index];\n            attachDynamicDom(value, contexts, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, contexts, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, contexts, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, contexts };\n}\nfunction attachDomElement(newNode, node, values, support, contexts, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        for (const attr of node.at) {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            const howToSet = attr.length > 1 ? howToSetFirstInputValue : howToSetStandAloneAttr;\n            processAttribute(values, name, domElement, support, howToSet, contexts, isSpecial, counts, value);\n        }\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement]]);\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { blankHandler } from \"./dom/attachDomElements.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(promise) {\n    if (paintRemoveAwaits.length) {\n        paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push(...paintRemoves);\n        paintRemoves = [];\n    }\n    paintRemoveAwaits.push({ promise, paintRemoves });\n    paintRemoves = [];\n}\nlet paintRemoveAwaits = [];\nexport let paintCommands = [];\nexport let paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    return runCycles();\n}\nfunction runCycles() {\n    runPaintCycles();\n    runAfterCycle();\n}\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    if (paintRemoveAwaits.length) {\n        const currentAwaits = paintRemoveAwaits.map(data => data.promise.then(() => {\n            const paintRemoves = data.paintRemoves;\n            for (const content of paintRemoves) {\n                // call paintRemover()\n                content[0](...content[1]);\n            }\n        }));\n        paintRemoveAwaits = [];\n        const outerPaintRemoves = paintRemoves;\n        return Promise.all(currentAwaits).then(() => {\n            for (const content of outerPaintRemoves) {\n                content[0](...content[1]);\n            }\n        });\n    }\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    runPaintRemoves();\n    paintRemoves = [];\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element) {\n    paintRemoves.push([paintRemover, [element]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element, _caller) {\n    const parentNode = element.parentNode;\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element) {\n    relative.parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteSubContext(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.deleted = true;\n    delete contextItem.subContext;\n    const appendMarker = subscription.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker);\n        delete subscription.appendMarker;\n    }\n    delete contextItem.delete;\n    // contextItem.handler = tagValueUpdateHandler\n    // const tagJsVar = contextItem.tagJsVar as TagJsVar\n    //tagJsVar.processUpdate = tagValueUpdateHandler\n    if (!subscription.hasEmitted) {\n        return;\n    }\n    const subContextItem = subscription.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.delete(subContextItem, ownerSupport);\n    return 76;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem, counts);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    counts, appendTo, insertBefore);\n    // contextItem.handler = function outDomTagHanlder(\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate = function outDomTagHanlder(value, newSupport, contextItem2, counts) {\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport, counts);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.checkValueChange = checkOuterTagValueChange;\n}\nfunction checkOuterTagValueChange(newValue, contextItem, counts) {\n    return checkTagValueChange(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem, // subContext.contextItem as any,\n    counts);\n}\n/** When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { getStringTag } from './processOuterDomTagInit.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nexport function registerTagElement(support, element, global, templater, app, placeholder) {\n    console.debug('🏷️ Building element into tag...', { element, app, support });\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    console.debug('🏷️ Element Tag DOM built ✅');\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterRender } from '../render/afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reState } from '../state/state.utils.js';\nexport function renderTagElement(app, global, templater, templater2, element, subject, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn('🏷️🏷️ Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    return renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const subject = {\n        value: templater,\n        valueIndex: 0,\n        valueIndexSetBy: 'getNewSubject',\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        tagJsVar,\n    };\n    const global = getNewGlobal(subject);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\n","import { paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport);\n    };\n}\nexport function syncWrapCallback(args, callback, ownerSupport) {\n    const global = ownerSupport.context.global;\n    const newestOwner = global.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newestOwner.states, ownerSupport.states);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(ownerSupport.states, newestOwner.states);\n    // now render the owner\n    paintAfters.push([() => {\n            const newGlobal = newestOwner.context.global;\n            if (!newGlobal) {\n                // paint()\n                return; // its not a tag anymore\n            }\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            // safeRenderSupport(global.newest)\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { checkSubContext, ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    const support = getSupportInCycle();\n    const states = support ? getSupportWithState(support).states : [];\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        processUpdate: checkSubContext,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states,\n        Observables: [Observable],\n    };\n}\n","import { deleteSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, newSupport, contextItem, counts) {\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport, counts);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, counts, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, counts, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, counts, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        delete: deleteSubContext,\n    };\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processPipe,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, counts, appendTo) {\n    return setupSubscribe(values, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/checkSubContext.function.js\";\n/** Use to gain access to element */\nexport function host(callback, options = {}) {\n    return {\n        tagJsType: ValueTypes.host,\n        processInit: processHost,\n        processUpdate: processHostUpdate,\n        delete: deleteHost,\n        options: { callback, ...options },\n    };\n}\n// Attach the functions to the host namespace\n;\nhost.onInit = (callback) => {\n    return host(() => { }, { onInit: callback });\n};\nhost.onDestroy = (callback) => {\n    return host(() => { }, { onDestroy: callback });\n};\nfunction processHostUpdate(newValue, ownerSupport, contextItem, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    const element = contextItem.element;\n    options.callback(element, newValue, contextItem);\n}\nfunction processHost(element, tagJsVar, contextItem) {\n    tagJsVar.options.callback(element, tagJsVar, contextItem);\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        const element = contextItem.element;\n        options.onInit(element, tagJsVar, contextItem);\n    }\n}\nfunction deleteHost(contextItem) {\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    if (options.onDestroy) {\n        const element = contextItem.element;\n        const hostDestroy = function processHostDestroy() {\n            return options.onDestroy(element, tagJsVar, contextItem);\n        };\n        const stateOwner = contextItem.stateOwner;\n        syncWrapCallback([], hostDestroy, stateOwner);\n    }\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribeWith,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables: [Observable],\n    };\n}\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { renderTagOnly } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","global","RouteQuery","_name","variablePrefix","variableSuffix","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","placeholderRegex","RegExp","getTagVarIndex","value","search","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","length","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","index","textContent","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","pop","attributes","attrMatch","parseAttrString","element","nn","at","ch","push","textNode","pushTo","tc","postProcessTagsInComments","inputString","split","filter","notEmptyStringMapper","part","attrValue","undefined","notEmpty","noValue","lowerName","toLowerCase","fixedName","eventName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","x","forEach","isSpecial","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","strings","values","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","join","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","replacePlaceholders","valueCount","currentTail","i","loopTail","attrs","processAttributes","children","innerLoopTail","examineChild","child","textChild","string","secondMatch","wIndex","parseInt","isNaN","varContent","after","splice","v","lastIndex","mapped","tagJsVar","lengthMapper","lastRuns","getDomMeta","stringId","array","map","Number","getStringsId","lastRun","matches","every","isLastRunMatched","domMetaMap","template","interpolation","howToSetInputValue","name","paintContent","howToSetFirstInputValue","howToSetStandAloneAttr","_value","setAttribute","removeAttribute","specialAttribute","specialName","autofocus","autoselect","names","paintStyle","shift","classListAdd","classListRemove","processSpecialClass","Error","smallName","style","setProperty","classList","add","remove","select","focus","isSimpleType","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","handleProviderChanges","appSupport","provider","tagsWithProvider","support","memory","context","childTags","cSubject","getTagsWithProvider","mapToSupport","deepClone","maxDepth","makeDeepClone","clone","create","getPrototypeOf","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","getSupportInCycle","setUseMemory","stateConfig","setSupportInCycle","getSupportWithState","component","ownerSupport","newest","returnArgs","args","firstStatesHandler","setter","config","states","statesIndex","reStatesHandler","oldStates","prevSupport","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","stateArray","reState","newSupport","prevState","runRestate","StateEchoBack","getStateValue","state","callback","defaultValue","checkValue","getCallbackValue","restate","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","setValue","item","subscription","clones","subscriptions","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","super","defineValueOn","tagClosed$","syncSupports","newestSupport","syncStatesArray","from","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","processUpdateOneContext","counts","processUpdate","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","painting","locks","len","added","removed","processUpdateContext","paint","cloneValueArray","cloneTagJsValue","shallowMapper","shallowCompareDepth","deepMapper","props","deepCompareDepth","getBaseSupport","castedProps","baseSupport","blocked","destroy$","upgradeBaseToSupport","propsConfig","castProps","propWatch","PropWatches","IMMUTABLE","latest","SHALLOW","clonePropsBy","createHtmlSupport","createSupport","tryUpdateToTag","isComp","processInit","placeholder","oldSupport","oldWrapper","wrapper","newWrapper","isSameTag","skipComparing","isLikeTags","innerHTML","_innerHTML","outerHTML","oldestSupport","oldest","destroySupport","swapTags","hasChanged","newTemplater","latestProps","pastCloneProps","propsChanged","hasPropChanges","hasSupportChanged","newProps","syncFunctionProps","lastPropsConfig","DEEP","locked","renderSupport","updateExistingTagComponent","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","tagValueUpdateHandler","forceUpdateExistingValue","runBeforeDestroy","providers","destroyContext","lastArray","childValue","delete","iSubs","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","checkArrayValueChange","destroyArrayContextItem","destroyArray","destroyArrayItem","smartRemoveKids","allPromises","withinOwnerElement","supportOwner","elm","simpleValueElm","addPaintRemover","subGlobal","deleted","smartRemoveByContext","htmlDomMeta","destroyClone","destroyClones","marker","domElement","promises","compareArrayItems","newLength","lessLength","prevContext","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","destroyArrayItemByGlobal","processFirstSubjectValue","appendTo","insertBefore","domProcessContextItem","castTextValue","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkValueChange","checkSimpleValueChange","castedValue","paintBeforeText","paintCommands","oldClone","setContent","processUpdateRegularValue","getArrayTagVar","processArrayInit","processTagArray","valueToTagJsVar","getBasicTagVar","createAndProcessContextItem","document","createTextNode","valueIndexSetBy","paintBefore","paintAppends","paintAppend","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","updateToDiffValue","ignoreOrDestroyed","before","processNowRegularValue","checkSubContext","handleTagTypeChangeFrom","subContext","hasEmitted","valuesHandler","originalType","onFirstSubContext","guaranteeInsertBefore","appendMarker","setupSubscribe","observables","insertBeforeOriginal","onOutput","checkToPaint","syncRun","updateValue","valueHandler","responseValue","observable","setupSubscribeCallbackProcessor","deleteAndUnsubscribe","deleteSubContext","processSubscribe","Observables","processSubscribeWith","obValue","withDefault","processSignal","initialValue","Signal","Set","unsub","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","defaultFinally","init","final","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","owner","cm","compareTo","inject","ownerProviders","find","msg","console","warn","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","syncError","createTrigger","maybePromise","finally","callbackStateUpdate","callbackMaker","renderTagUpdateArray","supports","mapTagUpdate","checkToResolvePromise","callbackResult","last","mode","resolvePromise","resolveValue","global1","getUpTags","thenResolveBy","onInit","onDestroy","firstSignal","sig","editors","readers","resignal","Proxy","target","action","isLike","isLikeBaseTags","templater0","templater1","newTag","oldTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings1","values0","values1","valuesLengthsMatch","allVarsMatch","isLikeValueSets","isLikeStringTags","checkTagValueChange","lastSupport","isTag","destroySupportByContextItem","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachDomElements","attachHtmlDomMeta","addOneContext","processTag","ph","tagFakeTemplater","processTagInit","newSupportByTemplater","processNewSubjectTag","getTemplaterResult","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","depth","checkProp","alterProp","already","mem","wrap","toCall","callWith","noCycle","apply","run","callbackPropOwner","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","executeWrap","useSupport","originalFunction","stateless","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","checkStateMismatch","tagFunction","newStates","error","hint","throwStateMismatch","runAfterRender","renderTagOnly","runBeforeRender","reSupport","processRenderOnceInit","processFirstSubjectComponent","newPropsConfig","processFirstTagResult","processTagComponentInit","processResult","processReplacementComponent","tagCount","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","pastProp","obEntries","subItem","objectItemMatches","use","deepPropWatch","route","_routeProps","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","pastValue","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","cGlobal","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","inlineHtml","checkRenderUp","selfPropChange","nowProps","hasPropsToOwnerChanged","isComponent","continueUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","bindSubjectCallback","subjectFunction","bindTo","eventHandlerSupport","renderCallbackSupport","afterTagCallback","runTagCallback","noData","promiseNoData","processNonDynamicAttr","howToSet","addSupportEventListener","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","parentNode","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","processUpdateAttrContext","_counts","isNameOnly","processNameOnlyAttrValue","updateNameOnlyAttrValue","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","createDynamicArrayAttribute","varNumber","startIndex","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","isAttr","newValues","createDynamicAttribute","varIndex","processDynamicNameValueAttribute","getTagJsVar","attrPart","processAttribute","stateOwner","hostVar","processHost","valueVar","special","paintContentPush","attachDynamicDom","blankHandler","nodes","node","newNode","attachDomText","attachDomElement","createElement","attr","paintAppendElementString","paintBeforeElementString","addPaintRemoveAwait","promise","paintRemoveAwaits","paintRemoves","paintAfters","removeLocks","text","currentAwaits","data","content","outerPaintRemoves","runPaintRemoves","runPaintCycles","nowPaintAfters","runAfterCycle","paintRemover","_caller","removeChild","relative","appendChild","contentCleaner","toPlainTextElm","textElm","subContextItem","processDomTagInit","processOuterDomTagInit","contextItem2","checkOuterTagValueChange","getDomTag","setHTML","oldProcessInit","acceptInnerHTML","useTagVar","stringTag","getStringTag","putOneDomDown","newFragment","loadNewBaseSupport","renderTagElement","templater2","isAppFunction","isFirstRender","executeStateWrap","runWrapper","isApp","destroy","removeEventListener","toAwait","debug","appElements","createDocumentFragment","domItem","registerTagElement","taggedJs","tagElement","appElmIndex","appElm","getNewSubject","syncWrapCallback","newestOwner","c","Observable","handleInnerHTML","realValue","processInnerHTML","checkInnerHTML","getInnerHTML","processPipe","options","processHostUpdate","deleteHost","hmr"],"sourceRoot":""}