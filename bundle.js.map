{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/letState.function.ts","webpack://taggedjs/./ts/state/setUse.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/TemplaterResult.class.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/Support.class.ts","webpack://taggedjs/./ts/tag/clonePropsBy.function.ts","webpack://taggedjs/./ts/alterProp.function.ts","webpack://taggedjs/./ts/tag/executeWrap.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/key.ts","webpack://taggedjs/./ts/tag/tag.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/paint.function.ts","webpack://taggedjs/./ts/updateBeforeTemplate.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/interpolations/attributes/elementInitCheck.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/tag/render/renderSupport.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDomElements.function.ts","webpack://taggedjs/./ts/tag/buildBeforeElement.function.ts","webpack://taggedjs/./ts/tag/update/processTag.function.ts","webpack://taggedjs/./ts/tag/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/tag/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/update/processNewValue.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/getChildTagsToDestroy.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/tag/elementDestroyCheck.function.ts","webpack://taggedjs/./ts/tag/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/render/beforeRerender.function.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/tag/afterRender.function.ts","webpack://taggedjs/./ts/tag/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/interpolations/processSubscriptionUpdate.function.ts","webpack://taggedjs/./ts/interpolations/subscribeToTemplate.function.ts","webpack://taggedjs/./ts/tag/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/tag/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/tag/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/tag/Tag.class.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/restorePlaceholders.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(subject) {\n    ;\n    subject.renderCount = 0;\n    return subject.global = {}; // TODO: make SupportTagGlobal\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: ['html'], // html'' aka StringTag | DomTag\n    dom: ['dom'], // compiled version of html''\n    templater: ['templater'],\n    tagComponent: ['tagComponent'],\n    tagArray: ['tagArray'],\n    subject: ['subject'],\n    tagJsSubject: ['tagJsSubject'],\n    renderOnce: ['renderOnce'],\n    stateRender: ['stateRender'],\n    version,\n};\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\nexport function isStaticTag(value) {\n    switch (value?.tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, _subscription) => {\n            subscription.unsubscribe();\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUse.function.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    config.array.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n","import { firstLetState, reLetState } from './letState.function.js';\nimport { runFirstState, runRestate } from './stateHandlers.js';\nexport function initState(support, config) {\n    config.handlers.handler = runFirstState;\n    config.handlers.letHandler = firstLetState;\n    config.rearray = [];\n    config.array = [];\n    config.support = support;\n}\nexport function reState(support, config, prevState) {\n    config.rearray = prevState;\n    config.array = [];\n    config.handlers.handler = runRestate;\n    config.handlers.letHandler = reLetState;\n    config.support = support;\n}\nexport class StateEchoBack {\n}\n// sends a fake value and then sets back to received value\nexport function getCallbackValue(callback) {\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [value] = oldState;\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\n/*\nconst badLetState = 'letState function incorrectly used. Second item in array is not setting expected value.\\n\\n' +\n'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n'For \"const\" state use `const name = state(default)()`\\n\\n' +\n'Problem state:\\n'\n*/\nexport function getStateValue(state) {\n    const callback = state.callback;\n    // state()\n    if (!callback) {\n        return state.defaultValue;\n    }\n    // letState()\n    const [value] = getCallbackValue(callback);\n    // TODO: not needed in production, needed in development\n    /*\n    const [value, checkValue] = getCallbackValue(callback)\n    if(checkValue !== StateEchoBack) {\n      const message = badLetState + (callback ? callback.toString() : JSON.stringify(state)) +'\\n'\n      console.error(message, {state, callback, value, checkValue})\n      throw new Error(message)\n    }\n    */\n    return value;\n}\n","import { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from './setUse.function.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function letState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.letHandler(defaultValue);\n}\nexport function firstLetState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    const initValue = typeof (defaultValue) === BasicTypes.function ? defaultValue() : defaultValue;\n    const push = {\n        get: function getPushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return makeStateResult(initValue, push);\n}\nexport function reLetState() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    const oldValue = getStateValue(restate);\n    const push = {\n        get: function getLetState() {\n            return getStateValue(push);\n        },\n        defaultValue: restate.defaultValue,\n    };\n    config.array.push(push);\n    return makeStateResult(oldValue, push);\n}\nfunction makeStateResult(initValue, push) {\n    return function msr(y) {\n        push.callback = y;\n        return initValue;\n    };\n}\n","import { firstLetState } from './letState.function.js';\nimport { runFirstState } from './stateHandlers.js';\nexport const setUseMemory = {\n    stateConfig: {\n        array: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            letHandler: firstLetState,\n        }\n    },\n};\n","import { setUseMemory } from './setUse.function.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","export function syncStates(stateFrom, stateTo) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const fromValue = stateFrom[index].get();\n        const callback = stateTo[index].callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered. Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = setUseMemory.stateConfig.array;\n                        const oldestState = firstSupport.subject.global.oldest.state;\n                        syncStates(newestState, oldestState);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUse.function.js';\nimport { state } from './state.function.js';\nimport { syncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(value, onSubscription) {\n    const oldestState = state(function subjectState() {\n        return setUseMemory.stateConfig.array;\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectState() {\n        const subject = new Subject(value, onSubscription).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return setUseMemory.stateConfig.array;\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            syncStates(nowSupport.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => setUseMemory.stateConfig.array);\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        syncStates(nowSupport.state, oldestState);\n        return x;\n    });\n}\nsubject.all = all;\n","import { letState } from './letState.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(prop) {\n    return getSetProp => {\n        let myProp = letState(prop)(getSetProp);\n        watch([prop], () => getSetProp(myProp = prop));\n        getSetProp(myProp); // always reset to my value and right await so that the old prop value never slips through\n        return myProp;\n    };\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUse.function.js';\nimport { state } from './state.function.js';\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(() => ({ stateDiff: 0, provider: undefined }));\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.array.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.array.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.subject.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        // find once, return same every time after\n        return state(() => {\n            // const memory = setUse.memory\n            const cm = constructor;\n            const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n            const support = getSupportInCycle(); // memory.stateConfig.support as Support\n            const providers = [];\n            let owner = {\n                ownerSupport: support.ownerSupport\n            };\n            while (owner.ownerSupport) {\n                const ownGlobal = owner.ownerSupport.subject.global;\n                const ownerProviders = ownGlobal.providers;\n                if (!ownerProviders) {\n                    owner = owner.ownerSupport; // cause reloop checking next parent\n                    continue;\n                }\n                const provider = ownerProviders.find(provider => {\n                    providers.push(provider);\n                    const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                    if (constructorMatch) {\n                        return true;\n                    }\n                });\n                if (provider) {\n                    const global = support.subject.global;\n                    const providers = global.providers = global.providers || [];\n                    providers.push(provider);\n                    provider.children.push(support);\n                    return provider.instance;\n                }\n                owner = owner.ownerSupport; // cause reloop checking next parent\n            }\n            const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n            console.warn(`${msg}. Available providers`, providers);\n            throw new Error(msg);\n        });\n    }\n};\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        propWatch,\n        props,\n        tagJsType: ValueTypes.templater,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { clonePropsBy } from './clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, subject, castedProps) {\n    const baseSupport = {\n        templater,\n        subject,\n        castedProps,\n        state: [], // TODO: this is not needed for every type of  tag\n        appSupport: undefined,\n    };\n    baseSupport.appSupport = baseSupport;\n    const global = subject.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    const props = templater.props; // natural props\n    if (props) {\n        baseSupport.propsConfig = clonePropsBy(baseSupport, props, castedProps);\n    }\n    return baseSupport;\n}\nexport function getSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\nexport function getHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = {\n        templater,\n        subject,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { cloneTagJsValue } from './cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { PropWatches } from './tag.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(x => cloneTagJsValue(x, shallowCompareDepth)),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(props => cloneTagJsValue(props, deepCompareDepth)),\n        castProps,\n    };\n}\n","import { isInlineHtml, renderInlineHtml } from './tag/render/renderSupport.function.js';\nimport { renderExistingReadyTag } from './tag/render/renderExistingTag.function.js';\nimport { getSupportInCycle } from './tag/getSupportInCycle.function.js';\nimport { deepCompareDepth } from './tag/hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nimport { setUseMemory } from './state/index.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(prop => alterProp(prop, newSupport.ownerSupport, newSupport, depth));\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        return getPropWrap(value, ownerSupport);\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.subject.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return wrap.toCall(...args);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n    wrap.toCall = function toCallRunner(...args) {\n        return callbackPropOwner(wrap.mem, args, ownerSupport);\n    };\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    const global = ownerSupport.subject.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    const callbackResult = toCall(...callWith);\n    const run = function propCallbackProcessor() {\n        const global = newest.subject.global;\n        // are we in a rendering cycle? then its being called by alterProps\n        if (noCycle === false) {\n            const allMatched = global.locked === true;\n            if (allMatched) {\n                return callbackResult; // owner did not change\n            }\n        }\n        safeRenderSupport(newest, ownerSupport);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\nexport function safeRenderSupport(newest, ownerSupport) {\n    const subject = newest.subject;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        const result = renderInlineHtml(ownerSupport, newest);\n        // TODO: below maybe never true\n        /*\n        const global = subject.global as TagGlobal\n        if(global) {\n          delete global.locked\n        }\n        */\n        return result;\n    }\n    const global = subject.global;\n    global.locked = true;\n    renderExistingReadyTag(global.newest, newest, ownerSupport, subject);\n    delete global.locked;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    const nowState = setUseMemory.stateConfig.array;\n    useSupport.state = nowState;\n    return useSupport;\n}\n","import { getSupport } from './Support.class.js';\nimport { castProps } from '../alterProp.function.js';\nimport { syncFunctionProps } from './update/updateExistingTagComponent.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { PropWatches } from './tag.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = getSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as Support,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","/** Used to give unique value to an array of tag content. Should not be an object */\nexport function key(arrayValue) {\n    return {\n        set html(newValue) {\n            newValue.arrayValue = arrayValue;\n        }\n    };\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from './TemplaterResult.class.js';\nimport { tags } from './tag.utils.js';\nimport { getTagWrap } from './getTagWrap.function.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { key } from './key.js';\nlet tagCount = 0;\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = (function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        if (!innerTagWrap.parentWrap) {\n            innerTagWrap.parentWrap = parentWrap;\n        }\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }) // we override the function provided and pretend original is what's returned\n    ;\n    parentWrap.original = tagComponent;\n    // parentWrap.compareTo = (tagComponent as any).toString()\n    const tag = tagComponent;\n    parentWrap.original = tag;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Used to create a tag component that renders once and has no addition rendering cycles */\ntag.renderOnce = function () {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n};\n/** Used to create variable scoping when calling a function that lives within a prop container function */\ntag.state = function () {\n    throw new Error('Do not call tag.state as a function but instead set it as: `(props) => tag.state = (state) => html`` `');\n};\n// TODO???: Is tag.route and tag.app in use?\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.route = function (_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.key = key;\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.deepPropWatch = tag;\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n    },\n});\nObject.defineProperty(tag, 'state', {\n    set(renderFunction) {\n        ;\n        renderFunction.parentWrap = {\n            original: {\n                setUse: setUseMemory,\n                tags,\n            }\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { isArray } from '../isInstance.js';\nimport { hasPropLengthsChanged } from './render/renderSupport.function.js';\nimport { PropWatches } from './tag.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function hasSupportChanged(lastSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = lastSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, lastSupport.templater.propWatch);\n    return propsChanged;\n}\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nfunction hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, () => {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","export let paintRemoves = [];\nexport let paintContent = [];\nexport let setContent = [];\nexport let paintAppends = [];\nexport let paintInsertBefores = [];\nexport let paintAfters = [];\nexport const painting = {\n    locks: 0\n};\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    ++painting.locks;\n    for (const toRemove of paintRemoves) {\n        const parentNode = toRemove.parentNode;\n        parentNode.removeChild(toRemove);\n    }\n    for (const content of paintContent) {\n        content();\n    }\n    for (const [text, textNode] of setContent) {\n        textNode.textContent = text;\n    }\n    for (const now of paintAppends) {\n        now.relative.appendChild(now.element);\n    }\n    for (const { element, relative } of paintInsertBefores) {\n        relative.parentNode.insertBefore(element, relative);\n    }\n    for (const now of paintAfters) {\n        now();\n    }\n    paintRemoves = [];\n    paintContent = [];\n    paintAppends = [];\n    paintInsertBefores = [];\n    paintAfters = [];\n    setContent = [];\n    --painting.locks;\n}\n","import { paintInsertBefores } from './tag/paint.function.js';\nimport { empty } from './tag/ValueTypes.enum.js';\n// Function to update the value of x\nexport function updateBeforeTemplate(value, // value should be casted before calling here\nlastFirstChild) {\n    const textNode = document.createTextNode(value); // never innerHTML\n    paintInsertBefores.push({\n        element: textNode,\n        relative: lastFirstChild,\n    });\n    return textNode;\n}\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","import { paintContent } from \"../../tag/paint.function.js\";\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push(() => {\n        if (value === undefined || value === false || value === null) {\n            element.removeAttribute(name);\n            return;\n        }\n        element.setAttribute(name, value);\n    });\n}\n","import { paintAfters, paintContent } from \"../../tag/paint.function.js\";\nimport { elementInitCheck } from \"./elementInitCheck.js\";\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'oninit':\n            paintAfters.push(() => elementInitCheck(element, { added: 0, removed: 0 }));\n            return;\n        case 'autofocus':\n            paintAfters.push(() => element.focus());\n            return;\n        case 'autoselect':\n            paintAfters.push(() => element.select());\n            return;\n        case 'style': {\n            const names = name.split('.');\n            // names.shift() // remove 'style'\n            paintContent.push(() => element.style[names[1]] = value); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push(() => element.classList.add(name));\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push(() => element.classList.remove(name));\n    }\n}\n","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.subject;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.subject;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../tag/render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as Support\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(ownerSupport, newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","import { deepEqual } from '../../deepFunctions.js';\nimport { renderExistingReadyTag } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../hasSupportChanged.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const global = support.subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (global.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return renderInlineHtml(ownerSupport, support);\n    }\n    global.locked = true;\n    const subject = support.subject;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    delete global.locked;\n    const tag = renderExistingReadyTag(global.newest, support, ownerSupport, subject);\n    return tag;\n}\nexport function renderInlineHtml(ownerSupport, support) {\n    const ownGlobal = ownerSupport.subject.global;\n    if (!ownGlobal || ownGlobal.deleted === true) {\n        return support;\n    }\n    // ??? new change\n    const newest = ownGlobal.newest || ownerSupport;\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(ownerSupport, templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (ownerSupport && selfPropChange) {\n        return true;\n    }\n    return false;\n}\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    /*\n    const noLength = nowProps && nowLen === 0 && latestLen === 0\n  \n    if(noLength) {\n      return false\n    }\n    */\n    return nowLen !== latestLen;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(x => x.support));\n    }\n    return prosWithChanges;\n}\n","import { paint, painting } from '../../tag/paint.function.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.subject.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    // renderSupport(support)\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise, isTagComponent } from '../../isInstance.js';\nimport { renderSupport } from '../../tag/render/renderSupport.function.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nexport function bindSubjectCallback(value, support) {\n    const global = support.subject.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function (element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as Support // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    subjectFunction.support = support;\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, bindTo, args) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    const global = component.subject.global; // tag.subject.global as TagGlobal\n    global.locked = true; // prevent another render from re-rendering this tag\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    return afterTagCallback(callbackResult, component);\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.subject.global; // tag.subject.global as SupportTagGlobal\n    delete global.locked;\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkAfterCallbackPromise(callbackResult, last, global);\n}\nexport function checkAfterCallbackPromise(callbackResult, last, global) {\n    if (isPromise(callbackResult)) {\n        const global0 = last.subject.global;\n        global0.locked = true;\n        return callbackResult.then(() => {\n            if (global.deleted === true) {\n                return promiseNoData; // tag was deleted during event processing\n            }\n            const global1 = last.subject.global;\n            delete global1.locked;\n            const tagsToUpdate = getUpTags(last);\n            renderTagUpdateArray(tagsToUpdate);\n            return promiseNoData;\n        });\n    }\n    return noData;\n}\nexport function runBlocked(tag) {\n    const global = tag.subject.global;\n    const blocked = global.blocked;\n    for (const block of blocked) {\n        const lastResult = renderSupport(block);\n        global.newest = lastResult;\n    }\n    global.blocked = [];\n    return global.newest;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from './processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial) {\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.subject.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction) {\n        return true;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit':\n            return 'oninit';\n    }\n    return false;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from './specialAttribute.js';\nimport { isFunction, isObject, isSubjectInstance } from '../../isInstance.js';\nimport { bindSubjectCallback } from './bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../tag/paint.function.js';\nimport { processDynamicNameValueAttribute, processNonDynamicAttr } from './processNameValueAttribute.function.js';\nimport { addOneContext, checkSimpleValueChange } from '../../tag/index.js';\nimport { processAttributeFunction } from './processAttributeCallback.function.js';\nimport { isSpecialAttr } from './isSpecialAttribute.function.js';\n/** Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, attrName, element, support, howToSet, //  = howToSetInputValue\ncontext, value, isSpecial) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.howToSet = howToSet;\n        contextItem.isNameOnly = true;\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context);\n        return;\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        const contextItem = {\n            isAttr: true,\n            element,\n            attrName: attrName,\n            checkValueChange: checkSimpleValueChange,\n            withinOwnerElement: true,\n        };\n        context.push(contextItem);\n        const isSubject = isSubjectInstance(contextItem.value);\n        if (isSubject) {\n            return processNameValueAttributeAttrSubject(attrName, contextItem, element, support, howToSet, isSpecial);\n        }\n        processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, isSpecial);\n        contextItem.value = value;\n        return;\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, isSpecial);\n}\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push(function paintContent() {\n                        element.removeAttribute(name);\n                    });\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context);\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, value, isSpecialAttr(name));\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\n/** Processor for flat attributes and object attributes */\nfunction processNameValueAttributeAttrSubject(attrName, result, element, support, howToSet, isSpecial) {\n    if (isSpecial) {\n        paintContent.push(function paintContent() {\n            element.removeAttribute(attrName);\n        });\n    }\n    const contextValueSubject = result.value;\n    if (isSubjectInstance(contextValueSubject)) {\n        const callback = function processAttrCallback(newAttrValue) {\n            processAttributeEmit(newAttrValue, attrName, result, element, support, howToSet, isSpecial);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        const global = result.global;\n        const subs = global.subscriptions = global.subscriptions || [];\n        subs.push(sub);\n    }\n    processAttributeEmit(result.value, attrName, result, element, support, howToSet, isSpecial);\n    return;\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support) {\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    if (isSpecial) {\n        specialAttribute(attrName, newAttrValue, element, isSpecial);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push(function paintContentPush() {\n                element.removeAttribute(attrName);\n            });\n            return;\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject) {\n    const wrapper = support.templater.wrapper;\n    const parentWrap = wrapper?.parentWrap;\n    const tagJsType = wrapper?.tagJsType || parentWrap?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    const prevFun = subject.value;\n    if (prevFun && prevFun.tagFunction && prevFun.support) {\n        prevFun.tagFunction = newAttrValue;\n        prevFun.support = support;\n        return prevFun;\n    }\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\nexport function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nimport { howToSetInputValue } from \"../attributes/howToSetInputValue.function.js\";\nimport { paintAppends, paintInsertBefores } from \"../../tag/paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { addOneContext } from \"../../tag/index.js\";\nimport { isSubjectInstance } from \"../../isInstance.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\n// ??? TODO: This could be done within exchangeParsedForValues to reduce loops\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nowner, insertBefore, subs = []) {\n    const x = document.createElement('div');\n    const dom = [];\n    for (const node of nodes) {\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            attachDynamicDom(values, context, owner, support, subs, counts, depth);\n            continue;\n        }\n        if (node.nn === 'text') {\n            const textNode = newNode;\n            const string = textNode.tc = node.tc;\n            x.innerHTML = string;\n            const domElement = textNode.domElement = document.createTextNode(x.innerText);\n            domElement.id = `tp_${context.length}_${values.length}`;\n            if (owner) {\n                paintAppends.push({\n                    element: domElement,\n                    relative: owner,\n                });\n            }\n            else {\n                paintInsertBefores.push({\n                    element: domElement,\n                    relative: insertBefore,\n                });\n            }\n            continue;\n        }\n        const domElement = newNode.domElement = document.createElement(node.nn);\n        // attributes that may effect style, come first\n        if (node.at) {\n            node.at.map(attr => processAttribute(values, attr[0], // name\n            domElement, support, howToSetInputValue, context, attr[1], // value\n            attr[2]));\n        }\n        if (owner) {\n            paintAppends.push({\n                element: domElement,\n                relative: owner,\n            });\n        }\n        else {\n            paintInsertBefores.push({\n                element: domElement,\n                relative: insertBefore,\n            });\n        }\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore, subs).dom;\n        }\n    }\n    return { subs, dom, context };\n}\nfunction attachDynamicDom(values, context, owner, support, subs, counts, // used for animation stagger computing\ndepth) {\n    const subVal = values[context.length];\n    const marker = document.createTextNode(empty);\n    marker.id = `dvp_${context.length}_${values.length}`;\n    const contextItem = addOneContext(subVal, context, depth > 0);\n    contextItem.placeholder = marker;\n    if (owner) {\n        paintAppends.push({\n            relative: owner,\n            element: marker,\n        });\n    }\n    else {\n        paintInsertBefores.push({\n            element: marker,\n            relative: support.subject.placeholder,\n        });\n    }\n    if (isSubjectInstance(subVal)) {\n        subs.push({\n            insertBefore: marker,\n            appendTo: owner,\n            subject: subVal,\n            support, // ownerSupport,\n            counts,\n            contextItem,\n        });\n        return;\n    }\n    const global = support.subject.global;\n    global.locked = true;\n    processFirstSubjectValue(subVal, contextItem, support, counts, `rvp_${context.length}_${values.length}`, owner);\n    const global2 = support.subject.global;\n    delete global2.locked;\n    contextItem.value = subVal;\n    return;\n}\n","import { attachDomElements } from '../interpolations/optimizers/attachDomElements.function.js';\nimport { checkSimpleValueChange } from './index.js';\nimport { getDomMeta } from './domMetaCollector.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, element, insertBefore, options) {\n    const global = support.subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = getHtmlDomMeta(support, options, element, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction getHtmlDomMeta(support, options = {\n    counts: { added: 0, removed: 0 },\n}, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const context = [];\n    const global = support.subject.global;\n    global.context = context;\n    const result = attachDomElements(domMeta, values, support, options.counts, context, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag; // || templater\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    return getDomMeta(thisTag.strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { getHtmlSupport } from '../Support.class.js';\nimport { checkTagValueChange } from '../checkDestroyPrevious.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\nsubject) {\n    const global = subject.global;\n    const support = global.newest;\n    support.ownerSupport = ownerSupport;\n    subject.checkValueChange = checkTagValueChange;\n    const ph = subject.placeholder;\n    const result = buildBeforeElement(support, undefined, ph, { counts: { added: 0, removed: 0 } });\n    for (const sub of result.subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n    };\n    return fake;\n}\n/** Create Support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = getHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.context = [];\n    return support;\n}\n","import { processAttributeEmit, updateNameOnlyAttrValue } from '../interpolations/attributes/processAttribute.function.js';\nexport function processUpdateAttrContext(values, value, contextItem, ownerSupport) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, []);\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial);\n    contextItem.value = value;\n    return;\n}\n","import { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { updateExistingValue } from './update/updateExistingValue.function.js';\nimport { isSubjectInstance } from '../isInstance.js';\nexport function processUpdateContext(support, context) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    while (index < len) {\n        processUpdateOneContext(values, index, context, support);\n        ++index;\n    }\n    return context;\n}\n/** returns boolean of did render */\nexport function processUpdateOneContext(values, index, context, ownerSupport) {\n    const value = values[index];\n    // is something already there?\n    const contextItem = context[index];\n    if (isSubjectInstance(value)) {\n        return; // emits on its own\n    }\n    if (contextItem.isAttr) {\n        // Do not continue if the value is just the same\n        if (value === contextItem.value) {\n            return;\n        }\n        processUpdateAttrContext(values, value, contextItem, ownerSupport);\n        contextItem.value = value;\n    }\n    // listeners will evaluate updated values to possibly update display(s)\n    updateExistingValue(contextItem, value, ownerSupport);\n    contextItem.value = value;\n}\n","import { paint, painting } from './paint.function.js';\nimport { processUpdateContext } from './processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.subject.global;\n    const context = global.context;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const tempTag = (newerSupport.templater.tag || newerSupport.templater);\n    const values = newerSupport.templater.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { getSupport } from '../Support.class.js';\nimport { getFakeTemplater, newSupportByTemplater, processTag } from './processTag.function.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function.js';\nimport { BasicTypes, ValueTypes } from '../ValueTypes.enum.js';\nimport { updateSupportBy } from '../updateSupportBy.function.js';\nimport { isArray, isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processTagArray } from './processTagArray.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function updateExistingValue(contextItem, value, ownerSupport) {\n    // Do not continue if the value is just the same\n    if (value === contextItem.value) {\n        return;\n    }\n    const wasDestroyed = contextItem.checkValueChange(value, contextItem);\n    if (wasDestroyed === -1) {\n        return; // do nothing\n    }\n    // handle already seen tag components\n    const tagJsType = value && value.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        const isComp = isTagComponent(value);\n        if (isComp) {\n            if (!contextItem.global) {\n                getNewGlobal(contextItem);\n            }\n            prepareUpdateToComponent(value, contextItem, ownerSupport);\n            return;\n        }\n    }\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            updateContextItemBySupport(support, contextItem, value, ownerSupport);\n            return;\n        }\n    }\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.templater:\n                processTag(ownerSupport, contextItem);\n                return;\n            case ValueTypes.tag:\n            case ValueTypes.dom: {\n                const tag = value;\n                let templater = tag.templater;\n                if (!templater) {\n                    templater = getFakeTemplater();\n                    tag.templater = templater;\n                    templater.tag = tag;\n                }\n                const nowGlobal = (contextItem.global ? contextItem.global : getNewGlobal(contextItem));\n                nowGlobal.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n                processTag(ownerSupport, contextItem);\n                return;\n            }\n        }\n    }\n    if (isArray(value)) {\n        processTagArray(contextItem, value, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        contextItem.value = value; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (wasDestroyed) {\n        processNowRegularValue(value, contextItem);\n    }\n}\nfunction handleStillTag(lastSupport, subject, value, ownerSupport) {\n    const templater = value.templater || value;\n    const valueSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = lastSupport.subject;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        processReplacementComponent(templater, contextItem, ownerSupport, { added: 0, removed: 0 });\n        return;\n    }\n    const support = getSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n/** Used to destro */\nfunction updateContextItemBySupport(support, contextItem, value, ownerSupport) {\n    if (typeof (value) === BasicTypes.function) {\n        return;\n    }\n    handleStillTag(support, contextItem, value, ownerSupport);\n    return;\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { castProps, isSkipPropValue } from '../../alterProp.function.js';\nimport { renderSupport } from '../render/renderSupport.function.js';\nimport { BasicTypes, ValueTypes } from '../ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { PropWatches } from '../tag.js';\nexport function updateExistingTagComponent(ownerSupport, support, // lastest\nsubject) {\n    const global = subject.global;\n    const lastSupport = global.newest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = support.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = support.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = support.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(lastSupport, support);\n    }\n    else if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.parentWrap.original;\n        const newFunction = newWrapper.parentWrap.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = support.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(lastSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, support, lastSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (global.locked) {\n        global.blocked.push(support);\n        return;\n    }\n    renderSupport(support);\n    return;\n}\nexport function syncFunctionProps(newSupport, lastSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const global = lastSupport.subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    lastSupport = newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, depth + 1, maxDepth);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nfunction syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    // prevent infinite recursion\n    if (depth === maxDepth) {\n        return prop;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth);\n    }\n    if (priorProp === undefined) {\n        return prop;\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\nfunction updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const result = syncPriorPropFunction(priorProp[name], subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (prop[name] === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        ;\n        prop[name] = result;\n    }\n    return prop;\n}\nfunction updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        prop[index] = syncPriorPropFunction(priorProp[index], x, newSupport, ownerSupport, depth + 1, index);\n    }\n    return prop;\n}\nexport function moveProviders(lastSupport, newSupport) {\n    const global = lastSupport.subject.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.subject.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\nfunction syncSupports(templater, support, lastSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, lastSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = lastSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return lastSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(subject, templater, // new tag\nownerSupport) {\n    const global = subject.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, 0);\n    getNewGlobal(subject);\n    const newSupport = processReplacementComponent(templater, subject, ownerSupport, { added: 0, removed: 0 });\n    return newSupport;\n}\n","import { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { setContent } from '../paint.function.js';\nimport { checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    setContent.push([castedValue, oldClone]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, subject) {\n    subject.checkValueChange = checkSimpleValueChange;\n    const before = subject.placeholder;\n    const castedValue = castTextValue(value);\n    // Processing of regular values\n    subject.simpleValueElm = updateBeforeTemplate(castedValue, before);\n}\n","import { getTemplaterResult } from '../TemplaterResult.class.js';\nimport { checkTagValueChange } from '../checkDestroyPrevious.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getSupport } from '../Support.class.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { PropWatches } from '../tag.js';\nexport function processNewArrayValue(value, ownerSupport, contextItem) {\n    const tagJsType = value.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.templater: {\n                const templater = value;\n                const tag = templater.tag;\n                processNewTag(tag, ownerSupport, contextItem);\n                break;\n            }\n            case ValueTypes.tag:\n            case ValueTypes.dom:\n                processNewTag(value, ownerSupport, contextItem);\n                break;\n        }\n    }\n    return contextItem;\n}\nfunction processNewTag(value, ownerSupport, contextItem) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const tag = value;\n    let templater = tag.templater;\n    // TODO: Can this ever happen?\n    if (!templater) {\n        templater = getTemplaterResult(PropWatches.DEEP);\n        templater.tag = tag;\n        tag.templater = templater;\n    }\n    const global = contextItem.global = getNewGlobal(contextItem); // contextItem.global as SupportTagGlobal\n    const newest = global.newest = getSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    global.oldest = newest;\n    return contextItem;\n}\n","import { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { setUseMemory } from '../state/index.js';\nimport { Subject } from '../subject/index.js';\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nsetUseMemory.tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(support) {\n    // TODO: We don't need to remove from parents if parent is being destroyed\n    // remove me from my parents\n    const global = support.subject.global;\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.subject.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    support.subject.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nexport function getChildTagsToDestroy(childTags) {\n    for (const child of childTags) {\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            getChildTagsToDestroy(lastArray);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(iSub => iSub.unsubscribe());\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support);\n        }\n        const subTags = global.context;\n        getChildTagsToDestroy(subTags);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.context;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { elementDestroyCheck } from './elementDestroyCheck.function.js';\nimport { paint, paintRemoves } from './paint.function.js';\nimport { isPromise } from '../isInstance.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(support, promises, stagger) {\n    const startStagger = stagger;\n    const subject = support.subject;\n    const thisGlobal = subject.global;\n    const htmlDomMeta = thisGlobal.htmlDomMeta;\n    const context = thisGlobal.context;\n    thisGlobal.deleted = true;\n    for (const subject of context) {\n        if (subject.withinOwnerElement) {\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            paintRemoves.push(elm);\n            continue;\n        }\n        const global = subject.global;\n        if (global === undefined) {\n            continue; // subject\n        }\n        if (global.deleted === true) {\n            continue;\n        }\n        global.deleted = true;\n        const oldest = global.oldest;\n        if (oldest) {\n            // recurse\n            stagger = stagger + smartRemoveKids(oldest, promises, stagger);\n            continue;\n        }\n    }\n    destroyClones(htmlDomMeta, startStagger, promises);\n    return stagger;\n}\nfunction destroyClones(oldClones, stagger, promises) {\n    // check subjects that may have clones attached to them\n    const newPromises = oldClones.map(clone => {\n        const marker = clone.marker;\n        if (marker) {\n            paintRemoves.push(marker);\n        }\n        const dom = clone.domElement;\n        if (!dom) {\n            return;\n        }\n        return checkCloneRemoval(dom, stagger);\n    }).filter(x => x); // only return promises\n    if (newPromises.length) {\n        promises.push(Promise.all(newPromises));\n        return stagger;\n    }\n    return stagger;\n}\n/** Reviews elements for the presences of ondestroy */\nfunction checkCloneRemoval(clone, stagger) {\n    const customElm = clone;\n    if (customElm.ondestroy) {\n        const promise = elementDestroyCheck(customElm, stagger);\n        if (isPromise(promise)) {\n            return promise.then(() => {\n                paintRemoves.push(clone);\n                paint();\n            });\n        }\n    }\n    paintRemoves.push(clone);\n}\n","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    const event = {\n        target: nextSibling,\n        stagger\n    };\n    return onDestroy(event);\n}\n","import { getChildTagsToDestroy } from './getChildTagsToDestroy.function.js';\nimport { smartRemoveKids } from './smartRemoveKids.function.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nexport function destroySupport(support, stagger) {\n    const global = support.subject.global;\n    global.deleted = true;\n    support.subject.renderCount = 0; // if it comes back, wont be considered an update\n    const context = global.context;\n    getChildTagsToDestroy(context);\n    if (global.destroy$) {\n        global.destroy$.next();\n        runBeforeDestroy(support);\n    }\n    // first paint\n    const promises = [];\n    stagger = smartRemoveKids(support, promises, stagger);\n    if (promises.length) {\n        return Promise.all(promises).then(() => stagger);\n    }\n    return stagger;\n}\n","// taggedjs-no-compile\nimport { paintAppends, paintInsertBefores, paintRemoves } from '../paint.function.js';\nimport { processFirstSubjectValue } from './processFirstSubjectValue.function.js';\nimport { checkSimpleValueChange } from '../checkDestroyPrevious.function.js';\nimport { updateExistingValue } from './updateExistingValue.function.js';\nimport { processNewArrayValue } from './processNewValue.function.js';\nimport { destroySupport } from '../destroySupport.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    if (!subject.lastArray) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    const filteredLast = [];\n    for (let index = 0; index < lastArray.length; ++index) {\n        const item = lastArray[index];\n        const newRemoved = reviewLastArrayItem(item, value, index, lastArray, removed, counts);\n        if (newRemoved === 0) {\n            filteredLast.push(item);\n            continue;\n        }\n        removed = removed + newRemoved;\n        // do the same number again because it was a mid delete\n        if (newRemoved === 2) {\n            index = index - 1;\n        }\n    }\n    subject.lastArray = filteredLast;\n    // const eAppendTo = existed ? undefined : appendTo\n    const eAppendTo = appendTo; // existed ? undefined : appendTo\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, filteredLast, ownerSupport, runtimeInsertBefore, counts, eAppendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    return processAddTagArrayItem(item, runtimeInsertBefore, // thisInsert as any,\n    ownerSupport, counts, lastArray, appendTo);\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        updateExistingValue(itemSubject, value, ownerSupport);\n        return itemSubject;\n    }\n    const result = processAddTagArrayItem(value, runtimeInsertBefore, // thisInsert as any,\n    ownerSupport, counts, lastArray, appendTo);\n    return result;\n}\nfunction processAddTagArrayItem(value, before, // used during updates\nownerSupport, counts, lastArray, appendTo) {\n    const itemSubject = {\n        value,\n        checkValueChange: checkSimpleValueChange,\n        withinOwnerElement: false, // TODO: we need to pass down depth so we can answer this truthfully\n    };\n    counts.added = counts.added + 1; // index\n    const subPlaceholder = document.createTextNode('');\n    itemSubject.placeholder = subPlaceholder;\n    if (!appendTo) {\n        paintInsertBefores.push({\n            element: subPlaceholder,\n            relative: before,\n        });\n    }\n    processNewArrayValue(value, ownerSupport, itemSubject);\n    processFirstSubjectValue(value, itemSubject, ownerSupport, // support,\n    counts, `rvp_${lastArray.length}_array`, appendTo);\n    // after processing\n    itemSubject.value = value;\n    // Added to previous array\n    lastArray.push(itemSubject);\n    if (appendTo) {\n        paintAppends.push({\n            element: subPlaceholder,\n            relative: appendTo,\n        });\n    }\n    return itemSubject;\n}\nexport function destroyArrayItem(item, counts) {\n    const global = item.global;\n    if (global) {\n        const support = global.oldest;\n        global.deleted = true;\n        destroySupport(support, counts.removed);\n        global.deleted = true;\n    }\n    else {\n        const element = item.simpleValueElm;\n        delete item.simpleValueElm;\n        paintRemoves.push(element);\n    }\n    ++counts.removed;\n}\nfunction reviewLastArrayItem(_subTag, // used to compare arrays\nvalue, index, lastArray, removed, counts) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prev = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prev, counts);\n        ++removed;\n        return 1;\n    }\n    if (lastArray[index].value.arrayValue !== value[index].arrayValue) {\n        destroyArrayItem(prev, counts);\n        lastArray.splice(index, 1);\n        ++removed;\n        return 2;\n    }\n    /*\n    const nowValue = getArrayValueByItem(subTag)\n    const lastArrayValue = lastArray.array[index].arrayValue\n    */\n    // check for html``.key()\n    /*\n    const keySet = 'arrayValue' in tag\n    if (!keySet) {\n      const details = {\n        array: value.map(item => item.values || item),\n        vdom: (tag as any)?.support.templater.tag.dom,\n        tag,\n        lastArray: lastArray.array[index]\n      }\n      const message = 'Found Tag in array without key value, during array update. Be sure to use \"html`...`.key(unique)\" OR import TaggedJs \"key\" \"key(unique).html = CustomTag(props)\"'\n      console.error(message, details)\n      const err = new ArrayNoKeyError(message, details)\n      throw err\n    }\n    */\n    /*\n    const destroyItem = nowValue !== lastArrayValue\n    if(destroyItem) {\n      destroyArrayItem(lastArray.array, index, counts)\n      ++removed\n      return 1\n    }\n    */\n    return 0;\n}\n/*\nfunction getArrayValueByItem(item: any) {\n  return item?.arrayValue || item\n}\n*/\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(support0, // new\nsupport1) {\n    const templater0 = support0.templater;\n    const templater1 = support1.templater;\n    const tag0 = templater0?.tag || support0;\n    const tag1 = templater1.tag; // || (support1 as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    if (tag0.tagJsType === ValueTypes.dom) {\n        if (tag1?.tagJsType !== ValueTypes.dom) {\n            return false; // tag0 is not even same type\n        }\n        return isLikeDomTags(tag0, tag1);\n    }\n    const like = isLikeStringTags(tag0, tag1, support0, support1);\n    return like;\n}\n// used when compiler was used\nexport function isLikeDomTags(tag0, tag1) {\n    const domMeta0 = tag0.dom;\n    const domMeta1 = tag1.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(tag0, tag1, support0, // new\nsupport1) {\n    const strings0 = tag0.strings;\n    const strings1 = tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    // strings1[index] === string // slower\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = support0.templater.values || tag0.values;\n    const values1 = support1.templater.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","// Functions in here are attached as ContextItem.checkValueChange\nimport { processUpdateRegularValue } from './update/processRegularValue.function.js';\nimport { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroyArrayItem } from './update/processTagArray.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { isArray, isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { paintRemoves } from './paint.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        const lastArray = subject.lastArray;\n        destroyArray(subject, lastArray);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArray(subject, lastArray) {\n    const counts = { added: 0, removed: 0 };\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index], counts);\n    }\n    delete subject.lastArray;\n}\nexport function checkSimpleValueChange(newValue, subject) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, subject);\n        return -1; // no need to destroy, just update display\n    }\n    const elm = subject.simpleValueElm;\n    delete subject.simpleValueElm;\n    paintRemoves.push(elm);\n    return 6; // 'changed-simple-value'\n}\nexport function checkTagValueChange(newValue, subject) {\n    const global = subject.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, 0);\n            getNewGlobal(subject);\n            return 7; // 'tag-swap'\n        }\n        return false;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        return false; // its still a tag component\n    }\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, 0);\n    delete subject.global;\n    subject.renderCount = 0;\n    return 8; // 'no-longer-tag'\n}\n","import { getTemplaterResult } from '../TemplaterResult.class.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nimport { PropWatches } from '../tag.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || (wrapper());\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.parentWrap = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.parentWrap.original = wrapper;\n    return support;\n}\n","import { reState } from '../../state/state.utils.js';\nimport { setUseMemory } from '../../state/setUse.function.js';\nexport function beforeRerender(support, // new\nprevState) {\n    reState(support, setUseMemory.stateConfig, prevState);\n    return;\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.array.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.array.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.parentWrap.original) {\n        tagFunction = wrapper.parentWrap.original;\n    }\n    const details = {\n        oldStates: config.array,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUse.function.js';\nimport { checkStateMismatch } from './checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.subject;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    delete config.support;\n    support.state = config.array;\n    setUseMemory.tagClosed$.next(ownerSupport);\n    checkStateMismatch(config, support);\n    subject.global.newest = support;\n}\n","import { getSupport } from '../Support.class.js';\nimport { beforeRerender } from './beforeRerender.function.js';\nimport { executeWrap } from '../executeWrap.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { runAfterRender } from '../afterRender.function.js';\nimport { initState } from '../../state/state.utils.js';\nimport { setUseMemory } from '../../state/setUse.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    const global = subject.global;\n    const oldRenderCount = subject.renderCount;\n    const prevState = prevSupport?.state;\n    if (prevState) {\n        beforeRerender(newSupport, prevState);\n    }\n    else {\n        initState(newSupport, setUseMemory.stateConfig);\n    }\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        const useSupport = getSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as Support,\n        subject);\n        reSupport = executeWrap(templater, result, useSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n    // TODO: below most likely not needed\n    if (subject.renderCount > oldRenderCount + 1) {\n        return global.newest;\n    }\n    return reSupport;\n}\n","import { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { checkTagValueChange } from '../checkDestroyPrevious.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { paintAppends } from '../paint.function.js';\nimport { newSupportByTemplater } from './processTag.function.js';\nexport function processNewSubjectTag(templater, ownerSupport, // owner\nsubject, // could be tag via result.tag\nappendTo) {\n    subject.checkValueChange = checkTagValueChange;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, appendTo, undefined, { counts: { added: 0, removed: 0 } });\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            paintAppends.push({\n                element: dom.marker,\n                relative: appendTo, // ph.parentNode as Element,\n            });\n        }\n        if (dom.domElement) {\n            paintAppends.push({\n                element: dom.domElement,\n                relative: appendTo, // ph.parentNode as Element,\n            });\n        }\n    }\n    let index = -1;\n    const length = result.subs.length - 1;\n    //++painting.locks\n    while (index++ < length) {\n        const sub = result.subs[index];\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\n","import { checkArrayValueChange, checkSimpleValueChange, checkTagValueChange } from '../checkDestroyPrevious.function.js';\nimport { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { newSupportByTemplater, processTag, tagFakeTemplater } from './processTag.function.js';\nimport { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function.js';\nimport { oneRenderToSupport } from './oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../render/renderTagOnly.function.js';\nimport { isArray, isSubjectInstance } from '../../isInstance.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processFirstSubjectValue(value, subject, // could be tag via result.tag\nownerSupport, // owning support\ncounts, // {added:0, removed:0}\nvalueId, appendTo) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            // TODO: Do we ever get in here? because dom, tag, and component are covered below\n            case ValueTypes.templater:\n                subject.checkValueChange = checkTagValueChange;\n                if (appendTo) {\n                    return processNewSubjectTag(value, ownerSupport, subject, appendTo);\n                }\n                return processTag(ownerSupport, subject);\n            case ValueTypes.dom:\n            case ValueTypes.tag: {\n                subject.checkValueChange = checkTagValueChange;\n                const tag = value;\n                let templater = tag.templater;\n                if (!templater) {\n                    templater = tagFakeTemplater(tag); // TODO: most likely a not needed performance hit\n                }\n                const global = getNewGlobal(subject);\n                if (appendTo) {\n                    return processNewSubjectTag(templater, ownerSupport, subject, appendTo);\n                }\n                global.newest = newSupportByTemplater(templater, ownerSupport, subject);\n                subject.checkValueChange = checkTagValueChange;\n                return processTag(ownerSupport, subject);\n            }\n            case ValueTypes.stateRender:\n            case ValueTypes.tagComponent: {\n                getNewGlobal(subject);\n                subject.checkValueChange = checkTagValueChange;\n                if (appendTo) {\n                    const processResult = processFirstSubjectComponent(value, subject, ownerSupport, counts, appendTo);\n                    // ++subject.global.renderCount\n                    return processResult;\n                }\n                const processResult = processReplacementComponent(value, subject, ownerSupport, counts);\n                // ++subject.global.renderCount\n                return processResult;\n            }\n            case ValueTypes.renderOnce: {\n                getNewGlobal(subject);\n                const support = oneRenderToSupport(value, subject, ownerSupport);\n                renderTagOnly(support, undefined, // support (no prev support)\n                subject, ownerSupport);\n                const result = processNewSubjectTag(support.templater, ownerSupport, subject, appendTo);\n                // ++subject.global.renderCount\n                subject.checkValueChange = checkTagValueChange;\n                return result;\n            }\n        }\n    }\n    if (isArray(value)) {\n        processTagArray(subject, value, ownerSupport, counts, appendTo);\n        subject.checkValueChange = checkArrayValueChange;\n        return;\n    }\n    if (isSubjectInstance(value)) {\n        return; // will be subscribed to for value\n    }\n    processFirstRegularValue(value, subject, subject.placeholder, valueId);\n}\nfunction processFirstRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore, // <template end interpolate /> (will be removed)\nvalueId) {\n    const castedValue = castTextValue(value);\n    const clone = updateBeforeTemplate(castedValue, insertBefore);\n    clone.id = valueId;\n    subject.simpleValueElm = clone;\n    subject.checkValueChange = checkSimpleValueChange;\n}\n","import { processFirstTagResult, processReplaceTagResult } from './processTagResult.function.js';\nimport { getSupport } from '../Support.class.js';\nimport { renderWithSupport } from '../render/renderWithSupport.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag\n    subject, ownerSupport);\n    processReplaceTagResult(support, counts, subject);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    // TODO: This below check not needed in production mode\n    // validateTemplater(templater)\n    const newSupport = getSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const { support } = renderWithSupport(newSupport, global.newest, // existing tag   \n    subject, ownerSupport);\n    processFirstTagResult(support, counts, appendTo);\n    return support;\n}\n","import { subscribeToTemplate } from '../../interpolations/subscribeToTemplate.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { paintAppends } from '../paint.function.js';\nimport { checkTagValueChange } from '../index.js';\nexport function processReplaceTagResult(support, counts, contextItem) {\n    contextItem.checkValueChange = checkTagValueChange;\n    const ph = contextItem.placeholder;\n    const result = buildBeforeElement(support, undefined, // element for append child\n    ph, // placeholder\n    { counts });\n    const subs = result.subs;\n    for (const sub of subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\nexport function processFirstTagResult(support, counts, appendTo) {\n    let appendIndex = paintAppends.length;\n    const result = buildBeforeElement(support, appendTo, undefined, { counts });\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.domElement,\n                relative: appendTo,\n            });\n        }\n        if (dom.marker) {\n            paintAppends.splice(appendIndex++, 0, {\n                element: dom.marker,\n                relative: appendTo,\n            });\n        }\n    }\n    const subs = result.subs;\n    for (const sub of subs) {\n        subscribeToTemplate(sub);\n    }\n    return support;\n}\n","import { updateExistingValue } from '../tag/update/updateExistingValue.function.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nimport { paint } from '../tag/paint.function.js';\nexport function processSubUpdate(value, contextItem, support) {\n    if (value === contextItem.value) {\n        return; // same value emitted\n    }\n    updateExistingValue(contextItem, value, support);\n    if (!setUseMemory.stateConfig.support) {\n        paint();\n    }\n    return;\n}\n","import { processFirstSubjectValue } from '../tag/update/processFirstSubjectValue.function.js';\nimport { processSubUpdate } from './processSubscriptionUpdate.function.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nimport { paint } from '../tag/paint.function.js';\nexport function subscribeToTemplate({ subject, support, counts, contextItem, appendTo, }) {\n    let onValue = function onSubValue(value) {\n        processFirstSubjectValue(value, contextItem, support, { ...counts }, `rvp_-1_${support.templater.tag?.values.length}`, syncRun ? appendTo : undefined);\n        if (!syncRun && !setUseMemory.stateConfig.support) {\n            paint();\n        }\n        // from now on just run update\n        onValue = function subscriptionUpdate(value) {\n            processSubUpdate(value, contextItem, support);\n        };\n    };\n    const callback = function subValueProcessor(value) {\n        onValue(value);\n    };\n    let syncRun = true;\n    const sub = subject.subscribe(callback);\n    contextItem.subject = subject;\n    syncRun = false;\n    const global = support.subject.global;\n    const subs = global.subscriptions = global.subscriptions || [];\n    subs.push(sub);\n}\n","import { getChildTagsToSoftDestroy } from '../getChildTagsToDestroy.function.js';\nimport { getNewGlobal } from '../update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const global = lastSupport.subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.context);\n    softDestroyOne(lastSupport);\n    for (const child of tags) {\n        softDestroyOne(child);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(sub => sub.unsubscribe());\n    }\n    getNewGlobal(lastSupport.subject);\n}\nfunction softDestroyOne(child) {\n    const subject = child.subject;\n    const global = subject.global;\n    if (global.deleted === true) {\n        return;\n    }\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    subject.renderCount = 0;\n    smartRemoveKids(child, [], 0);\n}\n","import { moveProviders } from '../update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../isLikeTags.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous\nsubject, // events & memory\nownerSupport) {\n    const lastTemplater = lastSupport?.templater;\n    const lastTag = lastTemplater?.tag;\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.subject.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    const lastOwnerSupport = lastSupport?.ownerSupport;\n    reSupport.ownerSupport = (ownerSupport || lastOwnerSupport);\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from '../update/processTag.function.js';\nimport { updateSupportBy } from '../updateSupportBy.function.js';\n// TODO: This function is being called for 1st time renders WHEN renderCount === 1\nexport function renderExistingReadyTag(lastSupport, newSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const global = subject.global;\n    const { support, wasLikeTags } = renderWithSupport(newSupport, lastSupport, // renderCount <= 0 ? undefined : lastSupport\n    subject, ownerSupport);\n    if (wasLikeTags) {\n        updateSupportBy(global.oldest, support);\n        return support;\n    }\n    processTag(ownerSupport, subject);\n    return support;\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUse.function.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig.array, callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    return function trigger(...args) {\n        const callbackMaker = support.subject.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, toCallback, oldState, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../tag/render/renderSupport.function.js';\nimport { syncStates } from './syncStates.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, callback, oldState, ...args) {\n    const global = support.subject.global;\n    support = global.newest; // || support\n    const state = support.state;\n    // ensure that the oldest has the latest values first\n    syncStates(state, oldState);\n    // run the callback\n    const maybePromise = callback(...args);\n    // send the oldest state changes into the newest\n    syncStates(oldState, state);\n    renderSupport(support);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            syncStates(oldState, state);\n            renderSupport(support);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUse.function.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig.array;\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(callback);\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.subject.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        strings: strings,\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    return tag;\n}\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    return tag;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/Tag.class.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nconst ondoubleclick = 'ondoubleclick';\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst fragReplacer = /(^:tagvar\\d+:|:tagvar\\d+:$)/g;\nconst safeVar = '__safeTagVar';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\nexport function htmlInterpolationToDomMeta(strings, values) {\n    htmlInterpolationToPlaceholders(strings, values);\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = sanitizePlaceholders(strings);\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction sanitizePlaceholders(fragments) {\n    return fragments.map(fragment => fragment.replace(fragReplacer, (match, index) => safeVar + index));\n}\nfunction addPlaceholders(strings, values) {\n    const results = strings.map((fragment, index) => {\n        if (index < values.length) {\n            return fragment + variablePrefix + index + variableSuffix;\n        }\n        return fragment;\n    });\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                textVarMatches.forEach(textContent => {\n                    if (textContent.startsWith(variablePrefix)) {\n                        textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                });\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n            const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n            let attrValue = attrChoice;\n            if (attrName === undefined) {\n                continue;\n            }\n            const notEmpty = attrMatch[2] !== '';\n            const noValue = attrValue === undefined && notEmpty;\n            const lowerName = attrName.toLowerCase();\n            const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n            if (noValue) {\n                const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n                if (standAloneVar) {\n                    const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                    valuePositions.push(['at', valueName]);\n                    attributes.push([valueName]); // the name itself is dynamic\n                    continue;\n                }\n                const startMatched = attrMatch[0].startsWith(attrName);\n                const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n                if (standAloneAttr) {\n                    attributes.push([fixedName]);\n                    continue;\n                }\n                const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n                attrValue = valueName;\n            }\n            if (!notEmpty) {\n                attrValue = attrMatch[2];\n            }\n            const attrSet = [fixedName, attrValue];\n            const isSpecial = isSpecialAttr(fixedName);\n            if (isSpecial) {\n                attrSet.push(isSpecial);\n            }\n            attributes.push(attrSet);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            textVarMatches.forEach(textContent => {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                return pushTextTo(currentElement, elements, textContent);\n            });\n        }\n    }\n    return elements;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(part => part !== '');\n    return filteredParts;\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postprocessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction postprocessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\n","// taggedjs-no-compile\nimport { variableSuffix, variablePrefix } from \"../../tag/Tag.class.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nconst placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, ...[{\n                    nn: 'text',\n                    v: wIndex\n                }]);\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    return attributes.map(attrSet => {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [{ tagJsVar: index }];\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                return [key, { tagJsVar: index }, isSpecial];\n            }\n        }\n        return attrSet;\n    });\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/Tag.class.js\";\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nexport const safeVar = '__safeTagVar';\nexport function restorePlaceholders(elements) {\n    elements.forEach(traverseAndRestore);\n}\nconst safeReplacer = /__safeTagVar(\\d+)/g;\nfunction traverseAndRestore(element) {\n    if (element.at) {\n        element.at = element.at ? element.at.map(attr => {\n            if (attr.length === 1) {\n                return attr;\n            }\n            const [, value] = attr;\n            if (typeof value === ImmutableTypes.string && value.startsWith(safeVar)) {\n                const index = parseInt(value.replace(safeVar, ''), 10);\n                attr[1] = variablePrefix + index + variableSuffix;\n            }\n            return attr;\n        }) : [];\n    }\n    if (element.ch) {\n        const children = element.ch;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.nn === 'text') {\n                if (typeof child.tc !== ImmutableTypes.string) {\n                    return;\n                }\n                child.tc = child.tc.replace(safeReplacer, (_match, index) => variablePrefix + index + variableSuffix);\n            }\n            traverseAndRestore(child);\n        }\n        // Remove empty children array\n        if (children.length === 0) {\n            delete element.ch;\n        }\n    }\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { restorePlaceholders } from '../interpolations/optimizers/restorePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    // Restore any sanitized placeholders in text nodes\n    restorePlaceholders(map);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(x => x.length);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { getStringTag, getDomTag } from './Tag.class.js';\nimport { PropWatches } from './tag.js';\nimport { getTemplaterResult } from './TemplaterResult.class.js';\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { getBaseSupport } from './Support.class.js';\nimport { subscribeToTemplate } from '../interpolations/subscribeToTemplate.function.js';\nimport { buildBeforeElement } from './buildBeforeElement.function.js';\nimport { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { checkTagValueChange, PropWatches } from './index.js';\nimport { setUseMemory } from '../state/setUse.function.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { beforeRerender } from './render/beforeRerender.function.js';\nconst appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        destroySupport(appElements[appElmIndex].support, 0);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    // todo: props should be an array\n    templater.props = [props];\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest, setUseMemory.stateConfig);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    const placeholder = document.createTextNode('');\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        destroySupport(support, 0); // never return anything here\n        paint();\n    };\n    let tags = []; // TagWrapper<unknown>[]\n    ++painting.locks;\n    const result = buildBeforeElement(support, element);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        // const parentWrap = wrap.parentWrap\n        // const original = (wrap as unknown).original || parentWrap.original as Original\n        //  const original = parentWrap.original as Original\n        setUse = original.setUse;\n        tags = original.tags;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    for (const sub of result.subs) {\n        subscribeToTemplate(sub);\n    }\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nfunction getNewSubject(templater, appElement) {\n    const subject = {\n        value: templater,\n        checkValueChange: checkTagValueChange,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n    };\n    const global = getNewGlobal(subject);\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\nfunction loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const useSupport = global.newest;\n    const oldest = global.oldest;\n    const isFirstRender = useSupport === oldest;\n    if (!isFirstRender) {\n        beforeRerender(useSupport, oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = (templater.wrapper || { original: templater });\n        if (!isAppFunction) {\n            const newSupport = loadNewBaseSupport(templater, subject, appElement);\n            const nowState = setUseMemory.stateConfig.array;\n            newSupport.state = nowState;\n            runAfterRender(newSupport);\n            return newSupport;\n        }\n        const nowSupport = executeWrap(templater, result, useSupport);\n        runAfterRender(nowSupport);\n        return nowSupport;\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(useSupport, subject);\n    runAfterRender(nowSupport);\n    return nowSupport;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","export * from './tag/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport * from './state/index.js';\nexport * from './subject/index.js';\nexport * from './interpolations/index.js';\nexport * from './tag/Support.class.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './interpolations/attributes/ElementTargetEvent.interface.js';\nimport { renderTagOnly } from './tag/render/renderTagOnly.function.js';\nimport { renderSupport } from './tag/render/renderSupport.function.js';\nimport { renderWithSupport } from './tag/render/renderWithSupport.function.js';\nexport { key } from './tag/key.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './tag/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","subject","renderCount","global","RouteQuery","_name","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","tagJsSubject","renderOnce","stateRender","version","Date","now","isSimpleType","value","string","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","isObject","subscribe","function","isPromise","isFunction","then","object","isArray","Array","combineLatest","subjects","output","Subject","subscribeWith","callback","valuesSeen","values","setValue","x","index","length","item","subscription","clones","shift","subscriptions","map","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","splice","removeSubFromArray","valSub","add","push","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","handler","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","_subscription","pipe","operations","setMethods","all","args","arg","static","Subjective","_value","super","defineValueOn","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","runRestate","config","setUseMemory","stateConfig","restate","rearray","array","defaultValue","runFirstState","initValue","original","getStateValue","initState","support","handlers","letHandler","firstLetState","StateEchoBack","state","oldState","checkValue","getCallbackValue","letState","makeStateResult","reLetState","oldValue","y","syncStates","stateFrom","stateTo","fromValue","watch","currentValues","setupWatch","defaultFinally","init","before","final","previous","pastResult","undefined","previousValues","result","every","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","getSupportInCycle","method","nowSupport","setTo","oldest","oldestState","letProp","getSetProp","myProp","newWatch","providers","create","constructMethod","stateDiffMemory","stateDiff","provider","oldStateCount","instance","owner","children","cm","compareTo","toString","inject","ownerSupport","ownerProviders","find","msg","name","console","warn","Error","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","deepClone","maxDepth","makeDeepClone","RegExp","clone","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","getTemplaterResult","propWatch","props","arrayValue","tags","cloneValueArray","cloneTagJsValue","getBaseSupport","castedProps","baseSupport","appSupport","blocked","destroy$","propsConfig","castProps","PropWatches","IMMUTABLE","latest","SHALLOW","shallowCompareDepth","deepCompareDepth","clonePropsBy","getSupport","getHtmlSupport","newSupport","depth","checkProp","alterProp","already","mem","wrap","toCall","callWith","newest","noCycle","callbackResult","run","locked","isInline","isInlineHtml","renderInlineHtml","renderExistingReadyTag","safeRenderSupport","tagClosed$","callbackPropOwner","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","executeWrap","useSupport","originalFunction","nowState","getCastedProps","lastSupport","DEEP","preCastedProps","lastPropsConfig","lastCastProps","syncFunctionProps","html","tagCount","parentWrap","innerTagWrap","getTagWrap","wrapper","setUse","tagIndex","hasSupportChanged","newTemplater","propsChanged","pastCloneProps","hasLenChanged","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","hasPropChanges","len","pastProp","obEntries","subItem","objectItemMatches","route","_routeProps","app","_routeTag","deepPropWatch","immutableProps","watchProps","oneRenderFunction","renderFunction","onDelete","compareOriginal","pastValue","paintRemoves","paintContent","setContent","paintAppends","paintInsertBefores","paintAfters","painting","locks","paint","toRemove","parentNode","removeChild","content","text","textNode","textContent","relative","appendChild","element","insertBefore","updateBeforeTemplate","lastFirstChild","document","createTextNode","castTextValue","howToSetInputValue","setAttribute","removeAttribute","specialAttribute","specialName","nextSibling","counts","onInitDoubleWrap","oninit","added","onInitWrap","tagFunction","onInit","target","stagger","elementInitCheck","removed","focus","select","names","split","style","classList","remove","processSpecialClass","handleProviderChanges","tagsWithProvider","memory","childTags","child","cSubject","getTagsWithProvider","getUpTags","supports","inlineHtml","isComponent","continueUp","selfPropChange","nowProps","latestProps","hasPropsToOwnerChanged","checkRenderUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","renderTagUpdateArray","forEach","mapTagUpdate","noData","promiseNoData","bindSubjectCallback","subjectFunction","deleted","bindTo","component","apply","eventHandlerSupport","last","checkAfterCallbackPromise","renderCallbackSupport","afterTagCallback","runTagCallback","processNonDynamicAttr","attrName","howToSet","isSpecial","addSupportEventListener","eventName","elm","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","processAttributeFunction","newAttrValue","fun","isSpecialAttr","startsWith","specialAction","isSpecialAction","processAttribute","context","nameVar","getTagJsVar","contextItem","addOneContext","isAttr","isNameOnly","processNameOnlyAttrValue","valueVar","checkValueChange","checkSimpleValueChange","withinOwnerElement","contextValueSubject","processAttributeEmit","processNameValueAttributeAttrSubject","processTagCallbackFun","processDynamicNameValueAttribute","attrValue","isNoDisplayValue","processAttributeSubjectValue","callbackFun","prevFun","attrPart","tagJsVar","attachDomElements","nodes","createElement","node","newNode","v","isNaN","attachDynamicDom","nn","tc","innerHTML","domElement","innerText","id","at","attr","ch","subVal","marker","placeholder","appendTo","processFirstSubjectValue","buildBeforeElement","options","domMeta","thisTag","getDomMeta","strings","loadDomMeta","getHtmlDomMeta","htmlDomMeta","processTag","checkTagValueChange","subscribeToTemplate","getFakeTemplater","newSupportByTemplater","processUpdateAttrContext","updateNameOnlyAttrValue","processUpdateOneContext","updateExistingValue","updateSupportBy","olderSupport","newerSupport","tempTag","updateSupportValuesBy","processUpdateContext","wasDestroyed","processReplacementComponent","oldWrapper","newWrapper","isSameTag","skipComparing","isLikeTags","oldestSupport","destroySupport","swapTags","hasChanged","newProps","syncSupports","updateExistingTagComponent","prepareUpdateToComponent","valueSupport","newGlobal","handleStillTag","updateContextItemBySupport","processTagArray","castedValue","simpleValueElm","processNowRegularValue","processNewTag","runBeforeDestroy","getChildTagsToDestroy","lastArray","iSubs","iSub","getChildTagsToSoftDestroy","subTags","smartRemoveKids","promises","startStagger","thisGlobal","destroyArray","oldClones","newPromises","customElm","ondestroy","promise","onDestroyWrap","onDestroy","elementDestroyCheck","checkCloneRemoval","filter","destroyClones","runtimeInsertBefore","filteredLast","newRemoved","reviewLastArrayItem","eAppendTo","reviewArrayItem","itemSubject","couldBeSame","processAddTagArrayItem","reviewPreviousArrayItem","subPlaceholder","processNewArrayValue","destroyArrayItem","_subTag","newLength","lessLength","prev","support0","support1","templater0","templater1","tag0","tag1","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings1","values0","values1","valuesLengthsMatch","allVarsMatch","isLikeValueSets","isLikeStringTags","checkArrayValueChange","oldClone","processUpdateRegularValue","isTag","oneRenderToSupport","beforeRerender","prevState","reState","checkStateMismatch","oldStates","newStates","error","hint","throwStateMismatch","runAfterRender","renderTagOnly","prevSupport","oldRenderCount","reSupport","processNewSubjectTag","valueId","tagFakeTemplater","processResult","newPropsConfig","renderWithSupport","appendIndex","processFirstTagResult","processFirstSubjectComponent","processFirstRegularValue","processSubUpdate","onValue","syncRun","processReplaceTagResult","newPropsArray","priorPropsArray","newArray","syncPriorPropFunction","priorProp","updateExistingArray","hasSetter","updateExistingObject","softDestroySupport","softDestroyOne","lastTemplater","lastTag","isLikeTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","lastOwnerSupport","wasLikeTags","pop","ownGlobal","syncError","createTrigger","maybePromise","finally","callbackStateUpdate","callbackMaker","variablePrefix","variableSuffix","getStringTag","getDomTag","ondoubleclick","fragFindAny","fragReplacer","safeVar","regexAttr","regexTagOrg","htmlInterpolationToDomMeta","htmlInterpolationToPlaceholders","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","slice","trim","splitByTagVar","pushTextTo","attributes","attrMatch","notEmpty","noValue","lowerName","toLowerCase","fixedName","cleanEventName","valueName","search","attrSet","parseHTML","join","results","fragment","diff","balanceArrayByArrays","addPlaceholders","inputString","part","pushTo","postprocessTagsInComments","placeholderRegex","replacePlaceholders","valueCount","currentTail","loopTail","attrs","processAttributes","innerLoopTail","examineChild","textChild","secondMatch","wIndex","parseInt","varContent","after","lastIndex","safeReplacer","traverseAndRestore","_match","lastRuns","stringId","Number","getStringsId","lastRun","matches","isLastRunMatched","domMetaMap","template","interpolation","stringTag","appElements","tagElement","appElmIndex","appElm","templater2","loadNewBaseSupport","getNewSubject","isAppFunction","runWrapper","isApp","destroy","removeEventListener","newFragment","createDocumentFragment","domItem","putOneDomDown","hmr"],"sourceRoot":""}