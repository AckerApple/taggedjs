{"version":3,"file":"bundle.js","mappings":"AACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,KCA3E,SAASI,EAAaC,GAGzB,OADAA,EAAYC,YAAcD,EAAYC,aAAe,EAC9CD,EAAYE,OAAS,CAAC,CACjC,C,+2BCJO,MAAMC,EACT,GAAAV,CAAIW,GACA,MAAO,MACX,ECFG,MAAMC,EAAiB,UACjBC,EAAiB,ICDvB,SAASC,EAAcC,GAC1B,GAAIA,EAASC,WAAW,UACpB,MAAO,QAEX,MAAMC,EASH,SAAyBF,GAC5B,OAAQA,GACJ,IAAK,aACD,MAAO,aACX,IAAK,YACD,MAAO,YAEf,OAAO,CACX,CAjB0BG,CAAgBH,GACtC,OAAsB,IAAlBE,EACOA,IAEPF,EAASC,WAAW,WACb,OAGf,CCZO,MAAMG,EAAmB,IAAIC,OAAOR,EAAiB,SAAWC,EAAgB,KAChF,SAASQ,EAAeC,GAC3B,OAAIA,EAAMC,QAAUD,EAAMN,WAAWJ,GAC1BU,EAAMC,OAAOJ,IAEhB,CACZ,CCHA,MAAMK,EAAc,gBACdC,EAAgB,gBAChBC,EAAY,sDACZC,EAAc,2GAEb,SAASC,EAAUC,GACtB,MAAMC,EAAiB,GACjBC,EAAW,GACXC,EAAQ,GACd,IAAIC,EAAiB,KACjBC,GAAc,EACdC,EAAW,EACf,MAAMC,EAAW,IAAIhB,OAAOO,EAAa,KAEzC,IADAE,EAqEJ,SAAkCA,GAE9B,OAAOA,EAAKQ,QAAQC,GAAmB,SAAUC,GAE7C,OAAOA,EAAMF,QAAQ,WAAY,cAAcA,QAAQ,WAAY,cAAcA,QAAQ,KAAM,SAASA,QAAQ,KAAM,QAC1H,GACJ,CA3EWG,CAAyBX,GACzBM,EAAWN,EAAKY,QAAQ,CAC3B,MAAMC,EAAWN,EAASO,KAAKd,GAC/B,IAAKa,EACD,MAEJ,MAAOE,EAAWC,EAASC,GAAcJ,EACnCK,EAAeH,EAAU5B,WAAW,MACpCgC,EAAgBJ,EAAUK,SAAS,MACzC,GAAId,EAAWO,EAASQ,MAAO,CAC3B,MAAMC,EAActB,EAAKuB,MAAMjB,EAAUO,EAASQ,OAClD,GAAIC,EAAYE,OAAQ,CACpB,MAAMC,EAAiBC,EAAcJ,GACrC,IAAK,IAAIA,KAAeG,EAChBH,EAAYnC,WAAWJ,IAAmBuC,EAAY5B,OAAOC,IAAgB,IAElC,IAAvC2B,EAAY5B,OAAOiC,KACnBL,EAAcvC,KAAoBsB,EAAcrB,GAGxD4C,EAAWxB,EAAgBF,EAAUoB,EAE7C,CACJ,CAEA,GADAhB,EAAWO,EAASQ,MAAQN,EAAUH,OAClCM,EAAc,CACdd,EAAiBD,EAAM0B,OAAS,KAChC,QACJ,CACA,MAAMC,EAAa,GACnB,IAAIC,EACJ,KAAoD,QAA5CA,EAAYlC,EAAUiB,KAAKG,KAC/BZ,EAAa2B,EAAgBD,EAAW1B,EAAYJ,EAAgB6B,GAExE,MAAMG,EAAU,CACZC,GAAIlB,GAEJc,EAAWlB,SACXqB,EAAQE,GAAKL,GAEb1B,GACKA,EAAegC,KAChBhC,EAAegC,GAAK,IAExBhC,EAAegC,GAAGC,KAAKJ,IAGvB/B,EAASmC,KAAKJ,GAEbd,IACDhB,EAAMkC,KAAKjC,GACXA,EAAiB6B,EAEzB,CACA,GAAI3B,EAAWN,EAAKY,OAAQ,CACxB,MAAMU,EAActB,EAAKuB,MAAMjB,GAC/B,GAAIgB,EAAYE,OAAQ,CACpB,MAAMC,EAAiBC,EAAcJ,GACrC,IAAK,MAAMA,KAAeG,EAClBH,EAAYnC,WAAWJ,MACrBsB,EAENuB,EAAWxB,EAAgBF,EAAUoB,EAE7C,CACJ,CACA,OAAOpB,CACX,CACA,MAAMO,EAAoB,IAAIlB,OAAO,4BAAuB,KAkB5D,SAASqC,EAAWxB,EAAgBF,EAAUoB,IAe9C,SAAgBlB,EAAgBF,EAAUoC,GAClClC,GACKA,EAAegC,KAChBhC,EAAegC,GAAK,IAExBhC,EAAegC,GAAGC,KAAKC,IAGvBpC,EAASmC,KAAKC,EAEtB,CApBIC,CAAOnC,EAAgBF,EAJN,CACbgC,GAAI,OACJM,GAAIC,EAA0BnB,IAGtC,CAEA,SAASmB,EAA0BzC,GAE/B,OAAOA,EAAKQ,QAAQ,kCAAkC,SAAUE,GAE5D,OAAOA,EAAMF,QAAQ,WAAY,KAAKA,QAAQ,WAAY,KAAKA,QAAQ,gBAAiB,SAASA,QAAQ,gBAAiB,QAC9H,GACJ,CAYA,SAASkB,EAAcgB,GAKnB,OAHcA,EAAYC,MAAMhD,GAEJiD,OAAOC,EAEvC,CACA,SAASA,EAAqBC,GAC1B,MAAgB,KAATA,CACX,CACA,SAASd,EAAgBD,EAAW1B,EAAYJ,EAAgB6B,GAC5D,MAAM5C,EAAW6C,EAAU,IAAMA,EAAU,IAAMA,EAAU,GAE3D,IAAIgB,EADehB,EAAU,IAAMA,EAAU,IAAMA,EAAU,GAE7D,QAAiBiB,IAAb9D,EACA,OAAOmB,EAEX,MAAM4C,EAA4B,KAAjBlB,EAAU,GACrBmB,OAAwBF,IAAdD,GAA2BE,EACrCE,EAAYjE,EAASkE,cACrBC,EAAYF,EAAUhE,WAAW,MAxD3C,SAAwBmE,GACpB,GAAIA,EAAUnE,WAAW,MAErB,OADwBmE,EAAU1C,SAAWhB,EAAcgB,QAAU0C,IAAc1D,EAExE,WAEJ0D,EAAU/B,MAAM,EAAG+B,EAAU1C,QAExC,OAAO0C,CACX,CA+CmDC,CAAeJ,GAAaA,EAC3E,GAAID,EAAS,CAET,GADsBhE,EAASqC,MAAM,EAAGxC,EAAe6B,UAAY7B,EAChD,CACf,MAAMyE,EAAYzE,KAAoBsB,EAAcrB,EAGpD,OAFAiB,EAAeoC,KAAK,CAAC,KAAMmB,IAC3B1B,EAAWO,KAAK,CAACmB,IACVnD,CACX,CAGA,GAFqB0B,EAAU,GAAG5C,WAAWD,IACN6C,EAAU,GAAGR,MAAMrC,EAAS0B,OAAQmB,EAAU,GAAGnB,QAAQlB,OAAO,SAAW,EAG9G,OADAoC,EAAWO,KAAK,CAACgB,IACVhD,EAEX,MAAMoD,EAAa1B,EAAU,GAE7B,GADkB0B,EAAW/D,OAAOiC,IAAkB,EACvC,CACXoB,EAAYU,EAEZ,MAAMC,EAAU,CAACL,EAAWN,GAE5B,OADAjB,EAAWO,KAAKqB,GACTrD,CACX,CAGI0C,EADkBhE,KAAoBsB,EAAcrB,CAG5D,CACKiE,IACDF,EAAYhB,EAAU,IAG1B,MAAM4B,EAAiBZ,EAAUJ,MAAMiB,GAAmBhB,QAAQiB,GAAMA,EAAEjD,OAAS,IAC/E+C,EAAe/C,OAAS,IACxBmC,EAAYY,EACZA,EAAeG,SAASrE,IAChBA,EAAMC,OAAOJ,IAAqB,KAChCe,CACN,KAGR,MAAMqD,EAAU,CAACL,EAAWN,GACtBgB,EAAY9E,EAAckE,GAKhC,OAJIY,GACAL,EAAQrB,KAAK0B,GAGC,UAAdV,GACAvB,EAAWkC,QAAQN,GACZrD,IAEXyB,EAAWO,KAAKqB,GACTrD,EACX,CCzMO,MAAM4D,EAAgB,IAAI1E,OAAOR,EAAiB,SAAWC,EAAgB,MACvE4E,EAAoB,IAAIrE,OAAO,IAAMR,EAAiB,OAASC,EAAiB,IAAK,MAE5FkF,EAAanF,EAAewC,MAAM,EAAGxC,EAAe6B,OAAS,GACtDe,EAAgB,IAAIpC,OAAO2E,EAAa,eAAiBlF,EAAgB,MAEhFmF,EAAcD,EAAa,WAAalF,EAEvC,SAASoF,EAA2BC,EAASC,GAEhD,MAAMC,EAIH,SAAyCF,EAASC,GAErD,MAAME,EAAqBH,EAG3B,OAEJ,SAAyBA,EAASC,GAC9B,MAAMG,EAAU,GAChB,IAAK,IAAIpD,EAAQ,EAAGA,EAAQgD,EAAQzD,SAAUS,EAAO,CACjD,MACMqD,EADWL,EAAQhD,GACKb,QAAQyD,EAAeE,GACjD9C,EAAQiD,EAAO1D,OACf6D,EAAQpC,KAAKqC,EAAe3F,EAAiBsC,EAAQrC,GAGzDyF,EAAQpC,KAAKqC,EACjB,CAEA,OAEG,SAA8BD,EAASJ,EAASC,GACnD,MAAMK,EAAOL,EAAO1D,OAASyD,EAAQzD,OACrC,GAAI+D,EAAO,EACP,IAAK,IAAId,EAAIc,EAAMd,EAAI,IAAKA,EACxBY,EAAQpC,KAAKtD,GAAkBsF,EAAQzD,OAASiD,EAAI,GAAK7E,EAGrE,CAVI4F,CAAqBH,EAASJ,EAASC,GAChCG,CACX,CAfWI,CAAgBL,EAAoBF,EAC/C,CAVuBQ,CAAgCT,EAASC,GAAQS,KAAK,IAEzE,OADgBhF,EAAUwE,EAE9B,CCfO,MAAMS,EAAQ,GACd,IAAIC,EAOAC,GANX,SAAWD,GACPA,EAAuB,OAAI,SAC3BA,EAAuB,OAAI,SAC3BA,EAAwB,QAAI,UAC5BA,OAAe,GAAe,WACjC,CALD,CAKGA,IAAmBA,EAAiB,CAAC,IAExC,SAAWC,GACPA,EAAqB,SAAI,WACzBA,EAAiB,KAAI,OACrBA,EAAoB,QAAI,UACxBA,EAAmB,OAAI,QAC1B,CALD,CAKGA,IAAeA,EAAa,CAAC,IAChC,MAEaC,EAAa,CACtBC,IAAK,OACLC,IAAK,MACLC,UAAW,YACXC,aAAc,eACdC,SAAU,WACVC,KAAM,OACNC,UAAW,YACXC,OAAQ,SACRC,WAAY,aACZC,YAAa,cACbC,QAbYC,KAAKC,OCXf5D,EAAK,KACJ,SAAS6D,EAAoBZ,EAAKa,EAAYjG,EAAiB,GAAIkG,EAAc,IACpF,MAAMjG,EAAWmF,EACjB,IAAK,IAAIe,EAAI,EAAGA,EAAIlG,EAASU,OAAQwF,IAAK,CACtC,MAAMC,EAAW,IAAIF,EAAaC,GAC5BnE,EAAU/B,EAASkG,GACzB,GAAInE,EAAQE,GAAI,CACZ,MAAMmE,EAAQrE,EAAQE,GACtBF,EAAQE,GAAKoE,EAAkBD,EAAOJ,EAC1C,CACA,GAAIjE,EAAQG,GAAI,CACZ,MAAMoE,EAAWvE,EAAQG,GACnBqE,EAAgB,IAAIJ,EAAUjE,GACpCH,EAAQG,GAAK6D,EAAoBO,EAAUN,EAAYjG,EAAgBwG,EAC3E,CACAL,EAAIM,EAAazE,EAASiE,EAAYhG,EAAUkG,EACpD,CACA,OAAOlG,CACX,CACA,SAASwG,EAAaC,EAAOT,EAAYM,EAAUnF,GAC/C,GAAiB,SAAbsF,EAAMzE,GACN,OAAOb,EAEX,MAAMuF,EAAYD,EAClB,IAIIjG,EAJAY,EAAcsF,EAAUpE,GAC5B,UAAWlB,IAAgB2D,EAAe4B,OACtC,OAAOxF,EAGX,KAAwD,QAAhDX,EAAQpB,EAAiBwB,KAAKQ,KAAwB,CAC1D,MAAMwF,EAAcpG,EAAM,GACpBqG,EAASC,SAASF,EAAa,IAErC,IADiBG,MAAMF,IAAWA,EAASb,EAC9B,CACT,MAAMgB,EAAanI,EAAiBgI,EAAS/H,EACvCmI,EAAQ7F,EAAYC,MAAMb,EAAMW,MAAQ6F,EAAWtG,QACzD4F,EAASY,OAAO/F,EAAO,EAAG,CACtBa,GAAI,OACJmF,EAAGN,IAEPzF,EAAc6F,EACd7H,EAAiBgI,UAAY,CACjC,CACJ,CAEA,OADAV,EAAUpE,GAAKlB,EACRD,CACX,CACA,SAASkF,EAAkBzE,EAAYoE,GACnC,MAAMqB,EAAS,GACf,IAAK,MAAM7D,KAAW5B,EAAY,CAC9B,MAAOhE,EAAK2B,EAAOsE,GAAaL,EAChC,GAAI5F,EAAIqB,WAAWJ,GAAiB,CAChC,MAAMsC,EAAQ2F,SAASlJ,EAAI0C,QAAQzB,EAAgB,IAAK,IACxD,IAAKkI,MAAM5F,IAAUA,EAAQ6E,EAAY,CACrCqB,EAAOlF,KAAK,CAAC,CAAEmF,SAAUnG,KACzB,QACJ,CACJ,CACA,UAAW5B,IAAUwF,EAAe4B,QAAUpH,EAAMN,WAAWJ,GAAiB,CAC5E,MAAMsC,EAAQ2F,SAASvH,EAAMe,QAAQzB,EAAgB,IAAK,IAC1D,IAAKkI,MAAM5F,IAAUA,EAAQ6E,EAAY,CACrCqB,EAAOlF,KAAK,CAACvE,EAAK,CAAE0J,SAAUnG,GAAS0C,IACvC,QACJ,CACJ,CACAwD,EAAOlF,KAAKqB,EAChB,CACA,OAAO6D,CACX,CCnEA,SAASE,EAAa5D,GAClB,OAAOA,EAAEjD,MACb,CCFA,MAAM8G,EAAW,CAAC,EAEX,SAASC,EAAWtD,EAASC,GAChC,MAAMsD,EDRH,SAAsBvD,GACzB,MAAMwD,EAAQxD,EAAQyD,IAAIL,GAE1B,OADAI,EAAMxF,KAAKgC,EAAQzD,QACZmH,OAAOF,EAAM9C,KAAK,IAC7B,CCIqBiD,CAAa3D,GACxB4D,EAAUP,EAASE,GACnBM,EAAUD,GCVb,SAA0B5D,EAASC,EAAQ2D,GAC9C,GAAIA,GACIA,EAAQ5D,QAAQzD,SAAWyD,EAAQzD,QACdqH,EAAQ5D,QAAQ8D,OAAM,CAACtB,EAAQxF,IAEpDwF,IAAWxC,EAAQhD,MACC4G,EAAQ3D,OAAO1D,SAAW0D,EAAO1D,OACjD,OAAO,EAInB,OAAO,CACX,CDF+BwH,CAAiB/D,EAASC,EAAQ2D,GAC7D,GAAIC,EACA,OAAOD,EAAQI,WAEnB,MACMP,EAAM7B,EADI7B,EAA2BC,EAASC,GACXA,EAAO1D,QAC1C0H,EAAW,CACbC,mBAAevF,EACf6D,YAAQ7D,EACRqB,UACAC,SACA+D,WAAYP,GAGhB,OADAJ,EAASE,GAAYU,EACdR,CACX,CEvBO,SAASU,EAAmBvG,EAASwG,EAAMhJ,GAC9CiJ,GAAarG,KAAK,CAACsG,EAAyB,CAAC1G,EAASwG,EAAMhJ,IAChE,CACO,SAASkJ,EAAwB1G,EAASwG,EAAMhJ,QACrCuD,IAAVvD,IAAiC,IAAVA,GAA6B,OAAVA,EAI9CwC,EAAQ2G,aAAaH,EAAMhJ,GAHvBwC,EAAQ4G,gBAAgBJ,EAIhC,CCTO,SAASK,EAAiBL,EAAMhJ,EAAOwC,EAAS8G,GACnD,OAAQA,GACJ,IAAK,YAED,YADAL,GAAarG,KAAK,CAAC2G,EAAW,CAAC/G,KAEnC,IAAK,aAED,YADAyG,GAAarG,KAAK,CAAC4G,EAAY,CAAChH,KAEpC,IAAK,QAAS,CACV,MAAMiH,EAAQT,EAAK9F,MAAM,KAEzB,YADA+F,GAAarG,KAAK,CAAC8G,EAAY,CAAClH,EAASiH,EAAOzJ,IAEpD,CACA,IAAK,QAED,YASZ,SAA6BgJ,EAAMhJ,EAAOwC,GACtC,MAAMiH,EAAQT,EAAK9F,MAAM,KAGzB,GAFAuG,EAAME,QAEF3J,EAAO,CACP,IAAK,MAAMgJ,KAAQS,EACfR,GAAarG,KAAK,CAACgH,EAAc,CAACpH,EAASwG,KAE/C,MACJ,CAEA,IAAK,MAAMA,KAAQS,EACfR,GAAarG,KAAK,CAACiH,EAAiB,CAACrH,EAASwG,IAEtD,CAxBYc,CAAoBd,EAAMhJ,EAAOwC,GAGzC,MAAM,IAAIuH,MAAM,gCAAgCT,MAAgBN,IACpE,CACA,SAASU,EAAWlH,EAASiH,EAAOzJ,GAChC,MAAMgK,EAAYP,EAAM,GACxBjH,EAAQyH,MAAMD,GAAahK,EAC3BwC,EAAQyH,MAAMC,YAAYF,EAAWhK,EACzC,CAgBA,SAAS4J,EAAapH,EAASwG,GAC3BxG,EAAQ2H,UAAUC,IAAIpB,EAC1B,CACA,SAASa,EAAgBrH,EAASwG,GAC9BxG,EAAQ2H,UAAUE,OAAOrB,EAC7B,CACA,SAASQ,EAAWhH,GAChBA,EAAQ8H,QACZ,CACA,SAASf,EAAU/G,GACfA,EAAQ+H,OACZ,CCnDO,SAASC,EAAaxK,GACzB,OAAQA,GACJ,KAAKwF,EAAe4B,OACpB,KAAK5B,EAAeiF,OACpB,KAAKjF,EAAekF,QAChB,OAAO,EAEf,OAAO,CACX,CAEO,SAASC,EAAY3K,GACxB,IAAKA,EACD,OAAO,EAGX,OADkBA,EAAM4K,WAEpB,KAAKlF,EAAWE,IAChB,KAAKF,EAAWC,IAChB,KAAKD,EAAWG,UACZ,OAAO,EAEf,OAAO,CACX,CAEO,SAASgF,EAAe7K,GAC3B,MAAM8K,EAAU9K,GAAO4K,UACvB,OAAOE,IAAYpF,EAAWI,cAAgBgF,IAAYpF,EAAWU,WACzE,CAEO,SAAS2E,EAAkBC,GAC9B,OAAOC,EAASD,WAAmBA,EAAQ/E,YAAcR,EAAWyF,QACxE,CACO,SAASC,EAAUnL,GACtB,OAAOA,GAASoL,EAAWpL,EAAMqL,KACrC,CACO,SAASD,EAAWpL,GACvB,cAAcA,IAAUyF,EAAWyF,QACvC,CACO,SAASD,EAASjL,GACrB,cAAc,IAAYyF,EAAW6F,QAAoB,OAAVtL,CACnD,CACO,SAASuL,EAAQvL,GACpB,OAAOwL,MAAMD,QAAQvL,EACzB,CC5CO,SAASyL,EAAsBC,EAAYC,GAC9C,MAAMC,EAIV,SAA6BC,EAASF,EAAUG,EAAS,IACrD,MAAMd,EAAUa,EAAQE,QACxBD,EAAOlJ,KAAK,CACRiJ,UACA3M,YAAa8L,EAAQ9L,YACrByM,aAEJ,MAAMK,EAAYL,EAAS5E,SAC3B,IAAK,IAAInF,EAAQoK,EAAU7K,OAAS,EAAGS,GAAS,IAAKA,EAAO,CACxD,MAAMsF,EAAQ8E,EAAUpK,GAClBqK,EAAW/E,EAAM6E,QACvBD,EAAOlJ,KAAK,CACRiJ,QAAS3E,EACThI,YAAa+M,EAAS/M,YACtByM,YAER,CACA,OAAOG,CACX,CAtB6BI,CAAoBR,EAAYC,GACzD,OAAOC,CACX,CCaA,SAASO,GAAa/H,GAClB,OAAOA,EAAEyH,OACb,CChBO,SAASO,GAAUzN,EAAK0N,GAE3B,OAAOC,GAAc3N,EAAK0N,EAC9B,CACA,SAASC,GAAc3N,EAEvB0N,GAEI,GAAY,OAAR1N,UAAuBA,IAAQ8G,EAAW6F,OAC1C,OAAO3M,EAQX,GAAI0N,EAAW,EACX,OAAO1N,EAGX,GAAIA,aAAe2H,KACf,OAAO,IAAIA,KAAK3H,GAEpB,GAAIA,aAAemB,OACf,OAAO,IAAIA,OAAOnB,GAGtB,MAAM4N,EAAQhB,EAAQ5M,GAAO,GAAKJ,OAAOiO,OAAOjO,OAAOkO,eAAe9N,IAEtE,GAAI4M,EAAQ5M,GACR,IAAK,IAAIgI,EAAI,EAAGA,EAAIhI,EAAIwC,OAAQwF,IAC5B4F,EAAM5F,GAAK2F,GAAc3N,EAAIgI,GAAI0F,EAAW,QAIhD,IAAK,MAAMhO,KAAOM,EACVJ,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKN,KAC1CkO,EAAMlO,GAAOiO,GAAc3N,EAAIN,GAAMgO,EAAW,IAI5D,OAAOE,CACX,CACO,SAASG,GAAUC,EAAMC,EAAMP,GAClC,OAAOQ,GAAYF,EAAMC,EAAMP,EACnC,CACA,SAASQ,GAAYF,EAAMC,EAE3BP,GAEI,QADoBM,IAASC,IA2DRE,EA1DcH,EA0DTI,EA1DeH,GA2DpBxB,EAAW0B,KAAQ1B,EAAW2B,IAC5BD,EAAIE,aAAeD,EAAIC,eAvD1CX,EAAW,UAGJM,IAASlH,EAAW6F,eAAiBsB,IAASnH,EAAW6F,SAE5DqB,aAAgBrG,MAAQsG,aAAgBtG,KACjCqG,EAAKM,YAAcL,EAAKK,UAK/B1B,EAAQoB,IAASpB,EAAQqB,GA+BrC,SAA0BD,EAAMC,EAAMP,GAClC,GAAIM,EAAKxL,SAAWyL,EAAKzL,OACrB,OAAO,EAEX,IAAK,IAAIwF,EAAI,EAAGA,EAAIgG,EAAKxL,OAAQwF,IAC7B,IAAKkG,GAAYF,EAAKhG,GAAIiG,EAAKjG,GAAI0F,EAAW,GAC1C,OAAO,EAGf,OAAO,CACX,CAxCmBa,CAAiBP,EAAMC,EAAMP,EAAW,IAE1Cd,EAAQoB,KAASpB,EAAQqB,IAS1C,SAA2BD,EAAMC,EAEjCP,GACI,MAAMc,EAAQ5O,OAAO6O,KAAKT,GACpBU,EAAQ9O,OAAO6O,KAAKR,GAC1B,GAAqB,IAAjBO,EAAMhM,QAAiC,IAAjBkM,EAAMlM,OAC5B,OAAO,EAEX,GAAIgM,EAAMhM,SAAWkM,EAAMlM,OACvB,OAAO,EAEX,IAAK,MAAM9C,KAAO8O,EAAO,CAErB,IADiBE,EAAMC,SAASjP,KACdwO,GAAYF,EAAKtO,GAAMuO,EAAKvO,GAAMgO,EAAW,GAC3D,OAAO,CAEf,CACA,OAAO,CACX,CAtBekB,CAAkBZ,EAAMC,EAAMP,EAAW,KAkCxD,IAAyBS,EAAKC,CA/B9B,CC/EO,SAASS,KACZ,OAAOC,GAAaC,YAAY7B,OACpC,CACO,SAAS8B,GAAkB9B,GAC9B,OAAO4B,GAAaC,YAAY7B,QAAUA,CAC9C,CCLO,SAAS+B,GAAoB/B,GAEhC,IAAIgC,EAAYhC,EAChB,KAAOgC,EAAUC,eAAiBjD,EAAegD,EAAUhI,YACvDgI,EAAYA,EAAUC,aAE1B,OAAOD,EAAU9B,QAAQ5M,OAAO4O,QAAUF,CAC9C,CCNA,SAASG,MAAcC,GACnB,OAAOA,CACX,CACO,SAASC,GAAmBC,GAC/B,MAAMC,EAASX,GAAaC,YAG5B,OAFAU,EAAOC,OAAOD,EAAOE,aAAeH,IAClCC,EAAOE,YACFH,EAAOH,GAClB,CAEO,SAASO,GAAgBJ,GAC5B,MAAMC,EAASX,GAAaC,YACtBY,EAAcF,EAAOE,YAIrBE,EAHcZ,GAAoBQ,EAAOK,aAChBJ,OAEFC,GAC7B,IAAII,EAAa,GACjBF,GAAU,YAAqBP,GAE3B,OADAS,EAAaT,EACNA,CACX,IAMA,OAFAG,EAAOC,OAAOD,EAAOE,aAAeH,IAClCC,EAAOE,YACFH,GALU,YAA0BQ,GACvC,OAAOD,CACX,GAIJ,CC1BO,SAASE,GAAU/C,GACtB,MAAMuC,EAASX,GAAaC,YAC5BU,EAAOS,SAASC,QAAUC,GAC1BX,EAAOS,SAASG,cAAgBd,GAChCE,EAAOa,QAAU,GACjBb,EAAOc,WAAa,GACpBd,EAAOC,OAAS,GAChBD,EAAOE,YAAc,EACrBX,GAAkB9B,EACtB,CACO,SAASsD,GAAQC,EAAYX,EAAaY,GAC7C,MAAMjB,EAASX,GAAaC,YAE5BU,EAAOa,QAAUI,EACjBjB,EAAOc,WAAa,GACpBd,EAAOC,OAAS,GAChBD,EAAOE,YAAc,EACrBF,EAAOS,SAASC,QAAUQ,GAC1BlB,EAAOS,SAASG,cAAgBT,GAChCH,EAAOK,YAAcA,EACrBd,GAAkByB,EACtB,CACO,MAAMG,ICzBN,SAASC,GAAcC,GAC1B,MAAMC,EAAWD,EAAMC,SACvB,IAAKA,EACD,OAAOD,EAAME,aAEjB,MAAO3P,GDuBJ,SAA0B0P,GAC7B,MAAO1P,GAAS0P,EAASH,KAClBK,GAAcF,EAAS1P,GAC9B,MAAO,CAACA,EAAO4P,EACnB,CC3BoBC,CAAiBH,GACjC,OAAO1P,CACX,CCLO,SAASsP,KACZ,MAAMlB,EAASX,GAAaC,YAEtBoC,EADU1B,EAAOa,QACCb,EAAOc,WAAW/N,QAE1C,OADAiN,EAAOc,WAAWtM,KAAKkN,GAChBA,EAAQH,YACnB,CACO,SAASZ,GAAcY,GAC1B,MAAMvB,EAASX,GAAaC,YAE5B,IAAIqC,EAAYJ,EAKhB,UAJW,IAAmBlK,EAAWyF,WACrC6E,EAAYJ,YAGL,IAAgBlK,EAAWyF,SAAU,CAC5C,MAAM8E,EAAWD,EACjBA,EAAY,YAAyB9B,GAEjC,OADe+B,KAAY/B,EAE/B,EACA8B,EAAUC,SAAWA,CACzB,CACA,MAAMpN,EAAO,CACTlE,IAAK,WACD,OAAO8Q,GAAc5M,EACzB,EACA+M,aAAcI,GAGlB,OADA3B,EAAOc,WAAWtM,KAAKA,GAChBmN,CACX,CCjCO,SAASE,GAAcC,GAC1B,MAAMC,EAAS,IAAIC,GA6BnB,OADAD,EAAOE,cA3BYX,IACf,MAAMY,EAAa,GACbzL,EAAS,GACT0L,EAAW,CAACnM,EAAGxC,KACjB0O,EAAW1O,IAAS,EACpBiD,EAAOjD,GAASwC,EAEhB,GADqBkM,EAAWnP,SAAW+O,EAAS/O,OACpD,CAGA,IAAK,MAAMqP,KAAQF,EACf,IAAKE,EACD,OAIRd,EAAS7K,EAAQ4L,EAPjB,CAO8B,EAE5BC,EAAS,IAAIR,GAEbO,EADWC,EAAO/G,QACM1D,WAAU7B,GAAKmM,EAASnM,EAAG,KACnDuM,EAAgBD,EAAOrI,KAAI,CAAC2C,EAASpJ,IAChCoJ,EAAQ/E,WAAU7B,GAAKmM,EAASnM,EAAGxC,EAAQ,OAGtD,OADA6O,EAAaE,cAAgBA,EACtBF,CAAY,EAGhBN,CACX,CCzBO,SAASS,GAAgB5F,EAAS0E,EAAUmB,GAC/C,MAAMC,EAAeV,GAAQW,gBAC7BX,GAAQW,gBAAgBC,KAAKF,EAAa9Q,MAAQ,GAClD,MAAMyQ,EAAe,WACjBA,EAAaQ,aACjB,EAcA,OAbAR,EAAaf,SAAWA,EACxBe,EAAaE,cAAgB,GAE7BF,EAAaQ,YAAc,WACvB,OA0BR,SAAqBR,EAAcI,EAAanB,IA1ChD,SAA4BmB,EAAanB,GACrC,MAAM9N,EAAQiP,EAAYK,WAAUC,GAAOA,EAAIzB,WAAaA,KAC7C,IAAX9N,GACAiP,EAAYlJ,OAAO/F,EAAO,EAElC,CAsCIwP,CAAmBP,EAAanB,GAChC,MAAM2B,EAASjB,GAAQW,gBACvBX,GAAQW,gBAAgBC,KAAKK,EAAOrR,MAAQ,GAE5CyQ,EAAaQ,YAAc,IAAMR,EAEjC,MAAME,EAAgBF,EAAaE,cACnC,IAAK,MAAMQ,KAAOR,EACdQ,EAAIF,cAER,OAAOR,CACX,CAtCeQ,CAAYR,EAAcI,EAAanB,EAClD,EACAe,EAAarG,IAAO+G,IAChBV,EAAaE,cAAc/N,KAAKuO,GACzBV,GAEXA,EAAaO,KAAQhR,IACjB0P,EAAS1P,EAAOyQ,EAAa,EAE1BA,CACX,CACO,SAASa,GAAgBtR,EAAOuR,EAASC,GAC5C,MAAMC,EAAe,IAAIF,GACnBG,EAAcD,EAAa9H,QAC3BqH,EAAQW,IACV,GAAIF,EAAatQ,OACb,OAAOmQ,GAAgBK,EAAUF,EAAcD,GAEnDA,EAAWG,EAAS,EAExB,IAAI7C,EAAUkC,EACd,MAEMY,EAAiBF,EAAY1R,EADjB,CAAE6R,WADAzN,GAAM0K,EAAU1K,EACJ4M,SAEhClC,EAAQ8C,EACZ,CCvCO,MAAMxB,GACTpQ,MACA8R,eAEAP,QAAU,GACVQ,WAAY,EAEZlB,YAAc,GACdR,cACA,WAAA2B,CAAYhS,EAEZ8R,GACIG,KAAKjS,MAAQA,EACbiS,KAAKH,eAAiBA,CAE1B,CACA,SAAA7L,CAAUyJ,GACN,MAAMe,EAAeG,GAAgBqB,EAAMvC,EAAUuC,KAAKpB,aAEpDR,EAAgB4B,KAAK5B,cAC3B,GAAIA,EAAe,CAEf,GAAI4B,KAAKV,QAAQpQ,OAAQ,CACrB,MAAM+Q,EAAcxC,EACpBA,EAAY1P,IACRsR,GAAgBtR,EAAOiS,KAAKV,SAASY,GAAaD,EAAYC,EAAW1B,IAAc,CAE/F,CACA,OAAOJ,EAAcX,EACzB,CAKA,OAJAuC,KAAKpB,YAAYjO,KAAK6N,GAClBwB,KAAKH,gBACLG,KAAKH,eAAerB,GAEjBA,CACX,CACA,IAAAO,CAAKhR,GACDiS,KAAKjS,MAAQA,EACbiS,KAAKG,MACT,CACAC,IAAMJ,KAAKjB,KAAKsB,KAAKL,MACrB,IAAAG,GACI,MAAMpS,EAAQiS,KAAKjS,MAGbuS,EAAON,KAAKpB,YAElB,IAAK,MAAMM,KAAOoB,EACdpB,EAAIzB,SAAS1P,EAAOmR,EAE5B,CACA,SAAAqB,GACI,OAAO,IAAIC,SAAQC,IACfT,KAAKhM,WAAU,CAAC7B,EAAGqM,KACfA,EAAaQ,cACbyB,EAAItO,EAAE,GACR,GAEV,CAEA,UAAAuO,CAAWjD,GACP,MAAMe,EAAewB,KAAKhM,WAAU,CAAC7B,EAAGwO,KACpC,MAAMC,EAAaD,GAAY3B,YAC3B4B,EACAA,IAGAC,YAAW,IAAMrC,EAAaQ,eAAe,GAEjDvB,EAAStL,EAAE,IAEf,OAAO6N,IACX,CACA,IAAAc,IAAQC,GACJ,MAAMhI,EAAU,IAAIoF,GAAQ6B,KAAKjS,OAIjC,OAHAgL,EAAQiI,WAAWD,GACnBhI,EAAQqF,cAAiBjM,GAAM6N,KAAKhM,UAAU7B,GAC9C4G,EAAQgG,KAAO5M,GAAK6N,KAAKjB,KAAK5M,GACvB4G,CACX,CACA,UAAAiI,CAAWD,GACPf,KAAKV,QAAUyB,CACnB,CACA,UAAOE,CAAIjF,GAWP,OAAOgC,GAVUhC,EAAK5F,KAAI8K,IACtB,GAAIpI,EAAkBoI,GAClB,OAAOA,EAMX,OAJU,IAAI/C,GAAQ+C,GAAK1C,IACvBA,EAAaO,KAAKmC,GACX1C,IAEH,IAGhB,CACA2C,uBAAyB,IAAIhD,GAAQ,GAElC,MAAMiD,WAAmBjD,GAC5BpQ,MACA8R,eACAwB,OACA,WAAAtB,CAAYhS,EAEZ8R,GACIyB,MAAMvT,EAAO8R,GACbG,KAAKjS,MAAQA,EACbiS,KAAKH,eAAiBA,EACtBG,KAAKqB,OAAStT,EACdwT,GAAcvB,KAClB,CACA,IAAAjB,CAAKhR,GACDiS,KAAKqB,OAAStT,EACdiS,KAAKG,MACT,CACA,IAAAA,GACI,MAAMpS,EAAQiS,KAAKqB,OAGbf,EAAON,KAAKpB,YAElB,IAAK,MAAMM,KAAOoB,EACdpB,EAAIzB,SAAS1P,EAAOmR,EAE5B,EAEG,SAASqC,GAAcxI,GAC1BzM,OAAOC,eAAewM,EAAS,QAAS,CAEpC,GAAAqH,CAAIrS,GACAgL,EAAQsI,OAAStT,EACjBgL,EAAQoH,MACZ,EAEA1T,IAAG,IACQsM,EAAQsI,QAG3B,CC1IO,MAAMG,GAAa,IAAIrD,QAAQ7M,GAAW,SAAmBkN,GAC3DjD,MACDiD,EAAaO,MAErB,ICJavD,GAAe,CACxBC,YAAa,CACTwB,WAAY,GACZ7I,QAASC,KAAKC,MACdsI,SAAU,CACNC,QAASC,GACTC,cAAed,KAGvBuF,WAAU,ICNP,SAASC,GAAa7H,EAC7B8H,GACI,OAAOC,GAAgB/H,EAAQwC,OAAQsF,EAActF,OACzD,CACO,SAASuF,GAAgBC,EAAMC,GAClC,IAAK,IAAIlS,EAAQ,EAAGA,EAAQiS,EAAK1S,SAAUS,EAAO,CAG9CmS,GAFeF,EAAKjS,GACLkS,EAAKlS,GAExB,CACJ,CACA,IAAIoS,GACJ,SAASC,MAAiB7P,GAEtB,OADA4P,GAAM5P,EACCA,CACX,CACA,SAAS8P,KACL,OAAOF,EACX,CACO,SAASD,GAAWF,EAAMC,GAC7BD,EAAKI,GAAe,GACpBH,EAAKI,GAAe,EACxB,CAEO,SAASC,GAAcC,EAAWC,EAASC,EAAYC,GAC1D,IAAK,IAAI3S,EAAQwS,EAAUjT,OAAS,EAAGS,GAAS,IAAKA,EAAO,CACxD,MACM4S,EADkBJ,EAAUxS,GACAlD,MAG5BgR,EADgB2E,EAAQzS,GACC8N,SAC1BA,GAGLA,EAAS8E,EACb,CAEA,IAAK,IAAI5S,EAAQ2S,EAAWpT,OAAS,EAAGS,GAAS,IAAKA,EAAO,CACzD6S,GAAUtT,OAAS,EACnBuT,GAAW,GAGXC,EAFwBJ,EAAW3S,IAEnBgT,IAEhBN,EAAW1S,GAAOiT,GACtB,CACJ,CACA,IAAIH,GAAW,EACf,MAAMD,GAAY,GAClB,SAASG,MAAkB3G,GAEvB,OADAwG,GAAU7R,KAAKqL,GACRA,CACX,CAEA,SAAS4G,MAAkBC,GACvB,OAAOL,GAAUC,KACrB,CCjDA,SAASK,GAAwBlQ,EACjCjD,EAAOmK,EAAS+B,EAAckH,GAC1B,MAAMrD,EAAW9M,EAAOjD,GAClB3C,EAAc8M,EAAQnK,GAE5B,GAAI+P,IAAa1S,EAAYe,MACzB,OAEaf,EAAY8I,SACpBkN,cAActD,EAAU7D,EAAc7O,EAAa+V,EAAQnQ,GACpE5F,EAAYe,MAAQ2R,CAExB,CCvBO,SAASuD,GAAgBC,EAAcC,GAC1C,MACMrJ,EADSoJ,EAAapJ,QAAQ5M,OACbkW,UAOpB,SAA+BF,EAAcC,GAChD,MAAME,EAAcF,EAAavP,UAC3B0P,EAAUH,EAAavP,UAAUF,IACjCd,EAASyQ,EAAYzQ,QAAU0Q,EAAQ1Q,OACvCc,EAAMwP,EAAatP,UAAUF,IACnCA,EAAId,OAASA,CACjB,CAZI2Q,CAAsBL,EAAcC,KAClCK,GAASC,MDNR,SAA8B7J,EAASwJ,GAC1C,MACMxQ,EADUgH,EAAQhG,UAAUF,IACXd,OACvB,IAAIjD,EAAQ,EACZ,MAAM+T,EAAM9Q,EAAO1D,OACb6T,EAAS,CAAEY,MAAO,EAAGC,QAAS,GACpC,KAAOjU,EAAQ+T,GACXZ,GAAwBlQ,EAAQjD,EAAOyT,EAAUxJ,EAASmJ,KACxDpT,CAGV,CCJIkU,CAAqBX,EAAcpJ,KACjC0J,GAASC,MACXK,IACJ,CCPO,SAASC,GAAgBnR,GAC5B,OAAOA,EAAOwD,IAAI4N,GACtB,CAEO,SAASA,GAAgBjW,EAAOqM,GACnC,MAAM1G,EAAM3F,EACN4K,EAAY5K,GAAO4K,UACzB,GAAIA,EACA,OAAQA,GACJ,KAAKlF,EAAWQ,OAChB,KAAKR,EAAWO,UAChB,KAAKP,EAAWU,YACZ,OACJ,KAAKV,EAAWE,IAChB,KAAKF,EAAWC,IAChB,KAAKD,EAAWG,UACZ,OAAOmQ,GAAgBrQ,EAAId,QAGvC,OAAI0G,EAAQvL,GACDgW,GAAgBrQ,GAEpByG,GAAUpM,EAAOqM,EAC5B,CCAA,SAAS6J,GAAc9R,GACnB,OAAO6R,GAAgB7R,EAAG+R,GAC9B,CACA,SAASC,GAAWC,GAChB,OAAOJ,GAAgBI,EAAOC,GAClC,CC5BO,SAASC,GAAe1Q,EAAWkG,EAASyK,GAC/C,MAAMC,EAAc,CAChB5Q,YACAkG,UACAyK,cACA9K,gBAAYnI,GAGVpE,EAAS4M,EAAQ5M,OAKvB,OAJAA,EAAOuX,QAAU,GACjBvX,EAAOwX,SAAW,IAAIvG,GAGfqG,CACX,CAEO,SAASG,GAAqB/Q,EACrCgG,EAASH,EAAY8K,GAGjB3K,EAAQH,WAAaA,EACrB,MAAM2K,EAAQxQ,EAAUwQ,MAIxB,OAHIA,IACAxK,EAAQgL,YDtBT,SAAsBhL,EAASwK,EAAOS,GACzC,MAAMjR,EAAYgG,EAAQhG,UAC1B,GAAIA,EAAU+E,YAAclF,EAAWU,YAAvC,CAGA,OAAQP,EAAUkR,WACd,KAAKC,GAAYC,UACb,OAAOpL,EAAQgL,YAAc,CACzBK,OAAQb,EACRS,aAER,KAAKE,GAAYG,QACb,OAAOtL,EAAQgL,YAAc,CACzBK,OAAQb,EAAMhO,IAAI6N,IAClBY,aAGZ,OAAOjL,EAAQgL,YAAc,CACzBK,OAAQb,EAAMhO,IAAI+N,IAClBU,YAfJ,CAiBJ,CCC8BM,CAAavL,EAASwK,EAAOG,IAEhD3K,CACX,CACO,SAASwL,GAAkBxR,EAClCiI,EAAcpC,EAAYK,EAASyK,GAC/B,MAAM3K,EAAU,CACZhG,YACAkG,UACAyK,cACA9K,gBAAYnI,GAIhB,OAFAsI,EAAQiC,aAAeA,EACvBjC,EAAQH,WAAaA,EACdG,CACX,CCxCO,SAASyL,GAAczR,EAC9BiI,EAAcpC,EAAYV,EAASwL,GAC/B,MAAM3K,EAAU0K,GAAe1Q,EAAWmF,EAASwL,GAEnD,OADA3K,EAAQiC,aAAeA,EAChB8I,GAAqB/Q,EAAWgG,EAASH,EAAY8K,EAChE,CCCO,SAASe,GAAetY,EAAa0S,EAC5C7D,EAAckH,GACV,MAAMwC,EAAS3M,EAAe8G,GAE9B,GADA1S,EAAY8I,SAAW4J,EACnB6F,EAKA,YAJ2BjU,IAAvBtE,EAAYE,QACZH,EAAaC,GAuBzB,SAAkC4G,EAAW5G,EAAa6O,EAAckH,GACpE,MAAM7V,EAASF,EAAYE,OAE3B,IAAKA,EAAO4O,OAIR,YAFAlI,EAAU4R,YAAY5R,EAAW5G,EAAa6O,EAAckH,OAAQzR,EACpEtE,EAAYyY,aAGhB,MAAM7L,EAAUyL,GAAczR,EAAWiI,EAAcA,EAAapC,WAAYzM,ICpC7E,SAAoC6O,EAAcsB,EACzDpE,GACI,MAAM7L,EAAS6L,EAAQ7L,OACjBwY,EAAaxY,EAAO4O,OACpB6J,EAAaD,EAAW9R,UAAUgS,QACxC,IAAIC,EAAa1I,EAAWvJ,UAAUgS,QAClCE,GAAY,EAChB,MAAMnN,EAAYwE,EAAWvJ,UAAU+E,UACjCoN,EAAgBtS,EAAWU,cAAgBwE,GAAalF,EAAWS,aAAeyE,EACxF,GAAIoN,EACAD,EAAY3I,EAAWvJ,UAAU+E,YAAclF,EAAWS,YAAc8R,GAAWN,EAAYvI,QAE9F,GAAIwI,GAAcE,EAAY,CAE/B,MAAMI,EAAYP,EAAW9R,UAAUF,KAAKwS,WACxCD,IAEAJ,EAAa1I,EAAWgJ,WAK5BL,EAHoBH,EAAW5H,WACX8H,EAAW9H,QAGnC,CACA,MAAMnK,EAAYuJ,EAAWvJ,UAC7B,IAAKkS,EAED,YA6ER,SAAkB9Y,EAAa4G,EAC/BiI,GACI,MAAM3O,EAASF,EAAYE,OACrBkZ,EAAgBlZ,EAAOmZ,OAC7BC,GAAeF,EAAelZ,GAC9BH,EAAaC,GACb4G,EAAU4R,YAAY5R,EAAW5G,EAAa6O,EAAc,CAAE8H,MAAO,EAAGC,QAAS,QAAKtS,EACtFtE,EAAYyY,YAChB,CAtFQc,CAASxN,EAASnF,EAAWiI,GAGjC,MAAM2K,EAAaT,GClChB,SAA2BL,EAAYe,GAC1C,MAAMC,EAAcD,EAAarC,MAC3BQ,EAAcc,EAAWd,YACzB+B,EAAiB/B,EAAYK,OAC7B2B,EAAeC,GAAeH,EAAaC,EAAgBjB,EAAW9R,UAAUkR,WACtF,OAAO8B,CACX,CD4BwCE,CAAkBpB,EAAY9R,GAElE,IAAK4S,EAAY,CAGb,YAyDR,SAAsB5S,EAAWgG,EAAS8L,EAAY7J,EAAczB,GAEhE,MAAM2M,EAAWnT,EAAUwQ,MACrBG,EAAcyC,GAAkBpN,EAAS8L,EAAY7J,EAAckL,EAAU3M,GAC7EwK,EAAchL,EAAQgL,YAE5BA,EAAYC,UAAYN,EACxB,MAAM0C,EAAkBvB,EAAWd,YAEnCqC,EAAgBhC,OAASL,EAAYK,MAEzC,CArEQ,CAAarR,EAAWuJ,EAAYuI,EAAY7J,EAD/BjI,EAAUkR,YAAcC,GAAYmC,KAAO7C,GAAmBH,GAGnF,CACA,GAAInL,EAAQoO,OAER,YADAja,EAAOuX,QAAQ9T,KAAKwM,GAGxBiK,GAAcjK,KACZpE,EAAQ9L,WAEd,CDNIoa,CAA2BxL,EAAcjC,EACzC5M,EACJ,CAjCQsa,CAAyB5H,EAAU1S,EAAa6O,EAAckH,IACvD,EAGX,MAAM7V,EAASF,EAAYE,OAC3B,GAAIA,EAAQ,CAER,MAAM0M,EAAU1M,EAAO4O,OACvB,GAAIlC,EACA,cAAW,IAAepG,EAAWyF,UGtB1C,SAAwByM,EAAY3M,EAAShL,EAAO8N,GAEvD,IAAIjI,EAAY7F,EAAM6F,WAAa7F,EACnC,MAAMwZ,EAAU7B,EAAW9R,UAAUF,IACjC6T,GACkBA,EAAQrB,aAGtBtS,EAAY7F,EAAMoY,WAAapY,EAAMmY,WAAWC,WAGxD,MAAMqB,EAAenC,GAAczR,EAAWiI,EAAcA,EAAapC,WAAYV,GAIrFkK,GAHoByC,EAAW5L,QACD5M,OACLmZ,OACDmB,EAC5B,CHSYC,CAAe7N,EAAS5M,EAAa0S,EAAU7D,IAFpC,CAKnB,CAIA,OAFA6D,EAAS8F,YAAY9F,EAAU1S,EAAa6O,EAAckH,OAAQzR,EAClEtE,EAAYyY,cACL,CACX,CIjCO,SAASiC,GAAsBhI,EACtC7D,EAAc7O,EAAa+V,GAEnBrD,IAAa1S,EAAYe,OAG7B4Z,GAAyB3a,EAAa0S,EAAU7D,EAAckH,EAClE,CCRO,SAAS6E,GAAiBhO,EAAS1M,GACtC,MAAM2a,EAAY3a,EAAO2a,UACzB,GAAIA,EACA,IAAK,MAAMnO,KAAYmO,EACnB,IAAK,IAAIlY,EAAQ+J,EAAS5E,SAAS5F,OAAS,EAAGS,GAAS,IAAKA,EAAO,CAClD+J,EAAS5E,SAASnF,GACtBmK,QAAQ5M,SAAWA,GACzBwM,EAAS5E,SAASY,OAAO/F,EAAO,EAExC,CAGJzC,EAAOwX,UACPxX,EAAOwX,SAAS3F,OAEpBnF,EAAQE,QAAQ7M,YAAc,CAClC,CCdO,SAAS6a,GAAe/N,EAAW8B,GACtC,IAAK,MAAM5G,KAAS8E,EAAW,CAE3B,MAAMgO,EAAY9S,EAAM8S,UACxB,GAAIA,EAAW,CAEXD,GAAeC,EAAWlM,GAC1B,QACJ,CACA,MAAMmM,EAAa/S,EAAMlH,MACzB,GAAIia,GAAYrP,YAAclF,EAAWO,UAAW,CAChDgU,EAAWC,OAAOhT,EAAO4G,GACzB,QACJ,CACA,MAAM3O,EAAS+H,EAAM/H,OACrB,IAAKA,EACD,SAEJ,MAAM0M,EAAU1M,EAAO4O,OACjBoM,EAAQhb,EAAOwR,cACjBwJ,GACAA,EAAM9V,QAAQ+V,IAEdvP,EAAegB,EAAQhG,YACvBgU,GAAiBhO,EAAS1M,GAI9B4a,GAFgB5a,EAAOkW,SAECxJ,EAC5B,CACJ,CACO,SAASwO,GAA0BrO,EAAWsO,EAAO,GAAI/H,EAAO,IACnE,IAAK,MAAMrL,KAAS8E,EAAW,CAC3B,MAAM7M,EAAS+H,EAAM/H,OACrB,IAAKA,EACD,SAEJ,MAAM0M,EAAU1M,EAAO4O,OACvB,GAAIlC,EAAS,CACTyO,EAAK1X,KAAKiJ,GACV,MAAMsO,EAAQhb,EAAOwR,cACjBwJ,GACA5H,EAAK3P,QAAQuX,EAErB,CACA,MAAMI,EAAUpb,EAAOkW,SACnBkF,GACAF,GAA0BE,EAASD,EAAM/H,EAEjD,CACA,MAAO,CAAE+H,OAAM/H,OACnB,CACO,SAAS6H,GAAgBvG,GAC5BA,EAAK5C,aACT,CCvDO,SAASuJ,GAAsB7I,EAAU3G,GAE5C,OAAKO,EAAQoG,KACT8I,GAAwBzP,GACjB,EAGf,CACO,SAASyP,GAAwBzP,GAEpC0P,GAAa1P,EADKA,EAAQgP,UAE9B,CACO,SAASU,GAAa1P,EAASgP,GAClC,IAAK,IAAIpY,EAAQ,EAAGA,EAAQoY,EAAU7Y,SAAUS,EAC5C+Y,GAAiBX,EAAUpY,WAExBoJ,EAAQgP,SACnB,CChBO,SAASY,GAAgBzb,EAAQ0b,IAKxC,SAA8B9O,EAAS8O,GACnC,IAAK,MAAM7P,KAAWe,EAAS,CAC3B,GAAIf,EAAQoO,OACR,SAEJ,GAAIpO,EAAQ8P,mBAAoB,CAC5B,MAAM/S,EAAWiD,EAAQjD,SACzB,GAAIA,GAAmC,SAAvBA,EAAS6C,UAAsB,CAC3C,MAAMmD,EAAS/C,EAAQ+P,aACvBhT,EAASmS,OAAOlP,EAAS+C,EAC7B,CACA,QACJ,CACA,MAAMiM,EAAYhP,EAAQgP,UAC1B,GAAIA,EAAW,CACXU,GAAa1P,EAASgP,GACtB,QACJ,CAEA,MAAMgB,EAAMhQ,EAAQiQ,eACpB,GAAID,EAAK,QACEhQ,EAAQiQ,eACfC,GAAgBF,GAChB,QACJ,CACA,MAAMG,EAAYnQ,EAAQ7L,OAC1B,QAAkBoE,IAAd4X,EACA,SAEJ,IAA0B,IAAtBA,EAAUC,QACV,SAEJD,EAAUC,SAAU,EACLD,EAAU7C,QAErBsC,GAAgBO,EAAWN,EAGnC,CACJ,CA1CIQ,CADgBlc,EAAOkW,SACOwF,GA4ClC,SAAuB1b,GACnB,MAAMmc,EAAcnc,EAAOmc,YAE3B,IAAK,IAAI1Z,EAAQ0Z,EAAYna,OAAS,EAAGS,GAAS,IAAKA,EAAO,CAE1D2Z,GADcD,EAAY1Z,IAE1B0Z,EAAY3T,OAAO/F,EAAO,EAC9B,CACJ,CAnDI4Z,CAAcrc,EAClB,CAmDA,SAASoc,GAAahP,GAClB,MAAMkP,EAASlP,EAAMkP,OACjBA,GACAP,GAAgBO,GAEpB,MAAM7V,EAAM2G,EAAMmP,WACb9V,GAGLsV,GAAgBtV,EACpB,CCjEO,SAAS2S,GAAe1M,EAAS1M,GACpC,MAAM6L,EAAUa,EAAQE,QACxB5M,EAAOic,SAAU,EACjBpQ,EAAQ9L,YAAc,EACtB,MAAMyc,EAAW,GAOjB,OALA5B,GADgB5a,EAAOkW,SACCxJ,GACpB1M,EAAOwX,UACPkD,GAAiBhO,EAAS1M,GAE9Byb,GAAgBzb,EAAQwc,GACjBA,CACX,CCbO,SAASC,GAAkB5b,EAAO4B,EAAOoY,EAAWnE,GACvD,MAAMgG,EAAY7b,EAAMmB,OAAS,EAC3BuB,EAAKd,EAAQiU,EACbiG,EAAapZ,EAAK,GAAKmZ,EAAYnZ,EACnCqZ,EAAc/B,EAAUpY,GAC9B,GAAIka,EAEA,OADAnB,GAAiBoB,GACV,EAEX,MAEMC,EAGV,SAA0BC,EAAQC,EAAaH,EAAa/B,EAAWpY,GACnE,MAAMua,EAASD,GAAeD,IAAWC,EAAYE,WACrD,GAAID,EAGA,OAFAxB,GAAiBoB,GACjB/B,EAAUrS,OAAO/F,EAAO,GACjB,EAEX,OAAO,CACX,CAXmBya,CAFAN,EAAY/b,MAAMoc,WACbpc,EAAM4B,GAC2Bma,EAAa/B,EAAWpY,GAC7E,OAAOoa,CACX,CAUO,SAASrB,GAAiBnK,IAIjC,SAAkCrR,EAAQqR,GACtC,GAAIrR,EAAQ,CAGR,YADAoZ,GADgBpZ,EAAOmZ,OACCnZ,EAE5B,CACA,MAAMqD,EAAUgO,EAAKyK,sBACdzK,EAAKyK,eACZC,GAAgB1Y,EACpB,CAXI8Z,CADe9L,EAAKrR,OACaqR,EACrC,CC5BO,SAAS+L,GAAyBvc,EAAOf,EAChD6O,EACAkH,EAAQwH,EAAUC,GAId,OADiBxd,EAAY8I,SACb0P,YAAYzX,EAAOf,EAAa6O,EAAckH,EAAQwH,EAAUC,EACpF,CCLO,SAASC,GAAsB1c,EAAO6L,EAAS5M,EAAa+V,EACnEwH,EAAUC,GAGN,MAAMzR,EAAUa,EAAQE,QACxBf,EAAQoO,QAAS,EACjBmD,GAAyBvc,EAAOf,EAAa4M,EAASmJ,EAAQwH,EAAUC,UACjEzR,EAAQoO,OACfna,EAAYe,MAAQA,CACxB,CCVO,SAAS2c,GAAc3c,GAC1B,OAAQA,GACJ,UAAKuD,EACL,KAAK,EACL,KAAK,KACD,OAAOgC,EAEf,OAAOvF,CACX,CCJO,SAAS4c,GAAgB5c,GAC5B,MAAO,CACH4K,UAAW,SACX5K,QACAyX,YAAaoF,GACb3C,OAAQ4C,GAERC,iBAAkBC,GAClB/H,cAAe0E,GAEvB,CACA,SAASkD,GAAuB7c,EAChCf,EAAa6O,EAAckH,EAAQwH,EAAUC,GAEzC,MAAMQ,EAAcN,GAAc3c,GAClCyc,EAAexd,EAAYyY,YAE3B,MAAM3B,EAAQ9W,EAAY8W,MAAQ,CAACmH,GAAiB,CAACT,EAAcQ,EAAa,SAA0B7Y,GAC9FnF,EAAYgc,eAAiB7W,SACtBnF,EAAY8W,KACvB,IACRoH,GAAcva,KAAKmT,EACvB,CACO,SAAS+G,GAAkB7d,GAC9B,MAAM+b,EAAM/b,EAAYgc,sBACjBhc,EAAYgc,eACnBC,GAAgBF,EACpB,CACO,SAASgC,GAAuBrL,EAAU1S,GAG7C,OAFmB0S,gBAC4B,IAAelM,EAAW6F,QAMzEwR,GAAkB7d,GACX,ICvCJ,SAAmCe,EAAOf,GAC7C,MAAMge,EAAcN,GAAc3c,GAClC,GAAIf,EAAY8W,MAGZ,YADA9W,EAAY8W,MAAM,GAAG,GAAKkH,GAG9B,MAAMG,EAAWne,EAAYgc,eAC7BhS,GAAarG,KAAK,CAACya,GAAY,CAACJ,EAAaG,IACjD,CD0BQE,CAA0B3L,EAAU1S,IAC5B,EAIhB,CExCO,SAASse,GAAevd,GAC3B,MAAO,CACH4K,UAAW,QACX5K,QACAyX,YAAa+F,GACbvI,cAAe0E,GACfoD,iBAAkBvC,GAClBN,OAAQO,GAEhB,CACA,SAAS+C,GAAiBxd,EAC1Bf,EAAa6O,EAAckH,EAAQwH,GAE/BiB,GAAgBxe,EADCe,EACsB8N,EAAckH,EAAQwH,EACjE,CCdO,SAASkB,GAAgB1d,GAC5B,MAAM4K,EAAY5K,GAAO4K,UACzB,OAAIA,EACO5K,EAIf,SAAwBA,GACpB,GAAIuL,EAAQvL,GACR,OAAOud,GAAevd,GAE1B,OAAO4c,GAAgB5c,EAC3B,CAPW2d,CAAe3d,EAC1B,CCHO,SAAS4d,GAA4B5d,EAAO8N,EAAckH,EAAQyH,EACzED,GACI,MAAMha,EAAUqb,SAASC,eAAevY,GAClCtG,EAAc,CAChBe,QACA+H,SAAU2V,GAAgB1d,GAC1B8a,oBAAoB,EACpBpD,YAAalV,GASjB,OAPKga,GACDW,GAAcva,KAAK,CAACmb,GAAa,CAACtB,EAAcja,KAEpDka,GAAsB1c,EAAO8N,EAAc7O,EAAa+V,EAAQwH,EAAUC,GACtED,GACAwB,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAUha,KAExCvD,CACX,CCnBO,SAASwe,GAAgBzS,EAAShL,EACzC8N,EAAckH,EAAQwH,GAClB,MAAM0B,OAA+B3a,IAAtByH,EAAQgP,UACnBkE,IACAlT,EAAQgP,UAAY,IAExB,MAAMA,EAAYhP,EAAQgP,UAC1B,IAAImE,EAAsBnT,EAAQ0M,YAC9B7B,EAAU,EAEd,MAAMuI,EAAe,GAErB,IAAKF,EAAQ,CAET,IAAK,IAAItc,EAAQ,EAAGA,EAAQoY,EAAU7Y,SAAUS,EAAO,CACnD,MAAM4O,EAAOwJ,EAAUpY,GAEjByc,EAAazC,GAAkB5b,EAAO4B,EAAOoY,EAAWnE,GAC3C,IAAfwI,EAKe,IAAfA,EAIJxI,GAAoBwI,EAHhBzc,GAAgB,EALhBwc,EAAaxb,KAAK4N,EAS1B,CACAxF,EAAQgP,UAAYoE,CACxB,CACA,MAAMjd,EAASnB,EAAMmB,OACrB,IAAK,IAAIS,EAAQ,EAAGA,EAAQT,IAAUS,EAAO,CAEzCuc,EADmBG,GAAgBte,EAAO4B,EAAOoJ,EAAQgP,UAAWlM,EAAcqQ,EAAqBnJ,EAAQwH,GAC9E9E,WACrC,CACJ,CACA,SAAS4G,GAAgBlW,EAAOxG,EAAOoY,EAAWlM,EAAcqQ,EAChEnJ,EAAQwH,GACJ,MAAMhM,EAAOpI,EAAMxG,GACb2c,EAAWvE,EAAUpY,GAC3B,GAAI2c,EACA,OAOR,SAAiCve,EAAOwe,EAAaxE,EAAWlM,EAAclM,EAAOuc,EACrFnJ,EAAQwH,GACJ,MAAMiC,EAAczE,EAAU7Y,OAASS,EACvC,GAAI6c,EAEA,OADA9E,GAAsB3Z,EAAO8N,EAAc0Q,EAAaxJ,GACjDwJ,EAEX,MAAMvf,EAAc2e,GAA4B5d,EAAO8N,EAAckH,EAAQmJ,EAAqB3B,GAGlG,OADAxC,EAAUpX,KAAK3D,GACRA,CACX,CAlBeyf,CAAwBlO,EAAM+N,EAAUvE,EAAWlM,EAAclM,EAAOuc,EAAqBnJ,EAAQwH,GAEhH,MAAMvd,EAAc2e,GAA4BpN,EAAM1C,EAAckH,EAAQmJ,EAAqB3B,GAGjG,OADAxC,EAAUpX,KAAK3D,GACRA,CACX,CC7CO,SAAS0f,GAAkBhN,EAAU1S,EAAa6O,EAAc8Q,EAAmB5J,GAEtF,MAAMpK,EAAY+G,GAAYA,EAAS/G,UAEvC,GADA3L,EAAY8I,SAAW2V,GAAgB/L,GACnC/G,EAAJ,CACI,GAAIA,IAAclF,EAAWS,WACzB,OAEJoR,GAAetY,EAAa0S,EAAU7D,EAAckH,EAExD,KANA,CAOA,GAAIzJ,EAAQoG,GAGR,OAFA8L,GAAgBxe,EAAa0S,EAAU7D,EAAckH,QACrD/V,EAAY8I,SAAWwV,GAAe5L,WAG/B,IAAelM,EAAWyF,SAIjC0T,GLbD,SAAgC5e,EAAOf,GAC1CA,EAAYe,MAAQA,EACpBf,EAAY8I,SAAW6U,GAAgB5c,GACvC,MAAM6e,EAAS5f,EAAYyY,YACrBuF,EAAcN,GAAc3c,GAC5B+V,EAAQ9W,EAAY8W,MAAQ,CAACmH,GAAiB,CAAC2B,EAAQ5B,EAAa,SAA2B7Y,GACzFnF,EAAYgc,eAAiB7W,SACtBnF,EAAY8W,KACvB,IACRoH,GAAcva,KAAKmT,EACvB,CKIQ+I,CAAuBnN,EAAU1S,GAJjCA,EAAYe,MAAQ2R,CAPxB,CAaJ,CC5BO,SAASiI,GAAyB3a,EAAa0S,EACtD7D,EAAckH,GAEV,MACM4J,EADW3f,EAAY8I,SACMgV,iBAAiBpL,EAAU1S,EAAa+V,EAAQlH,IAExD,IAAvB8Q,GAGJD,GAAkBhN,EAAU1S,EAAa6O,EAAc8Q,EAAmB5J,EAC9E,CCVO,SAAS+J,GAAgBpN,EAAU7D,EAAc7O,EAAa+V,GACjE,MAAMyD,EAAauG,GAAwBtZ,EAAWO,UAAW0L,EAAU7D,EAAc7O,EAAa+V,GACtG,GAAIyD,EACA,OAAOA,EAEX,MAAMhI,EAAexR,EAAYggB,WACjC,OAAKxO,GAAiBA,EAAayO,YAGnCzO,EAAaf,SAAWiC,EAASjC,SACjCe,EAAa0O,cAAc1O,EAAa/B,aAChC,IAJI,CAKhB,CACO,SAASsQ,GAAwBI,EAAczN,EAAU7D,EAAc7O,EAAa+V,GACvF,IAAKrD,IAAaA,EAAS/G,WAAa+G,EAAS/G,YAAcwU,EAAc,CAIzE,OAHiBngB,EAAY8I,SACpBmS,OAAOjb,EAAa6O,GAC7B6Q,GAAkBhN,EAAU1S,EAAa6O,EAAc,GAAIkH,GACpD,EACX,CACJ,CCrBO,SAASqK,GAAkBrf,EAAOif,EAAYnR,EACrDkH,EACAyH,GAEI,OADAwC,EAAWC,YAAa,EACjBD,EAAWhgB,YAAc2e,GAA4B5d,EAAO8N,EAAckH,EAAQyH,EAC7F,CCJO,SAAS6C,GAAsB9C,EAAUC,GAC5C,IAAI8C,EAMJ,OAJI/C,IACA+C,EAAe9C,EAAeoB,SAASC,eAAevY,GACtDyY,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAUC,MAExC,CACH8C,eACA9C,aAAcA,EAEtB,CCJO,SAAS+C,GAAeC,EAAaxgB,EAAa6O,EAAckH,EAAQtF,EAAU8M,EAAUkD,GAC/F,MAAM,aAAEH,EAAY,aAAE9C,GAAiB6C,GAAsB9C,EAAUkD,GACjET,EAOH,SAAyCQ,EAAa3R,EAC7DkH,EACAyH,EAAc/M,GACV,MAAM7B,EAAYD,GAAoBE,GACtC,IAAI6R,EAAW,SAAoB3f,GAC/Bqf,GAAkBrf,EAAOif,EAAYnR,EAAckH,EAAQyH,GAC3DmD,GAAaC,GAEbF,EAAW,SAA4BG,GAEnClG,GADiBqF,EAAWhgB,YACO6gB,EAAahS,EAAc,CAAE8H,MAAO,EAAGC,QAAS,IACnF+J,GAAaC,EACjB,CACJ,EAEA,SAASE,EAAa/f,EAAO4B,GACzBqd,EAAWvQ,WAAW9M,GAAS5B,EAC/Bmf,EAAcF,EAAWvQ,WAC7B,CACA,SAASyQ,EAActa,GAGnB,GADA6O,GADqB7F,EAAU9B,QAAQ5M,OAAO4O,OACnBF,GACvBoR,EAAWvP,SAAf,CACI,MAAMsQ,EAAgBf,EAAWvP,YAAY7K,GAC7C8a,EAASK,EAEb,MACAL,EAAS9a,EAAO,GACpB,CACA,IAAIgb,GAAU,EACd,MAAMZ,EAAa,CACfvQ,WAAY,GACZqR,eACAZ,gBACAzP,WACAiB,cAAe,IAQnB,OALA8O,EAAYpb,SAAQ,CAAC4b,EAAYre,KAC7Bie,GAAU,EACVZ,EAAWtO,cAAc/N,KAAKqd,EAAWha,WAAUjG,GAAS+f,EAAa/f,EAAO4B,MAChFie,GAAU,CAAK,IAEZZ,CACX,CAnDuBiB,CAAgCT,EAAa3R,EAAckH,EAAQyH,EAAc/M,GAKpG,OAJAuP,EAAWM,aAAeA,EAC1BtgB,EAAYggB,WAAaA,EAEzBhgB,EAAY8I,SAASkN,cAAgB8J,GAC9BE,CACX,CA8CO,SAASkB,GAAqBlhB,EAAa6O,GAG9C,OAFqB7O,EAAYggB,WACpBtO,cAActM,SAAQ8M,GAAOA,EAAIF,gBACvCmP,GAAiBnhB,EAAa6O,EACzC,CACA,SAAS8R,GAAaC,GACbA,GAAYpS,GAAaC,YAAY7B,SACtCkK,IAER,CCvEO,SAASsK,GAAiBrgB,EAAOf,EAAa6O,EAAckH,EAAQwH,EAAUC,GACjF,OAAO+C,GAAexf,EAAMsgB,YAAarhB,EAAa6O,EAAckH,EAAQhV,EAAM0P,SAAU8M,EAAUC,EAC1G,CACO,SAAS8D,GAAqBvgB,EAAOf,EAAa6O,EAAckH,EAAQwH,EAAUC,GACrF,MAAMgD,EAAczf,EAAMsgB,YACpB7P,EAAe+O,GAAeC,EAAaxgB,EAAa6O,EAAckH,EAAQhV,EAAM0P,SAAU8M,EAAUC,GAC9G,IAAKhM,EAAayO,WAAY,CAC1B,MAAMsB,EAAUf,EAAY,IAAIzf,MAChCyQ,EAAasP,aAAcS,GAAWxgB,EAAMygB,YAAc,EAC9D,CACA,OAAOhQ,CACX,CACO,SAASiQ,GAAc1gB,EAAOf,EAAa6O,EAAckH,EAAQwH,GACpEgD,GAAe,CAACxf,GAAQf,EAAa6O,EAAckH,OAAQzR,EAAWiZ,EAC1E,CCRO,SAAStW,GAAOya,GAEnB,OADgBnT,KAELiC,IAAM,IAAMmR,GAAOD,KAEvBC,GAAOD,EAClB,CAEO,SAASC,GAAOD,GACnB,IAAI3gB,EAAQ2gB,EACZ,MAAM9P,EAAc,IAAIgQ,IAClBzO,EAAQT,IAEVd,EAAYxM,SAAQqL,GAAYA,EAASiC,IAAU,EAEvD,MAAO,CACH/G,UAAWlF,EAAWQ,OACtBuR,YAAaiJ,GACbzL,cAAe,CAACtD,EAAU7D,EAAc7O,EAAa+V,IAAWgK,GAAwBtZ,EAAWQ,OAAQyL,EAAU7D,EAAc7O,EAAa+V,GAChJ,SAAIhV,GACA,OAAOA,CACX,EACA,SAAIA,CAAM2R,GACF3R,IAAU2R,IACV3R,EAAQ2R,EACRS,EAAKT,GAEb,EACAuI,OAAQiG,GACR/N,OACA,SAAAnM,CAAUyJ,GACNA,EAAS1P,GACT6Q,EAAYzG,IAAIsF,GAEhB,MAAMoR,EAAQ,IAAMjQ,EAAYqJ,OAAOxK,GAGvC,OADAoR,EAAM7P,YAAc6P,EACbA,CACX,EAER,CC9CO,MAAMC,WAAqB3Q,GAC9BpQ,MACA,WAAAgS,CAAYhS,GACRuT,MAAMvT,GACNiS,KAAKjS,MAAQA,CACjB,CACA,SAAAiG,CAAUyJ,GACN,MAAMe,EAAe8C,MAAMtN,UAAUyJ,GAGrC,OADAA,EAASuC,KAAKjS,MAAOyQ,GACdA,CACX,EAEG,MAAMuQ,WAAwB5Q,GACjCpQ,MACA,WAAAgS,CAAYhS,GACRuT,MAAMvT,GACNiS,KAAKjS,MAAQA,EACbiS,KAAKqB,OAAStT,EACdwT,GAAcvB,KAClB,CACA,SAAAhM,CAAUyJ,GACN,MAAMe,EAAe8C,MAAMtN,UAAUyJ,GAGrC,OADAA,EAASuC,KAAKqB,OAAQ7C,GACfA,CACX,EC3BG,SAASwQ,GAAavR,GACzB,MAAO,CAAEyC,EAAW+O,KAChBA,EAAMrP,YAAW,KACG,IAEpBnC,EAASyC,EAAW+O,EAAMlQ,KAC7B,CACL,CAEO,SAASmQ,GAAYzR,GACxB,MAAO,CAAEyC,EAAW+O,KAChBA,EAAMrP,YAAW,KACG,IAELnC,EAASyC,GACjB9G,MAAKjH,GAAK8c,EAAMlQ,KAAK5M,IAC/B,CACL,CAEO,MAAMgd,GAAiB1R,GACnB,CAAEyC,EAAW+O,KAChBA,EAAMrP,YAAW,KACG,IAEpB,MACMpB,EADSf,EAASyC,GACIlM,WAAU7B,IAClCqM,EAAaQ,cACbiQ,EAAMlQ,KAAK5M,EAAE,GAEpB,EC3BE,SAASqL,GAAME,GAClB,OAAOlC,GAAaC,YAAYmB,SAASC,QAAQa,EACrD,CCQO,MAAM0R,GAAQ,CAAEC,EAAe5R,IAC3B6R,GAAWD,EAAe5R,GAE/B8R,GAAkBpd,GAAMA,EAgB9B,MAAMmd,GAAa,CAACD,EAAe5R,GAAY+R,OAAM5C,SAAQ6C,QAAQF,IAAoB,CAAC,KACtF,MAAMjD,EAAW9O,GAAM,CACnBkS,gBAAYpe,EACZsB,YAAQtB,IAENqe,EAAiBrD,EAAS1Z,OAEhC,QAAuBtB,IAAnBqe,EAA8B,CAC9B,GAAI/C,IAAWA,EAAOyC,GAElB,OADA/C,EAAS1Z,OAASyc,EACX/C,EAASoD,WAEpB,MACM3F,GADayF,GAAQ/R,GACD4R,EAAeM,GAGzC,OAFArD,EAASoD,WAAaD,EAAM1F,GAC5BuC,EAAS1Z,OAASyc,EACX/C,EAASoD,UACpB,CAEA,GADiBL,EAAc5Y,OAAM,CAAC8H,EAAM5O,IAAU4O,IAASoR,EAAehgB,KAE1E,OAAO2c,EAASoD,WAEpB,GAAI9C,IAAWA,EAAOyC,GAElB,OADA/C,EAAS1Z,OAASyc,EACX/C,EAASoD,WAEpB,MAAM3F,EAAStM,EAAS4R,EAAeM,GAIvC,OAHArD,EAASoD,WAAaD,EAAM1F,GAC5B4F,EAAezgB,OAAS,EACxBygB,EAAehf,QAAQ0e,GAChB/C,EAASoD,UAAU,EAE9B,SAASE,GAAeC,EAAUC,GA8C9B,OA7CAxjB,OAAOC,eAAeujB,EAAU,SAAU,CACtC,GAAArjB,GACI,MAAM2iB,EAAQS,IAEd,OADAT,EAAMW,MAAMP,KAAO,KAAe,EAC3BJ,CACX,IAEJ9iB,OAAOC,eAAeujB,EAAU,YAAa,CACzC,GAAArjB,GACI,MAAMujB,EAAWH,IACXI,EAAezS,IAAM,IAAMjC,OAC3BxC,EAAUyE,IAAM,IAAM,IAAIsR,QAAaxd,KACvC4e,EAAW1S,IAAM,KAAM,CACzBP,WAAYzB,GAAaC,YAAYwB,WACrCb,OAAQZ,GAAaC,YAAYW,WAE/B+T,EAAS,CAACd,EAAe5R,KAC3B6R,GAAWD,GAAe,CAACA,EAAeM,KACtC,MAAMS,EAAa7U,KACb8U,EAAQ5S,EAAS4R,EAAeM,GACtC,GAAIS,IAAeH,EAAc,CAC7B,MAAMK,EAAcJ,EAASjT,WAEvBoJ,EADS4J,EAAanW,QAAQ5M,OACdmZ,OAItBnE,GAAcoO,EAHMjK,EAAO7I,MACT0S,EAAS9T,OACTiK,EAAOjK,OAE7B,CACArD,EAAQgG,KAAKsR,EAAM,GACpBL,EAASD,OACLhX,GAIX,OAFAoX,EAAOJ,MAAQC,EAASD,MACxBH,IAAe,IAAMO,GAAQA,GACtBA,CACX,IAEJ7jB,OAAOC,eAAeujB,EAAU,SAAU,CACtC,GAAArjB,GACI,MAAM2iB,EAAQS,IAEd,OADAT,EAAMW,MAAMnD,OAAUyC,GAAkBA,EAAc5Y,OAAMtE,GAAKA,IAC1Did,CACX,IAEGU,CACX,CCxGO,SAAS/W,GAAQ2V,GAEpB,OADgBnT,KAELiC,IAAM,IAAM,IAAIW,GAAQuQ,KAE5B,IAAIvQ,GAAQuQ,EACvB,CCVO,SAAStS,GAAOF,GAEnB,OADeV,GAAaC,YACdmB,SAASG,cAAcb,EACzC,CCGO,SAASqU,GAAQrU,GACpB,MAAMsU,EAAcvc,GAAO,IACrBwc,EAASxc,GAAO,GAChByc,EAAWzc,GAAO,GACxB,IAAI0c,EAAY,GACZC,EAAS,EAgCb,OA/BAF,EAAS3iB,MAAQ0iB,EAAO1iB,MACxBmO,GAAO,IAAItJ,KACP+d,EAAY/d,EACL4d,EAAYziB,SAGvBqhB,GAAMuB,GAAW,OACXC,EACFJ,EAAYziB,MAAQ4iB,EACpBzU,GAAO,IAAMyU,GAAU,IAG3BvU,IAAO,CAACyU,EAAIC,KAER,GAAIF,EASA,OARA1U,GAAO,IAAItJ,KACFke,GAA2B,IAAdA,IACdN,EAAYziB,MAAQ6E,GAEjB4d,EAAYziB,SAEvB2iB,EAAS3iB,MAAQ0iB,EAAO1iB,YACtB0iB,EAAO1iB,MAIbmO,GAAO,IACIsU,EAAYziB,OACrB,MAEJ6iB,EACKJ,EAAYziB,KACvB,CC3CA,SAASgjB,KACL,MAAO,CAAEC,UAAW,EAAGtX,cAAUpI,EACrC,CJ0GAse,IAAe,IA/Ff,SAAkBG,GACd,MAAMI,EAAS,CAACd,EAAe5R,IACpB6R,GAAWD,EAAe5R,EAAUsS,GAI/C,OAFAI,EAAOJ,MAAQA,EACfH,IAAe,IAAMO,GAAQA,GACtBA,CACX,CAwFqBc,CAAS,CAAC,IAAI7B,IClGnCrW,GAAQsI,OAAUtT,IACd,MAAMmjB,EAAc1T,IAAM,WACtB,MAAO,CACHP,WAAYzB,GAAaC,YAAYwB,WACrCb,OAAQZ,GAAaC,YAAYW,OAEzC,IACMgU,EAAa7U,KACnB,OAAOiC,IAAM,WAKT,OAJgB,IAAIsR,GAAa/gB,GAAO+S,MAAK3O,IACzC+P,GAAckO,EAAW5S,MAAO0T,EAAYjU,WAAYmT,EAAWhU,OAAQ8U,EAAY9U,QAChFjK,IAGf,GAAE,EAaN4G,GAAQkI,IAXR,SAAajF,GACT,MAAMkV,EAAc1T,IAAM,KAAM,CAC5BP,WAAYzB,GAAaC,YAAYwB,WACrCb,OAAQZ,GAAaC,YAAYW,WAE/BgU,EAAa7U,KACnB,OAAO4C,GAAQ8C,IAAIjF,GAAM8E,MAAK3O,IAC1B+P,GAAckO,EAAW5S,MAAO0T,EAAYjU,WAAYmT,EAAWhU,OAAQ8U,EAAY9U,QAChFjK,IAEf,EGjCO,MAAM0V,GAAY,CACrBtN,OAAS4W,IACL,MAAMC,EAAkB5T,GAAMuT,IAE9B,GAAIK,EAAgBJ,UAAW,CAC3B,IAAI7e,EAAIif,EAAgBJ,UACxB,KAAO7e,KACHqL,QAAMlM,GAGV,OADekM,QAAMlM,EAEzB,CACA,MAAMyY,EAASvM,IAAM,KACjB,MAAM/B,EAAcD,GAAaC,YAC3B4V,EAAgB5V,EAAYwB,WAAW/N,OAEvCoiB,EAAWH,EAAgBvkB,UAAY,IAAIukB,EAAoBA,IAC/DvX,EAAU6B,EAAY7B,QACtBoX,EAAYvV,EAAYwB,WAAW/N,OAASmiB,EAC5C3X,EAAW,CACbyX,kBACAG,WACAN,YACAO,MAAO3X,EACP9E,SAAU,IAEdsc,EAAgB1X,SAAWA,EAC3B,MAAMxM,EAAS0M,EAAQE,QAAQ5M,OAI/B,OAHkBA,EAAO2a,UAAY3a,EAAO2a,WAAa,IAC/ClX,KAAK+I,GACf0X,EAAgBJ,UAAYA,EACrBM,CAAQ,IAEbE,EAAKL,EACLM,EAAYD,EAAGC,UAAYD,EAAGzW,WAEpC,OADAqW,EAAgB1X,SAASyX,gBAAgBM,UAAYA,EAC9C1H,CAAM,EAOjB2H,OAEJ,SAAwB3R,GAEpB,OAAOvC,IAAM,WAET,MAAMgU,EAAKzR,EACL0R,EAAYD,EAAGC,UAAYD,EAAGC,WAAa1R,EAAYhF,WACvDnB,EAAU2B,KACVsM,EAAY,GAClB,IAAI0J,EAAQ,CACR1V,aAAcjC,EAAQiC,cAE1B,KAAO0V,EAAM1V,cAAc,CACvB,MACM8V,EADYJ,EAAM1V,aAAa/B,QAAQ5M,OACZ2a,UACjC,IAAK8J,EAAgB,CACjBJ,EAAQA,EAAM1V,aACd,QACJ,CACA,MAAMnC,EAAWiY,EAAeC,MAAKlY,IACjCmO,EAAUlX,KAAK+I,GAEf,GADyBA,EAASyX,gBAAgBM,YAAcA,EAE5D,OAAO,CACX,IAEJ,GAAI/X,EAAU,CACV,MAAMxM,EAAS0M,EAAQE,QAAQ5M,OAI/B,OAHkBA,EAAO2a,UAAY3a,EAAO2a,WAAa,IAC/ClX,KAAK+I,GACfA,EAAS5E,SAASnE,KAAKiJ,GAChBF,EAAS4X,QACpB,CACAC,EAAQA,EAAM1V,YAClB,CACA,MAAMgW,EAAM,8BAA8B9R,EAAYhJ,QAAQgJ,IAE9D,MADA+R,QAAQC,KAAK,GAAGF,yBAA4BhK,GACtC,IAAI/P,MAAM+Z,EACpB,GACJ,GCzFO,MAAMG,WAAiBla,MAC1Bma,QACA,WAAAlS,CAAYmS,EAASC,EAAWF,EAAU,CAAC,GACvC3Q,MAAM4Q,GACNlS,KAAKjJ,KAAOib,GAASjb,KACrBiJ,KAAKiS,QAAU,IAAKA,EAASE,YACjC,EAEG,MAAMC,WAAwBJ,GACjC,WAAAjS,CAAYmS,EAASD,GACjB3Q,MAAM4Q,EAAS,qBAAsBD,GACrCjS,KAAKjJ,KAAOqb,GAAgBrb,IAChC,EAEG,MAAMsb,WAA2BL,GACpC,WAAAjS,CAAYmS,EAASD,GACjB3Q,MAAM4Q,EAAS,uBAAwBD,GACvCjS,KAAKjJ,KAAOsb,GAAmBtb,IACnC,EAEG,MAAMub,WAA0BN,GACnC,WAAAjS,CAAYmS,EAASD,GACjB3Q,MAAM4Q,EAAS,sBAAuBD,GACtCjS,KAAKjJ,KAAOub,GAAkBvb,IAClC,ECnBG,SAAS0G,GAASA,GACrB,MAAM7D,EAAU2B,KAChB,IAAK3B,EACD,MAAM2Y,GAEV,OAAOC,GAAc5Y,EAAS4B,GAAaC,YAC3CgC,EACJ,CACO,SAAS+U,GAAc5Y,EAASsW,EAAUxP,GAE7C,MAAMnE,EAAY2T,EAAS9T,OAC3B,OAAO,YAAoBJ,GAEvB,OADsBpC,EAAQE,QAAQ7M,YAAc,ECf7C,SAA6B2M,EAAS2C,EAAWkB,KAAazB,GACzE,MACM0F,EADS9H,EAAQE,QAAQ5M,OACF4O,OAIvB2W,EAAehV,KAAYzB,GAQjC,OAPAoL,GAAc1F,GACVxI,EAAUuZ,IACVA,EAAaC,SAAQ,KACjBtL,GAAc1F,EAAc,IAI7B+Q,CACX,CDEmBE,CAAoB/Y,EAAS2C,EAAWmE,KAAe1E,GAG3D0E,KAAc1E,EACzB,CACJ,CEpBO,MAAM4W,GAAgB,KACzB,MAAMhZ,EAAU2B,KAEhB,IAAK3B,EACD,MAAM2Y,GAEV,MAAMrC,EAAW1U,GAAaC,YAC9B,OAAO,SAAsBgC,GACzB,OAAO+U,GAAc5Y,EAASsW,EAAUzS,EAC5C,CAAC,EAEQ8U,GAAY,IAAID,GAAkB,iKCbxC,SAASO,GAAqBC,KAC/BtP,GAASC,MACXqP,EAAS1gB,QAAQ2gB,MACfvP,GAASC,MACXK,IACJ,CACA,SAASiP,GAAanZ,GAClB,MAAM1M,EAAS0M,EAAQE,QAAQ5M,OAC1BA,GAGLka,GAAcla,EAAO4O,OACzB,CCRO,SAASkX,GAAsBC,EAAgBC,EAAMhmB,EAAQimB,GAAM,eAAEC,EAAc,aAAEC,IAExF,GADena,EAAU+Z,GACb,CAGR,OAFgBC,EAAKpZ,QACbqN,QAAS,EACV8L,EAAe7Z,KAIvB,SAAuB8Z,EAAME,GAChC,OAAQjhB,IAGJ,IAAuB,IAFR+gB,EAAKpZ,QAAQ5M,OAEjBic,QACP,OAAOiK,EAAejhB,GAE1B,MAAM4G,EAAUma,EAAKpZ,QACfwZ,EAAUJ,EAAKpZ,QAAQ5M,cACtB6L,EAAQoO,OAEf1F,GAAayR,EAAMI,EAAQxX,QAG3B,OADA+W,GADqBU,GAAUL,IAExBE,EAAejhB,EAAE,CAEhC,CApBmCqhB,CAAcN,EAAME,GACnD,CACA,OAAOC,EAAaJ,EACxB,CCVO,SAASQ,GAAOhW,GACnBD,IAAM,KACF,MAAMuM,EAAStM,IACT2S,EAAa7U,KACnB,OAAOyX,GAAsBjJ,EAAQqG,EAAYA,EAAWtW,QAAQ5M,OAAQ,EAAU,CAAEkmB,kBAAgBC,iBAAe,GAE/H,CACA,SAASD,GAAejhB,GACpB,OAAOA,CACX,CACA,SAASkhB,GAAalhB,GAClB,OAAOA,CACX,CCdO,SAASuhB,GAAUjW,GACtBD,IAAM,WACcjC,KACOzB,QAAQ5M,OACxBwX,SAAShE,WAAWjD,EAC/B,GACJ,CCJO,SAAStH,GAAMuY,EAAe,IAEjC,OADgBnT,KAELiC,IAAM,IAAMmW,GAAYhF,GAAOD,MAEnCiF,GAAYhF,GAAOD,GAC9B,CACA,SAASiF,GAAYC,GACjB,MAAMC,EAAU,CAAC,OAAQ,MAAO,SAAU,QAAS,WAC7CC,EAAU,CAAC,MAAO,SAAU,UAAW,SAQvCC,EAAW,IAAIC,MAAMJ,EAAK,CAC5B,GAAAnnB,CAAIwnB,EAAQtnB,GAER,OAAK4I,MAAM5I,GAGE,WAATA,EACOinB,EAAI7lB,MAAMmB,OAEjB2kB,EAAQxY,SAAS1O,GAflBonB,EADeG,EAiBUvnB,GAhBN,IAAIqP,KAC1B,MAAM+N,EAAS6J,EAAI7lB,MAAMmmB,MAAWlY,GAEpC,OADA4X,EAAIzT,KAAKyT,EAAI7lB,OACNgc,CAAM,EAgBT+J,EAAQzY,SAAS1O,GACVinB,EAAI7lB,MAAMpB,GAAM0T,KAAKuT,EAAI7lB,OAE7B6lB,EAAIjnB,GAZAinB,EAAI7lB,MAAMpB,GAXJ,IAACunB,CAwBtB,EACA9T,IAAG,CAAC6T,EAAQtnB,EAAMoB,IACTwH,MAAM5I,GAKE,WAATA,GACAinB,EAAI7lB,MAAMmB,OAASnB,EACnB6lB,EAAIzT,KAAKyT,EAAI7lB,QACN,IAIX6lB,EAAIjnB,GAAQoB,GACL,IAZH6lB,EAAI7lB,MAAMpB,GAAQoB,EAClB6lB,EAAIzT,KAAKyT,EAAI7lB,QACN,KAanB,OAAOgmB,CACX,CCxDO,SAAS/N,GAAW7I,EAC3BuI,GACI,MAAMyO,EAASC,GAAejX,EAAYuI,GAE1C,QAAKyO,IAAUzO,EAAW9R,UAAUF,KAAKwS,aACjCkO,GAAejX,EAAWgJ,UAAWT,KAItCyO,CACX,CACA,SAASC,GAAejX,EACxBuI,GACI,MAAM2O,EAAalX,EAAWvJ,UACxB0gB,EAAa5O,EAAW9R,UACxB2gB,EAASF,GAAY3gB,KAAOyJ,EAC5BqX,EAASF,EAAW5gB,IAC1B,GAAI2gB,GAAY1b,YAAclF,EAAWU,YACrC,OAAOkgB,EAAW1gB,MAAQ2gB,EAAW3gB,IAEzC,OAAQ4gB,EAAO5b,WACX,KAAKlF,EAAWE,IACZ,OAAI6gB,GAAQ7b,YAAclF,EAAWE,KAa1C,SAAuB4gB,EAAQC,GAClC,MAAMC,EAAWF,EAAO5gB,IAClB+gB,EAAWF,EAAO7gB,IACxB,OAAO8gB,IAAaC,CACxB,CAdmBC,CAAcJ,EAAQC,GAEjC,KAAK/gB,EAAWC,IAAK,CACjB,MAAMkhB,EAalB,SAA0BL,EAAQC,EAAQrX,EAC1CuI,GACI,MAAMmP,EAAWN,EAAO5hB,QAClBmiB,EAAWN,EAAO7hB,QACxB,GAAIkiB,EAAS3lB,SAAW4lB,EAAS5lB,OAC7B,OAAO,EAIX,IAF2B2lB,EAASpe,OAAM,CAACtB,EAAQxF,IAAUmlB,EAASnlB,GAAOT,SAAWiG,EAAOjG,SAG3F,OAAO,EAEX,MAAM6lB,EAAU5X,EAAWvJ,UAAUhB,QAAU2hB,EAAO3hB,OAChDoiB,EAAUtP,EAAW9R,UAAUhB,QAAU4hB,EAAO5hB,OACtD,OAEG,SAAyBmiB,EAASC,GACrC,MAAMC,EAAqBF,EAAQ7lB,SAAW8lB,EAAQ9lB,OACtD,IAAK+lB,EACD,OAAO,EAEX,MAAMC,EAAeF,EAAQve,OAAM,SAA2B1I,EAAO4B,GACjE,MAAM8hB,EAAYsD,EAAQplB,GAE1B,UAD2B,IAAY6D,EAAWyF,iBAAmB,IAAgBzF,EAAWyF,SAC/E,CAEb,SADoBlL,EAAMgN,aAAe0W,EAAU1W,WAKvD,CACA,OAAO,CACX,IACA,GAAIma,EACA,OAAO,EAEX,OAAO,CACX,CAvBWC,CAAgBJ,EAASC,EACpC,CA5ByBI,CAAiBb,EAAQC,EAAQrX,EAAYuI,GAC1D,OAAOkP,CACX,EAEJ,MAAM,IAAI9c,MAAM,wBAAwByc,EAAO5b,YACnD,CC7BO,SAAS0c,GAAoB3V,EAAU1S,EAAa+V,GACvD,MAAM7V,EAASF,EAAYE,OACrBooB,EAAcpoB,GAAQ4O,OAG5B,GAFmBpD,EAAYgH,GAEf,CAGZ,OADiBsG,GAHNtG,EAGyB4V,IAOpChQ,GAAetY,EAAa0S,EAAU4V,EAAavS,IAC3C,IANJuD,GAAegP,EAAapoB,GAC5BH,EAAaC,GACN,EAKf,CACA,MAAMuoB,EAAQ7V,GAAU/G,UACxB,GAAI4c,EAAO,CAKP,OAD+B,IADhBjQ,GAAetY,EAAa0S,EAF3BxS,EAAO4O,OACMD,aACsCkH,IAGvD,EAEL,EACX,CAEA,OADAyS,GAA4BxoB,GACrB,CACX,CACO,SAASwoB,GAA4BxoB,GACxC,MAAME,EAASF,EAAYE,OACrBooB,EAAcpoB,GAAQ4O,OAE5BwK,GAAegP,EAAapoB,UACrBF,EAAYE,OACnBF,EAAYC,YAAc,CAC9B,CCrCO,SAASwoB,GAAmB7b,EAASmJ,EAAQwH,EAAUC,GAC1D,MACMtd,EADU0M,EAAQE,QACD5M,OACvBA,EAAOmZ,OAASzM,EAChB1M,EAAO4O,OAASlC,IACd4J,GAASC,MACX,MAAMsG,EAMV,SAA2BnQ,EAASmJ,EAAQwH,EAAUC,GAClD,MAAMkL,EASV,SAAqB9b,GACjB,MAAMhG,EAAYgG,EAAQhG,UACpB+hB,EAAU/hB,EAAUF,IAC1B,GAAIiiB,EAAQhd,YAAclF,EAAWE,IACjC,OAAOgiB,EAAQhiB,IAEnB,MAAMhB,EAAUgjB,EAAQhjB,QACxB,OAAOsD,EAAWtD,EAASgjB,EAAQ/iB,OACvC,CAjBoBgjB,CAAYhc,GACtB+b,EAAU/b,EAAQhG,UAAUF,IAC5Bd,EAAS+iB,EAAQ/iB,OACjBwQ,EAAW,GACXlW,EAAS0M,EAAQE,QAAQ5M,OAC/BA,EAAOkW,SAAWA,EAClB,MAAM2G,EAAS8L,GAAkBH,EAAS9iB,EAAQgH,EAASmJ,EAAQK,EAAU,EAAGmH,EAAUC,GAC1F,OAAOT,CACX,CAfmB+L,CAAkBlc,EAASmJ,EAAQwH,EAAUC,GAI5D,OAHAtd,EAAOmc,YAAcU,EAAOpW,MAC1B6P,GAASC,MAEJsG,CACX,CAoBO,SAASgM,GAAchoB,EAAO+L,EAAS+O,GAC1C,MAAM7b,EAAc,CAChBe,QACA+H,SAAU2V,GAAgB1d,GAC1B8a,sBAGJ,OADA/O,EAAQnJ,KAAK3D,GACNA,CACX,CCpCO,SAASgpB,GAAWna,EAC3B7O,EACA+V,GACI,MACMnJ,EADS5M,EAAYE,OACJ4O,OACjBma,EAAKjpB,EAAYyY,YAGvB,OAFA7L,EAAQiC,aAAeA,EACvB4Z,GAAmB7b,EAASmJ,OAAQzR,EAAW2kB,GACxCrc,CACX,CACO,SAASsc,GAAiBxiB,GAC7B,MAAME,EAMO,CACT+E,UAAWlF,EAAWG,UACtB4R,YAAa2Q,GACbrL,iBAAkBuK,IANtB,OAFAzhB,EAAUF,IAAMA,EAChBA,EAAIE,UAAYA,EACTA,CACX,CAUO,SAASwiB,GAAsBxiB,EAAWiI,EAAc9C,GAC3D,MAAMa,EAAUwL,GAAkBxR,EAAWiI,EAAcA,EAAapC,WAAYV,GAGpF,OAFeA,EAAQ7L,OAChBkW,SAAW,GACXxJ,CACX,CCpCO,SAASyc,GAAqBziB,EAAWmF,EAChD8C,EACAkH,EAAQwH,EAAUC,GACd,MAAM5Q,EAAUwc,GAAsBxiB,EAAWiI,EAAc9C,GAC/Da,EAAQiC,aAAeA,EACvB,MAAMkO,EAAS0L,GAAmB7b,EAASmJ,EAAQwH,EAAUA,OAAWjZ,EAAYkZ,GACpF,IAAK,MAAM7W,KAAOoW,EAAOpW,IACjBA,EAAI6V,SACAe,EACAwB,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAU5W,EAAI6V,UAG/C0B,GAAcva,KAAK,CAACmb,GAAa,CAACtB,EAAc7W,EAAI6V,WAGxD7V,EAAI8V,aACAc,EACAwB,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAU5W,EAAI8V,cAG/CyB,GAAcva,KAAK,CAACmb,GAAa,CAACtB,EAAc7W,EAAI8V,eAIhE,OAAO7P,CACX,CC1BO,SAASuc,GAAepoB,EAAOf,EAAa6O,EAAckH,EAAQwH,EAAUC,GAC/E,OAAID,EACO8L,GAAqBtoB,EAAOf,EAAa6O,EAAckH,EAAQwH,EAAUC,GAE7EwL,GAAWna,EAAc7O,EAAa+V,EACjD,CCHO,SAASuT,GAAmBxR,EAAWV,GAC1C,MAAMxQ,EAAY,CACd+E,UAAWlF,EAAWG,UACtB4R,YAAa2Q,GACbnT,cAAe0E,GACfoD,iBAAkBuK,GAClBpN,OAAQuN,GACR1Q,YACAV,QACAhY,IAAK,SAAqB+d,GAEtB,OADAvW,EAAUuW,WAAaA,EAChBvW,CACX,GAEJ,OAAOA,CACX,CCnBO,MAAMyU,GAAO,GCEb,SAASkO,GAAkBza,GAC9B,MAAM/C,EAAU+C,EAAOhC,QAEvB,OADiB0c,GAAa1a,EAAOlI,WAE1B6iB,GAAiB3a,GAErB4a,GAAsB5a,EAAQA,EAAQ/C,EACjD,CCHO,SAAS8L,GAAUT,EAAOjH,EAAYwZ,GACzC,OAAOvS,EAAMhO,KAAI,SAAsBzJ,GACnC,OAIR,SAAmBA,EAAMkP,EAAcsB,EAAYwZ,GAC/C,GAAIje,EAAY/L,KAAUA,EACtB,OAAOA,EAEX,IAAKkP,EACD,OAAOlP,EAEX,OAAOiqB,GAAUjqB,EAAMkP,EAAcsB,EAAYwZ,EACrD,CAZeE,CAAUlqB,EAAMwQ,EAAWtB,aAAcsB,EAAYwZ,EAChE,GACJ,CAWO,SAASC,GAAU7oB,EAAO8N,EAAcsB,EAAYwZ,EAAOpF,GAC9D,IAAKxjB,EACD,OAAOA,EAEX,GAAIA,EAAM4K,UACN,OAAO5K,EAEX,UAAW,IAAYyF,EAAWyF,SAC9B,OAAI0d,GAAS,EAgEd,SAAqB5oB,EAAOwjB,EAAO1V,GACtC,MAAMib,EAAU/oB,EAAMgpB,IAEtB,GAAID,EACA,OAAO/oB,EAEX,MAAMipB,EAAO,YAAuBhb,GAChC,OASD,SAA2Bib,EAClC1F,EAAO2F,EAAUrb,GACb,MAAM3O,EAAS2O,EAAa/B,QAAQ5M,OAC9B4O,EAAS5O,GAAQ4O,QAAUD,EAE3Bsb,OAA6B7lB,IADZiK,KAGjB0X,EAAiBgE,EAAOG,MAAM7F,EAAO2F,GACrCG,EAAM,WACR,MAAMte,EAAU+C,EAAOhC,QAEvB,OADef,EAAQ7L,SACW,IAAnB6L,EAAQoO,QAGvBoP,GAAkBza,GACXmX,GAHIA,CAIf,EACA,GAAIkE,EACA,OAAOE,IAGX,OADA7b,GAAagG,WAAWd,WAAW2W,GAC5BpE,CACX,CA/BeqE,CAAkBN,EAAKD,IAAKxF,EAAOvV,EAAMH,EACpD,EAKA,OAJAmb,EAAKjZ,SAAWhQ,EAChBipB,EAAKD,IAAMhpB,EAEXzB,OAAOirB,OAAOP,EAAMjpB,GACbipB,CACX,CA5EmBQ,CAAYzpB,EAAOwjB,EAAO1V,GAE9B9N,EAEX,GAAI4oB,IAAUtS,GACV,OAAOtW,EAGX,OADa0pB,GAAgB1pB,GAElBA,EAEPuL,EAAQvL,GAKhB,SAAwBA,EAAOoP,EAAYtB,EAAc8a,GACrD,IAAK,IAAIhnB,EAAQ5B,EAAMmB,OAAS,EAAGS,GAAS,IAAKA,EAAO,CACpD,MAAM+nB,EAAW3pB,EAAM4B,GAEvB,GADA5B,EAAM4B,GAASinB,GAAUc,EAAU7b,EAAcsB,EAAYwZ,EAAQ,EAAG5oB,UAC7D,IAAeyF,EAAWyF,SAAU,CAC3C,GAAIye,EAASX,IACT,SAEJY,GAAehB,EAAQ,EAAGhnB,EAAO+nB,EAAU3pB,EAAOoP,EACtD,CACJ,CACA,OAAOpP,CACX,CAhBe6pB,CAAe7pB,EAAOoP,EAAYtB,EAAc8a,GAiB/D,SAAyB5oB,EAAOoP,EAAYtB,EAAc8a,GACtD,MAAMxb,EAAO7O,OAAO6O,KAAKpN,GACzB,IAAK,MAAMgJ,KAAQoE,EAAM,CACrB,MAAMuc,EAAW3pB,EAAMgJ,GACjBgT,EAAS6M,GAAUc,EAAU7b,EAAcsB,EAAYwZ,EAAQ,EAAG5oB,GAExE,GADoBA,EAAMgJ,KACNgT,EAChB,SAEJ,MAAM8N,EAASvrB,OAAOwrB,yBAAyB/pB,EAAOgJ,GAEtD,KADkB8gB,GAAQprB,KAAOorB,GAAQzX,OAIzCrS,EAAMgJ,GAAQgT,SACH,IAAavW,EAAWyF,UAAU,CACzC,GAAIye,EAASX,IACT,SAEJY,GAAehB,EAAQ,EAAG5f,EAAM2gB,EAAU3pB,EAAOoP,EACrD,CACJ,CACA,OAAOpP,CACX,CAtCWgqB,CAAgBhqB,EAAOoP,EAAYtB,EAAc8a,EAC5D,CAsCA,SAASgB,GAAehB,EAAOhnB,EAAOqoB,EAAeC,EAAS9a,GAE1D,GAAIwZ,EAAQ,EAAG,CACX,MAAMzpB,EAASiQ,EAAWrD,QAAQ5M,OAClC+qB,EAAQtoB,GAAO6O,aAAetR,EAAOwX,SAAShE,YAAW,WACrDuX,EAAQtoB,GAASqoB,CACrB,GACJ,CACJ,CAwCO,SAASP,GAAgB1pB,GAC5B,cAAc,IAAYyF,EAAW6F,SAAWtL,GAASA,EAAM4K,SACnE,CCnIO,SAASuf,GAAYtkB,EAAWmW,EAAQoO,EAAY5T,GACvD,MAAM6T,EAAmBrO,EAAOhM,SAC1Bsa,EAAYzkB,EAAU+E,YAAclF,EAAWU,YAC/CgI,EAASX,GAAaC,YAE5B,IAAI/H,EAgBJ,OAjBAgI,GAAkByc,GAEdE,EACA3kB,EAAME,KAGNF,EAAM0kB,KAAoB7T,UAEf,IAAU/Q,EAAWyF,WAC5BvF,EAAMA,MAGdA,EAAIE,UAAYA,EAChBA,EAAUF,IAAMA,EAChBykB,EAAW3a,MAAQrB,EAAOc,WAC1Bkb,EAAW/b,OAASD,EAAOC,OAEpB+b,CACX,CCHO,SAASG,GAAe1kB,EAAWuJ,EAAYmY,GAClD,MAAMlb,EAAWxG,EAAUkR,YAAcC,GAAYmC,KAAO7C,GAAmBH,GACzEE,EAAQxQ,EAAUwQ,MAClBQ,EAAczH,EAAWyH,YAE/B,IAAI2T,EAAiB3T,EAAYC,UACjC,MAAMoC,EAAkBqO,GAAa1Q,YAC/B4T,EAAgBvR,GAAiBpC,UACnC2T,IACA5T,EAAYC,UAAY2T,EACxBD,EAAiBvR,GAAkB7J,EAAYmY,EAAaA,EAAYzZ,aAAcuI,EAAOhK,IAGjG,OADoBme,GAAkB1T,GAAUT,EAAOjH,EAAY,EAEvE,CCjCO,SAASsb,GAAmB7S,EAAS7M,EAAS8C,GACjD,MAAMjI,EAAY0iB,GAAmBvR,GAAYmC,MACjDtT,EAAU+E,UAAYiN,EAAQjN,UAC9B,MAAMiB,EAAUwc,GAAsBxiB,EAAWiI,EAAc9C,GAE/D,SAASie,IAEL,OADApjB,EAAUF,IAAakS,IAChBhM,CACX,CAIA,OAHAhG,EAAUgS,QAAUoR,EACpBA,EAAKre,UAAYiN,EAAQjN,UACzBqe,EAAKjZ,SAAW6H,EAAQ7H,UAAY6H,EAC7BhM,CACX,CCfO,SAAS8e,GAAmBvc,EAAQvC,GACvC,MAAMoD,EAAUb,EAAOa,QACnBA,EAAQ9N,QAAU8N,EAAQ9N,SAAWiN,EAAOc,WAAW/N,QAK/D,SAA4B8N,EAASpD,EAASuC,GAC1C,MAAM+V,EAAU,2DAA2DlV,EAAQ9N,qBAAqBiN,EAAOc,WAAW/N,UACpH0W,EAAUhM,EAAQhG,WAAWgS,QACnC,IAAI+S,EAAc/S,GACdA,GAAS7H,UAGJ6H,GAAS7H,YAFd4a,EAAc/S,EAAQ7H,UAK1B,MAAMkU,EAAU,CACZ1V,UAAWJ,EAAOc,WAClB2b,UAAWzc,EAAOa,QAClB2b,cACA/kB,UAAWgG,EAAQhG,WAEjBilB,EAAQ,IAAIxG,GAAmBH,EAASD,GAE9C,MADAH,QAAQ+G,MAAMC,GAAM7G,GACd4G,CACV,CAvBQE,CAAmB/b,EAASpD,EAASuC,EAE7C,CACA,MAAM2c,GAAO,kQCDN,SAASE,GAAepf,EAASiC,GACpC,MAAM9C,EAAUa,EAAQE,UACtBf,EAAQ9L,YACV,MAAMkP,EAASX,GAAaC,YAC5B7B,EAAQ4D,MAAQrB,EAAOc,WACvBrD,EAAQwC,OAASD,EAAOC,OACxBrD,EAAQ7L,OAAO4O,OAASlC,EACxB8e,GAAmBvc,EAAQvC,UACpBuC,EAAOK,mBACPL,EAAOvC,eACPuC,EAAOc,kBACPd,EAAOC,OACdZ,GAAagG,WAAWzC,KAAKlD,EACjC,CCdO,SAASod,GAAc9b,EAAYX,EAC1CzD,EAAS8C,IAqBT,SAAyBsB,EAAYX,GACjC,MAAMY,EAAYZ,GAAagB,MAC/B,GAAIJ,EAEA,YADAF,GAAQC,EAAYX,EAAaY,GAGrCT,GAAUQ,EACd,CA3BI+b,CAAgB/b,EAAYX,GAC5B,MAAM5I,EAAYuJ,EAAWvJ,UAC7B,IAAIulB,EAEJ,GAAIvlB,EAAU+E,YAAclF,EAAWU,YAAa,CAChD,MAAM4V,EAASnW,EACfulB,EAAY9T,GAAczR,EAAWiI,EAAcsB,EAAW1D,WAC9DV,GACAmf,GAAYtkB,EAAWmW,EAAQoP,EACnC,KACK,CAIDA,GAAYvT,EAFIhS,EAAUgS,SAENzI,EAAYpE,EAASyD,EAC7C,CAGA,OAFAwc,GAAeG,EAAWtd,GAC1Bsd,EAAUtd,aAAesB,EAAWtB,aAC7Bsd,CACX,CCtBO,SAASC,GAAsBrrB,EAAOf,EAC7C6O,EACAkH,EAAQwH,EAAUC,GACdzd,EAAaC,GACb,MAAM4M,EAAU6e,GAAmB1qB,EAAOf,EAAa6O,GAEvD,OADAod,GAAcrf,OAAStI,EAAWtE,GAC3BqpB,GAAqBzc,EAAQhG,UAAW5G,EAAa6O,EAAckH,EAAQwH,EAAUC,EAChG,CCSO,SAAS6O,GAA6BzlB,EAAWmF,EAAS8C,EAAckH,EAAQwH,GACnF,MAAMpN,EAAakI,GAAczR,EAAWiI,EAAcA,EAAapC,WAAYV,GAC7EugB,EAAiBnc,EAAWyH,YAClC,GAAI0U,EAAgB,CAChB,MAAM/U,EAAc3Q,EAAU+E,YAAclF,EAAWI,aAAe,GAAKykB,GAAe1kB,EAAWuJ,GACrGmc,EAAezU,UAAYN,CAC/B,CAIA,OC5BG,SAA+B3K,EAASmJ,EAAQwH,GACnD,MAAMR,EAAS0L,GAAmB7b,EAASmJ,EAAQwH,OAAUjZ,GAC7D,IAAK,MAAMqC,KAAOoW,EAAOpW,IACjBA,EAAI8V,YACJsC,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAU5W,EAAI8V,cAE/C9V,EAAI6V,QACJuC,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAU5W,EAAI6V,UAGvD,OAAO5P,CACX,CDiBW2f,CAFSN,GAAc9b,EADfpE,EAAQ7L,OAC0B4O,OACjD/C,GACsCgK,EAAQwH,EAClD,CE7BO,SAASiP,GAAwBzrB,EAAOf,EAC/C6O,EACAkH,EAAQwH,GAEJ,GADAxd,EAAaC,GACTud,EAAU,CAEV,OADsB8O,GAA6BtrB,EAAOf,EAAa6O,EAAckH,EAAQwH,EAEjG,CACA,MAAMkP,EFJH,SAAqC7lB,EAAWmF,EAAS8C,EAAckH,GAC1E,MAAM5F,EAAakI,GAAczR,EAAWiI,EAAcA,EAAapC,WAAYV,GAC7EugB,EAAiBnc,EAAWyH,YAClC,GAAI0U,EAAgB,CAChB,MAAM/U,EAAc3Q,EAAU+E,YAAclF,EAAWI,aAAe,GAAKykB,GAAe1kB,EAAWuJ,GACrGmc,EAAezU,UAAYN,CAC/B,CACA,MACM3K,EAAUqf,GAAc9b,EADfpE,EAAQ7L,OAC0B4O,OACjD/C,GAGA,OAFA0c,GAAmB7b,EAASmJ,OAAQzR,EACpCyH,EAAQ0M,aACD7L,CACX,CET0B8f,CAA4B3rB,EAAOf,EAAa6O,EAAckH,GACpF,OAAO0W,CACX,CCFA,IAAIE,GAAW,EAER,IAAI5U,GAWJ,SAASrR,GAAIG,EAAciR,EAAYC,GAAYG,SAEtD,MAAM0U,EAAa,YAAuBxV,GACtC,MAAMxQ,EAAY0iB,GAAmBxR,EAAWV,GAChDxQ,EAAU+E,UAAYlF,EAAWI,aACjCD,EAAU4R,YAAcgU,GAExB,MAAMK,ETrBP,SAAoBjmB,EAAWmW,GAWlC,OATgB,SAAoB5M,EAAYpE,EAASuc,GAGrD,MAAM/Q,EAAc+T,GAAe1kB,EAAWuJ,EAAYmY,GACpDzZ,EAAesB,EAAWtB,aAC1Bsc,EAAa9S,GAAczR,EAAWiI,EAAcsB,EAAW1D,WACrEV,EAASwL,GACT,OAAO2T,GAAYtkB,EAAWmW,EAAQoO,EAAY5T,EACtD,CAEJ,CSS6BuV,CAAWlmB,EAAWgmB,GAG3C,OAFAC,EAAa9b,SAAWlK,EACxBD,EAAUgS,QAAUiU,EACbjmB,CACX,EACMF,EAAMG,EAQZ,OAPA+lB,EAAW7b,SAAWlK,EAEtBH,EAAI2U,KAAOA,GACX3U,EAAIqmB,OAASve,GACb9H,EAAID,WAAaA,EACjBC,EAAIsmB,SAAWL,KACftR,GAAK1X,KAAKipB,GACHA,CACX,CCjCO,SAAS/S,GAAezC,EAC/BuC,EACA7B,GAEI,GADsBmV,GAAsB7V,EAAOuC,GAE/C,OAAO,GAEX,OAAQ7B,GACJ,KAAKC,GAAYmV,KACb,OAAO,EACX,KAAKnV,GAAYG,QACb,OAAOiV,GAAiB/V,EAAOuC,GACnC,KAAK5B,GAAYC,UACb,OAAOoV,GAAmBhW,EAAOuC,GAEzC,OAEJ,SAA+BvC,EAAOuC,GAElC,IAAIpC,EAAcH,EACdiW,EAAkB1T,EACtBpC,EAAc,IAAIH,GAClBiW,EAAkB,IAAK1T,GAAkB,IAEzC,IAD0BpC,EAAY9N,OAAM,CAAC1I,EAAO4B,IAMxD,SAAwB5B,EAAO4B,EAAO4U,EAAa8V,GAC/C,MAAMC,EAAUD,EAAgB1qB,GAChC,UAAW,IAAY6D,EAAW6F,OAAQ,CACtC,MAAMkhB,EAAiB,IAAKxsB,GACtBysB,EAAkB,IAAKF,GAAW,CAAC,GACnCG,EAAUnuB,OAAOouB,QAAQH,GAAgB9jB,OAAM,EAAErK,EAAK2B,KAAW4sB,GAAa5sB,EAAOysB,EAAgBpuB,IAAM,YACtGmuB,EAAenuB,UACfouB,EAAgBpuB,EAAI,MAE/B,OAAOquB,CACX,CACA,OAAOE,GAAa5sB,EAAOusB,GAAS,WAChC/V,EAAY7O,OAAO/F,EAAO,GAC1B0qB,EAAgB3kB,OAAO/F,EAAO,EAClC,GACJ,CArBkEirB,CAAe7sB,EAAO4B,EAAO4U,EAAa8V,KAEpG,OAAO,EAEX,OAAO,CACX,CAbWQ,CAAsBzW,EAAOuC,EACxC,CA8BA,SAASgU,GAAa5sB,EAAOusB,EAASQ,GAClC,UAAa,IAAYtnB,EAAWyF,SAChC,QAAOwB,GAAU1M,EAAOusB,EAASjW,KAAoB,EAGzD,UADkBiW,IACW9mB,EAAWyF,SACpC,OAAO,EAGX,MAAM8hB,EAAkBT,GAASvc,SAC7Bgd,IACAT,EAAUS,GAEGhtB,EAAMgQ,WAEnBhQ,EAAQA,EAAMgQ,UAIlB,OAFoBhQ,EAAMgN,aACJuf,EAAQvf,YAE1B+f,IACO,IAEXA,IACO,EACX,ChEvEO,SAASV,GAAmBhW,EAAOuC,GAEtC,MAAMjD,EAAMU,EAAMlV,OAClB,IAAK,IAAIS,EAAQ,EAAGA,EAAQ+T,IAAO/T,EAAO,CAGtC,GAFayU,EAAMzU,KACFgX,EAAehX,GAE5B,OAAO,CAEf,CACA,OAAO,CACX,CACO,SAASwqB,GAAiB/V,EAAOuC,GAEpC,MAAMjD,EAAMU,EAAMlV,OAClB,IAAK,IAAIS,EAAQ,EAAGA,EAAQ+T,IAAO/T,EAAO,CACtC,MAAMhD,EAAOyX,EAAMzU,GACbqrB,EAAWrU,EAAehX,GAChC,GAAI2J,EAAQ3M,IAAS2M,EAAQ0hB,GAAW,CACpC,GAAIruB,IAASquB,EACT,SAEJ,OAAO,CACX,CACA,UAAW,IAAWxnB,EAAWyF,iBAAmB,IAAezF,EAAWyF,SAG9E,UAAW,IAAWzF,EAAW6F,QAYjC,GAAI1M,IAASquB,EAGb,OAAO,SAdH,UAAW,IAAqBxnB,EAAW6F,OAAQ,CAC/C,MAAM4hB,EAAY3uB,OAAOouB,QAAQ/tB,GACjC,IAAK,MAAMuuB,KAAWD,EAAW,CAE7B,IADeE,GAAkBD,EAASF,GAEtC,OAAO,GAEf,CACJ,CAOR,CACA,OAAO,CACX,E+D3CA,SAAWjW,GACPA,EAAkB,KAAI,OAEtBA,EAAqB,QAAI,UACzBA,EAAkB,KAAI,OACtBA,EAAuB,UAAI,WAC9B,CAND,CAMGA,KAAgBA,GAAc,CAAC,IAwClCrR,GAAIQ,WARJ,WACI,MAAM,IAAI4D,MAAM,8GACpB,EAOApE,GAAI0nB,IALJ,WACI,MAAM,IAAItjB,MAAM,mGACpB,EAIApE,GAAI2nB,cAAgB3nB,GACpBA,GAAI4nB,MAdJ,SAAiBC,GACb,MAAM,IAAIzjB,MAAM,0HACpB,EAaApE,GAAI8nB,IAAM,SAAUC,GAChB,MAAM,IAAI3jB,MAAM,0HACpB,EACApE,GAAIgoB,eAAiB,SAAwB7nB,GACzC,OAAOH,GAAIG,EAAckR,GAAYC,UACzC,EACAtR,GAAIioB,WAAa,SAAoB9nB,GACjC,OAAOH,GAAIG,EAAckR,GAAYG,QACzC,EAEA5Y,OAAOC,eAAemH,GAAK,aAAc,CACrC,GAAA0M,CAAIwb,GACAA,EAAkBjjB,UAAYlF,EAAWS,WACzC0nB,EAAkBpW,YAAc4T,GAChCwC,EAAkB5Y,cAAgB0E,GAClCkU,EAAkB3T,OAASuN,GAC3BoG,EAAkB9Q,iBAAmB,WACjC,OAAQ,CACZ,CACJ,IAEJxe,OAAOC,eAAemH,GAAK,MAAO,CAC9B,GAAA0M,CAAIyb,GACAA,EAAe9d,SAAW,CACtBgc,OAAQve,GACR6M,KAAI,IAERwT,EAAeljB,UAAYlF,EAAWU,YACtC0nB,EAAerW,YAAcgU,GAC7BqC,EAAe7Y,cAAgB0E,GAC/BmU,EAAe/Q,iBAAmBuK,GAClCwG,EAAe5T,OAASuN,EAC5B,I/DtCG,MAAMtR,GAAsB,EACtBG,GAAmB,GAChC,SAAS8W,IAAmBpkB,EAAMhJ,GAAQitB,GACtC,MAAMc,EAAYd,EAASjkB,GAC3B,cAAW,IAAYvD,EAAWyF,iBAAmB,IAAgBzF,EAAWyF,UAGzE6iB,IAAc/tB,CACzB,CiE5DO,SAASguB,GAAsBC,EAAWrvB,EAAMwQ,EAAYtB,EAAczB,EAAUuc,GACvF,OAAIqF,SAIArF,EAAQvc,EAHDzN,SAMA,IAAgB6G,EAAWyF,SAE9BtM,EAAKoqB,KACLiF,EAAUjF,IAAMpqB,EAAKoqB,IACdpqB,IAEXqvB,EAAUjF,IAAMpqB,EACTqvB,GAEPvE,GAAgB9qB,GACTA,EAEP2M,EAAQ3M,GCxBT,SAA6BA,EAAMqvB,EAAW7e,EAAYtB,EAAc8a,EAAOvc,GAClF,IAAK,IAAIzK,EAAQhD,EAAKuC,OAAS,EAAGS,GAAS,IAAKA,EAAO,CACnD,MAAMwC,EAAIxF,EAAKgD,GACTssB,EAAUD,EAAUrsB,GAC1BhD,EAAKgD,GAASosB,GAAsBE,EAAS9pB,EAAGgL,EAAYtB,EAAczB,EAAUuc,EAAQ,EAChG,CACA,OAAOhqB,CACX,CDkBeuvB,CAAoBvvB,EAAMqvB,EAAW7e,EAAYtB,EAAc8a,EAAOvc,GEzB9E,SAA8BzN,EAAMqvB,EAAW7e,EAAYtB,EAAc8a,EAAOvc,GACnF,MAAMe,EAAO7O,OAAO6O,KAAKxO,GACzB,IAAK,MAAMoK,KAAQoE,EAAM,CACrB,MAAMuc,EAAW/qB,EAAKoK,GAEhBgT,EAASgS,GADCC,EAAUjlB,GACoB2gB,EAAUva,EAAYtB,EAAczB,EAAUuc,EAAQ,GACpG,GAAIe,IAAa3N,EACb,SAEJ,MAAMoS,EAAY7vB,OAAOwrB,yBAAyBnrB,EAAMoK,IAAOqJ,IAC3D+b,IAGJxvB,EAAKoK,GAAQgT,EACjB,CACA,OAAOpd,CACX,CFWWyvB,CAAqBzvB,EAAMqvB,EAAW7e,EAAYtB,EAAc8a,EAAOvc,EAClF,ClEwBO,SAAS4M,GAAkB7J,EAAYuI,EAAY7J,EAAcwgB,EACxEjiB,EAAUuc,GAAQ,GACd,MACMzpB,EADUwY,EAAW5L,QACJ5M,OACvB,IAAKA,IAAWA,EAAO4O,OAAQ,CAC3B,MAAMyI,EAAcM,GAAUwX,EAAelf,EAAYwZ,GACzD0F,EAAc1rB,QAAQ4T,GAGtB,OAFoBpH,EAAWyH,YACnBC,UAAYN,EACjB8X,CACX,CACA,MAGMC,GAFN5W,EADexY,EAAO4O,QACC4J,GACYd,YACKC,UAClC0X,EAAW,GACjB,IAAK,IAAI5sB,EAAQ,EAAGA,EAAQ0sB,EAAcntB,SAAUS,EAAO,CACvD,MAAMhD,EAAO0vB,EAAc1sB,GAErB+P,EAAWqc,GADCO,EAAgB3sB,GACgBhD,EAAMwQ,EAAYtB,EAAczB,EAAUuc,EAAQ,GACpG4F,EAAS5rB,KAAK+O,EAClB,CAGA,OAFuBvC,EAAWyH,YACnBC,UAAY0X,EACpBA,CACX,CqE1EO,SAASC,GAAmBlH,GAC/B,MAAMvc,EAAUuc,EAAYxb,QACtB5M,EAAS6L,EAAQ7L,QACjB,KAAEoT,EAAI,KAAE+H,GAASD,GAA0Blb,EAAOkW,UACxDqZ,GAAevvB,GACf,IAAK,MAAM+H,KAASoT,EAAM,CACtB,MAAMqU,EAAUznB,EAAM6E,QAAQ5M,OAC9B,IAAwB,IAApBwvB,EAAQvT,QACR,OAEJsT,GAAeC,EACnB,CACexvB,EAAOwR,eAElB4B,EAAKlO,QAAQ+V,IAEjBpb,EAAagM,EACjB,CACA,SAAS0jB,GAAevvB,GACpBA,EAAOic,SAAU,EACjBR,GAAgBzb,EAAQ,GAC5B,CCnBO,SAASyvB,GAAkBxf,EAAYmY,EAC9Cvc,GACI,MAAMogB,EAAYF,GAAc9b,EAAYmY,EAAavc,GACnD6jB,GAAatH,GAAetP,GAAWsP,EAAa6D,GAC1D,GAAKyD,GAOA,GAAItH,EAAa,CAClB,MAAM5hB,EAAM4hB,EAAY1hB,UAAUF,IAClC,GAAIA,GAAOqF,EAAQ9L,YAAc,EAAG,CAChC,MAAM4vB,EAAgBvH,GAAa1hB,UAC7BkpB,EAAUD,GAAenpB,KAU3C,SAA6BA,EAAK4hB,EAAawH,GAC3C,GAAIppB,EAAIiF,YAAclF,EAAWE,IAAK,CAClC,MAAMopB,EAAUD,GAASnpB,IAKzB,YAHIopB,IADWrpB,EAAIC,KAEf6oB,GAAmBlH,GAG3B,CACA,GAAIwH,EAAS,CACT,MAAME,EAAcF,EAAQnqB,QAC5B,GAAIqqB,EAAa,CACb,MAAMC,EAAYD,GAAa9tB,OAE3B+tB,IADcvpB,EAAIf,QAAQzD,QAE1BstB,GAAmBlH,EAE3B,CACJ,CACJ,CA5BY4H,CAAoBxpB,EAAK4hB,EAAawH,EAC1C,CACJ,MAdgB,EtEqEb,SAAuBpX,EAAYvI,GACtC,MAAMjQ,EAASwY,EAAW5L,QAAQ5M,OAClC,IAAIiwB,GAAU,EACd,MAAMtV,EAAY3a,EAAO2a,UAAY3a,EAAO2a,WAAa,GACnDuV,EAAOvV,EAAU3Y,OAAS,EAChC,KAAOiuB,IAAWC,GAAM,CACpB,MAAM1jB,EAAWmO,EAAUsV,GAC3B,IAAIxtB,GAAS,EACb,MAAM0tB,EAAQ3jB,EAAS5E,SAAS5F,OAAS,EACzC,KAAOS,IAAU0tB,GAGb,GADuBnwB,IADTwM,EAAS5E,SAASnF,GACQmK,QAAQ5M,OAI5C,OAFAwM,EAAS5E,SAASY,OAAO/F,EAAO,QAChC+J,EAAS5E,SAASnE,KAAKwM,EAInC,CACJ,CsEvFQmgB,CAAchI,EAAa6D,GAC3BqD,GAAmBlH,GACnB,MAAMpoB,EAASisB,EAAUrf,QAAQ5M,OACjCA,EAAOmZ,OAAS8S,EAChBjsB,EAAO4O,OAASqd,CACpB,CAUA,OADAA,EAAUtd,aAAesB,EAAWtB,aAC7B,CACHjC,QAASuf,EACToE,YAAaX,EAErB,CC3BO,SAASlG,GAAsBpB,EACtCnY,EACApE,GACI,MAAMgR,EAAS4S,GAAkBxf,EAAYmY,EAAavc,GACpD7L,EAAS6L,EAAQ7L,OAEvB,OAAI6c,EAAOwT,aACPta,GAAgB/V,EAAOmZ,OAAQ0D,EAAOnQ,SAC/BmQ,EAAOnQ,SAEXoc,GAAW7Y,EAAYpE,EAAS,CAAE4K,MAAO,EAAGC,QAAS,GAChE,CCRO,SAAS4S,GAAa5iB,GACzB,OAAOH,EAAWG,YAAcA,EAAU+E,SAC9C,CAEO,SAASyO,GAAcxN,GAC1B,MAAMb,EAAUa,EAAQE,QAClB5M,EAAS6L,EAAQ7L,OAEjBswB,EAAahH,GADD5c,EAAQhG,WAE1B,GAAImF,EAAQoO,OAER,OADAja,EAAOuX,QAAQ9T,KAAKiJ,GACbA,EAGX,GAAI4jB,EAAY,CAEZ,OADe/G,GAAiB7c,EAEpC,CACAb,EAAQoO,QAAS,EACbja,EAAOuX,QAAQvV,SACf0K,EAAU1M,EAAOuX,QAAQtU,MACzBjD,EAAOuX,QAAU,IAErB,MAAM/Q,EAAMgjB,GAAsBxpB,EAAO4O,OAAQlC,EAASb,GAE1D,cADOA,EAAQoO,OACRzT,CACX,CAEO,SAAS+iB,GAAiB7c,GAM7B,OADewN,GAJMzL,GAAoB/B,GACVE,QAAQ5M,OACd4O,OAI7B,CACO,SAAS2hB,GAAc7pB,EAAWgG,GACrC,MAAM8jB,EAQV,SAAgC9pB,EAAWgG,GACvC,MAAM+jB,EAAW/pB,EAAUwQ,MACrBQ,EAAchL,EAAQgL,YACtB8B,EAAc9B,EAAYK,OAEhC,GADmBgV,GAAsB0D,EAAUjX,GAE/C,OAAO,EAEX,OAAQ9S,EAAUkR,WACd,KAAKC,GAAYC,UACb,OAAOoV,GAAmBuD,EAAUjX,GACxC,KAAK3B,GAAYG,QACb,OAAOiV,GAAiBwD,EAAUjX,GAE1C,OAAQjM,GAAUkjB,EAAUjX,EAAarC,GAC7C,CAvB2BuZ,CAAuBhqB,EAAWgG,GAEzD,QAAI8jB,CAIR,CAkBO,SAASzD,GAAsB0D,EAAUjX,GAG5C,OAFeiX,EAASzuB,SACNwX,EAAYxX,MAElC,CCnEO,SAASqkB,GAAU3Z,EAASkZ,EAAW,IAC1C,MAAM/Z,EAAUa,EAAQE,QAGlB0jB,EAAahH,GADD5c,EAAQhG,WAEpBiI,EAAejC,EAAQiC,aAC7B,GAAI9C,EAAQoO,OAER,OADA2L,EAASniB,KAAKiJ,GACPkZ,EAGX,GAAI0K,EACA,OAAOjK,GAAU1X,EAAciX,GAEnC,MAAM3V,EAAavD,EACbikB,EAAcjlB,EAAeuE,EAAWvJ,WACxC+E,EAAYiB,EAAQhG,UAAU+E,UAE9BmlB,EADgBjiB,GAAgBlD,IAAclF,EAAWU,eACzB0pB,GAAeJ,GAActgB,EAAWvJ,UAAWuJ,IACnF4gB,E9FtBH,SAA8BnkB,GACjC,MACMiO,EADSjO,EAAQE,QAAQ5M,OACN2a,UACzB,IAAKA,EACD,MAAO,GAEX,MAAMmW,EAAkB,GAExB,IAAK,MAAMtkB,KAAYmO,EAAW,CAC9B,MACMoW,EAAYzkB,EADJE,EAAS6X,MACwB7X,GAC/CskB,EAAgBrtB,QAAQstB,EAAU7nB,IAAI8D,IAC1C,CACA,OAAO8jB,CACX,C8FQwBE,CAAqB/gB,GAEzC,OADA2V,EAASniB,QAAQotB,GACbD,GACAvK,GAAU1X,EAAciX,GACpB+K,GACA/K,EAASniB,KAAKwM,GAEX2V,IAEXA,EAASniB,KAAKwM,GACP2V,EACX,CC5BO,SAASqL,GAAoBpwB,EAAO6L,GACvC,MAAM1M,EAAS0M,EAAQE,QAAQ5M,OAEzBkxB,EAAkB,SAA6B7tB,EAASyL,GAC1D,IAAuB,IAAnB9O,EAAOic,QAIX,OAaD,SAAwBpb,EAAO6L,EAEtCykB,EAAQriB,GAEJ,MAAMJ,EAAYD,GAAoB/B,GAChCb,EAAU6C,EAAU9B,QAE1Bf,EAAQoO,QAAS,EAIjB,MAAM8L,EAAiBllB,EAAMqpB,MAAMiH,EAAQriB,UAGpCjD,EAAQoO,OAEf,OAEG,SAA0B8L,EAAgBqL,GAC9BA,EAAoBxkB,QAAQ5M,OAC3C,OAEJ,SAA+BgmB,EAAMD,EAAgB/lB,GAGjD,OADA2lB,GADqBU,GAAUL,IAExBF,GAAsBC,EAAgBC,EAAMhmB,EAAQ,EAAQ,CAAEkmB,eAAc,gBAAc,IACrG,CANWmL,CAAsBD,EAAqBrL,EACtD,CANmBuL,CAAiBvL,EAAgBrX,EAEpD,CA9Be6iB,CAAeL,EAAgBzF,YAAayF,EAAgBxkB,QAEnErJ,EAASyL,EACb,EAQA,OANAoiB,EAAgBzF,YAAc5qB,EAE9BqwB,EAAgBxkB,QAAUA,EAInBwkB,CACX,CA4BA,MAAMM,GAAS,eACTC,GAAgB,uBACtB,SAAS,KACL,OAAOA,EACX,CACA,SAAS,KACL,OAAOD,EACX,CChDO,SAASE,GAAsBpxB,EAAUO,EAAOwC,EAASsuB,EAAU9b,EAAQnJ,EAASvH,GACvF,GAAIA,EACA,OAAO+E,EAAiB5J,EAAUO,EAAOwC,EAAS8B,GAEtDwsB,EAAStuB,EAAS/C,EAAUO,EAChC,CClBO,SAAS+wB,GAAwBllB,EAAShI,EAAWrB,EAASkN,GACjE,MAAMsL,EAAMnP,EAAQmlB,WAEF,SAAdntB,IACAA,EAAY,YAEhB,MAAMotB,EAAmB,IAAMptB,EAGzBqtB,EADSrlB,EAAQE,QAAQ5M,OACPgyB,OACxB,IAAKD,EAASrtB,GAAY,CACtB,MAAMutB,EAAW,SAAuBC,GACpCA,EAAMC,wBAA0BD,EAAME,gBACtCC,GAAYH,EAAOJ,EAAkBI,EAAMnL,OAC/C,EACAgL,EAASrtB,GAAautB,EACtBpW,EAAIyW,iBAAiB5tB,EAAWutB,EACpC,CAGA5uB,EAAQyuB,GAAoBvhB,EAC5BlN,EAAQqB,GAAa6L,CACzB,CACA,SAAS8hB,GAAYH,EAAOJ,EAAkB/K,GAC1C,MAAMxW,EAAWwW,EAAO+K,GACxB,GAAIvhB,EAAU,CACV,IAAIgiB,GAAU,EAMd,GALAL,EAAME,gBAAkB,WACpBG,GAAU,EACVL,EAAMC,wBAAwBvyB,KAAKsyB,EACvC,EACA3hB,EAAS2hB,GACLA,EAAMM,kBAAoBD,EAC1B,MAER,CACA,MAAME,EAAa1L,EAAO0L,WACtBA,GACAJ,GAAYH,EAAOJ,EAAkBW,EAE7C,CCvCO,SAASC,GAAyBrvB,EAASsvB,EAAcjmB,EAASpM,GACrE,MAAMsyB,EAAM,YAAa9jB,GACrB,OAAO8jB,EAAInH,YAAYpoB,EAASyL,EACpC,EAEA8jB,EAAInH,YAAckH,EAClBC,EAAIlmB,QAAUA,EACdklB,GAAwBllB,EAAQH,WAAYjM,EAAU+C,EACtDuvB,EACJ,CCVO,SAASC,GAAiB1uB,GAC7B,OAAOC,MAAcD,IAAmC,IAAUA,CACtE,CC8BA,SAAS8F,GAAgB5G,EAASwG,GAC9BxG,EAAQ4G,gBAAgBJ,EAC5B,CChCO,SAASipB,GAAyBjyB,EAAO8N,EAAc7O,EAAaizB,EAASrtB,GAChF,GAAI5F,EAAYkzB,WAKZ,ODHD,SAAiCttB,EAAQvB,EAAW6O,EAAW3P,EAASsL,EAAcgjB,EAAU/kB,EAASiJ,GAE5G,GAAI7C,EAAW,CACX,GAAI6f,GAAiB1uB,GAEjB,YADAd,EAAQ4G,gBAAgB+I,GAG5B,UAAW,IAAgB1M,EAAW6F,OAElC,UADyB,IAAgB7F,EAAW6F,OAEhD,IAAK,MAAMtC,KAAQmJ,EAEXnJ,KAAQ1F,GAGZ2F,GAAarG,KAAK,CAACwG,GAAiB,CAAC5G,EAASwG,UAIlD,IAAK,MAAMA,KAAQmJ,EACflJ,GAAarG,KAAK,CAACwG,GAAiB,CAAC5G,EAASwG,IAI9D,CACAopB,GAAyBvtB,EAAQvB,EAAWd,EAASsL,EAAcgjB,EAAU/kB,EAASiJ,EAC1F,CC3BQqd,CAAwBxtB,EAAQ7E,EAAOf,EAAYe,MAAOf,EAAYuD,QACtEsL,EAAc7O,EAAY6xB,SAAU,GACpC,CAAElb,MAAO,EAAGC,QAAS,SACrB5W,EAAYe,MAAQA,GAGxB,MAAMwC,EAAUvD,EAAYuD,SC+DzB,SAA8BsvB,EAAcryB,EAAUuL,EAASxI,EAASqJ,EAASilB,EAAUxsB,EAAW0Q,GAEzG,GAAI5J,EAAW0mB,GACX,OAwBR,SAAqBjmB,EAASimB,EAActvB,EAAS/C,EAAU6E,EAAWwsB,EAAU9lB,EAASgK,GACzF,MAAM6C,EAAUhM,EAAQhG,UAAUgS,QAGlC,IAFkBA,GAASjN,WAAaiN,GAAS7H,UAAUpF,aAC3BlF,EAAWS,WAEvC,OAAOmsB,GAAsBtnB,EAAS8mB,EAAcjmB,EAASpM,EAAU+C,GAE3E,OAAO+vB,GAA6BT,EAActvB,EAAS/C,EAAU6E,EAAWwsB,EAAUjlB,EAASmJ,EACvG,CAhCewd,CAAY3mB,EAASimB,EAActvB,EAAS/C,EAAU6E,EAAWwsB,EAAU9lB,EAASgK,GAExFud,GAA6BT,EAActvB,EAAS/C,EAAU6E,EAAWwsB,EAAUjlB,EAASmJ,EACvG,CDpEIyd,CAAqBzyB,EAAOf,EAAYQ,SAAUR,EAAauD,EAASsL,EAAc7O,EAAY6xB,SAAU7xB,EAAYqF,UAAW,CAAEsR,MAAO,EAAGC,QAAS,IACxJ5W,EAAYe,MAAQA,CAExB,CERO,SAAS0yB,GAA4BjzB,EAAU2I,EAAO5F,EAASuJ,EAAS+kB,EAC/EjlB,EAASmJ,EAAQnQ,GACb,MAAM8tB,EAAa5mB,EAAQ5K,OAuB3B,SAASyxB,EAAM/tB,GACX,MAAMguB,EAKd,SAAgCzqB,EAAOvD,EAAQ8tB,GAC3C,OAAOvqB,EAAM0qB,QAAO,CAAC5f,EAAKlT,KAEtB,GADiBD,EAAeC,IAChB,EAAG,CACf,MAAM+yB,EAAUJ,IACVK,EAAYnuB,EAAOkuB,GAEzB,OADA7f,EAAItQ,KAAKowB,GACF9f,CACX,CAEA,OADAA,EAAItQ,KAAK5C,GACFkT,CAAG,GACX,GACP,CAjB4B+f,CAAuB7qB,EAAOvD,EAAQ8tB,GAAYrtB,KAAK,IAC3EwrB,EAAStuB,EAAS/C,EAAUozB,EAChC,CAxBAzqB,EAAM/D,SAASrE,IAEX,GADiBD,EAAeC,IAChB,EAAG,CACf,MAAM+yB,EAAUhnB,EAAQ5K,OAClB4G,EAAW2V,GAAgB1d,GAC3Bf,EAAc,CAChBi0B,QAAQ,EACR1wB,UACA/C,SAAUA,EACVqb,oBAAoB,EACpB/S,YAGJA,EAASkN,cAAgB,SAA0BjV,EAAOoP,EAAYnQ,EAAa+V,EAAQme,GACvFP,EAAMO,EACV,EACA,MAAMH,EAAYnuB,EAAOkuB,GACzB9zB,EAAYe,MAAQgzB,EACpBjnB,EAAQnJ,KAAK3D,EACjB,KAMJ2zB,EAAM/tB,EACV,CAcO,SAASuuB,GAAuB3zB,EAAUO,EAAOwC,EAASuJ,EAAS+kB,EAC1EjlB,EAASmJ,EAAQ1Q,GACb,MAAMyD,EAAW2V,GAAgB1d,GAC3Bf,EAAc,CAChBi0B,QAAQ,EACR1wB,UACA/C,WACAqb,oBAAoB,EACpB/S,YAEJgE,EAAQnJ,KAAK3D,GACb8I,EAASkN,cAAgBgd,GP1DtB,SAA0CxyB,EAAUO,EAAOf,EAAauD,EAASsuB,EAAUjlB,EAASmJ,EAAQ1Q,GAC/GrF,EAAYuD,QAAUA,EACtBvD,EAAY6xB,SAAWA,SACZ,IAAYrrB,EAAWyF,SACvBonB,GAAsBrzB,EAAae,EAAO6L,EAASpM,EAAU+C,IAExEvD,EAAYQ,SAAWA,EACvBR,EAAYqF,UAAYA,EACjBusB,GAAsBpxB,EAAUO,EAAOwC,EAASsuB,EAAU9b,EAAQnJ,EAASvH,GACtF,COkDI+uB,CAAiC5zB,EAAUO,EAAOf,EAAauD,EAASsuB,EAAUjlB,EAASmJ,EAAQ1Q,GACnGrF,EAAYe,MAAQA,CACxB,CC9DO,SAASszB,GAAYC,GACxB,OAAItoB,EAASsoB,IAAa,aAAcA,EAC7BA,EAASxrB,UACZ,CAEZ,CFSO,SAASyrB,GAAiB3uB,EACjCpF,EAAU+C,EAASqJ,EAASilB,EAC5B/kB,EAASzH,EAAW0Q,EAAQhV,GACxB,MAAMyzB,EAAUH,GAAY7zB,GAE5B,GADkBg0B,GAAW,EACd,CACX,MAAMzzB,EAAQ6E,EAAO4uB,GACfx0B,EAAc+oB,GAAchoB,EAAO+L,GAAS,GAIlD,GAHA9M,EAAYi0B,QAAS,EACrBj0B,EAAYuD,QAAUA,EACtBvD,EAAYkzB,YAAa,EACrBnyB,EAAM4K,UAIN,OAHA3L,EAAY8I,SAAW/H,EACvBf,EAAYy0B,WAAa9lB,GAAoB/B,GAC7C5M,EAAY8b,aAAelP,EAoBvC,SAAqBrJ,EAASmxB,EAAS10B,GAEnC,YADA00B,EAAQlc,YAAYjV,EAASmxB,EAAS10B,EAE1C,CAtBmB20B,CAAYpxB,EAASxC,EAAOf,GAEvCA,EAAY6xB,SAAWA,EAKvB,OAJiB7xB,EAAY8I,SACpBkN,cAAgBgd,QAEzBG,GAAyBvtB,EAAQ7E,EAAOwC,EAASqJ,EAASilB,EAAU/kB,EAASiJ,EAEjF,CACA,GAAIxJ,MAAMD,QAAQvL,GACd,OAAO0yB,GAA4BjzB,EAAUO,EAAOwC,EAASuJ,EAAS+kB,EAAUjlB,EAASmJ,EAAQnQ,GAErG,MAAMgvB,EAAWP,GAAYtzB,GAC7B,GAAI6zB,GAAY,EAAG,CAEf,OAAOT,GAAuB3zB,EADhBoF,EAAOgvB,GAC0BrxB,EAASuJ,EAAS+kB,EAAUjlB,EAASmJ,EAAQ1Q,EAChG,CACA,OAAOusB,GAAsBpxB,EAAUO,EAAOwC,EAASsuB,EAAU9b,EAAQnJ,EAASvH,EACtF,CAKO,SAAS8tB,GAAyBvtB,EAAQvB,EAAWd,EAASsL,EAAcgjB,EAAU/kB,EAASiJ,GAClG,IAAIgd,GAAiB1uB,GAIrB,UAAWA,IAAcmC,EAAW6F,OASX,IAArBhI,EAAUnC,QAGd2vB,EAAStuB,EAASc,EAAWiC,QAXzB,IAAK,MAAMyD,KAAQ1F,EAAW,CAC1B,MAAMtD,EAAQsD,EAAU0F,GACxBwqB,GAAiB3uB,EAAQmE,EAAMxG,EAASsL,EAAcgjB,EAAU/kB,EAASvM,EAAcwJ,GACvFgM,EAAQhV,EACZ,CAQR,CASO,SAASuyB,GAA6BT,EAActvB,EAAS/C,EAAUq0B,EAAShD,EAAUjlB,EAASmJ,GAEtG,IAAgB,IAAZ8e,EAAJ,CAIA,OAAQhC,GACJ,UAAKvuB,EACL,KAAK,EACL,KAAK,KAED,YADA0F,GAAarG,KAAK,CAACmxB,GAAkB,CAACvxB,EAAS/C,KAGvD,GAAI2L,EAAW0mB,GACX,OAAOD,GAAyBrvB,EAASsvB,EAAcjmB,EAASpM,GAGpEqxB,EAAStuB,EAAS/C,EAAUqyB,EAZ5B,MAFIzoB,EAAiB5J,EAAUqyB,EAActvB,EAASsxB,EAe1D,CAUO,SAASxB,GAAsBtnB,EAAS8mB,EAAcjmB,EAASpM,EAAU+C,GAE5EsvB,EAAe1B,GAAoB0B,EAAcjmB,GAGjD,OAFiBb,EAAQjD,SAChBkN,cAAgBgd,GAClBJ,GAAyBrvB,EAASsvB,EAAcjmB,EAASpM,EACpE,CACA,SAASs0B,GAAiBvxB,EAAS/C,GAC/B+C,EAAQ4G,gBAAgB3J,EAC5B,CGjHO,SAASu0B,GAAiBh0B,EAAO+L,EAASF,EACjDmJ,EACA4T,EACApM,EAAUC,GACN,MAAMhB,EAASoC,SAASC,eAAevY,GAEjCtG,EAAc+oB,GAAchoB,EAAO+L,EADZ6c,EAAQ,GAErC3pB,EAAYyY,YAAc+D,EACtBe,EACAwB,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAUf,KAG3C0B,GAAcva,KAAK,CAACmb,GAAa,CAACtB,EAAchB,KAEpDiB,GAAsB1c,EAAO6L,EAAS5M,EAAa+V,EAAQwH,EAAUC,EACzE,CCdO,MAAMwX,GAAe,WAE5B,EACO,SAASnM,GAAkBoM,EAAOrvB,EAAQgH,EAASmJ,EAC1DjJ,EAAS6c,EACTpM,EAAUC,GACN,MAAM7W,EAAM,GACR4W,QAA6BjZ,IAAjBkZ,IACZA,EAAeoB,SAASC,eAAevY,GACvCyY,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAUC,KAC3CD,OAAWjZ,GAEf,IAAK,IAAI3B,EAAQ,EAAGA,EAAQsyB,EAAM/yB,SAAUS,EAAO,CAC/C,MAAMuyB,EAAOD,EAAMtyB,GACb5B,EAAQm0B,EAAKvsB,EAEnB,IADeJ,MAAMxH,GACV,CAGPg0B,GADcnvB,EADAkH,EAAQ5K,QAEE4K,EAASF,EAASmJ,EAAQ4T,EAAOpM,EAAUC,GACnE,QACJ,CACA,MAAM2X,EAAU,CAAC,EAEjB,GADAxuB,EAAIhD,KAAKwxB,GACO,SAAZD,EAAK1xB,GAAe,CACpB4xB,GAAcD,EAASD,EAAM3X,EAAUC,GACvC,QACJ,CAEA,MAAMf,EAAa4Y,GAAiBF,EAASD,EAAMtvB,EAAQgH,EAASE,EAASiJ,EAAQwH,EAAUC,GAC3F0X,EAAKxxB,KACLyxB,EAAQzxB,GAAKmlB,GAAkBqM,EAAKxxB,GAAIkC,EAAQgH,EAASmJ,EAAQjJ,EAAS6c,EAAQ,EAAGlN,EAAYe,GAAc7W,IAEvH,CACA,MAAO,CAAEA,MAAKmG,UAClB,CACA,SAASuoB,GAAiBF,EAASD,EAAMtvB,EAAQgH,EAASE,EAASiJ,EAAQwH,EAAUC,GACjF,MAAMf,EAAa0Y,EAAQ1Y,WAAamC,SAAS0W,cAAcJ,EAAK1xB,IAEpE,GAAI0xB,EAAKzxB,GACL,IAAK,MAAM8xB,KAAQL,EAAKzxB,GAAI,CACxB,MAAMsG,EAAOwrB,EAAK,GACZx0B,EAAQw0B,EAAK,GAGnBhB,GAAiB3uB,EAAQmE,EAAM0S,EAAY7P,EAD1B3C,EAC6C6C,EAF5CyoB,EAAK,KAAM,EAEqDxf,EAAQhV,EAC9F,CAQJ,OANIwc,EACAwB,GAAapb,KAAK,CAACqb,GAAa,CAACzB,EAAUd,KAG3CyB,GAAcva,KAAK,CAACmb,GAAa,CAACtB,EAAcf,KAE7CA,CACX,CACA,SAAS2Y,GAAcD,EAASD,EAAM3Q,EAAO/G,GACzC,MAAM5Z,EAAWuxB,EACXhtB,EAASvE,EAASE,GAAKoxB,EAAKpxB,GAC9BygB,EACAxF,GAAapb,KAAK,CAAC6xB,GAA0B,CAACjR,EAAOpc,EAAQ,SAA2B4T,GAC5EnY,EAAS6Y,WAAaV,CAC1B,KAGZmC,GAAcva,KAAK,CAAC8xB,GAA0B,CAACjY,EAAcrV,EAAQ,SAA4B4T,GACrFnY,EAAS6Y,WAAaV,CAC1B,IACZ,CCxEO,SAAS2Z,GAAoBC,GAC5BC,GAAkB1zB,SAClB0zB,GAAkBA,GAAkB1zB,OAAS,GAAG2zB,aAAalyB,QAAQkyB,IACrEA,GAAe,IAEnBD,GAAkBjyB,KAAK,CAAEgyB,UAASE,kBAClCA,GAAe,EACnB,CACA,IAAID,GAAoB,GACb1X,GAAgB,GAChB2X,GAAe,GACf7rB,GAAe,GAEf+U,GAAe,GACf+W,GAAc,GAClB,MAAMtf,GAAW,CACpBC,MAAO,EACPsf,YAAa,GAEV,SAAS3X,GAAW4X,EAAMpyB,GAC7BA,EAAShB,YAAcozB,CAC3B,CACO,SAASlf,KACZ,KAAIN,GAASC,MAAQ,GAGrB,OAmCJ,YArBA,WACI,GAAImf,GAAkB1zB,OAAQ,CAC1B,MAAM+zB,EAAgBL,GAAkBxsB,KAAI8sB,GAAQA,EAAKP,QAAQvpB,MAAK,KAClE,MAAMypB,EAAeK,EAAKL,aAC1B,IAAK,MAAMM,KAAWN,EAClBM,EAAQ,MAAMA,EAAQ,GAC1B,MAEJP,GAAoB,GACpB,MAAMQ,EAAoBP,GAC1B,OAAOriB,QAAQS,IAAIgiB,GAAe7pB,MAAK,KACnC,IAAK,MAAM+pB,KAAWC,EAClBD,EAAQ,MAAMA,EAAQ,GAC1B,GAER,CAEA,IAAK,MAAMA,KAAWN,GAClBM,EAAQ,MAAMA,EAAQ,GAE9B,EAEIE,GACAR,GAAe,GAEf,IAAK,MAAMM,KAAWnsB,GAClBmsB,EAAQ,MAAMA,EAAQ,IAG1B,IAAK,MAAMA,KAAWpX,GAClBoX,EAAQ,MAAMA,EAAQ,IAG1B,IAAK,MAAMA,KAAWjY,GAClBiY,EAAQ,MAAMA,EAAQ,GAE9B,CA/CIG,QAGJ,WA8CIpY,GAAgB,GAChBlU,GAAe,GACf+U,GAAe,GA9Cf,MAAMwX,EAAiBT,GACvBA,GAAc,GACd,IAAK,MAAMK,KAAWI,EAClBJ,EAAQ,MAAMA,EAAQ,GAE9B,CATIK,EAHJ,CAuDO,SAASva,GAAgB1Y,GAC5BsyB,GAAalyB,KAAK,CAAC8yB,GAAc,CAAClzB,IACtC,CAEA,SAASkzB,GAAalzB,GACCA,EAAQovB,WAChB+D,YAAYnzB,EAC3B,CACO,SAASub,GAAY6X,EAAUpzB,GAClCozB,EAAShE,WAAWnV,aAAaja,EAASozB,EAC9C,CACO,SAAS3X,GAAY2X,EAAUpzB,GAClCozB,EAASC,YAAYrzB,EACzB,CACA,MAAMszB,GAAsC,iBAAbjY,UAAyBA,SAAS0W,cAAc,OAC/E,SAASwB,GAAed,GAIpB,OAFAa,GAAe5d,UAAY+c,EAEpBpX,SAASC,eAAegY,GAAe5d,UAClD,CACO,SAASgF,GAAgB0Y,EAAUX,EAAMvlB,EAAWukB,IACvD,MAAM+B,EAAUD,GAAed,GAC/BlX,GAAY6X,EAAUI,GACtBtmB,EAASsmB,EACb,CAOO,SAAStB,GAAyBkB,EAAUX,EAAMvlB,EAAWukB,IAChE6B,GAAe5d,UAAY+c,EAC3B,MAAMe,EAAUnY,SAASC,eAAegY,GAAej0B,aACvDkc,GAAY6X,EAAUI,GACtBtmB,EAASsmB,EACb,CAEO,SAASvB,GAAyBmB,EAAUX,EAAMvlB,GACrDomB,GAAe5d,UAAY+c,EAC3B,MAAMe,EAAUnY,SAASC,eAAegY,GAAej0B,aACvDoc,GAAY2X,EAAUI,GACtBtmB,EAASsmB,EACb,CC/HO,SAAS5V,GAAiBnhB,EAAa6O,GAC1C,MAAM2C,EAAexR,EAAYggB,WACjCxO,EAAa2K,SAAU,SAChBnc,EAAYggB,WACnB,MAAMM,EAAe9O,EAAa8O,aASlC,GARIA,IACArE,GAAgBqE,UACT9O,EAAa8O,qBAEjBtgB,EAAYib,QAIdzJ,EAAayO,WACd,OAEJ,MAAM+W,EAAiBxlB,EAAaxR,YAGpC,OAFoBg3B,EAAeluB,SACvBmS,OAAO+b,EAAgBnoB,GAC5B,EACX,CClBO,SAASooB,GAAkBl2B,EAClCf,EACA6O,EACAkH,EAAQwH,EAAUC,GACd,MAAM9W,EAAM3F,EACZ,IAAI6F,EAAYF,EAAIE,UACfA,IACDA,EAAYsiB,GAAiBxiB,IAEjC,MAAMxG,EAASH,EAAaC,GAC5B,OAAIud,EACO8L,GAAqBziB,EAAW5G,EAAa6O,EAAckH,EAAQwH,EAAUC,IAExFtd,EAAO4O,OAASsa,GAAsBxiB,EAAWiI,EAAc7O,GACxDgpB,GAAWna,EAAc7O,EAAa+V,GACjD,CCVO,SAASmhB,GAAuBn2B,EAAOf,EAC9C6O,EACAkH,EAAQwH,EAAUC,GAEdyZ,GADkBl2B,EAAMoY,UACKnZ,EAC7B6O,EACAkH,EAAQwH,EAAUC,GAEDxd,EAAY8I,SACpBkN,cAAgB,SAA0BjV,EAAOoP,EAAYgnB,EAAcphB,GAChF4E,GAAyBwc,EAAcp2B,GAAOoY,WAAapY,EAAOoP,EAAY4F,EAClF,EAEAhV,EAAM+c,iBAAmBsZ,EAC7B,CACA,SAASA,GAAyB1kB,EAAU1S,EAAa+V,GACrD,OAAOsS,GAAoB3V,EAC3B1S,EACA+V,EACJ,CCnBO,SAASshB,GAAU1wB,EAAKf,GAC3B,MAAMc,EAAM,CACRd,SACAiJ,aAAcN,KACd5H,MACAgF,UAAWlF,EAAWE,IACtB6R,YAAaye,GACbjhB,cAAe0E,GACfoD,iBAAkBuK,GAClBpN,OAAQuN,GACRppB,IAAK,SAAgB+d,GAEjB,OADAzW,EAAIyW,WAAaA,EACVzW,CACX,EACA4wB,QAAS,SAAiBre,GAMtB,OALAA,EAAUE,UAAYzS,EACtBA,EAAIwS,WAAaD,EACjBA,EAAUse,eAAiBte,EAAUT,YAErCS,EAAUT,YAAc0e,GACjBxwB,CACX,EAEA8wB,gBAAiB,SAAyBC,GAGtC,OADAA,EAAUlT,MAAQ7d,EACXA,CACX,EACApF,KAAM,CACFqF,IAAK,SAAaA,EAClBf,GAEI,OADAc,EAAIoB,SAAW,CAAEnB,IAAKA,EAAKf,UACpBc,CACX,IAQR,OALApH,OAAOC,eAAemH,EAAK,YAAa,CACpC0M,IAAI6F,GACOvS,EAAI4wB,QAAQre,KAGpBvS,CACX,CC7CO,SAASpF,GAAKqE,KAAYC,GAC7B,MAAM8xB,EFuBH,SAAsB/xB,EAASC,GAClC,MAAMc,EAAM,CACRd,SACAiJ,aAAcN,KACd5C,UAAWlF,EAAWC,IACtB8R,YAAaye,GACbjhB,cAAe0E,GACfoD,iBAAkBuK,GAClBpN,OAAQuN,GACR7iB,UAEAvG,IAAI+d,IACAzW,EAAIyW,WAAaA,EACVzW,GAGX4wB,QAAS,SAAiBre,GAMtB,OALAA,EAAUE,UAAYzS,EACtBA,EAAIwS,WAAaD,EACjBA,EAAUse,eAAiBte,EAAUT,YAErCS,EAAUT,YAAc0e,GACjBxwB,CACX,EAEA8wB,gBAAiB,SAAyBC,GAGtC,OADAA,EAAUlT,MAAQ7d,EACXA,CACX,EACApF,KAAM,SAAcqE,EAASC,GAEzB,OADAc,EAAIoB,SAAW,CAAEnC,UAASC,UACnBc,CACX,GAOJ,OALApH,OAAOC,eAAemH,EAAK,YAAa,CACpC0M,IAAI6F,GACOvS,EAAI4wB,QAAQre,KAGpBvS,CACX,CEhEsBixB,CAAahyB,EAASC,GAClCgB,EAAY0iB,GAAmBvR,GAAYmV,MAGjD,OAFAtmB,EAAUF,IAAMgxB,EAChBA,EAAU9wB,UAAYA,EACf8wB,CACX,CCeA,SAASE,GAAcjxB,EAAKkxB,GACpBlxB,EAAI8V,YACJob,EAAYjB,YAAYjwB,EAAI8V,YAE5B9V,EAAI6V,QACJqb,EAAYjB,YAAYjwB,EAAI6V,OAEpC,CChCO,SAASsb,GAAmBlxB,EAAWmF,EAASgmB,GACnD,MAAM7xB,EAAS6L,EAAQ7L,OACjBiQ,EAAamH,GAAe1Q,EAAWmF,GAK7C,OAJA4L,GAAqB/Q,EAAWuJ,EAAYA,GAC5CA,EAAW4hB,WAAaA,EACxB7xB,EAAOmZ,OAASnZ,EAAOmZ,QAAUlJ,EACjCjQ,EAAO4O,OAASqB,EACTA,CACX,CCCO,SAAS4nB,GAAiBvJ,EAAKtuB,EAAQ0G,EAAWoxB,EAAYz0B,EAASwI,EAASksB,GACnF,MAAMxf,EAAcmG,SAASC,eAAevY,GAC5C+U,GAAK1X,KAAMiD,EAAUgS,SAAW,CAAE7H,SAAUnK,IAC5C,MAAMgG,EAkCH,SAAoBhG,EAAW6R,EAAasZ,EAAYhmB,EAASksB,GACpElsB,EAAQ0M,YAAcA,EACtB,MAAMvY,EAAS6L,EAAQ7L,OACjBmZ,EAASnZ,EAAOmZ,OAChB6e,EAAgBh4B,EAAO4O,SAAWuK,EAClClJ,EAAakI,GAAczR,EAAW1G,EAAO4O,OAAQ5O,EAAO4O,OAAOrC,WACzEV,GACKmsB,GACDhoB,GAAQC,EAAYjQ,EAAO4O,OAC3BuK,EAAO7I,OAEX,GAAI5J,EAAU+E,YAAclF,EAAWU,YACnC,OAQR,SAA0BP,EAAWqxB,EAAe9nB,EAAYpE,EAASgmB,GACrE,MAAMhV,EAAUnW,EAAUgS,SAAW,CAAE7H,SAAUnK,GACjD,IAAKqxB,EAAe,CAChB,MAAM9nB,EAAa2nB,GAAmBlxB,EAAWmF,EAASgmB,GAE1D,OADA/F,GAAe7b,GACRA,CACX,CAGA,OAFA+a,GAAYtkB,EAAWmW,EAAQ5M,GAC/B6b,GAAe7b,GACRA,CACX,CAlBegoB,CAAiBvxB,EAAWqxB,EAAe9nB,EAAYpE,EAASgmB,GAG3E,MAAMnZ,EAAUhS,EAAUgS,QACpBwK,EAAaxK,EAAQzI,EAAYpE,GAEvC,OADAigB,GAAe7b,GACRiT,CACX,CArDoBgV,CAAWxxB,EAAW6R,EAAalV,EAASwI,EAASksB,GAKrE,GAJA/3B,EAAOm4B,OAAQ,EACXJ,IACAD,EAAWtxB,IAAMkG,EAAQhG,UAAUF,MAElCnD,EACD,MAAM,IAAIuH,MAAM,sDAAsDvH,0BAI1EA,EAAQ+0B,QAAU,WACd,MAAMpG,EAAShyB,EAAOgyB,OACtB,IAAK,MAAMttB,KAAastB,EAAQ,CAC5B,MAAMzhB,EAAWyhB,EAAOttB,GACxBrB,EAAQg1B,oBAAoB3zB,EAAW6L,EAC3C,CACAvQ,EAAOgyB,OAAS,CAAC,IACf1b,GAASC,MACX,MAAM+hB,EAAUlf,GAAe1M,EAAS1M,GAGxC,QAFEsW,GAASC,MACXK,KACO0hB,CACX,IACEhiB,GAASC,MACX,MAAMohB,EFnCH,SAA4BjrB,EAASrJ,EAASrD,EAAQ0G,EAAW4nB,EAAK/V,GACzEqM,QAAQ2T,MAAM,mCAAoC,CAAEl1B,UAASirB,MAAK5hB,YAClE,MAAMmQ,EAAS0L,GAAmB7b,EAAS,CAAE+J,MAAO,EAAGC,QAAS,GAAKrT,OAASe,GAC9EpE,EAAOmZ,OAASzM,EAChB1M,EAAO4O,OAASlC,EAChB,IAAImgB,EAASnmB,EAAUmmB,OACvB,GAAInmB,EAAU+E,YAAclF,EAAWU,YAAa,CAChD,MACM4J,EADOyd,EACSzd,SACtBgc,EAAShc,EAASgc,OAClBhc,EAASsnB,OAAQ,CACrB,CAEA90B,EAAQwpB,OAASA,EACjBxpB,EAAQkD,WAAaA,EACrBiyB,GAAY/0B,KAAK,CAAEJ,UAASqJ,YAC5B,MAAMirB,EAAcjZ,SAAS+Z,yBAC7Bd,EAAYjB,YAAYne,GACxB,IAAK,MAAMmgB,KAAW7b,EAAOpW,IACzBixB,GAAcgB,EAASf,GAG3B,OADA/S,QAAQ2T,MAAM,+BACPZ,CACX,CEYwBgB,CAAmBjsB,EAASrJ,EAASrD,EAAQ0G,EAAW4nB,EAAK/V,GAIjF,QAHEjC,GAASC,MACXK,KACAvT,EAAQqzB,YAAYiB,GACb,CACHjrB,UACAyO,KAAI,GACJ5U,WAAU,EAElB,CHlCAnF,GAAKqF,IAAM,SAAUA,KAAQf,GACzB,OAAOyxB,GAAU1wB,EAAKf,EAC1B,EIJ0B,iBAAf,WACHgZ,SAASka,UACThU,QAAQC,KAAK,sEAEjBnG,SAASka,UAAW,GAEjB,MAAMJ,GAAc,GAQpB,SAASK,GAAWvK,EAAKjrB,EAAS6T,GACrC,MAAM4hB,EAAcN,GAAYzmB,WAAUgnB,GAAUA,EAAO11B,UAAYA,IACvE,GAAIy1B,GAAe,EAAG,CAClB,MAAMpsB,EAAU8rB,GAAYM,GAAapsB,QACzC0M,GAAe1M,EAASA,EAAQE,QAAQ5M,QACxCw4B,GAAYhwB,OAAOswB,EAAa,GAEhClU,QAAQC,KAAK,8DAA+D,CAAExhB,WAClF,CAEA,IAAIqD,EAAY,IAAOoxB,EAAW5gB,GAClCxQ,EAAUkR,UAAYC,GAAYmV,KAClCtmB,EAAU+E,UAAYlF,EAAWU,YACjCP,EAAUoP,cAAgB0E,GAE1B9T,EAAUwQ,MAAQ,CAACA,GACnBxQ,EAAUyxB,OAAQ,EAElB,MAAMtsB,EAuBV,SAAuBnF,EAAWmrB,GAC9B,MASMhmB,EAAU,CACZhL,MAAO6F,EACPiV,oBAAoB,EACpB5b,YAAa,EACbC,YAAQoE,EACRwE,SAda,CACb6C,UAAW,YACXmS,iBAAkBuK,GAClBpN,OAAQuN,GACRhQ,YAAa,WACTsM,QAAQ2T,MAAM,0BAClB,EACAziB,cAAe0E,KASbxa,EAASH,EAAagM,GAK5B,OAFA7L,EAAOgyB,OAAS,CAAC,EACjB4F,GAAmBlxB,EAAWmF,EAASgmB,GAChChmB,CACX,CA9CoBmtB,CAActyB,EAAWrD,GACnCrD,EAAS6L,EAAQ7L,OACvByP,GAAUzP,EAAO4O,QACjB,IAAIkpB,EAAaxJ,EAAIpX,GACrB,MAAM6gB,SAAuBD,GAAcxxB,EAAWyF,SAiBtD,OAhBKgsB,IACIrsB,EAAeosB,IAKhB93B,EAAO4O,OAAO8I,YAAc,CACxBK,OAAQ,CAACb,GACTS,UAAW,CAACT,IAEhBxQ,EAAUkR,UAAYkgB,EAAWlgB,UACjClR,EAAU+E,UAAYqsB,EAAWrsB,UACjC/E,EAAUgS,QAAUof,EAAWpf,QAC/BhS,EAAYoxB,IAXZpxB,EAAUF,IAAMsxB,EAChBA,EAAaxJ,IAaduJ,GAAiBvJ,EAAKtuB,EAAQ0G,EAAWoxB,EAAYz0B,EAASwI,EAASksB,EAClF,CCzDO,SAAS/mB,GAAOT,GACnB,IAAKA,EACD,OAAOukB,GAEX,MAAMpoB,EAAU2B,KAChB,IAAK3B,EACD,MAAM,IAAI9B,MAAM,8CAEpB,MAAO,IAAIkE,KACP,MAAMH,EAAejC,EAAQiC,aAC7B,OAAOsqB,GAAiBnqB,EAAMyB,EAAU5B,EAAa,CAE7D,CACO,SAASsqB,GAAiBnqB,EAAMyB,EAAU5B,GAC7C,MACMuqB,EADSvqB,EAAa/B,QAAQ5M,OACT4O,OAE3B6F,GAAgBykB,EAAYhqB,OAAQP,EAAaO,QACjD,MAAMiqB,EAAI5oB,KAAYzB,GAgBtB,OAdA2F,GAAgB9F,EAAaO,OAAQgqB,EAAYhqB,QAEjD0mB,GAAYnyB,KAAK,CAAC,KACQy1B,EAAYtsB,QAAQ5M,WAKpCsW,GAASC,MACX8S,GAAkB6P,KAEhB5iB,GAASC,MACXK,KAAO,EACR,KACAuiB,CACX,CCpCO,SAASryB,GAAUsyB,EAAY7oB,GAClC,MAAM7D,EAAU2B,KACVa,EAASxC,EAAU+B,GAAoB/B,GAASwC,OAAS,GAC/D,MAAO,CACHzD,UAAWlF,EAAWO,UACtBwR,YAAa4I,GACbpL,cAAe8J,GACf7E,OAAQiG,GACRzQ,WACArB,SACAiS,YAAa,CAACiY,GAEtB,CChBA,SAASC,GAAgBx4B,EAAOoP,EAAYnQ,EAAa+V,GACrD,MACMyjB,EADQz4B,EAAMwjB,MACIrL,WACxBsgB,EAAUhhB,YAAcghB,EAAUjC,eAClC,MAAMzqB,EAAU9M,EAAYggB,YAAYhgB,YACxC2a,GAAyB7N,EAAS0sB,EAAWrpB,EAAY4F,EAC7D,CACA,SAAS0jB,GAAiB14B,EAAOf,EAAa6O,EAAckH,EAAQwH,EAAUC,GAC1Exd,EAAYggB,WAAa,CAAC,EAE1Bjf,EAAMiV,cAAgBujB,GAG1B,SAAwBx4B,EAAO8N,EAAc7O,EAAa+V,EAAQ0K,EAAsBlD,GACpF,MAAM,aAAE+C,EAAY,aAAE9C,GAAiB6C,GAAsB9C,EAAUkD,GACjET,EAAahgB,EAAYggB,WAC/BA,EAAWM,aAAeA,EAC1B,MAAMiE,EAAQxjB,EAAMwjB,MACdiV,EAAYjV,EAAMrL,WACxBsgB,EAAUhhB,YAAcghB,EAAUjC,eAElCnX,GAAkBoZ,EAAWxZ,EAAYnR,EAAckH,EAAQyH,EACnE,CAXIkc,CAAe34B,EAAO8N,EAAc7O,EAAa+V,EAAQyH,EAAcD,EAC3E,CAWO,SAASoc,KACZ,MAAO,CACHhuB,UAAW,YACX6M,YAAaihB,GACbzjB,cAAeujB,GACfte,OAAQkG,GAEhB,CC1BO,SAASrN,GAAKuN,EAAa5Q,GAC9B,MAAO,CACH9E,UAAWlF,EAAWO,UACtBwR,YAAaohB,GAEb5jB,cAAegf,GACf/Z,OAAQiG,GACRzQ,WACArB,OAAQT,GAAoBJ,MAAqBa,OACjDiS,cAER,CACA,SAASuY,GAAYh0B,EAAQ5F,EAAa6O,EAAckH,EAAQwH,GAC5D,OAAOgD,GAAe3a,EAAQ5F,EAAa6O,EAAckH,OAAQzR,EAAWiZ,EAChF,CChBO,SAASxW,GAAK0J,EAAUopB,EAAU,CAAC,GACtC,MAAO,CACHluB,UAAWlF,EAAWM,KACtByR,YAAa,GACbxC,cAAe8jB,GACf7e,OAAQ8e,GACRF,QAAS,CAAEppB,cAAaopB,GAEhC,CASA,SAASC,GAAkBpnB,EAAU7D,EAAc7O,EAAa+V,GAC5D,MAAMyD,EAAauG,GAAwBtZ,EAAWM,KAAM2L,EAAU7D,EAAc7O,EAAa+V,GACjG,GAAIyD,EACA,OAAOA,EAEX,MACMqgB,EADW75B,EAAY8I,SACJ+wB,QACnBt2B,EAAUvD,EAAYuD,QAC5Bs2B,EAAQppB,SAASlN,EAASmP,EAAU1S,EACxC,CACA,SAAS,GAAYuD,EAASuF,EAAU9I,GACpC8I,EAAS+wB,QAAQppB,SAASlN,EAASuF,EAAU9I,GAC7C,MAAM65B,EAAU/wB,EAAS+wB,QACzB,GAAIA,EAAQpT,OAAQ,CAChB,MAAMljB,EAAUvD,EAAYuD,QAC5Bs2B,EAAQpT,OAAOljB,EAASuF,EAAU9I,EACtC,CACJ,CACA,SAAS+5B,GAAW/5B,GAChB,MAAM8I,EAAW9I,EAAY8I,SACvB+wB,EAAU/wB,EAAS+wB,QACzB,GAAIA,EAAQnT,UAAW,CACnB,MAAMnjB,EAAUvD,EAAYuD,QAK5B41B,GAAiB,IAJG,WAChB,OAAOU,EAAQnT,UAAUnjB,EAASuF,EAAU9I,EAChD,GACmBA,EAAYy0B,WAEnC,CACJ,CC3CO,SAASrjB,GAAckoB,EAAY9X,EAAa/Q,GACnD,MAAO,CACH9E,UAAWlF,EAAWO,UACtBwR,YAAa8I,GAEbtL,cAAegf,GACf/Z,OAAQiG,GACRzQ,WACA+Q,cACApS,OAAQT,GAAoBJ,MAAqBa,OACjDiS,YAAa,CAACiY,GAEtB,CDJAvyB,GAAK0f,OAAUhW,GACJ1J,IAAK,QAAW,CAAE0f,OAAQhW,IAErC1J,GAAK2f,UAAajW,GACP1J,IAAK,QAAW,CAAE2f,UAAWjW,IEFjC,MAAMupB,GAAM,CACfjB,WAAU,qBAAmB,iBAAe,GAC5C9M,cAAa,SAAO,I","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContext.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/checkSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribe.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/render/afterRender.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/update/deleteSubContext.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/processOuterDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/render/registerNewTagElement.function.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/tagJsVars/pipe.function.ts","webpack://taggedjs/./ts/tagJsVars/host.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribeWith.function.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(contextItem) {\n    ;\n    contextItem.renderCount = contextItem.renderCount || 0;\n    return contextItem.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n    }\n    return false;\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push([howToSetFirstInputValue, [element, name, value]]);\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintContent } from \"../../render/paint.function.js\";\n/** handles autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName) {\n    switch (specialName) {\n        case 'autofocus':\n            paintContent.push([autofocus, [element]]);\n            return;\n        case 'autoselect':\n            paintContent.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value;\n    element.style.setProperty(smallName, value);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.context.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    return setUseMemory.stateConfig.support = support;\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.context.global.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function initState(support) {\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    setSupportInCycle(support);\n}\nexport function reState(newSupport, prevSupport, prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","export function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    const counts = { added: 0, removed: 0 };\n    while (index < len) {\n        processUpdateOneContext(values, index, contexts, support, counts);\n        ++index;\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport, counts) {\n    const newValue = values[index];\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate(newValue, ownerSupport, contextItem, counts, values);\n    contextItem.value = newValue;\n    // contextItem.tagJsVar = valueToTagJsVar(newValue)\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.context.global;\n    const context = global.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    // const global = context.global || getNewGlobal(context)\n    const global = context.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    // global.oldest = global.oldest || baseSupport as AnySupport\n    // global.oldest = baseSupport as AnySupport\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport, counts) {\n    const isComp = isTagComponent(newValue);\n    contextItem.tagJsVar = newValue;\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport, counts);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, counts, undefined, // appendTo,\n    contextItem.placeholder);\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport, counts) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, counts, undefined, // appendTo,\n        contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = global.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    if (!global || !global.newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    const newest = global.newest;\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const global = oldSupport.context.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n    contextItem.placeholder);\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = oldSupport.context;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\nownerSupport, contextItem, counts) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport, counts);\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContext(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContext(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.delete(child, ownerSupport);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.contexts;\n        // recurse\n        destroyContext(subTags, support);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContextItem(subject);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArrayContextItem(subject) {\n    const lastArray = subject.lastArray;\n    destroyArray(subject, lastArray);\n}\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { addPaintRemover } from '../render/paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.contexts;\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.locked) {\n            continue;\n        }\n        if (subject.withinOwnerElement) {\n            const tagJsVar = subject.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = subject.supportOwner;\n                tagJsVar.delete(subject, newest);\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            addPaintRemover(elm);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker);\n    }\n    const dom = clone.domElement;\n    if (!dom) {\n        return;\n    }\n    addPaintRemover(dom);\n}\n","import { destroyContext } from '../tag/destroyContext.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.context;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.contexts;\n    destroyContext(context, support);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nimport { destroySupport } from '../../render/destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    const element = item.simpleValueElm;\n    delete item.simpleValueElm;\n    addPaintRemover(element);\n}\n","export function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    // const tagJsVar = valueToTagJsVar(value)\n    // contextItem.tagJsVar = tagJsVar\n    const tagJsVar = contextItem.tagJsVar;\n    return tagJsVar.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nexport function domProcessContextItem(value, support, contextItem, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    // contextItem.handler = tagValueUpdateHandler\n    const subject = support.context;\n    subject.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    delete subject.locked;\n    contextItem.value = value;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { tagValueUpdateHandler } from \"../tag/update/tagValueUpdateHandler.function.js\";\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInit: processSimpleValueInit,\n        delete: deleteSimpleValue,\n        // TODO: get down to only one\n        checkValueChange: checkSimpleValueChange,\n        processUpdate: tagValueUpdateHandler,\n    };\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo, insertBefore) {\n    // value = value.value\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(contextItem) {\n    const elm = contextItem.simpleValueElm;\n    delete contextItem.simpleValueElm;\n    addPaintRemover(elm);\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    const isRegularUpdate = isBadValue || !(typeof (newValue) === BasicTypes.object);\n    if (isRegularUpdate) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return -1; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\n","import { checkArrayValueChange, destroyArrayContextItem } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInit: processArrayInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkArrayValueChange,\n        delete: destroyArrayContextItem,\n    };\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, counts, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = {\n        value,\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement: false,\n        placeholder: element,\n    };\n    if (!appendTo) {\n        paintCommands.push([paintBefore, [insertBefore, element]]);\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, ownerSupport, itemSubject, counts);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    contextItem.tagJsVar = valueToTagJsVar(newValue);\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, counts);\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport, counts) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.checkValueChange(newValue, contextItem, counts, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nexport function checkSubContext(newValue, ownerSupport, contextItem, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const subscription = contextItem.subContext;\n    if (!subscription || !subscription.hasEmitted) {\n        return -1;\n    }\n    subscription.callback = newValue.callback;\n    subscription.valuesHandler(subscription.lastValues);\n    return -1;\n}\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem, counts) {\n    if (!newValue || !newValue.tagJsType || newValue.tagJsType !== originalType) {\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.delete(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, ownerSupport, 99, counts);\n        return 99;\n    }\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, counts, insertBefore);\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { deleteSubContext } from './deleteSubContext.function.js';\nimport { checkSubContext } from './checkSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nexport function setupSubscribe(observables, contextItem, ownerSupport, counts, callback, appendTo, insertBeforeOriginal) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, counts, insertBefore, callback);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    // contextItem.handler = checkSubContext\n    contextItem.tagJsVar.processUpdate = checkSubContext;\n    return subContext;\n}\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore, callback) {\n    const component = getSupportWithState(ownerSupport);\n    let onOutput = function onSubValue(value) {\n        onFirstSubContext(value, subContext, ownerSupport, counts, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = function subscriptionUpdate(updateValue) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport, { added: 0, removed: 0 });\n            checkToPaint(syncRun);\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    function valueHandler(value, index) {\n        subContext.lastValues[index] = value;\n        valuesHandler(subContext.lastValues);\n    }\n    function valuesHandler(values) {\n        const newComponent = component.context.global.newest;\n        syncSupports(newComponent, component);\n        if (subContext.callback) {\n            const responseValue = subContext.callback(...values);\n            onOutput(responseValue);\n            return;\n        }\n        onOutput(values[0]);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        valueHandler,\n        valuesHandler,\n        callback,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => valueHandler(value, index)));\n        syncRun = false;\n    });\n    return subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.subscriptions.forEach(sub => sub.unsubscribe());\n    return deleteSubContext(contextItem, ownerSupport);\n}\nfunction checkToPaint(syncRun) {\n    if (!syncRun && !setUseMemory.stateConfig.support) {\n        paint();\n    }\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    return setupSubscribe(value.Observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSubscribeWith(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    const observables = value.Observables;\n    const subscription = setupSubscribe(observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n    if (!subscription.hasEmitted) {\n        const obValue = observables[0]?.value;\n        subscription.valueHandler((obValue || value.withDefault), 0);\n    }\n    return subscription;\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, appendTo) {\n    setupSubscribe([value], contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { handleTagTypeChangeFrom } from '../tag/update/checkSubContext.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        processUpdate: (newValue, ownerSupport, contextItem, counts) => handleTagTypeChangeFrom(ValueTypes.signal, newValue, ownerSupport, contextItem, counts),\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        delete: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.context.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.context.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const ownGlobal = owner.ownerSupport.context.global;\n            const ownerProviders = ownGlobal.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const global = support.context.global;\n                const providers = global.providers = global.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.context.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.context.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.context.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, global, mode, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        subject.locked = true;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const global = last.context.global;\n        //clearTimeout(timeout)\n        if (global.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        const subject = last.context;\n        const global1 = last.context.global;\n        delete subject.locked;\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, global1.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","import { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const nowSupport = getSupportInCycle();\n        return checkToResolvePromise(result, nowSupport, nowSupport.context.global, 'onInit', { resolvePromise, resolveValue });\n    });\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.context.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nexport function checkTagValueChange(newValue, contextItem, counts) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport, counts);\n        return -1;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return -1;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destroySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.context;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const global = support.context.global;\n    global.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, counts, contexts, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem, // could be tag via result.tag\ncounts) {\n    const global = contextItem.global;\n    const support = global.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.contexts = [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker]]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement]]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem, counts);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(function eachCastProp(prop) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, depth);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.context.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const global = ownerSupport.context.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const subject = newest.context;\n        const global = subject.global;\n        if (!global || subject.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from '../tag/checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n","import { executeWrap } from './executeWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    runBeforeRender(newSupport, prevSupport);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\nfunction runBeforeRender(newSupport, prevSupport) {\n    const prevState = prevSupport?.state;\n    if (prevState) {\n        reState(newSupport, prevSupport, prevState);\n        return;\n    }\n    initState(newSupport);\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { renderTagOnly } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    buildBeforeElement(support, counts, undefined, // element for append child\n    subject.placeholder);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    return processFirstTagResult(support, counts, appendTo);\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, counts, appendTo) {\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../tag/checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.delete = destroySupportByContextItem;\n        oneRenderFunction.checkValueChange = function renderOnceNeverChanges() {\n            return -1;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.checkValueChange = checkTagValueChange;\n        renderFunction.delete = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from '../render/renderSupport.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContext.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.context;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.contexts);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject) {\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.context.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return {\n        support: reSupport,\n        wasLikeTags: isLikeTag\n    };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    const global = subject.global;\n    // lastSupport !== newSupport && \n    if (result.wasLikeTags) {\n        updateSupportBy(global.oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject, { added: 0, removed: 0 });\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../tag/hasSupportChanged.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = true;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(global.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownGlobal = ownerSupport.context.global;\n    const newest = ownGlobal.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.context.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, global, 'bind', { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from '../../render/attributes/processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.context.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processNameOnlyAttrValue } from '../../render/attributes/processAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateAttribute.function.js';\nexport function processUpdateAttrContext(value, ownerSupport, contextItem, _counts, values) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        { added: 0, removed: 0 });\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, { added: 0, removed: 0 });\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { addOneContext } from '../index.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, // all the variables inside html``\nattrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.isNameOnly = true;\n        if (value.tagJsType) {\n            contextItem.tagJsVar = value;\n            contextItem.stateOwner = getSupportWithState(support);\n            contextItem.supportOwner = support;\n            return processHost(element, value, contextItem);\n        }\n        contextItem.howToSet = howToSet;\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // stand alone attributes\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, context, howToSet, support, counts, values);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, context, howToSet, support, counts, isSpecial);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nfunction processHost(element, hostVar, contextItem) {\n    hostVar.processInit(element, hostVar, contextItem);\n    return;\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    const tagJsVar = subject.tagJsVar; // = valueToTagJsVar(newAttrValue)\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, values) {\n    const startIndex = context.length;\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = context.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHanlder(value, newSupport, contextItem, counts, newValues) {\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            context.push(contextItem);\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, isSpecial) {\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        isAttr: true,\n        element,\n        attrName,\n        withinOwnerElement: true,\n        tagJsVar,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n    contextItem.value = value;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, marker]]);\n    }\n    domProcessContextItem(value, support, contextItem, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { howToSetFirstInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { paintAppend, paintAppendElementString, paintAppends, paintBefore, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nexport const blankHandler = function blankHandler() {\n    return undefined;\n};\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, context, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        for (const attr of node.at) {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            const howToSet = howToSetFirstInputValue;\n            processAttribute(values, name, domElement, support, howToSet, context, isSpecial, counts, value);\n        }\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement]]);\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { blankHandler } from \"./dom/attachDomElements.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(promise) {\n    if (paintRemoveAwaits.length) {\n        paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push(...paintRemoves);\n        paintRemoves = [];\n    }\n    paintRemoveAwaits.push({ promise, paintRemoves });\n    paintRemoves = [];\n}\nlet paintRemoveAwaits = [];\nexport let paintCommands = [];\nexport let paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    return runCycles();\n}\nfunction runCycles() {\n    runPaintCycles();\n    runAfterCycle();\n}\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    if (paintRemoveAwaits.length) {\n        const currentAwaits = paintRemoveAwaits.map(data => data.promise.then(() => {\n            const paintRemoves = data.paintRemoves;\n            for (const content of paintRemoves) {\n                content[0](...content[1]);\n            }\n        }));\n        paintRemoveAwaits = [];\n        const outerPaintRemoves = paintRemoves;\n        return Promise.all(currentAwaits).then(() => {\n            for (const content of outerPaintRemoves) {\n                content[0](...content[1]);\n            }\n        });\n    }\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    runPaintRemoves();\n    paintRemoves = [];\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element) {\n    paintRemoves.push([paintRemover, [element]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element) {\n    const parentNode = element.parentNode;\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element) {\n    relative.parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteSubContext(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.deleted = true;\n    delete contextItem.subContext;\n    const appendMarker = subscription.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker);\n        delete subscription.appendMarker;\n    }\n    delete contextItem.delete;\n    // contextItem.handler = tagValueUpdateHandler\n    // const tagJsVar = contextItem.tagJsVar as TagJsVar\n    //tagJsVar.processUpdate = tagValueUpdateHandler\n    if (!subscription.hasEmitted) {\n        return;\n    }\n    const subContextItem = subscription.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.delete(subContextItem, ownerSupport);\n    return 76;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem, counts);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    counts, appendTo, insertBefore);\n    // contextItem.handler = function outDomTagHanlder(\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate = function outDomTagHanlder(value, newSupport, contextItem2, counts) {\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport, counts);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.checkValueChange = checkOuterTagValueChange;\n}\nfunction checkOuterTagValueChange(newValue, contextItem, counts) {\n    return checkTagValueChange(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem, // subContext.contextItem as any,\n    counts);\n}\n/** When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { getStringTag } from './processOuterDomTagInit.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nexport function registerTagElement(support, element, global, templater, app, placeholder) {\n    console.debug(' Building element into tag...', { element, app, support });\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    console.debug(' Element Tag DOM built ');\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterRender } from '../render/afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reState } from '../state/state.utils.js';\nexport function renderTagElement(app, global, templater, templater2, element, subject, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    return renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const subject = {\n        value: templater,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        tagJsVar,\n    };\n    const global = getNewGlobal(subject);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\n","import { paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport);\n    };\n}\nexport function syncWrapCallback(args, callback, ownerSupport) {\n    const global = ownerSupport.context.global;\n    const newestOwner = global.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newestOwner.states, ownerSupport.states);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(ownerSupport.states, newestOwner.states);\n    // now render the owner\n    paintAfters.push([() => {\n            const newGlobal = newestOwner.context.global;\n            if (!newGlobal) {\n                // paint()\n                return; // its not a tag anymore\n            }\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            // safeRenderSupport(global.newest)\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { checkSubContext, ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    const support = getSupportInCycle();\n    const states = support ? getSupportWithState(support).states : [];\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        processUpdate: checkSubContext,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states,\n        Observables: [Observable],\n    };\n}\n","import { deleteSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, newSupport, contextItem, counts) {\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport, counts);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, counts, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, counts, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, counts, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        delete: deleteSubContext,\n    };\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processPipe,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, counts, appendTo) {\n    return setupSubscribe(values, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/checkSubContext.function.js\";\n/** Use to gain access to element */\nexport function host(callback, options = {}) {\n    return {\n        tagJsType: ValueTypes.host,\n        processInit: processHost,\n        processUpdate: processHostUpdate,\n        delete: deleteHost,\n        options: { callback, ...options },\n    };\n}\n// Attach the functions to the host namespace\n;\nhost.onInit = (callback) => {\n    return host(() => { }, { onInit: callback });\n};\nhost.onDestroy = (callback) => {\n    return host(() => { }, { onDestroy: callback });\n};\nfunction processHostUpdate(newValue, ownerSupport, contextItem, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    const element = contextItem.element;\n    options.callback(element, newValue, contextItem);\n}\nfunction processHost(element, tagJsVar, contextItem) {\n    tagJsVar.options.callback(element, tagJsVar, contextItem);\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        const element = contextItem.element;\n        options.onInit(element, tagJsVar, contextItem);\n    }\n}\nfunction deleteHost(contextItem) {\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    if (options.onDestroy) {\n        const element = contextItem.element;\n        const hostDestroy = function processHostDestroy() {\n            return options.onDestroy(element, tagJsVar, contextItem);\n        };\n        const stateOwner = contextItem.stateOwner;\n        syncWrapCallback([], hostDestroy, stateOwner);\n    }\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribeWith,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables: [Observable],\n    };\n}\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { renderTagOnly } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","global","RouteQuery","_name","variablePrefix","variableSuffix","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","placeholderRegex","RegExp","getTagVarIndex","value","search","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","length","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","index","textContent","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","pop","attributes","attrMatch","parseAttrString","element","nn","at","ch","push","textNode","pushTo","tc","postProcessTagsInComments","inputString","split","filter","notEmptyStringMapper","part","attrValue","undefined","notEmpty","noValue","lowerName","toLowerCase","fixedName","eventName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","x","forEach","isSpecial","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","strings","values","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","join","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","replacePlaceholders","valueCount","currentTail","i","loopTail","attrs","processAttributes","children","innerLoopTail","examineChild","child","textChild","string","secondMatch","wIndex","parseInt","isNaN","varContent","after","splice","v","lastIndex","mapped","tagJsVar","lengthMapper","lastRuns","getDomMeta","stringId","array","map","Number","getStringsId","lastRun","matches","every","isLastRunMatched","domMetaMap","template","interpolation","howToSetInputValue","name","paintContent","howToSetFirstInputValue","setAttribute","removeAttribute","specialAttribute","specialName","autofocus","autoselect","names","paintStyle","shift","classListAdd","classListRemove","processSpecialClass","Error","smallName","style","setProperty","classList","add","remove","select","focus","isSimpleType","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","handleProviderChanges","appSupport","provider","tagsWithProvider","support","memory","context","childTags","cSubject","getTagsWithProvider","mapToSupport","deepClone","maxDepth","makeDeepClone","clone","create","getPrototypeOf","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","getSupportInCycle","setUseMemory","stateConfig","setSupportInCycle","getSupportWithState","component","ownerSupport","newest","returnArgs","args","firstStatesHandler","setter","config","states","statesIndex","reStatesHandler","oldStates","prevSupport","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","stateArray","reState","newSupport","prevState","runRestate","StateEchoBack","getStateValue","state","callback","defaultValue","checkValue","getCallbackValue","restate","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","setValue","item","subscription","clones","subscriptions","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","syncSupports","newestSupport","syncStatesArray","from","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","processUpdateOneContext","counts","processUpdate","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","painting","locks","len","added","removed","processUpdateContext","paint","cloneValueArray","cloneTagJsValue","shallowMapper","shallowCompareDepth","deepMapper","props","deepCompareDepth","getBaseSupport","castedProps","baseSupport","blocked","destroy$","upgradeBaseToSupport","propsConfig","castProps","propWatch","PropWatches","IMMUTABLE","latest","SHALLOW","clonePropsBy","createHtmlSupport","createSupport","tryUpdateToTag","isComp","processInit","placeholder","oldSupport","oldWrapper","wrapper","newWrapper","isSameTag","skipComparing","isLikeTags","innerHTML","_innerHTML","outerHTML","oldestSupport","oldest","destroySupport","swapTags","hasChanged","newTemplater","latestProps","pastCloneProps","propsChanged","hasPropChanges","hasSupportChanged","newProps","syncFunctionProps","lastPropsConfig","DEEP","locked","renderSupport","updateExistingTagComponent","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","tagValueUpdateHandler","forceUpdateExistingValue","runBeforeDestroy","providers","destroyContext","lastArray","childValue","delete","iSubs","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","checkArrayValueChange","destroyArrayContextItem","destroyArray","destroyArrayItem","smartRemoveKids","allPromises","withinOwnerElement","supportOwner","elm","simpleValueElm","addPaintRemover","subGlobal","deleted","smartRemoveByContext","htmlDomMeta","destroyClone","destroyClones","marker","domElement","promises","compareArrayItems","newLength","lessLength","prevContext","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","destroyArrayItemByGlobal","processFirstSubjectValue","appendTo","insertBefore","domProcessContextItem","castTextValue","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkValueChange","checkSimpleValueChange","castedValue","paintBeforeText","paintCommands","oldClone","setContent","processUpdateRegularValue","getArrayTagVar","processArrayInit","processTagArray","valueToTagJsVar","getBasicTagVar","createAndProcessContextItem","document","createTextNode","paintBefore","paintAppends","paintAppend","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","updateToDiffValue","ignoreOrDestroyed","before","processNowRegularValue","checkSubContext","handleTagTypeChangeFrom","subContext","hasEmitted","valuesHandler","originalType","onFirstSubContext","guaranteeInsertBefore","appendMarker","setupSubscribe","observables","insertBeforeOriginal","onOutput","checkToPaint","syncRun","updateValue","valueHandler","responseValue","observable","setupSubscribeCallbackProcessor","deleteAndUnsubscribe","deleteSubContext","processSubscribe","Observables","processSubscribeWith","obValue","withDefault","processSignal","initialValue","Signal","Set","unsub","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","defaultFinally","init","final","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","owner","cm","compareTo","inject","ownerProviders","find","msg","console","warn","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","syncError","createTrigger","maybePromise","finally","callbackStateUpdate","callbackMaker","renderTagUpdateArray","supports","mapTagUpdate","checkToResolvePromise","callbackResult","last","mode","resolvePromise","resolveValue","global1","getUpTags","thenResolveBy","onInit","onDestroy","firstSignal","sig","editors","readers","resignal","Proxy","target","action","isLike","isLikeBaseTags","templater0","templater1","newTag","oldTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings1","values0","values1","valuesLengthsMatch","allVarsMatch","isLikeValueSets","isLikeStringTags","checkTagValueChange","lastSupport","isTag","destroySupportByContextItem","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachDomElements","attachHtmlDomMeta","addOneContext","processTag","ph","tagFakeTemplater","processTagInit","newSupportByTemplater","processNewSubjectTag","getTemplaterResult","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","depth","checkProp","alterProp","already","mem","wrap","toCall","callWith","noCycle","apply","run","callbackPropOwner","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","executeWrap","useSupport","originalFunction","stateless","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","checkStateMismatch","tagFunction","newStates","error","hint","throwStateMismatch","runAfterRender","renderTagOnly","runBeforeRender","reSupport","processRenderOnceInit","processFirstSubjectComponent","newPropsConfig","processFirstTagResult","processTagComponentInit","processResult","processReplacementComponent","tagCount","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","pastProp","obEntries","subItem","objectItemMatches","use","deepPropWatch","route","_routeProps","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","pastValue","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","cGlobal","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","inlineHtml","checkRenderUp","selfPropChange","nowProps","hasPropsToOwnerChanged","isComponent","continueUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","bindSubjectCallback","subjectFunction","bindTo","eventHandlerSupport","renderCallbackSupport","afterTagCallback","runTagCallback","noData","promiseNoData","processNonDynamicAttr","howToSet","addSupportEventListener","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","parentNode","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","processUpdateAttrContext","_counts","isNameOnly","processNameOnlyAttrValue","updateNameOnlyAttrValue","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","createDynamicArrayAttribute","startIndex","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","isAttr","newValues","createDynamicAttribute","processDynamicNameValueAttribute","getTagJsVar","attrPart","processAttribute","nameVar","stateOwner","hostVar","processHost","valueVar","special","paintContentPush","attachDynamicDom","blankHandler","nodes","node","newNode","attachDomText","attachDomElement","createElement","attr","paintAppendElementString","paintBeforeElementString","addPaintRemoveAwait","promise","paintRemoveAwaits","paintRemoves","paintAfters","removeLocks","text","currentAwaits","data","content","outerPaintRemoves","runPaintRemoves","runPaintCycles","nowPaintAfters","runAfterCycle","paintRemover","removeChild","relative","appendChild","contentCleaner","toPlainTextElm","textElm","subContextItem","processDomTagInit","processOuterDomTagInit","contextItem2","checkOuterTagValueChange","getDomTag","setHTML","oldProcessInit","acceptInnerHTML","useTagVar","stringTag","getStringTag","putOneDomDown","newFragment","loadNewBaseSupport","renderTagElement","templater2","isAppFunction","isFirstRender","executeStateWrap","runWrapper","isApp","destroy","removeEventListener","toAwait","debug","appElements","createDocumentFragment","domItem","registerTagElement","taggedJs","tagElement","appElmIndex","appElm","getNewSubject","syncWrapCallback","newestOwner","c","Observable","handleInnerHTML","realValue","processInnerHTML","checkInnerHTML","getInnerHTML","processPipe","options","processHostUpdate","deleteHost","hmr"],"sourceRoot":""}