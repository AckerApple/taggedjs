{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/./ts/tag/update/processFirstSubject.utils.ts","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/destroyTag.function.ts","webpack://taggedjs/./ts/insertAfter.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/state/setUse.function.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/letState.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/state/provider.utils.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/tag/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/tag/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/tag/render/renderTagSupport.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/children.ts","webpack://taggedjs/./ts/tag/Tag.class.ts","webpack://taggedjs/./ts/TemplaterResult.class.ts","webpack://taggedjs/./ts/interpolations/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/destroy.support.ts","webpack://taggedjs/./ts/tag/update/processNewValue.function.ts","webpack://taggedjs/./ts/tag/setTagPlaceholder.function.ts","webpack://taggedjs/./ts/interpolations/inputAttribute.ts","webpack://taggedjs/./ts/interpolations/processAttribute.function.ts","webpack://taggedjs/./ts/interpolations/interpolateAttributes.ts","webpack://taggedjs/./ts/interpolations/interpolations.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/render/renderSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/updateBeforeTemplate.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/scanTextAreaValue.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/hasTagSupportChanged.function.ts","webpack://taggedjs/./ts/alterProps.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingValue.function.ts","webpack://taggedjs/./ts/interpolations/interpolateTemplate.ts","webpack://taggedjs/./ts/interpolations/elementInitCheck.ts","webpack://taggedjs/./ts/interpolations/interpolateContentTemplates.ts","webpack://taggedjs/./ts/interpolations/interpolateElement.ts","webpack://taggedjs/./ts/interpolations/afterInterpolateElement.function.ts","webpack://taggedjs/./ts/render.ts","webpack://taggedjs/./ts/tag/TagSupport.class.ts","webpack://taggedjs/./ts/tag/update/updateContextItem.function.ts","webpack://taggedjs/./ts/tag/elementDestroyCheck.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/tag.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import { isSubjectInstance, isTagArray } from '../../isInstance';\nimport { isSimpleType } from '../checkDestroyPrevious.function';\nexport var ValueTypes;\n(function (ValueTypes) {\n    ValueTypes[\"unknown\"] = \"unknown\";\n    ValueTypes[\"tag\"] = \"tag\";\n    ValueTypes[\"templater\"] = \"templater\";\n    ValueTypes[\"tagComponent\"] = \"tag-component\";\n    ValueTypes[\"tagArray\"] = \"tag-array\";\n    ValueTypes[\"subject\"] = \"subject\";\n    ValueTypes[\"date\"] = \"date\";\n    ValueTypes[\"string\"] = \"string\";\n    ValueTypes[\"boolean\"] = \"boolean\";\n    ValueTypes[\"function\"] = \"function\";\n    ValueTypes[\"undefined\"] = \"undefined\";\n})(ValueTypes || (ValueTypes = {}));\nexport function getValueType(value) {\n    if (value === undefined || value === null) {\n        return ValueTypes.undefined;\n    }\n    const type = typeof (value);\n    if (value instanceof Function) {\n        return ValueTypes.function;\n    }\n    if (type === 'object') {\n        if (value instanceof Date) {\n            return ValueTypes.date;\n        }\n        if (isSimpleType(type)) {\n            return type;\n        }\n        const tagJsType = value.tagJsType;\n        if (tagJsType) {\n            const included = [\n                ValueTypes.tagComponent,\n                ValueTypes.templater,\n                ValueTypes.tag,\n            ].includes(tagJsType);\n            if (included) {\n                return tagJsType;\n            }\n        }\n        if (isTagArray(value)) {\n            return ValueTypes.tagArray;\n        }\n        if (isSubjectInstance(value)) {\n            return ValueTypes.subject;\n        }\n    }\n    return ValueTypes.unknown;\n}\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function isLikeTags(tagSupport0, // new\ntagSupport1) {\n    const templater0 = tagSupport0.templater;\n    const templater1 = tagSupport1.templater;\n    const tag0 = templater0?.tag || tagSupport0;\n    const tag1 = templater1.tag;\n    const strings0 = tag0.strings;\n    const strings1 = tagSupport1.strings || tag1.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index] === string);\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = tagSupport0.values || tag0.values;\n    const values1 = tagSupport1.values || tag1.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every((value, index) => {\n        const compareTo = values0[index];\n        const isFunctions = value instanceof Function && compareTo instanceof Function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true; // deepEqual(value, compareTo)\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","export function destroyTagMemory(oldTagSupport) {\n    // must destroy oldest which is tag with elements on stage\n    const oldest = oldTagSupport.global.oldest;\n    oldest.destroy();\n    destroyTagSupportPast(oldTagSupport);\n    oldTagSupport.global.context = {};\n}\nexport function destroyTagSupportPast(oldTagSupport) {\n    delete oldTagSupport.global.oldest;\n    delete oldTagSupport.global.newest;\n}\n","// Function to insert element after reference element\nexport function insertAfter(newNode, referenceNode) {\n    const parentNode = referenceNode.parentNode;\n    parentNode.insertBefore(newNode, referenceNode.nextSibling);\n}\n","import { isStaticTag } from '../isInstance';\nimport { ValueTypes, getValueType } from './update/processFirstSubject.utils';\nimport { isLikeTags } from './isLikeTags.function';\nimport { destroyTagMemory, destroyTagSupportPast } from './destroyTag.function';\nimport { insertAfter } from '../insertAfter.function';\nexport function checkDestroyPrevious(subject, // existing.value is the old value\nnewValue, insertBefore) {\n    const displaySubject = subject;\n    const hasLastValue = 'lastValue' in displaySubject;\n    const lastValue = displaySubject.lastValue; // TODO: we maybe able to use displaySubject.value and remove concept of lastValue\n    // was simple value but now something bigger\n    if (hasLastValue && lastValue !== newValue) {\n        // below is faster than using getValueType\n        const newType = typeof (newValue);\n        if (isSimpleType(newType) && typeof (lastValue) === newType) {\n            return false;\n        }\n        if (newValue instanceof Function && lastValue instanceof Function) {\n            return false;\n        }\n        destroySimpleValue(insertBefore, displaySubject);\n        return 'changed-simple-value';\n    }\n    const valueType = getValueType(newValue);\n    const arraySubject = subject;\n    const wasArray = arraySubject.lastArray;\n    // no longer an array\n    if (wasArray && valueType !== ValueTypes.tagArray) {\n        const placeholderElm = arraySubject.placeholder;\n        delete arraySubject.lastArray;\n        delete arraySubject.placeholder;\n        insertAfter(insertBefore, placeholderElm);\n        for (let index = wasArray.length - 1; index >= 0; --index) {\n            const { tagSupport } = wasArray[index];\n            destroyArrayTag(tagSupport, { added: 0, removed: 0 });\n        }\n        return 'array';\n    }\n    const tagSubject = subject;\n    const lastSupport = tagSubject.tagSupport;\n    // no longer tag or component?\n    if (lastSupport) {\n        const isValueTag = isStaticTag(newValue);\n        const isSubjectTag = isStaticTag(subject.value);\n        if (isSubjectTag && isValueTag) {\n            const newTag = newValue;\n            // its a different tag now\n            if (!isLikeTags(newTag, lastSupport)) {\n                // put template back down\n                restoreTagMarker(lastSupport);\n                destroyTagMemory(lastSupport);\n                return 2;\n            }\n            return false;\n        }\n        if (valueType === ValueTypes.tagComponent) {\n            return false; // its still a tag component\n        }\n        if (newValue && newValue.oneRender) {\n            return false;\n        }\n        // put template back down\n        restoreTagMarker(lastSupport);\n        // destroy old component, value is not a component\n        destroyTagMemory(lastSupport);\n        return 'different-tag';\n    }\n    return false;\n}\nexport function isSimpleType(value) {\n    return ['string', 'number', 'boolean'].includes(value);\n}\nexport function destroyArrayTag(tagSupport, counts) {\n    destroyTagSupportPast(tagSupport);\n    tagSupport.destroy({\n        stagger: counts.removed++,\n    });\n    const insertBefore = tagSupport.global.insertBefore;\n    const parentNode = insertBefore.parentNode;\n    parentNode.removeChild(insertBefore);\n}\nfunction destroySimpleValue(insertBefore, // always a template tag\nsubject) {\n    const clone = subject.clone;\n    const parent = clone.parentNode;\n    // 1 put the template back down\n    parent.insertBefore(insertBefore, clone);\n    parent.removeChild(clone);\n    delete subject.clone;\n    delete subject.lastValue;\n}\nexport function restoreTagMarker(lastSupport) {\n    const insertBefore = lastSupport.global.insertBefore;\n    const global = lastSupport.global;\n    const placeholderElm = global.placeholder;\n    if (placeholderElm) {\n        insertAfter(insertBefore, placeholderElm);\n        delete global.placeholder;\n    }\n}\n","import { ValueTypes } from \"./tag/update/processFirstSubject.utils\";\nexport function isStaticTag(value) {\n    return [\n        ValueTypes.tag,\n        ValueTypes.templater,\n    ].includes(value?.tagJsType);\n}\nexport function isTagTemplater(value) {\n    return value?.tagJsType === ValueTypes.templater;\n}\n// TODO: whats the difference between isTagClass and isTagComponent\nexport function isTagComponent(value) {\n    return value?.tagJsType === ValueTypes.tagComponent;\n}\nexport function isTagClass(value) {\n    return value?.tagJsType === ValueTypes.tag;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return (subject?.isSubject === true || subject?.subscribe) ? true : false; // subject?.isSubject === true || \n}\nexport function isTagArray(value) {\n    return value instanceof Array && value.every(x => [\n        ValueTypes.tag, ValueTypes.templater, ValueTypes.tag, ValueTypes.tagComponent\n    ].includes(x?.tagJsType));\n}\n","import { Subject } from \"./Subject.class\";\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (let index = valuesSeen.length - 1; index >= 0; --index) {\n                if (!valuesSeen[index]) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => subject.subscribe(x => setValue(x, index + 1)));\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from \"./Subject.class\";\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.set(countSubject.value + 1);\n    const subscription = () => {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = () => {\n        removeSubFromArray(subject.subscribers, callback); // each will be called when update comes in\n        // removeSubFromArray(Subject.globalSubs, callback) // 🔬 testing\n        Subject.globalSubCount$.set(countSubject.value - 1);\n        // any double unsubscribes will be ignored\n        subscription.unsubscribe = () => subscription;\n        // unsubscribe from any combined subjects\n        const subscriptions = subscription.subscriptions;\n        for (let index = subscriptions.length - 1; index >= 0; --index) {\n            subscriptions[index].unsubscribe();\n        }\n        return subscription;\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\n","import { isSubjectInstance } from \"../isInstance\";\nimport { combineLatest } from \"./combineLatest.function\";\nimport { getSubscription, runPipedMethods } from \"./subject.utils\";\nexport class Subject {\n    onSubscription;\n    methods = [];\n    isSubject = true;\n    subscribers = [];\n    subscribeWith;\n    _value;\n    constructor(value, onSubscription) {\n        this.onSubscription = onSubscription;\n        this._value = value;\n    }\n    get value() {\n        return this._value;\n    }\n    set value(newValue) {\n        this._value = newValue;\n        this.set(newValue);\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        // Subject.globalSubs.push(subscription) // 🔬 testing\n        const count = Subject.globalSubCount$.value;\n        Subject.globalSubCount$.set(count + 1); // 🔬 testing\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    set(value) {\n        this._value = value;\n        // Notify all subscribers with the new value\n        const subs = [...this.subscribers]; // subs may change as we call callbacks\n        const length = subs.length;\n        for (let index = 0; index < length; ++index) {\n            const sub = subs[index];\n            sub.callback(value, sub);\n        }\n    }\n    // next() is available for rxjs compatibility\n    next = this.set;\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster */\n    toCallback(callback) {\n        this.subscribe((x, subscription) => {\n            subscription.unsubscribe();\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this._value);\n        subject.methods = operations;\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.set = x => this.set(x);\n        subject.next = subject.set;\n        return subject;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging\n}\n","import { Subject } from './Subject.class';\nexport class ValueSubject extends Subject {\n    constructor(value) {\n        super(value);\n    }\n    get value() {\n        return this._value;\n    }\n    set value(newValue) {\n        this._value = newValue;\n        this.set(newValue);\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUse } from '../state';\nexport function getSupportInCycle() {\n    return setUse.memory.stateConfig.tagSupport;\n}\n","const tagUse = [];\nexport function setUse(use) {\n    // must provide defaults\n    const useMe = {\n        beforeRender: use.beforeRender || (() => undefined),\n        beforeRedraw: use.beforeRedraw || (() => undefined),\n        afterRender: use.afterRender || (() => undefined),\n        beforeDestroy: use.beforeDestroy || (() => undefined),\n    };\n    setUse.tagUse.push(useMe);\n}\nsetUse.tagUse = tagUse;\nsetUse.memory = {};\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { StateMismatchError } from '../errors';\nimport { setUse } from './setUse.function';\nsetUse.memory.stateConfig = {\n    array: [], // state memory on the first render\n    // rearray: [] as State,\n};\nconst beforeRender = (tagSupport) => initState(tagSupport);\nsetUse({\n    beforeRender,\n    beforeRedraw: beforeRender,\n    afterRender: (tagSupport) => {\n        const memory = tagSupport.memory;\n        const config = setUse.memory.stateConfig;\n        const rearray = config.rearray;\n        if (rearray.length) {\n            if (rearray.length !== config.array.length) {\n                const message = `States lengths have changed ${rearray.length} !== ${config.array.length}. State tracking requires the same amount of function calls every render. Typically this errors is thrown when a state like function call occurs only for certain conditions or when a function is intended to be wrapped with a tag() call`;\n                const wrapper = tagSupport.templater?.wrapper;\n                const details = {\n                    oldStates: config.array,\n                    newStates: config.rearray,\n                    tagFunction: wrapper.parentWrap.original,\n                };\n                const error = new StateMismatchError(message, details);\n                console.warn(message, details);\n                throw error;\n            }\n        }\n        delete config.rearray; // clean up any previous runs\n        delete config.tagSupport;\n        memory.state.length = 0;\n        memory.state.push(...config.array);\n        const state = memory.state;\n        for (let index = state.length - 1; index >= 0; --index) {\n            const item = state[index];\n            item.lastValue = getStateValue(item); // set last values\n        }\n        config.array = [];\n    }\n});\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value, checkValue] = getCallbackValue(callback);\n    if (checkValue !== StateEchoBack) {\n        const message = 'State property not used correctly. Second item in array is not setting value as expected.\\n\\n' +\n            'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n            'For \"const\" state use `const name = state(default)()`\\n\\n' +\n            'Problem state:\\n' + (callback ? callback.toString() : JSON.stringify(state)) + '\\n';\n        console.error(message, { state, callback, value, checkValue });\n        throw new Error(message);\n    }\n    return value;\n}\nexport class StateEchoBack {\n}\nfunction initState(tagSupport) {\n    const memory = tagSupport.memory;\n    const state = memory.state;\n    const config = setUse.memory.stateConfig;\n    // TODO: The following two blocks of code are state protects, have a production mode that removes this checks\n    /*\n    if (config.rearray) {\n      checkStateMismatch(tagSupport, config, state)\n    }\n    */\n    config.rearray = [];\n    const stateLength = state?.length;\n    if (stateLength) {\n        for (let index = 0; index < stateLength; ++index) {\n            getStateValue(state[index]);\n        }\n        config.rearray.push(...state);\n    }\n    config.tagSupport = tagSupport;\n}\n/*\nfunction checkStateMismatch(\n  tagSupport: BaseTagSupport,\n  config: Config,\n  state: State,\n) {\n  const wrapper = tagSupport.templater?.wrapper as Wrapper\n  const wasWrapper = config.tagSupport?.templater.wrapper as Wrapper\n  const message = 'last state not cleared. Possibly in the middle of rendering one component and another is trying to render'\n\n  if(!wasWrapper) {\n    return // its not a component or was not a component before\n  }\n\n  console.error(message, {\n    config,\n    tagFunction: wrapper.parentWrap.original,\n    wasInMiddleOf: wasWrapper.parentWrap.original,\n    state,\n    expectedClearArray: config.rearray,\n  })\n\n  throw new StateMismatchError(message, {\n    config,\n    tagFunction: wrapper.parentWrap.original,\n    state,\n    expectedClearArray: config.rearray,\n  })\n}\n*/\nexport function getCallbackValue(callback) {\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [value] = oldState;\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","export function syncStates(stateFrom, stateTo) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const state = stateFrom[index];\n        const fromValue = state.get();\n        const callback = stateTo[index].callback;\n        if (callback) {\n            callback(fromValue); // set the value\n        }\n        stateTo[index].lastValue = fromValue; // record the value\n    }\n}\n","import { setUse } from './setUse.function';\nimport { getStateValue } from './state.utils';\nimport { syncStates } from './syncStates.function';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    let getSetMethod;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return oldValue;\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    // the state is actually intended to be a function\n    if (initValue instanceof Function) {\n        const oldState = config.array;\n        const tagSupport = config.tagSupport;\n        const original = initValue;\n        initValue = ((...args) => {\n            const global = tagSupport.global;\n            const newest = global.newest;\n            const newState = newest.memory.state;\n            syncStates(newState, oldState);\n            const result = original(...args);\n            syncStates(oldState, newState);\n            return result;\n        });\n        initValue.original = original;\n    }\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n","import { ValueSubject } from '../subject';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function';\nimport { setUse } from './setUse.function';\nimport { state } from './state.function';\nimport { syncStates } from './syncStates.function';\n/**\n * When an item in watch array changes, callback function will be triggered. Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before = () => true, final = defaultFinally, } = {}) => {\n    let previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (!before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (!before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const method = (currentValues, callback) => {\n                const originalState = state(() => getSupportInCycle().memory.state);\n                const subject = state(() => new ValueSubject(undefined));\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const setTo = callback(currentValues, previousValues);\n                    if (originalState.length) {\n                        const newestState = setUse.memory.stateConfig.array;\n                        syncStates(newestState, originalState);\n                    }\n                    subject.set(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n            /*\n            method.setup = setup\n          \n            defineOnMethod(() => method as any, method)\n            \n            return method as any\n      \n            \n            const oldWatch = getWatch()\n            const watch = newWatch( oldWatch.setup )\n            // const watch = getWatch()\n            \n            const subject = state(() => new Subject())\n            watch.setup.final = (x: any) => {\n              subject.set(x)\n              return subject\n            }\n            return watch\n            */\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from \"../subject\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function\";\nimport { setUse } from \"./setUse.function\";\nimport { state } from \"./state.function\";\nimport { syncStates } from \"./syncStates.function\";\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(value, onSubscription) {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowTagSupport = getSupportInCycle();\n    return state(() => {\n        const subject = new Subject(value, onSubscription).pipe(x => {\n            syncStates(nowTagSupport.memory.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n}\nsubject.value = (value) => {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowTagSupport = getSupportInCycle();\n    return state(() => {\n        const subject = new ValueSubject(value).pipe(x => {\n            syncStates(nowTagSupport.memory.state, oldestState);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => setUse.memory.stateConfig.array);\n    const nowTagSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        syncStates(nowTagSupport.memory.state, oldestState);\n        return x;\n    });\n}\nsubject.all = all;\n","import { getStateValue } from './state.utils';\nimport { setUse } from './setUse.function';\n/** Used for variables that need to remain the same variable during render passes */\nexport function letState(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    const rearray = config.rearray;\n    let getSetMethod;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return makeStateResult(oldValue, push);\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return makeStateResult(initValue, push);\n}\nfunction makeStateResult(initValue, push) {\n    // return initValue\n    const result = (y) => {\n        push.callback = y || (x => [initValue, initValue = x]);\n        return initValue;\n    };\n    return result;\n}\n","import { letState } from \"./letState.function\";\nimport { watch } from \"./watch.function\";\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(prop) {\n    return getSetProp => {\n        let myProp = letState(prop)(getSetProp);\n        watch([prop], () => getSetProp(myProp = prop));\n        getSetProp(myProp);\n        return myProp;\n    };\n}\n","export function deepClone(obj) {\n    return makeDeepClone(obj, new WeakMap());\n}\nfunction makeDeepClone(obj, visited) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj)) {\n        return visited.get(obj);\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Register the cloned object to avoid cyclic references\n    visited.set(obj, clone);\n    // Clone each property or element of the object or array\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], visited);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clone[key] = makeDeepClone(obj[key], visited);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2) {\n    return isDeepEqual(obj1, obj2, new WeakMap());\n}\nfunction isDeepEqual(obj1, obj2, visited) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj1)) {\n        return true;\n    }\n    if (typeof obj1 === 'object' && typeof obj2 === 'object') {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        visited.set(obj1, 0);\n        // Check if obj1 and obj2 are both arrays\n        if (Array.isArray(obj1) && Array.isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, visited);\n        }\n        else if (Array.isArray(obj1) || Array.isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        return isObjectDeepEqual(obj1, obj2, visited);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, visited) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, visited) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = fn0 instanceof Function && fn1 instanceof Function;\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { deepClone } from '../deepFunctions';\nimport { setUse } from './setUse.function';\nimport { state } from './state.function';\nsetUse.memory.providerConfig = {\n    providers: [],\n    ownerSupport: undefined,\n};\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(() => ({ stateDiff: 0, provider: undefined }));\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            for (let x = stateDiffMemory.stateDiff; x > 0; --x) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            // stateDiffMemory.provider.constructMethod.compareTo = compareTo\n            return result;\n        }\n        const result = state(() => {\n            const memory = setUse.memory;\n            const stateConfig = memory.stateConfig;\n            const oldStateCount = stateConfig.array.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = 'prototype' in constructMethod ? new constructMethod() : constructMethod();\n            const stateDiff = stateConfig.array.length - oldStateCount;\n            const config = memory.providerConfig;\n            const provider = {\n                constructMethod,\n                instance,\n                clone: deepClone(instance),\n                stateDiff,\n            };\n            stateDiffMemory.provider = provider;\n            config.providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        // const compareTo = cm.compareTo = cm.compareTo || cm.toString()\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        // find once, return same every time after\n        return state(() => {\n            const config = setUse.memory.providerConfig;\n            const cm = constructor;\n            const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n            let owner = {\n                ownerTagSupport: config.ownerSupport\n            };\n            while (owner.ownerTagSupport) {\n                const ownerProviders = owner.ownerTagSupport.global.providers;\n                const provider = ownerProviders.find(provider => {\n                    const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                    if (constructorMatch) {\n                        return true;\n                    }\n                });\n                if (provider) {\n                    provider.clone = deepClone(provider.instance); // keep a copy of the latest before any change occur\n                    config.providers.push(provider);\n                    return provider.instance;\n                }\n                owner = owner.ownerTagSupport; // cause reloop checking next parent\n            }\n            const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n            console.warn(`${msg}. Available providers`, config.providers);\n            throw new Error(msg);\n        });\n    }\n};\nsetUse({\n    beforeRender: (tagSupport, ownerSupport) => {\n        run(tagSupport, ownerSupport);\n    },\n    beforeRedraw: (tagSupport, newTagSupport) => {\n        run(tagSupport, newTagSupport.ownerTagSupport);\n    },\n    afterRender: (tagSupport) => {\n        const config = setUse.memory.providerConfig;\n        tagSupport.global.providers = [...config.providers];\n        config.providers.length = 0;\n    }\n});\nfunction run(tagSupport, ownerSupport) {\n    const config = setUse.memory.providerConfig;\n    config.ownerSupport = ownerSupport;\n    if (tagSupport.global.providers.length) {\n        config.providers.length = 0;\n        config.providers.push(...tagSupport.global.providers);\n    }\n}\n","import { deepClone, deepEqual } from '../deepFunctions';\nimport { renderTagSupport } from '../tag/render/renderTagSupport.function';\nexport function providersChangeCheck(tagSupport) {\n    const global = tagSupport.global;\n    const providersWithChanges = global.providers.filter(provider => !deepEqual(provider.instance, provider.clone));\n    // reset clones\n    for (let index = providersWithChanges.length - 1; index >= 0; --index) {\n        const provider = providersWithChanges[index];\n        const appSupport = tagSupport.getAppTagSupport();\n        handleProviderChanges(appSupport, provider);\n        provider.clone = deepClone(provider.instance);\n    }\n}\nfunction handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    for (let index = tagsWithProvider.length - 1; index >= 0; --index) {\n        const { tagSupport, renderCount, provider } = tagsWithProvider[index];\n        if (tagSupport.global.deleted) {\n            continue; // i was deleted after another tag processed\n        }\n        const notRendered = renderCount === tagSupport.global.renderCount;\n        if (notRendered) {\n            provider.clone = deepClone(provider.instance);\n            renderTagSupport(tagSupport, false);\n            continue;\n        }\n    }\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(tagSupport, provider, memory = []) {\n    const global = tagSupport.global;\n    const compare = global.providers;\n    const hasProvider = compare.find(xProvider => xProvider.constructMethod.compareTo === provider.constructMethod.compareTo);\n    if (hasProvider) {\n        memory.push({\n            tagSupport,\n            renderCount: global.renderCount,\n            provider: hasProvider,\n        });\n    }\n    const childTags = tagSupport.childTags;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        getTagsWithProvider(childTags[index], provider, memory);\n    }\n    return memory;\n}\n","import { setUse } from '../state';\nimport { Subject } from '../subject';\nimport { getSupportInCycle } from './getSupportInCycle.function';\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nsetUse.memory.tagClosed$ = new Subject(undefined, subscription => {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n// Life cycle 1\nexport function runBeforeRender(tagSupport, ownerSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeRender(tagSupport, ownerSupport);\n    }\n}\n// Life cycle 2\nexport function runAfterRender(tagSupport, ownerTagSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].afterRender(tagSupport, ownerTagSupport);\n    }\n    setUse.memory.tagClosed$.next(ownerTagSupport);\n}\n// Life cycle 3\nexport function runBeforeRedraw(tagSupport, ownerTagSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeRedraw(tagSupport, ownerTagSupport);\n    }\n}\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(tagSupport, ownerTagSupport) {\n    const tagUse = setUse.tagUse;\n    const length = tagUse.length;\n    for (let index = 0; index < length; ++index) {\n        tagUse[index].beforeDestroy(tagSupport, ownerTagSupport);\n    }\n}\n","import { runBeforeRedraw, runBeforeRender } from '../tagRunner';\nimport { setUse } from '../../state';\nimport { runAfterRender } from '../tagRunner';\nexport function renderTagOnly(newTagSupport, lastSupport, subject, ownerSupport) {\n    const oldRenderCount = newTagSupport.global.renderCount;\n    beforeWithRender(newTagSupport, ownerSupport, lastSupport);\n    const templater = newTagSupport.templater;\n    // NEW TAG CREATED HERE\n    const wrapper = templater.wrapper;\n    let reSupport = wrapper(newTagSupport, subject);\n    /* AFTER */\n    runAfterRender(newTagSupport, ownerSupport);\n    // When we rendered, only 1 render should have taken place OTHERWISE rendering caused another render and that is the latest instead\n    if (reSupport.global.renderCount > oldRenderCount + 1) {\n        return newTagSupport.global.newest;\n    }\n    newTagSupport.global.newest = reSupport;\n    return reSupport;\n}\nfunction beforeWithRender(tagSupport, // new\nownerSupport, lastSupport) {\n    const lastOwnerSupport = lastSupport?.ownerTagSupport;\n    const runtimeOwnerSupport = lastOwnerSupport || ownerSupport;\n    if (lastSupport) {\n        const lastState = lastSupport.memory.state;\n        const memory = tagSupport.memory;\n        // memory.state.length = 0\n        // memory.state.push(...lastState)\n        memory.state = [...lastState];\n        tagSupport.global = lastSupport.global;\n        runBeforeRedraw(tagSupport, lastSupport);\n    }\n    else {\n        // first time render\n        runBeforeRender(tagSupport, runtimeOwnerSupport);\n        // TODO: Logic below most likely could live within providers.ts inside the runBeforeRender function\n        const providers = setUse.memory.providerConfig;\n        providers.ownerSupport = runtimeOwnerSupport;\n    }\n}\n","import { isLikeTags } from '../isLikeTags.function';\nimport { destroyTagMemory } from '../destroyTag.function';\nimport { renderTagOnly } from './renderTagOnly.function';\nexport function renderWithSupport(newTagSupport, lastSupport, // previous\nsubject, // events & memory\nownerSupport) {\n    const reSupport = renderTagOnly(newTagSupport, lastSupport, subject, ownerSupport);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        destroyUnlikeTags(lastSupport, reSupport, subject);\n    }\n    const lastOwnerSupport = lastSupport?.ownerTagSupport;\n    reSupport.ownerTagSupport = (ownerSupport || lastOwnerSupport);\n    return reSupport;\n}\nfunction destroyUnlikeTags(lastSupport, // old\nreSupport, // new\nsubject) {\n    const oldGlobal = lastSupport.global;\n    const insertBefore = oldGlobal.insertBefore;\n    destroyTagMemory(lastSupport);\n    // when a tag is destroyed, disconnect the globals\n    reSupport.global = { ...oldGlobal }; // break memory references\n    const global = reSupport.global;\n    global.insertBefore = insertBefore;\n    global.deleted = false;\n    delete global.oldest;\n    delete global.newest;\n    delete subject.tagSupport;\n}\n","import { providersChangeCheck } from '../../state/provider.utils';\nimport { isLikeTags } from '../isLikeTags.function';\nimport { renderWithSupport } from './renderWithSupport.function';\n/** Returns true when rendering owner is not needed. Returns false when rendering owner should occur */\nexport function renderExistingTag(oldestSupport, // oldest with elements on html\nnewSupport, // new to be rendered\nownerSupport, // ownerSupport\nsubject) {\n    const lastSupport = subject.tagSupport;\n    const global = lastSupport.global;\n    // share point between renders\n    newSupport.global = global;\n    const preRenderCount = global.renderCount;\n    providersChangeCheck(oldestSupport);\n    // When the providers were checked, a render to myself occurred and I do not need to re-render again\n    const prevSupport = global.newest;\n    if (preRenderCount !== global.renderCount) {\n        oldestSupport.updateBy(prevSupport);\n        return prevSupport; // already rendered during triggered events\n    }\n    const toRedrawTag = prevSupport || lastSupport || global.oldest;\n    const reSupport = renderWithSupport(newSupport, toRedrawTag, subject, ownerSupport);\n    const oldest = global.oldest || oldestSupport;\n    reSupport.global.oldest = oldest;\n    // TODO: renderWithSupport already does an isLikeTags compare\n    if (isLikeTags(prevSupport, reSupport)) {\n        subject.tagSupport = reSupport;\n        oldest.updateBy(reSupport);\n    }\n    return reSupport;\n}\n","import { deepEqual } from '../../deepFunctions';\nimport { renderExistingTag } from './renderExistingTag.function';\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderTagSupport(tagSupport, // must be latest/newest state render\nrenderUp) {\n    const global = tagSupport.global;\n    const templater = tagSupport.templater;\n    // is it just a vanilla tag, not component?\n    if (!templater.wrapper) { // || isTagTemplater(templater) \n        const ownerTag = tagSupport.ownerTagSupport;\n        ++global.renderCount;\n        return renderTagSupport(ownerTag, true);\n    }\n    const subject = tagSupport.subject;\n    let ownerSupport;\n    let selfPropChange = false;\n    const shouldRenderUp = renderUp && tagSupport;\n    if (shouldRenderUp) {\n        ownerSupport = tagSupport.ownerTagSupport;\n        if (ownerSupport) {\n            const nowProps = templater.props;\n            const latestProps = tagSupport.propsConfig.latestCloned;\n            selfPropChange = !nowProps.every((props, index) => deepEqual(props, latestProps[index]));\n        }\n    }\n    const oldest = tagSupport.global.oldest;\n    const tag = renderExistingTag(oldest, tagSupport, ownerSupport, // useTagSupport,\n    subject);\n    const renderOwner = ownerSupport && selfPropChange;\n    if (renderOwner) {\n        const ownerTagSupport = ownerSupport;\n        renderTagSupport(ownerTagSupport, true);\n        return tag;\n    }\n    return tag;\n}\n","import { setUse } from \"./setUse.function\";\nimport { renderTagSupport } from \"../tag/render/renderTagSupport.function\";\nimport { SyncCallbackError } from \"../errors\";\nimport { syncStates } from \"./syncStates.function\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function\";\nlet innerCallback = (callback) => (a, b, c, d, e, f) => {\n    throw new SyncCallbackError('Callback function was called immediately in sync and must instead be call async');\n};\nexport const callbackMaker = () => innerCallback;\nconst originalGetter = innerCallback; // callbackMaker\nsetUse({\n    beforeRender: (tagSupport) => initMemory(tagSupport),\n    beforeRedraw: (tagSupport) => initMemory(tagSupport),\n    afterRender: (tagSupport) => {\n        ;\n        tagSupport.global.callbackMaker = true;\n        innerCallback = originalGetter; // prevent crossing callbacks with another tag\n    },\n});\nexport function callback(callback) {\n    const tagSupport = getSupportInCycle();\n    if (!tagSupport) {\n        const error = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n        throw error;\n    }\n    const oldState = setUse.memory.stateConfig.array;\n    const trigger = (...args) => {\n        const callbackMaker = tagSupport.global.callbackMaker;\n        if (callbackMaker) {\n            return triggerStateUpdate(tagSupport, callback, oldState, ...args);\n        }\n        return callback(...args);\n    };\n    return trigger;\n}\nfunction initMemory(tagSupport) {\n    const oldState = setUse.memory.stateConfig.array;\n    innerCallback = (callback) => {\n        const trigger = (...args) => {\n            const callbackMaker = tagSupport.global.callbackMaker;\n            if (callbackMaker) {\n                return triggerStateUpdate(tagSupport, callback, oldState, ...args);\n            }\n            return callback(...args);\n        };\n        return trigger;\n    };\n}\nfunction triggerStateUpdate(tagSupport, callback, oldState, ...args) {\n    const state = tagSupport.memory.state;\n    // ensure that the oldest has the latest values first\n    syncStates(state, oldState);\n    // run the callback\n    const maybePromise = callback(...args);\n    // send the oldest state changes into the newest\n    syncStates(oldState, state);\n    /*\n    if(tagSupport.global.deleted) {\n      return maybePromise // While running callback the tag was deleted. Often that happens\n    }\n    */\n    renderTagSupport(tagSupport, false);\n    if (maybePromise instanceof Promise) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            syncStates(oldState, state);\n            renderTagSupport(tagSupport, false);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { setUse } from \"./setUse.function\";\nfunction setCurrentTagSupport(support) {\n    setUse.memory.currentSupport = support;\n}\nexport function onInit(callback) {\n    const tagSupport = setUse.memory.currentSupport;\n    if (!tagSupport.global.init) {\n        tagSupport.global.init = callback;\n        callback(); // fire init\n    }\n}\nsetUse({\n    beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n});\n","import { setUse } from \"./setUse.function\";\nfunction setCurrentTagSupport(support) {\n    setUse.memory.destroyCurrentSupport = support;\n}\nexport function onDestroy(callback) {\n    const tagSupport = setUse.memory.destroyCurrentSupport;\n    tagSupport.global.destroyCallback = callback;\n}\nsetUse({\n    beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeDestroy: (tagSupport) => {\n        const callback = tagSupport.global.destroyCallback;\n        if (callback) {\n            callback();\n        }\n    }\n});\n","import { setUse } from \"./setUse.function\";\nfunction setCurrentTagSupport(support) {\n    setUse.memory.childrenCurrentSupport = support;\n}\nexport function children() {\n    const tagSupport = setUse.memory.childrenCurrentSupport;\n    const children = tagSupport.templater.children;\n    return children;\n}\nsetUse({\n    beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n});\n","import { ValueTypes } from './update/processFirstSubject.utils';\nexport const variablePrefix = '__tagvar';\nexport const escapeVariable = '--' + variablePrefix + '--';\nexport const escapeSearch = new RegExp(escapeVariable, 'g');\nexport class Tag {\n    strings;\n    values;\n    tagJsType = ValueTypes.tag;\n    // present only when an array. Populated by Tag.key()\n    memory = {};\n    templater;\n    constructor(strings, values) {\n        this.strings = strings;\n        this.values = values;\n    }\n    /** Used for array, such as array.map(), calls aka array.map(x => html``.key(x)) */\n    key(arrayValue) {\n        this.memory.arrayValue = arrayValue;\n        return this;\n    }\n    // TODO: Is this just a fake function that can be data typed?\n    children;\n    html(strings, ...values) {\n        this.children = { strings, values };\n        return this;\n    }\n}\n","import { Tag } from './tag/Tag.class';\nimport { kidsToTagArraySubject } from './tag/tag';\nimport { ValueSubject } from './subject';\nexport class TemplaterResult {\n    props;\n    tagJsType = 'templater';\n    tagged;\n    wrapper;\n    madeChildIntoSubject = false;\n    tag;\n    children = new ValueSubject([]);\n    constructor(props) {\n        this.props = props;\n    }\n    html(strings, ...values) {\n        const children = new Tag(strings, values);\n        const { childSubject, madeSubject } = kidsToTagArraySubject(children);\n        this.children = childSubject;\n        this.madeChildIntoSubject = madeSubject;\n        return this;\n    }\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { renderTagSupport } from \"../tag/render/renderTagSupport.function\";\nexport function bindSubjectCallback(value, tagSupport) {\n    // Is this children? No override needed\n    if (value.isChildOverride) {\n        return value;\n    }\n    const subjectFunction = (element, args) => runTagCallback(value, tagSupport, element, args);\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    return subjectFunction;\n}\nexport function runTagCallback(value, tagSupport, bindTo, args) {\n    const myGlobal = tagSupport.global;\n    const renderCount = myGlobal.renderCount;\n    const method = value.bind(bindTo);\n    const callbackResult = method(...args);\n    const sameRenderCount = renderCount === myGlobal.renderCount;\n    const skipRender = !sameRenderCount || myGlobal.deleted;\n    // already rendered OR tag was deleted before event processing\n    if (skipRender) {\n        if (callbackResult instanceof Promise) {\n            return callbackResult.then(() => {\n                return 'promise-no-data-ever'; // tag was deleted during event processing\n            });\n        }\n        return 'no-data-ever'; // already rendered\n    }\n    const newest = renderTagSupport(myGlobal.newest, true);\n    myGlobal.newest = newest;\n    if (callbackResult instanceof Promise) {\n        return callbackResult.then(() => {\n            if (myGlobal.deleted) {\n                return 'promise-no-data-ever'; // tag was deleted during event processing\n            }\n            const newest = renderTagSupport(myGlobal.newest, true);\n            myGlobal.newest = newest;\n            return 'promise-no-data-ever';\n        });\n    }\n    // Caller always expects a Promise\n    return 'no-data-ever';\n}\n","import { deepClone } from '../deepFunctions';\nimport { ValueTypes, getValueType } from './update/processFirstSubject.utils';\nexport function cloneValueArray(values) {\n    return values.map((value) => {\n        const tag = value;\n        switch (getValueType(value)) {\n            case ValueTypes.tagComponent:\n                const tagComponent = value;\n                return deepClone(tagComponent.props);\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n            case ValueTypes.tagArray:\n                return cloneValueArray(tag);\n        }\n        return deepClone(value);\n    });\n}\n","export function getChildTagsToDestroy(childTags, allTags = []) {\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const cTag = childTags[index];\n        allTags.push(cTag);\n        childTags.splice(index, 1);\n        getChildTagsToDestroy(cTag.childTags, allTags);\n    }\n    return allTags;\n}\n","import { ValueSubject } from '../../subject/ValueSubject';\nimport { TemplaterResult } from '../../TemplaterResult.class';\nimport { TagSupport } from '../TagSupport.class';\nimport { ValueTypes, getValueType } from './processFirstSubject.utils';\nexport function processNewValue(value, ownerSupport) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.tagComponent:\n            const tagSubject = new ValueSubject(value);\n            return tagSubject;\n        case ValueTypes.templater:\n            const templater = value;\n            const tag = templater.tag;\n            return processNewTag(tag, ownerSupport);\n        case ValueTypes.tag:\n            return processNewTag(value, ownerSupport);\n        case ValueTypes.subject:\n            return value;\n    }\n    return new ValueSubject(value);\n}\nfunction processNewTag(value, ownerSupport) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = new TemplaterResult([]);\n        templater.tag = tag;\n        tag.templater = templater;\n    }\n    const subject = new ValueSubject(templater);\n    subject.tagSupport = new TagSupport(templater, ownerSupport, subject);\n    return subject;\n}\n","export function setTagPlaceholder(global) {\n    const insertBefore = global.insertBefore;\n    return global.placeholder = swapInsertBefore(insertBefore);\n}\nexport function swapInsertBefore(insertBefore) {\n    const placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n    return placeholder;\n}\n","export function inputAttribute(name, value, element) {\n    const names = name.split('.');\n    // style.position = \"absolute\"\n    if (names[0] === 'style') {\n        element.style[names[1]] = value;\n    }\n    // Example: class.width-full = \"true\"\n    if (names[0] === 'class') {\n        names.shift();\n        if (value) {\n            for (let index = 0; index < names.length; ++index) {\n                element.classList.add(names[index]);\n            }\n        }\n        else {\n            for (let index = 0; index < names.length; ++index) {\n                element.classList.remove(names[index]);\n            }\n        }\n    }\n}\n","import { inputAttribute } from './inputAttribute';\nimport { isSubjectInstance } from '../isInstance';\nimport { bindSubjectCallback } from './bindSubjectCallback.function';\nconst startRegX = /^\\s*{__tagvar/;\nconst endRegX = /}\\s*$/;\nfunction isTagVar(value) {\n    return value && value.search(startRegX) >= 0 && value.search(endRegX) >= 0;\n}\nexport function processAttribute(attrName, value, child, scope, ownerSupport, howToSet) {\n    if (isTagVar(value)) {\n        return processScopedNameValueAttr(attrName, value, child, scope, ownerSupport, howToSet);\n    }\n    if (isTagVar(attrName)) {\n        const contextValueSubject = getContextValueByVarString(scope, attrName);\n        let lastValue;\n        // the above callback gets called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe((value) => {\n            processNameOnlyAttr(value, lastValue, child, ownerSupport, howToSet);\n            lastValue = value;\n        });\n        ownerSupport.global.subscriptions.push(sub); // this is where unsubscribe is picked up\n        child.removeAttribute(attrName);\n        return;\n    }\n    // Non dynamic\n    const isSpecial = isSpecialAttr(attrName);\n    if (isSpecial) {\n        return inputAttribute(attrName, value, child);\n    }\n}\nfunction processScopedNameValueAttr(attrName, value, // {__tagVarN}\nchild, scope, ownerSupport, howToSet) {\n    // get the code inside the brackets like \"variable0\" or \"{variable0}\"\n    const result = getContextValueByVarString(scope, value);\n    return processNameValueAttr(attrName, result, child, ownerSupport, howToSet);\n}\nfunction getContextValueByVarString(scope, value) {\n    const code = value.replace('{', '').split('').reverse().join('').replace('}', '').split('').reverse().join('');\n    return scope[code];\n}\nfunction processNameOnlyAttr(attrValue, lastValue, child, ownerSupport, howToSet) {\n    if (lastValue && lastValue != attrValue) {\n        if (typeof (lastValue) === 'string') {\n            child.removeAttribute(lastValue);\n        }\n        else if (lastValue instanceof Object) {\n            for (const name in lastValue) {\n                child.removeAttribute(name);\n            }\n        }\n    }\n    if (typeof (attrValue) === 'string') {\n        if (!attrValue.length) {\n            return;\n        }\n        processNameValueAttr(attrValue, '', child, ownerSupport, howToSet);\n        return;\n    }\n    if (attrValue instanceof Object) {\n        for (const name in attrValue) {\n            processNameValueAttr(name, attrValue[name], child, ownerSupport, howToSet);\n        }\n    }\n}\nfunction processNameValueAttr(attrName, result, child, ownerSupport, howToSet) {\n    const isSpecial = isSpecialAttr(attrName);\n    if (result instanceof Function) {\n        const action = function (...args) {\n            const result2 = result(child, args);\n            return result2;\n        };\n        child[attrName].action = action;\n    }\n    // Most every variable comes in here since everything is made a ValueSubject\n    if (isSubjectInstance(result)) {\n        child.removeAttribute(attrName);\n        const callback = (newAttrValue) => {\n            // should the function be wrapped so every time its called we re-render?\n            if (newAttrValue instanceof Function) {\n                const wrapper = ownerSupport.templater.wrapper;\n                const parentWrap = wrapper?.parentWrap;\n                const oneRender = parentWrap?.oneRender;\n                if (!oneRender) {\n                    newAttrValue = bindSubjectCallback(newAttrValue, ownerSupport);\n                }\n            }\n            return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = result.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        ownerSupport.global.subscriptions.push(sub);\n        return;\n    }\n    howToSet(child, attrName, result);\n    // child.setAttribute(attrName, result.value)\n    return;\n}\nfunction processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet) {\n    if (newAttrValue instanceof Function) {\n        const fun = function (...args) {\n            return newAttrValue(child, args);\n        };\n        // access to original function\n        fun.tagFunction = newAttrValue;\n        child[attrName] = fun;\n        return;\n    }\n    if (isSpecial) {\n        inputAttribute(attrName, newAttrValue, child);\n        return;\n    }\n    if (newAttrValue) {\n        howToSet(child, attrName, newAttrValue);\n        return;\n    }\n    const isDeadValue = [undefined, false, null].includes(newAttrValue);\n    if (isDeadValue) {\n        child.removeAttribute(attrName);\n        return;\n    }\n    // value is 0\n    howToSet(child, attrName, newAttrValue);\n}\n/** Looking for (class | style) followed by a period */\nfunction isSpecialAttr(attrName) {\n    return attrName.search(/^(class|style)(\\.)/) >= 0;\n}\n","import { processAttribute } from \"./processAttribute.function\";\nfunction howToSetAttribute(element, name, value) {\n    element.setAttribute(name, value);\n}\nfunction howToSetInputValue(element, name, value) {\n    element[name] = value;\n}\nexport function interpolateAttributes(child, scope, ownerSupport) {\n    const attrNames = child.getAttributeNames();\n    let howToSet = howToSetAttribute;\n    for (let index = 0; index < attrNames.length; ++index) {\n        const attrName = attrNames[index];\n        if (child.nodeName === 'INPUT' && attrName === 'value') {\n            howToSet = howToSetInputValue;\n        }\n        const value = child.getAttribute(attrName);\n        processAttribute(attrName, value, child, scope, ownerSupport, howToSet);\n        howToSet = howToSetAttribute; // put back\n    }\n}\n","// support arrow functions in attributes\nexport const interpolateReplace = /(?:<[^>]*?(?:(?:\\s+\\w+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)))*\\s*)\\/?>)|({__tagvar[^}]+})/g;\n/** replaces ${x} with <template id=\"x-start\"></template><template id=\"x-end\"></template> */\nexport function interpolateToTemplates(template) {\n    const keys = [];\n    const string = template.replace(interpolateReplace, (match, expression) => {\n        if (match.startsWith('<')) {\n            // If the match is an HTML tag, don't replace\n            return match;\n        }\n        const noBraces = expression.substring(1, expression.length - 1);\n        const id = noBraces;\n        keys.push(id);\n        return `<template interpolate end id=\"${id}\"></template>`;\n    });\n    return { string, keys };\n}\n","export function processTagResult(tagSupport, subject, // used for recording past and current value\ninsertBefore, // <template end interpolate />\n{ counts, }) {\n    // *if appears we already have seen\n    const subjectTag = subject;\n    const lastSupport = subjectTag.tagSupport;\n    const prevSupport = lastSupport?.global.oldest || undefined;\n    const justUpdate = prevSupport;\n    if (prevSupport && justUpdate) {\n        return processTagResultUpdate(tagSupport, subjectTag, prevSupport);\n    }\n    tagSupport.buildBeforeElement(insertBefore, {\n        counts,\n    });\n}\nfunction processTagResultUpdate(tagSupport, subject, // used for recording past and current value\nprevSupport) {\n    // components\n    if (subject instanceof Function) {\n        const newSupport = subject(prevSupport);\n        prevSupport.updateBy(newSupport);\n        subject.tagSupport = newSupport;\n        return;\n    }\n    prevSupport.updateBy(tagSupport);\n    subject.tagSupport = tagSupport;\n    return;\n}\n","import { setUse } from '../../state';\nimport { processTagResult } from './processTagResult.function';\nimport { TagSupport } from '../TagSupport.class';\nimport { renderSubjectComponent } from '../render/renderSubjectComponent.function';\nexport function processSubjectComponent(templater, subject, insertBefore, ownerSupport, options) {\n    // Check if function component is wrapped in a tag() call\n    // TODO: This below check not needed in production mode\n    if (templater.tagged !== true) {\n        const wrapper = templater.wrapper;\n        const original = wrapper.parentWrap.original;\n        let name = original.name || original.constructor?.name;\n        if (name === 'Function') {\n            name = undefined;\n        }\n        const label = name || original.toString().substring(0, 120);\n        const error = new Error(`Not a tag component. Wrap your function with tag(). Example tag(props => html\\`\\`) on component:\\n\\n${label}\\n\\n`);\n        throw error;\n    }\n    const tagSupport = new TagSupport(templater, ownerSupport, subject);\n    let reSupport = subject.tagSupport;\n    const global = tagSupport.global = reSupport?.global || tagSupport.global;\n    global.insertBefore = insertBefore;\n    const providers = setUse.memory.providerConfig;\n    providers.ownerSupport = ownerSupport;\n    const isRender = !reSupport;\n    if (isRender) {\n        const support = reSupport || tagSupport;\n        reSupport = renderSubjectComponent(subject, support, ownerSupport);\n    }\n    processTagResult(reSupport, subject, // The element set here will be removed from document. Also result.tag will be added in here\n    insertBefore, // <template end interpolate /> (will be removed)\n    options);\n    return reSupport;\n}\n","import { renderWithSupport } from './renderWithSupport.function';\nexport function renderSubjectComponent(subject, reSupport, ownerSupport) {\n    const preClones = ownerSupport.clones.map(clone => clone);\n    reSupport = renderWithSupport(reSupport, subject.tagSupport, // existing tag\n    subject, ownerSupport);\n    reSupport.global.newest = reSupport;\n    if (ownerSupport.clones.length > preClones.length) {\n        const myClones = ownerSupport.clones.filter(fClone => !preClones.find(clone => clone === fClone));\n        reSupport.clones.push(...myClones);\n    }\n    ownerSupport.childTags.push(reSupport);\n    return reSupport;\n}\n","import { TagSupport } from '../TagSupport.class';\nimport { ValueSubject } from '../../subject';\n/** Could be a regular tag or a component. Both are Tag.class */\nexport function processTag(templater, insertBefore, ownerSupport, // owner\nsubject) {\n    let tagSupport = subject.tagSupport;\n    // first time seeing this tag?\n    if (!tagSupport) {\n        tagSupport = newTagSupportByTemplater(templater, ownerSupport, subject);\n    }\n    subject.tagSupport = tagSupport;\n    tagSupport.ownerTagSupport = ownerSupport;\n    tagSupport.buildBeforeElement(insertBefore, {\n        counts: { added: 0, removed: 0 },\n    });\n}\nexport function setupNewTemplater(tagSupport, ownerSupport, subject) {\n    tagSupport.global.oldest = tagSupport;\n    tagSupport.global.newest = tagSupport;\n    // asking me to render will cause my parent to render\n    tagSupport.ownerTagSupport = ownerSupport;\n    subject.tagSupport = tagSupport;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        children: new ValueSubject([]), // no children\n        // props: {} as Props,\n        props: [],\n        isTag: true,\n        tagJsType: 'templater',\n        tagged: false,\n        madeChildIntoSubject: false,\n        html: () => fake\n    };\n    return fake;\n}\nexport function newTagSupportByTemplater(templater, ownerSupport, subject) {\n    const tagSupport = new TagSupport(templater, ownerSupport, subject);\n    setupNewTemplater(tagSupport, ownerSupport, subject);\n    ownerSupport.childTags.push(tagSupport);\n    return tagSupport;\n}\n","import { ValueSubject } from '../../subject/ValueSubject';\nimport { ArrayNoKeyError } from '../../errors';\nimport { destroyArrayTag } from '../checkDestroyPrevious.function';\nimport { setupNewTemplater, tagFakeTemplater } from './processTag.function';\nimport { TagSupport } from '../TagSupport.class';\nimport { isTagClass } from '../../isInstance';\nexport function processTagArray(subject, value, // arry of Tag classes\ninsertBefore, // <template end interpolate />\nownerSupport, options) {\n    const clones = ownerSupport.clones; // []\n    let lastArray = subject.lastArray = subject.lastArray || [];\n    if (!subject.placeholder) {\n        setPlaceholderElm(insertBefore, subject);\n    }\n    const runtimeInsertBefore = subject.placeholder; // || insertBefore\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    lastArray = subject.lastArray = subject.lastArray.filter((item, index) => {\n        const newLength = value.length - 1;\n        const at = index - removed;\n        const lessLength = newLength < at;\n        const subValue = value[index - removed];\n        const subTag = subValue;\n        // const tag = subTag?.templater.tag as Tag\n        const lastTag = item.tagSupport.templater.tag;\n        const newArrayValue = subTag?.memory.arrayValue;\n        const lastArrayValue = lastTag.memory.arrayValue;\n        const destroyItem = lessLength || !areLikeValues(newArrayValue, lastArrayValue);\n        if (destroyItem) {\n            const last = lastArray[index];\n            const tagSupport = last.tagSupport;\n            destroyArrayTag(tagSupport, options.counts);\n            last.deleted = true;\n            ++removed;\n            ++options.counts.removed;\n            return false;\n        }\n        return true;\n    });\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const item = value[index];\n        const previous = lastArray[index];\n        const previousSupport = previous?.tagSupport;\n        const subTag = item;\n        if (isTagClass(subTag) && !subTag.templater) {\n            tagFakeTemplater(subTag);\n        }\n        const tagSupport = new TagSupport(subTag.templater, ownerSupport, new ValueSubject(undefined));\n        if (previousSupport) {\n            setupNewTemplater(tagSupport, ownerSupport, previousSupport.subject);\n            const global = previousSupport.global;\n            tagSupport.global = global;\n            global.newest = tagSupport;\n        }\n        // check for html``.key()\n        const keySet = 'arrayValue' in subTag.memory;\n        if (!keySet) {\n            const details = {\n                template: tagSupport.getTemplate().string,\n                array: value,\n            };\n            const message = 'Use html`...`.key(item) instead of html`...` to template an Array';\n            console.error(message, details);\n            const err = new ArrayNoKeyError(message, details);\n            throw err;\n        }\n        const couldBeSame = lastArray.length > index;\n        if (couldBeSame) {\n            const prevSupport = previous.tagSupport;\n            const prevGlobal = prevSupport.global;\n            // subTag.tagSupport = subTag.tagSupport || prevSupport\n            const oldest = prevGlobal.oldest;\n            oldest.updateBy(tagSupport);\n            // return []\n            continue;\n        }\n        processAddTagArrayItem(runtimeInsertBefore, tagSupport, index, options, lastArray);\n        ownerSupport.childTags.push(tagSupport);\n    }\n    return clones;\n}\nfunction setPlaceholderElm(insertBefore, subject) {\n    if (insertBefore.nodeName !== 'TEMPLATE') {\n        subject.placeholder = insertBefore;\n        return;\n    }\n    const placeholder = subject.placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n}\nfunction processAddTagArrayItem(before, tagSupport, index, options, lastArray) {\n    const lastValue = {\n        tagSupport, index\n    };\n    // Added to previous array\n    lastArray.push(lastValue);\n    const counts = {\n        added: options.counts.added + index,\n        removed: options.counts.removed,\n    };\n    const fragment = document.createDocumentFragment();\n    const newTempElm = document.createElement('template');\n    fragment.appendChild(newTempElm);\n    tagSupport.buildBeforeElement(newTempElm, // before,\n    { counts });\n    const parent = before.parentNode;\n    parent.insertBefore(fragment, before);\n}\n/** compare two values. If both values are arrays then the items will be compared */\nfunction areLikeValues(valueA, valueB) {\n    if (valueA === valueB) {\n        return true;\n    }\n    const bothArrays = valueA instanceof Array && valueB instanceof Array;\n    const matchLengths = bothArrays && valueA.length == valueB.length;\n    if (matchLengths) {\n        return valueA.every((item, index) => item == valueB[index]);\n    }\n    return false;\n}\n","// Function to update the value of x\nexport function updateBeforeTemplate(value, // value should be casted before calling here\nlastFirstChild) {\n    const parent = lastFirstChild.parentNode;\n    // Insert the new value (never use innerHTML here)\n    const textNode = document.createTextNode(value); // never innerHTML\n    parent.insertBefore(textNode, lastFirstChild);\n    /* remove existing nodes */\n    parent.removeChild(lastFirstChild);\n    return textNode;\n}\nexport function castTextValue(value) {\n    // mimic React skipping to display EXCEPT for true does display on page\n    if ([undefined, false, null].includes(value)) { // || value === true\n        return '';\n    }\n    return value;\n}\n","import { castTextValue, updateBeforeTemplate } from '../../updateBeforeTemplate.function';\nexport function processRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.insertBefore = insertBefore;\n    const before = subject.clone || insertBefore; // Either the template is on the doc OR its the first element we last put on doc\n    // matches but also was defined at some point\n    if (subject.lastValue === value && 'lastValue' in subject) {\n        return; // no need to update display, its the same\n    }\n    subject.lastValue = value;\n    const castedValue = castTextValue(value);\n    // replace existing string?\n    const oldClone = subject.clone;\n    if (oldClone) {\n        oldClone.textContent = castedValue;\n        return;\n    }\n    // Processing of regular values\n    const clone = updateBeforeTemplate(castedValue, before);\n    subject.clone = clone; // remember single element put down, for future updates\n}\nexport function processFirstRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.lastValue = value;\n    const castedValue = castTextValue(value);\n    // Processing of regular values\n    const clone = updateBeforeTemplate(castedValue, insertBefore);\n    subject.clone = clone; // remember single element put down, for future updates \n}\n","import { processSubjectComponent } from './processSubjectComponent.function';\nimport { processTagArray } from './processTagArray';\nimport { TemplaterResult } from '../../TemplaterResult.class';\nimport { processFirstRegularValue } from './processRegularValue.function';\nimport { newTagSupportByTemplater, processTag, tagFakeTemplater } from './processTag.function';\nimport { ValueTypes, getValueType } from './processFirstSubject.utils';\nimport { renderTagOnly } from '../render/renderTagOnly.function';\nexport function processFirstSubjectValue(value, subject, // could be tag via result.tag\ninsertBefore, // <template end interpolate /> (will be removed)\nownerSupport, // owner\noptions) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.templater:\n            processTag(value, insertBefore, ownerSupport, subject);\n            return;\n        case ValueTypes.tag:\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = tagFakeTemplater(tag);\n            }\n            processTag(templater, insertBefore, ownerSupport, subject);\n            return;\n        case ValueTypes.tagArray:\n            return processTagArray(subject, value, insertBefore, ownerSupport, options);\n        case ValueTypes.tagComponent:\n            processSubjectComponent(value, subject, insertBefore, ownerSupport, options);\n            return;\n        case ValueTypes.function:\n            const v = value;\n            if (v.oneRender) {\n                const templater = new TemplaterResult([]);\n                templater.tagJsType = 'oneRender';\n                const tagSupport = newTagSupportByTemplater(templater, ownerSupport, subject);\n                let tag;\n                const wrap = () => {\n                    templater.tag = tag || (v());\n                    return tagSupport;\n                };\n                // const wrap = () => ((v as any)())\n                templater.wrapper = wrap;\n                wrap.parentWrap = wrap;\n                wrap.oneRender = true;\n                wrap.parentWrap.original = v;\n                renderTagOnly(tagSupport, tagSupport, subject, ownerSupport);\n                // call inner function\n                // templater.tag = (v as any)() as Tag\n                processTag(templater, insertBefore, ownerSupport, subject);\n                return;\n            }\n            break;\n    }\n    processFirstRegularValue(value, subject, insertBefore);\n}\n","import { processAttribute } from './processAttribute.function';\nconst search = new RegExp('\\\\s*<template interpolate end id=\"__tagvar(\\\\d{1,4})\"([^>]*)></template>(\\\\s*)');\nexport function scanTextAreaValue(textarea, context, ownerSupport) {\n    const value = textarea.value;\n    if (value.search(search) >= 0) {\n        const match = value.match(/__tagvar(\\d{1,4})/);\n        const token = match ? match[0] : '';\n        const dynamic = '{' + token + '}';\n        textarea.value = '';\n        textarea.setAttribute('text-var-value', dynamic);\n        const howToSet = (_elm, _name, value) => textarea.value = value;\n        processAttribute('text-var-value', dynamic, // realValue, // context[token].value,\n        textarea, context, ownerSupport, howToSet);\n    }\n}\n","import { deepEqual } from \"../deepFunctions\";\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps) {\n    /*\n    const isCommonEqual = props === undefined && props === compareToProps\n    if(isCommonEqual) {\n      return false\n    }\n    */\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    // check all prop functions match\n    if (typeof (props) === 'object') {\n        if (!pastCloneProps) {\n            return 3;\n        }\n        // castedProps = {...props}\n        castedProps = [...props];\n        // castedPastProps = {...(pastCloneProps || {})}\n        castedPastProps = [...(pastCloneProps || [])];\n        const allFunctionsMatch = castedProps.every((value, index) => {\n            let compare = castedPastProps[index];\n            if (value && typeof (value) === 'object') {\n                const subCastedProps = { ...value };\n                const subCompareProps = { ...compare || {} };\n                const matched = Object.entries(subCastedProps).every(([key, value]) => {\n                    return compareProps(value, subCompareProps[key], () => {\n                        delete subCastedProps[key]; // its a function and not needed to be compared\n                        delete subCompareProps[key]; // its a function and not needed to be compared\n                    });\n                });\n                return matched;\n            }\n            return compareProps(value, compare, () => {\n                castedProps.splice(index, 1);\n                castedPastProps.splice(index, 1);\n            });\n        });\n        if (!allFunctionsMatch) {\n            return 6; // a change has been detected by function comparisons\n        }\n    }\n    // const isEqual = deepEqual(castedPastProps, castedProps)\n    // return isEqual ? false : 7 // if equal then no changes\n    return false;\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(value instanceof Function)) {\n        return deepEqual(value, compare) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(compareFn instanceof Function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 3; // both are function the same\n    }\n    onDelete();\n    return 5;\n}\n","import { hasPropChanges } from \"./hasPropChanges.function\";\nexport function hasTagSupportChanged(oldTagSupport, newTagSupport, newTemplater) {\n    const latestProps = newTemplater.props; // newTagSupport.propsConfig.latest\n    const pastCloneProps = oldTagSupport.propsConfig.latestCloned;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps);\n    // if no changes detected, no need to continue to rendering further tags\n    if (propsChanged) {\n        return propsChanged;\n    }\n    const kidsChanged = hasKidsChanged(oldTagSupport, newTagSupport);\n    // we already know props didn't change and if kids didn't either, than don't render\n    return kidsChanged;\n}\nexport function hasKidsChanged(oldTagSupport, newTagSupport) {\n    const oldCloneKidValues = oldTagSupport.propsConfig.lastClonedKidValues;\n    const newClonedKidValues = newTagSupport.propsConfig.lastClonedKidValues;\n    const everySame = oldCloneKidValues.every((set, index) => {\n        const x = newClonedKidValues[index];\n        return set.every((item, index) => item === x[index]);\n    });\n    return everySame ? false : 9;\n}\n","import { deepClone, deepEqual } from './deepFunctions';\nimport { isStaticTag } from './isInstance';\nimport { renderTagSupport } from './tag/render/renderTagSupport.function';\nimport { setUse } from './state';\nimport { getSupportInCycle } from './tag/getSupportInCycle.function';\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProps(props, ownerSupport) {\n    const isPropTag = isStaticTag(props);\n    const watchProps = isPropTag ? 0 : props;\n    const newProps = resetFunctionProps(watchProps, ownerSupport);\n    return newProps;\n}\nfunction resetFunctionProps(newProps, ownerSupport) {\n    if (typeof (newProps) !== 'object' || !ownerSupport) {\n        return newProps;\n    }\n    // BELOW: Do not clone because if first argument is object, the memory ref back is lost\n    // const newProps = {...props} \n    for (const name in newProps) {\n        const value = newProps[name];\n        if (!(value instanceof Function)) {\n            continue;\n        }\n        const toCall = newProps[name].toCall;\n        if (toCall) {\n            continue; // already previously converted\n        }\n        newProps[name] = (...args) => newProps[name].toCall(...args); // what gets called can switch over parent state changes\n        // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n        newProps[name].toCall = (...args) => callbackPropOwner(value, args, ownerSupport);\n        newProps[name].original = value;\n    }\n    return newProps;\n}\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    // const renderCount = ownerSupport.global.renderCount\n    const cycle = getSupportInCycle();\n    const result = toCall(...callWith);\n    const run = () => {\n        const lastestOwner = ownerSupport.global.newest;\n        if (cycle) {\n            // appears a prop function was called sync/immediately so lets see if owner changed state\n            const allMatched = lastestOwner.memory.state.every(state => {\n                const lastValue = state.lastValue;\n                const get = state.get();\n                const equal = deepEqual(deepClone(lastValue), get);\n                return equal;\n            });\n            if (allMatched) {\n                return result; // owner did not change\n            }\n        }\n        const newest = renderTagSupport(lastestOwner, true);\n        lastestOwner.global.newest = newest;\n        return result;\n    };\n    if (!cycle) {\n        return run();\n    }\n    setUse.memory.tagClosed$.toCallback(run);\n    return result;\n}\n","import { hasTagSupportChanged } from '../hasTagSupportChanged.function';\nimport { processSubjectComponent } from './processSubjectComponent.function';\nimport { destroyTagMemory } from '../destroyTag.function';\nimport { renderTagSupport } from '../render/renderTagSupport.function';\nimport { callbackPropOwner } from '../../alterProps.function';\nimport { isLikeTags } from '../isLikeTags.function';\nexport function updateExistingTagComponent(ownerSupport, tagSupport, // lastest\nsubject, insertBefore) {\n    let lastSupport = subject.tagSupport?.global.newest; // || subject.tagSupport\n    let oldestTag = lastSupport.global.oldest;\n    const oldWrapper = lastSupport.templater.wrapper;\n    const newWrapper = tagSupport.templater.wrapper;\n    let isSameTag = false;\n    if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.parentWrap.original;\n        const newFunction = newWrapper.parentWrap.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = tagSupport.templater;\n    if (!isSameTag) {\n        const oldestSupport = lastSupport.global.oldest;\n        destroyTagMemory(oldestSupport);\n        return processSubjectComponent(templater, subject, insertBefore, ownerSupport, {\n            counts: { added: 0, removed: 0 },\n        });\n    }\n    else {\n        const hasChanged = hasTagSupportChanged(lastSupport, tagSupport, templater);\n        if (!hasChanged) {\n            // if the new props are an object then implicitly since no change, the old props are an object\n            const newProps = templater.props;\n            syncFunctionProps(lastSupport, ownerSupport, newProps);\n            return lastSupport; // its the same tag component\n        }\n    }\n    const previous = lastSupport.global.newest;\n    const newSupport = renderTagSupport(tagSupport, false);\n    lastSupport = subject.tagSupport;\n    const newOldest = newSupport.global.oldest;\n    const hasOldest = newOldest ? true : false;\n    if (!hasOldest) {\n        return buildNewTag(newSupport, insertBefore, lastSupport, subject);\n    }\n    if (newOldest && templater.children.value.length) {\n        const oldKidsSub = newOldest.templater.children;\n        oldKidsSub.set(templater.children.value);\n    }\n    // detect if both the function is the same and the return is the same\n    const isLikeTag = isSameTag && isLikeTags(previous, newSupport);\n    if (isLikeTag) {\n        subject.tagSupport = newSupport;\n        oldestTag.updateBy(newSupport); // the oldest tag has element references\n        return newSupport;\n    }\n    else {\n        // Although function looked the same it returned a different html result\n        if (isSameTag && lastSupport) {\n            destroyTagMemory(lastSupport);\n            newSupport.global.context = {}; // do not share previous outputs\n        }\n        oldestTag = undefined;\n    }\n    if (!oldestTag) {\n        lastSupport = newSupport;\n        buildNewTag(newSupport, lastSupport.global.insertBefore, lastSupport, subject);\n    }\n    lastSupport.global.newest = newSupport;\n    return newSupport;\n}\nfunction buildNewTag(newSupport, oldInsertBefore, oldTagSupport, subject) {\n    newSupport.buildBeforeElement(oldInsertBefore, {\n        counts: { added: 0, removed: 0 },\n    });\n    newSupport.global.oldest = newSupport;\n    newSupport.global.newest = newSupport;\n    oldTagSupport.global.oldest = newSupport;\n    oldTagSupport.global.newest = newSupport;\n    subject.tagSupport = newSupport;\n    return newSupport;\n}\nfunction syncFunctionProps(lastSupport, ownerSupport, newPropsArray) {\n    lastSupport = lastSupport.global.newest || lastSupport;\n    const priorPropConfig = lastSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.latestCloned;\n    const prevSupport = ownerSupport.global.newest;\n    for (let index = newPropsArray.length - 1; index >= 0; --index) {\n        const argPosition = newPropsArray[index];\n        if (typeof (argPosition) !== 'object') {\n            return;\n        }\n        const priorProps = priorPropsArray[index];\n        if (typeof (priorProps) !== 'object') {\n            return;\n        }\n        for (const name in argPosition) {\n            const value = argPosition[name];\n            if (!(value instanceof Function)) {\n                continue;\n            }\n            const newCallback = argPosition[name]; // || value\n            const original = newCallback instanceof Function && newCallback.toCall;\n            if (original) {\n                continue; // already previously converted\n            }\n            // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n            priorProps[name].toCall = (...args) => {\n                return callbackPropOwner(newCallback, // value, // newOriginal,\n                args, prevSupport);\n            };\n        }\n    }\n}\n","import { TagSupport } from '../TagSupport.class';\nimport { TemplaterResult } from '../../TemplaterResult.class';\nimport { isTagClass, isTagTemplater } from '../../isInstance';\nimport { ValueTypes, getValueType } from './processFirstSubject.utils';\nimport { processTagArray } from './processTagArray';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function';\nimport { processRegularValue } from './processRegularValue.function';\nimport { checkDestroyPrevious, restoreTagMarker } from '../checkDestroyPrevious.function';\nimport { processSubjectComponent } from './processSubjectComponent.function';\nimport { isLikeTags } from '../isLikeTags.function';\nimport { setupNewTemplater, getFakeTemplater, processTag } from './processTag.function';\nimport { swapInsertBefore } from '../setTagPlaceholder.function';\nexport function updateExistingValue(subject, value, ownerSupport, insertBefore) {\n    const subjectTag = subject;\n    const valueType = getValueType(value);\n    checkDestroyPrevious(subject, value, insertBefore);\n    // handle already seen tag components\n    if (valueType === ValueTypes.tagComponent) {\n        return prepareUpdateToComponent(value, subjectTag, insertBefore, ownerSupport);\n    }\n    // was component but no longer\n    const tagSupport = subjectTag.tagSupport;\n    if (tagSupport) {\n        if (valueType === ValueTypes.function) {\n            return subjectTag; // its a oneRender tag\n        }\n        handleStillTag(subject, value, ownerSupport);\n        return subjectTag;\n    }\n    switch (valueType) {\n        case ValueTypes.tagArray:\n            processTagArray(subject, value, insertBefore, // oldInsertBefore as InsertBefore,\n            ownerSupport, { counts: {\n                    added: 0,\n                    removed: 0,\n                } });\n            return subject;\n        case ValueTypes.templater:\n            processTag(value, insertBefore, ownerSupport, subjectTag);\n            return subjectTag;\n        case ValueTypes.tag:\n            const tag = value;\n            let templater = tag.templater;\n            if (!templater) {\n                templater = getFakeTemplater();\n                tag.templater = templater;\n                templater.tag = tag;\n            }\n            processTag(templater, insertBefore, ownerSupport, subjectTag);\n            return subjectTag;\n        case ValueTypes.subject:\n            return value;\n        // now its a useless function (we don't automatically call functions)\n        case ValueTypes.function:\n            // const bound = bindSubjectCallback(value as Callback, ownerSupport)\n            // subject.set(bound)\n            if (!subject.clone) {\n                subject.clone = swapInsertBefore(insertBefore);\n            }\n            return subject;\n    }\n    // This will cause all other values to render\n    processRegularValue(value, subject, insertBefore);\n    return subjectTag;\n}\nfunction handleStillTag(subject, value, ownerSupport) {\n    const lastSupport = subject.tagSupport;\n    let templater = value;\n    const isClass = isTagClass(value);\n    if (isClass) {\n        const tag = value;\n        templater = tag.templater;\n        if (!templater) {\n            templater = new TemplaterResult([]);\n            templater.tag = tag;\n            tag.templater = templater;\n        }\n    }\n    const valueSupport = new TagSupport(templater, ownerSupport, subject);\n    if (isClass) {\n        valueSupport.global = lastSupport.global;\n    }\n    const isSameTag = value && isLikeTags(lastSupport, valueSupport);\n    if (isTagTemplater(value)) {\n        setupNewTemplater(valueSupport, ownerSupport, subject);\n    }\n    if (isSameTag) {\n        lastSupport.updateBy(valueSupport);\n        return;\n    }\n    if (isSameTag) {\n        // const subjectTag = subject as TagSubject\n        const global = lastSupport.global;\n        const insertBefore = global.insertBefore;\n        return processTag(templater, insertBefore, ownerSupport, subject);\n    }\n    return processRegularValue(value, subject, subject.insertBefore);\n}\nfunction prepareUpdateToComponent(templater, subjectTag, insertBefore, ownerSupport) {\n    // When last value was not a component\n    if (!subjectTag.tagSupport) {\n        processSubjectComponent(templater, subjectTag, insertBefore, // oldInsertBefore as InsertBefore,\n        ownerSupport, {\n            counts: { added: 0, removed: 0 },\n        });\n        return subjectTag;\n    }\n    const tagSupport = new TagSupport(templater, ownerSupport, subjectTag);\n    const subjectSup = subjectTag.tagSupport;\n    const prevSupport = subjectSup.global.newest;\n    if (prevSupport) {\n        const newestState = prevSupport.memory.state;\n        tagSupport.memory.state.length = 0;\n        tagSupport.memory.state.push(...newestState);\n    }\n    else {\n        restoreTagMarker(subjectSup);\n        processSubjectComponent(templater, subjectTag, insertBefore, ownerSupport, {\n            counts: { added: 0, removed: 0 },\n        });\n        return subjectTag;\n    }\n    tagSupport.global = subjectSup.global;\n    subjectTag.tagSupport = tagSupport;\n    updateExistingTagComponent(ownerSupport, tagSupport, // latest value\n    subjectTag, insertBefore);\n    return subjectTag;\n}\n","import { variablePrefix } from \"../tag/Tag.class\";\nimport { elementInitCheck } from \"./elementInitCheck\";\nimport { processFirstSubjectValue } from \"../tag/update/processFirstSubjectValue.function\";\nimport { isTagArray, isTagComponent } from \"../isInstance\";\nimport { scanTextAreaValue } from \"./scanTextAreaValue.function\";\nimport { updateExistingValue } from \"../tag/update/updateExistingValue.function\";\nimport { swapInsertBefore } from \"../tag/setTagPlaceholder.function\";\nexport function interpolateTemplate(insertBefore, // <template end interpolate /> (will be removed)\ncontext, // variable scope of {`__tagvar${index}`:'x'}\nownerSupport, // Tag class\ncounts, // used for animation stagger computing\noptions) {\n    // TODO: THe clones array is useless here\n    const clones = [];\n    if (!insertBefore.hasAttribute('end')) {\n        return { clones }; // only care about <template end>\n    }\n    const variableName = insertBefore.getAttribute('id');\n    if (variableName?.substring(0, variablePrefix.length) !== variablePrefix) {\n        return { clones }; // ignore, not a tagVar\n    }\n    const existingSubject = context[variableName];\n    const isDynamic = isTagComponent(existingSubject.value) || isTagArray(existingSubject.value);\n    // process dynamics later\n    if (isDynamic) {\n        return {\n            clones,\n            tagComponent: {\n                variableName,\n                ownerSupport,\n                subject: existingSubject,\n                insertBefore\n            }\n        };\n    }\n    subscribeToTemplate(insertBefore, existingSubject, ownerSupport, counts);\n    return { clones };\n}\nexport function subscribeToTemplate(insertBefore, subject, ownerSupport, counts) {\n    let called = false;\n    const onValue = (value) => {\n        if (called) {\n            updateExistingValue(subject, value, ownerSupport, insertBefore);\n            return;\n        }\n        const templater = value;\n        processFirstSubjectValue(templater, subject, insertBefore, ownerSupport, {\n            counts: { ...counts },\n        });\n        called = true;\n    };\n    let mutatingCallback = onValue;\n    const callback = (value) => mutatingCallback(value);\n    const sub = subject.subscribe(callback);\n    // on subscribe, the Subject did NOT emit immediately. Lets pull the template off the document\n    if (insertBefore.parentNode) {\n        const clone = subject.clone = swapInsertBefore(insertBefore);\n        mutatingCallback = v => {\n            const parentNode = clone.parentNode;\n            parentNode.insertBefore(insertBefore, clone);\n            parentNode.removeChild(clone);\n            delete subject.clone;\n            mutatingCallback = onValue; // all future calls will just produce value\n            onValue(v); // calls for rending\n        };\n    }\n    ownerSupport.global.subscriptions.push(sub);\n}\nexport function afterElmBuild(elm, options, context, ownerSupport) {\n    if (!elm.getAttribute) {\n        return;\n    }\n    const tagName = elm.nodeName; // elm.tagName\n    if (tagName === 'TEXTAREA') {\n        scanTextAreaValue(elm, context, ownerSupport);\n    }\n    let diff = options.counts.added;\n    diff = elementInitCheck(elm, options.counts) - diff;\n    if (elm.children) {\n        const children = elm.children;\n        for (let index = children.length - 1; index >= 0; --index) {\n            const child = children[index];\n            const subOptions = {\n                ...options,\n                counts: options.counts,\n            };\n            return afterElmBuild(child, subOptions, context, ownerSupport);\n        }\n    }\n}\n","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n","import { interpolateTemplate } from \"./interpolateTemplate\";\nexport function interpolateContentTemplates(context, tagSupport, options, children) {\n    // counting for animation stagger computing\n    const counts = options.counts;\n    const clones = [];\n    const tagComponents = [];\n    const childLength = children.length;\n    for (let index = childLength - 1; index >= 0; --index) {\n        const child = children[index];\n        const { clones: nextClones, tagComponent } = interpolateTemplate(child, context, tagSupport, counts, options);\n        clones.push(...nextClones);\n        if (tagComponent) {\n            tagComponents.push(tagComponent);\n            continue;\n        }\n        if (child.children) {\n            for (let index = child.children.length - 1; index >= 0; --index) {\n                const subChild = child.children[index];\n                // IF <template end /> its a variable to be processed\n                if (isRenderEndTemplate(subChild)) {\n                    const { tagComponent } = interpolateTemplate(subChild, context, tagSupport, counts, options);\n                    if (tagComponent) {\n                        tagComponents.push(tagComponent);\n                    }\n                }\n                const { clones: nextClones, tagComponents: nextTagComponent } = interpolateContentTemplates(context, tagSupport, options, subChild.children);\n                clones.push(...nextClones);\n                tagComponents.push(...nextTagComponent);\n            }\n        }\n    }\n    return { clones, tagComponents };\n}\nfunction isRenderEndTemplate(child) {\n    const isTemplate = child.tagName === 'TEMPLATE';\n    return isTemplate &&\n        child.getAttribute('interpolate') !== undefined &&\n        child.getAttribute('end') !== undefined;\n}\n","import { interpolateAttributes } from \"./interpolateAttributes\";\nimport { interpolateToTemplates } from \"./interpolations\";\nimport { interpolateContentTemplates } from \"./interpolateContentTemplates\";\nimport { escapeSearch, variablePrefix } from \"../tag/Tag.class\";\n/** Review elements within an element */\nexport function interpolateElement(container, // element containing innerHTML to review interpolations\ncontext, // variables used to evaluate\ninterpolatedTemplates, ownerSupport, options) {\n    const clones = [];\n    const tagComponents = [];\n    const result = interpolatedTemplates.interpolation;\n    const template = container.children[0];\n    const children = template.content.children;\n    if (result.keys.length) {\n        const { clones: nextClones, tagComponents: nextTagComponents } = interpolateContentTemplates(context, ownerSupport, options, children);\n        clones.push(...nextClones);\n        tagComponents.push(...nextTagComponents);\n    }\n    interpolateAttributes(template, context, ownerSupport);\n    processChildrenAttributes(children, context, ownerSupport);\n    return { clones, tagComponents };\n}\nfunction processChildrenAttributes(children, context, ownerSupport) {\n    for (let index = children.length - 1; index >= 0; --index) {\n        const child = children[index];\n        interpolateAttributes(child, context, ownerSupport);\n        if (child.children) {\n            processChildrenAttributes(child.children, context, ownerSupport);\n        }\n    }\n}\nexport function interpolateString(string) {\n    const result = interpolateToTemplates(string);\n    result.string = result.string.replace(escapeSearch, variablePrefix);\n    return result;\n}\n","import { buildClones } from '../render';\nimport { afterElmBuild } from './interpolateTemplate';\nexport function afterInterpolateElement(container, insertBefore, tagSupport, context, options) {\n    const clones = buildClones(container, insertBefore);\n    if (!clones.length) {\n        return clones;\n    }\n    for (let index = clones.length - 1; index >= 0; --index) {\n        const clone = clones[index];\n        afterElmBuild(clone, options, context, tagSupport);\n        tagSupport.clones.push(clone);\n    }\n    return clones;\n}\n","export function buildClones(temporary, insertBefore) {\n    const clones = [];\n    const template = temporary.children[0];\n    let nextSibling = template.content.firstChild;\n    const fragment = document.createDocumentFragment();\n    while (nextSibling) {\n        const nextNextSibling = nextSibling.nextSibling;\n        clones.push(nextSibling);\n        fragment.appendChild(nextSibling);\n        nextSibling = nextNextSibling;\n    }\n    if (insertBefore.parentNode) {\n        const parentNode = insertBefore.parentNode;\n        parentNode.insertBefore(fragment, insertBefore);\n    }\n    return clones;\n}\n","import { escapeVariable, variablePrefix } from './Tag.class';\nimport { deepClone } from '../deepFunctions';\nimport { isTagComponent } from '../isInstance';\nimport { cloneValueArray } from './cloneValueArray.function';\nimport { restoreTagMarker } from './checkDestroyPrevious.function';\nimport { runBeforeDestroy } from './tagRunner';\nimport { getChildTagsToDestroy } from './destroy.support';\nimport { elementDestroyCheck } from './elementDestroyCheck.function';\nimport { updateContextItem } from './update/updateContextItem.function';\nimport { processNewValue } from './update/processNewValue.function';\nimport { setTagPlaceholder } from './setTagPlaceholder.function';\nimport { interpolateElement, interpolateString } from '../interpolations/interpolateElement';\nimport { subscribeToTemplate } from '../interpolations/interpolateTemplate';\nimport { afterInterpolateElement } from '../interpolations/afterInterpolateElement.function';\nconst prefixSearch = new RegExp(variablePrefix, 'g');\n/** used only for apps, otherwise use TagSupport */\nexport class BaseTagSupport {\n    templater;\n    subject;\n    isApp = true;\n    appElement; // only seen on this.getAppTagSupport().appElement\n    strings;\n    values;\n    propsConfig;\n    // stays with current render\n    memory = {\n        state: [],\n    };\n    clones = []; // elements on document. Needed at destroy process to know what to destroy\n    // travels with all rerenderings\n    global = {\n        context: {}, // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n        providers: [],\n        /** Indicator of re-rending. Saves from double rending something already rendered */\n        renderCount: 0,\n        deleted: false,\n        subscriptions: [],\n    };\n    hasLiveElements = false;\n    constructor(templater, subject) {\n        this.templater = templater;\n        this.subject = subject;\n        const children = templater.children; // children tags passed in as arguments\n        const kidValue = children.value;\n        const props = templater.props; // natural props\n        const latestCloned = props.map(props => deepClone(props));\n        this.propsConfig = {\n            latest: props,\n            latestCloned, // assume its HTML children and then detect\n            lastClonedKidValues: kidValue.map(kid => {\n                const cloneValues = cloneValueArray(kid.values);\n                return cloneValues;\n            })\n        };\n    }\n    /** Function that kicks off actually putting tags down as HTML elements */\n    buildBeforeElement(insertBefore, options = {\n        counts: { added: 0, removed: 0 },\n    }) {\n        const subject = this.subject;\n        const global = this.global;\n        global.insertBefore = insertBefore;\n        if (!global.placeholder) {\n            setTagPlaceholder(global);\n        }\n        const placeholderElm = global.placeholder;\n        global.oldest = this;\n        global.newest = this;\n        subject.tagSupport = this;\n        this.hasLiveElements = true;\n        const context = this.update();\n        const template = this.getTemplate();\n        const elementContainer = document.createDocumentFragment();\n        const tempDraw = document.createElement('template');\n        tempDraw.innerHTML = template.string;\n        elementContainer.appendChild(tempDraw);\n        // Search/replace innerHTML variables but don't interpolate tag components just yet\n        const { tagComponents } = interpolateElement(elementContainer, context, template, this, // ownerSupport,\n        {\n            counts: options.counts\n        });\n        afterInterpolateElement(elementContainer, placeholderElm, this, // ownerSupport\n        context, options);\n        // Any tag components that were found should be processed AFTER the owner processes its elements. Avoid double processing of elements attributes like (oninit)=${}\n        const length = tagComponents.length;\n        for (let index = 0; index < length; ++index) {\n            const tagComponent = tagComponents[index];\n            subscribeToTemplate(tagComponent.insertBefore, tagComponent.subject, tagComponent.ownerSupport, options.counts);\n            afterInterpolateElement(elementContainer, tagComponent.insertBefore, tagComponent.ownerSupport, context, options);\n        }\n    }\n    getTemplate() {\n        const thisTag = this.templater.tag;\n        const strings = this.strings || thisTag.strings;\n        const values = this.values || thisTag.values;\n        const string = strings.map((string, index) => {\n            const safeString = string.replace(prefixSearch, escapeVariable);\n            const endString = safeString + (values.length > index ? `{${variablePrefix}${index}}` : '');\n            const trimString = endString.replace(/>\\s*/g, '>').replace(/\\s*</g, '<');\n            return trimString;\n        }).join('');\n        const interpolation = interpolateString(string);\n        return {\n            interpolation,\n            string: interpolation.string,\n            strings,\n            values,\n            context: this.global.context || {},\n        };\n    }\n    update() {\n        return this.updateContext(this.global.context);\n    }\n    updateContext(context) {\n        const thisTag = this.templater.tag;\n        const strings = this.strings || thisTag.strings;\n        const values = this.values || thisTag.values;\n        strings.map((_string, index) => {\n            const hasValue = values.length > index;\n            if (!hasValue) {\n                return;\n            }\n            const variableName = variablePrefix + index;\n            const value = values[index];\n            // is something already there?\n            const exists = variableName in context;\n            if (exists) {\n                return updateContextItem(context, variableName, value);\n            }\n            // 🆕 First time values below\n            context[variableName] = processNewValue(value, this);\n        });\n        return context;\n    }\n}\nexport class TagSupport extends BaseTagSupport {\n    templater;\n    ownerTagSupport;\n    subject;\n    version;\n    isApp = false;\n    childTags = []; // tags on me\n    constructor(templater, // at runtime rendering of a tag, it needs to be married to a new TagSupport()\n    ownerTagSupport, subject, version = 0) {\n        super(templater, subject);\n        this.templater = templater;\n        this.ownerTagSupport = ownerTagSupport;\n        this.subject = subject;\n        this.version = version;\n    }\n    destroy(options = {\n        stagger: 0,\n        byParent: false, // Only destroy clones of direct children\n    }) {\n        const firstDestroy = !options.byParent;\n        const global = this.global;\n        const subject = this.subject;\n        const childTags = options.byParent ? [] : getChildTagsToDestroy(this.childTags);\n        if (firstDestroy && isTagComponent(this.templater)) {\n            runBeforeDestroy(this, this);\n        }\n        this.destroySubscriptions();\n        // signify immediately child has been deleted (looked for during event processing)\n        for (let index = childTags.length - 1; index >= 0; --index) {\n            const child = childTags[index];\n            const subGlobal = child.global;\n            delete subGlobal.newest;\n            subGlobal.deleted = true;\n            if (isTagComponent(child.templater)) {\n                runBeforeDestroy(child, child);\n            }\n        }\n        // HTML DOM manipulation. Put back down the template tag\n        const insertBefore = global.insertBefore;\n        if (insertBefore.nodeName === 'TEMPLATE') {\n            const placeholder = global.placeholder;\n            if (placeholder && !('arrayValue' in this.memory)) {\n                if (!options.byParent) {\n                    restoreTagMarker(this);\n                }\n            }\n        }\n        let mainPromise;\n        if (this.ownerTagSupport) {\n            this.ownerTagSupport.childTags = this.ownerTagSupport.childTags.filter(child => child !== this);\n        }\n        if (firstDestroy) {\n            const { stagger, promise } = this.destroyClones(options);\n            options.stagger = stagger;\n            if (promise) {\n                mainPromise = promise;\n            }\n        }\n        else {\n            this.destroyClones();\n        }\n        // data reset\n        delete global.placeholder;\n        global.context = {};\n        delete global.oldest;\n        delete global.newest;\n        global.deleted = true;\n        this.childTags.length = 0;\n        this.hasLiveElements = false;\n        delete subject.tagSupport;\n        if (mainPromise) {\n            mainPromise = mainPromise.then(async () => {\n                const promises = childTags.map(kid => kid.destroy({ stagger: 0, byParent: true }));\n                return Promise.all(promises);\n            });\n        }\n        else {\n            mainPromise = Promise.all(childTags.map(kid => kid.destroy({ stagger: 0, byParent: true })));\n        }\n        return mainPromise.then(() => options.stagger);\n    }\n    destroySubscriptions() {\n        const subs = this.global.subscriptions;\n        for (let index = subs.length - 1; index >= 0; --index) {\n            subs[index].unsubscribe();\n        }\n        subs.length = 0;\n    }\n    destroyClones({ stagger } = {\n        stagger: 0,\n    }) {\n        const oldClones = [...this.clones];\n        this.clones.length = 0; // tag maybe used for something else\n        const promises = oldClones.map(clone => this.checkCloneRemoval(clone, stagger)).filter(x => x); // only return promises\n        // check subjects that may have clones attached to them\n        const oldContext = this.global.context;\n        for (const name in oldContext) {\n            const value = oldContext[name];\n            const clone = value.clone;\n            if (clone?.parentNode) {\n                clone.parentNode.removeChild(clone);\n            }\n        }\n        if (promises.length) {\n            return { promise: Promise.all(promises), stagger };\n        }\n        return { stagger };\n    }\n    /** Reviews elements for the presences of ondestroy */\n    checkCloneRemoval(clone, stagger) {\n        let promise;\n        const customElm = clone;\n        if (customElm.ondestroy) {\n            promise = elementDestroyCheck(customElm, stagger);\n        }\n        const next = () => {\n            const parentNode = clone.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(clone);\n            }\n            const ownerSupport = this.ownerTagSupport;\n            if (ownerSupport) {\n                // Sometimes my clones were first registered to my owner, remove them from owner\n                ownerSupport.clones = ownerSupport.clones.filter(compareClone => compareClone !== clone);\n            }\n        };\n        if (promise instanceof Promise) {\n            return promise.then(next);\n        }\n        else {\n            next();\n        }\n        return promise;\n    }\n    updateBy(tagSupport) {\n        const tempTag = tagSupport.templater.tag;\n        this.updateConfig(tempTag.strings, tempTag.values);\n    }\n    updateConfig(strings, values) {\n        this.strings = strings;\n        this.updateValues(values);\n    }\n    updateValues(values) {\n        this.values = values;\n        return this.updateContext(this.global.context);\n    }\n    getAppTagSupport() {\n        let tag = this;\n        while (tag.ownerTagSupport) {\n            tag = tag.ownerTagSupport;\n        }\n        return tag;\n    }\n}\nfunction restoreTagMarkers(support) {\n    restoreTagMarker(support);\n    const childTags = support.childTags;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        restoreTagMarkers(childTags[index].global.oldest);\n    }\n}\n","import { isSubjectInstance, isTagComponent } from '../../isInstance';\nimport { TagSupport } from '../TagSupport.class';\nexport function updateContextItem(context, variableName, value) {\n    const subject = context[variableName];\n    const tagSubject = subject;\n    const tagSupport = tagSubject.tagSupport;\n    if (tagSupport) {\n        if (value) {\n            if (isTagComponent(value)) {\n                const templater = value;\n                let newSupport = new TagSupport(templater, tagSupport.ownerTagSupport, subject);\n                // TODO: Need to review if this is used\n                if (isTagComponent(tagSupport)) {\n                    console.warn('👉 deprecated code is being used #shareTemplaterGlobal 👈');\n                    shareTemplaterGlobal(tagSupport, newSupport);\n                }\n            }\n        }\n    }\n    if (isSubjectInstance(value)) {\n        return; // emits on its own\n    }\n    // listeners will evaluate updated values to possibly update display(s)\n    subject.set(value);\n    return;\n}\nfunction shareTemplaterGlobal(oldTagSupport, tagSupport) {\n    const oldTemp = oldTagSupport.templater;\n    const oldWrap = oldTemp.wrapper; // tag versus component\n    const oldValueFn = oldWrap.parentWrap.original;\n    const templater = tagSupport.templater;\n    const newWrapper = templater.wrapper;\n    const newValueFn = newWrapper?.parentWrap.original;\n    const fnMatched = oldValueFn === newValueFn;\n    if (fnMatched) {\n        tagSupport.global = oldTagSupport.global;\n        const newest = oldTagSupport.global.newest;\n        if (newest) {\n            const prevState = newest.memory.state;\n            tagSupport.memory.state.length = 0;\n            tagSupport.memory.state.push(...prevState);\n            // tagSupport.memory.state = [...prevState]\n        }\n    }\n}\n","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    if (!onDestroyDoubleWrap) {\n        return;\n    }\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    if (!onDestroy) {\n        return;\n    }\n    const event = { target: nextSibling, stagger };\n    return onDestroy(event);\n}\n","export const tags = [];\n","import { isSubjectInstance, isTagArray } from '../isInstance';\nimport { setUse } from '../state';\nimport { TemplaterResult } from '../TemplaterResult.class';\nimport { runTagCallback } from '../interpolations/bindSubjectCallback.function';\nimport { deepClone } from '../deepFunctions';\nimport { TagSupport } from './TagSupport.class';\nimport { alterProps } from '../alterProps.function';\nimport { ValueSubject } from '../subject/ValueSubject';\nimport { tags } from './tag.utils';\nimport { ValueTypes } from './update/processFirstSubject.utils';\nlet tagCount = 0;\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent) {\n    /** function developer triggers */\n    const parentWrap = (function tagWrapper(...props) {\n        const templater = new TemplaterResult(props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        if (!innerTagWrap.parentWrap) {\n            innerTagWrap.parentWrap = parentWrap;\n        }\n        templater.tagged = true;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }) // we override the function provided and pretend original is what's returned\n    ;\n    parentWrap.original = tagComponent;\n    parentWrap.compareTo = tagComponent.toString();\n    updateResult(parentWrap, tagComponent);\n    // group tags together and have hmr pickup\n    updateComponent(tagComponent);\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Used to create a tag component that renders once and has no addition rendering cycles */\ntag.oneRender = (...props) => {\n    throw new Error('Do not call function tag.oneRender but instead set it as: `tag.oneRender = (props) => html`` `');\n};\nObject.defineProperty(tag, 'oneRender', {\n    set(oneRenderFunction) {\n        oneRenderFunction.oneRender = true;\n    },\n});\nexport function kidsToTagArraySubject(children) {\n    if (isSubjectInstance(children)) {\n        return { childSubject: children, madeSubject: false };\n    }\n    const kidArray = children;\n    if (isTagArray(kidArray)) {\n        return { childSubject: new ValueSubject(children), madeSubject: true };\n    }\n    const kid = children;\n    if (kid) {\n        kid.memory.arrayValue = 0;\n        return { childSubject: new ValueSubject([kid]), madeSubject: true };\n    }\n    return {\n        childSubject: new ValueSubject([]),\n        madeSubject: true // was converted into a subject\n    };\n}\nfunction updateResult(result, tagComponent) {\n    result.isTag = true;\n    result.original = tagComponent;\n}\nfunction updateComponent(tagComponent) {\n    tagComponent.tags = tags;\n    tagComponent.setUse = setUse;\n    tagComponent.tagIndex = tagCount++; // needed for things like HMR\n}\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nfunction getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function (newTagSupport, subject) {\n        const global = newTagSupport.global;\n        ++global.renderCount;\n        const childSubject = templater.children;\n        const lastArray = global.oldest?.templater.children.lastArray;\n        if (lastArray) {\n            childSubject.lastArray = lastArray;\n        }\n        // result.original\n        const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n        let props = templater.props;\n        let castedProps = props.map(props => alterProps(props, newTagSupport.ownerTagSupport));\n        const latestCloned = props.map(props => deepClone(props)); // castedProps\n        // CALL ORIGINAL COMPONENT FUNCTION\n        let tag = originalFunction(...castedProps);\n        if (tag instanceof Function) {\n            tag = tag();\n        }\n        tag.templater = templater;\n        templater.tag = tag;\n        const tagSupport = new TagSupport(templater, newTagSupport.ownerTagSupport, subject, global.renderCount);\n        tagSupport.global = global;\n        tagSupport.propsConfig = {\n            latest: props,\n            latestCloned,\n            lastClonedKidValues: tagSupport.propsConfig.lastClonedKidValues,\n        };\n        tagSupport.memory = newTagSupport.memory; // state handover\n        if (templater.madeChildIntoSubject) {\n            const value = childSubject.value;\n            for (let index = value.length - 1; index >= 0; --index) {\n                const kid = value[index];\n                const values = kid.values;\n                for (let index = values.length - 1; index >= 0; --index) {\n                    const value = values[index];\n                    if (!(value instanceof Function)) {\n                        continue;\n                    }\n                    const valuesValue = kid.values[index];\n                    if (valuesValue.isChildOverride) {\n                        continue; // already overwritten\n                    }\n                    // all functions need to report to me\n                    kid.values[index] = function (...args) {\n                        const ownerSupport = tagSupport.ownerTagSupport;\n                        return runTagCallback(value, // callback\n                        ownerSupport, this, // bindTo\n                        args);\n                    };\n                    valuesValue.isChildOverride = true;\n                }\n            }\n        }\n        return tagSupport;\n    };\n    return wrapper;\n}\n","import { Tag } from \"./Tag.class\";\nexport function html(strings, ...values) {\n    return new Tag(strings, values);\n}\n","import { BaseTagSupport } from './TagSupport.class';\nimport { runAfterRender, runBeforeRender } from './tagRunner';\nimport { ValueSubject } from '../subject/ValueSubject';\nconst appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, // (...args: unknown[]) => TemplaterResult,\nelement, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        appElements[appElmIndex].tagSupport.destroy();\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    const wrapper = app(props);\n    // have a function setup and call the tagWrapper with (props, {update, async, on})\n    const tagSupport = runWrapper(wrapper);\n    // TODO: is the below needed?\n    tagSupport.appElement = element;\n    tagSupport.isApp = true;\n    tagSupport.global.isApp = true;\n    const templateElm = document.createElement('template');\n    templateElm.setAttribute('id', 'app-tag-' + appElements.length);\n    templateElm.setAttribute('app-tag-detail', appElements.length.toString());\n    const fragment = document.createDocumentFragment();\n    fragment.appendChild(templateElm);\n    element.destroy = async () => {\n        await tagSupport.destroy();\n        const insertBefore = tagSupport.global.insertBefore;\n        const parentNode = insertBefore.parentNode;\n        parentNode.removeChild(insertBefore);\n    };\n    tagSupport.buildBeforeElement(templateElm);\n    tagSupport.global.oldest = tagSupport;\n    tagSupport.global.newest = tagSupport;\n    element.setUse = app.original.setUse;\n    appElements.push({ element, tagSupport });\n    element.appendChild(fragment);\n    return {\n        tagSupport,\n        tags: app.original.tags,\n    };\n}\nexport function runWrapper(templater) {\n    let newSupport = {};\n    const subject = new ValueSubject(newSupport);\n    newSupport = new BaseTagSupport(templater, subject);\n    subject.set(templater);\n    subject.tagSupport = newSupport;\n    runBeforeRender(newSupport, undefined);\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const tagSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport, tagSupport);\n    return tagSupport;\n}\n","export * from \"./tag/tag\";\nexport * from \"./tag/tag.utils\";\nexport * from \"./tag/html\";\nexport * from \"./errors\";\nexport * from \"./isInstance\";\nexport * from \"./state/index\";\nexport * from \"./subject/index\";\nexport * from \"./tag/TagSupport.class\";\nexport * from \"./interpolations/ElementTargetEvent.interface\";\nexport * from \"./interpolations/interpolateElement\";\nexport { tagElement } from \"./tag/tagElement\";\nexport { Tag } from \"./tag/Tag.class\";\nexport { runBeforeRender } from \"./tag/tagRunner\";\nexport { renderTagSupport } from \"./tag/render/renderTagSupport.function\";\nexport { renderWithSupport } from \"./tag/render/renderWithSupport.function\";\nexport { isLikeValueSets } from \"./tag/isLikeTags.function\";\nimport { renderTagOnly } from \"./tag/render/renderTagOnly.function\";\nimport { renderTagSupport } from \"./tag/render/renderTagSupport.function\";\nimport { renderWithSupport } from \"./tag/render/renderWithSupport.function\";\nimport { tagElement } from \"./tag/tagElement\";\nexport const hmr = {\n    tagElement, renderWithSupport, renderTagSupport,\n    renderTagOnly,\n};\n"],"names":["ValueTypes","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","isLikeTags","tagSupport0","tagSupport1","templater0","templater","templater1","tag0","tag","tag1","strings0","strings","strings1","length","every","string","index","isLikeValueSets","values","values0","values1","value","compareTo","Function","toString","destroyTagMemory","oldTagSupport","global","oldest","destroy","destroyTagSupportPast","context","newest","insertAfter","newNode","referenceNode","parentNode","insertBefore","nextSibling","isSimpleType","includes","destroyArrayTag","tagSupport","counts","stagger","removed","removeChild","lastSupport","placeholderElm","placeholder","getValueType","undefined","type","function","Date","date","tagJsType","tagComponent","isTagArray","tagArray","isSubjectInstance","subject","unknown","isStaticTag","isTagTemplater","isTagComponent","isTagClass","isSubject","subscribe","Array","x","combineLatest","subjects","output","Subject","subscribeWith","callback","valuesSeen","setValue","subscription","clones","shift","subscriptions","map","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","next","newValue","handler","methodResponse","setHandler","onSubscription","subscribers","_value","constructor","this","set","countSubject","globalSubCount$","unsubscribe","findIndex","sub","splice","removeSubFromArray","add","push","getSubscription","orgCallback","lastValue","count","subs","toPromise","Promise","res","toCallback","pipe","operations","all","args","arg","static","ValueSubject","super","willCallback","utils","willPromise","then","willSubscribe","getSupportInCycle","setUse","memory","stateConfig","use","useMe","beforeRender","beforeRedraw","afterRender","beforeDestroy","tagUse","TagError","Error","details","message","errorCode","name","ArrayNoKeyError","StateMismatchError","SyncCallbackError","array","state","config","rearray","stateLength","getStateValue","initState","defaultValue","checkValue","oldState","StateEchoBack","getCallbackValue","JSON","stringify","console","error","wrapper","oldStates","newStates","tagFunction","parentWrap","original","warn","item","syncStates","stateFrom","stateTo","fromValue","getSetMethod","restate","oldValue","initValue","newState","result","watch","currentValues","setupWatch","defaultFinally","init","before","final","previous","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","method","originalState","setTo","oldestState","nowTagSupport","letState","makeStateResult","y","letProp","getSetProp","myProp","deepClone","makeDeepClone","WeakMap","visited","has","RegExp","clone","isArray","create","getPrototypeOf","i","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","getTime","isArrayDeepEqual","keys1","keys","keys2","isObjectDeepEqual","newWatch","providerConfig","providers","ownerSupport","constructMethod","stateDiffMemory","stateDiff","provider","oldStateCount","instance","cm","inject","owner","ownerTagSupport","find","msg","run","handleProviderChanges","appSupport","tagsWithProvider","getTagsWithProvider","renderCount","deleted","renderTagSupport","hasProvider","xProvider","childTags","runBeforeRender","runAfterRender","tagClosed$","runBeforeDestroy","renderTagOnly","newTagSupport","oldRenderCount","lastOwnerSupport","runtimeOwnerSupport","lastState","runBeforeRedraw","beforeWithRender","reSupport","renderWithSupport","oldGlobal","destroyUnlikeTags","renderExistingTag","oldestSupport","newSupport","preRenderCount","providersWithChanges","filter","getAppTagSupport","providersChangeCheck","prevSupport","updateBy","renderUp","ownerTag","selfPropChange","nowProps","props","latestProps","propsConfig","latestCloned","innerCallback","a","b","c","d","e","f","callbackMaker","originalGetter","triggerStateUpdate","initMemory","maybePromise","finally","setCurrentTagSupport","support","currentSupport","onInit","destroyCurrentSupport","onDestroy","destroyCallback","childrenCurrentSupport","children","variablePrefix","escapeVariable","escapeSearch","Tag","arrayValue","html","TemplaterResult","tagged","madeChildIntoSubject","childSubject","madeSubject","kidsToTagArraySubject","runTagCallback","bindTo","myGlobal","callbackResult","bind","cloneValueArray","getChildTagsToDestroy","allTags","cTag","processNewTag","TagSupport","swapInsertBefore","document","createTextNode","inputAttribute","element","names","split","style","classList","remove","startRegX","endRegX","isTagVar","search","processAttribute","attrName","child","scope","howToSet","getContextValueByVarString","processNameValueAttr","processScopedNameValueAttr","attrValue","removeAttribute","processNameOnlyAttr","isSpecialAttr","replace","reverse","join","isSpecial","action","newAttrValue","oneRender","isChildOverride","subjectFunction","bindSubjectCallback","fun","isDeadValue","processAttributeSubjectValue","howToSetAttribute","setAttribute","howToSetInputValue","interpolateAttributes","attrNames","getAttributeNames","nodeName","getAttribute","interpolateReplace","processTagResult","subjectTag","processTagResultUpdate","buildBeforeElement","processSubjectComponent","options","label","substring","preClones","myClones","fClone","renderSubjectComponent","processTag","newTagSupportByTemplater","added","setupNewTemplater","tagFakeTemplater","getFakeTemplater","fake","isTag","processTagArray","lastArray","setPlaceholderElm","runtimeInsertBefore","lessLength","subTag","lastTag","newArrayValue","lastArrayValue","destroyItem","valueA","valueB","areLikeValues","last","previousSupport","template","getTemplate","processAddTagArrayItem","fragment","createDocumentFragment","newTempElm","createElement","appendChild","updateBeforeTemplate","lastFirstChild","parent","textNode","castTextValue","processRegularValue","castedValue","oldClone","textContent","processFirstSubjectValue","v","wrap","processFirstRegularValue","compareProps","compare","onDelete","compareOriginal","hasTagSupportChanged","newTemplater","propsChanged","pastCloneProps","castedProps","castedPastProps","subCastedProps","subCompareProps","matched","entries","hasPropChanges","kidsChanged","oldCloneKidValues","lastClonedKidValues","newClonedKidValues","hasKidsChanged","alterProps","newProps","toCall","callbackPropOwner","resetFunctionProps","callWith","cycle","lastestOwner","allMatched","updateExistingTagComponent","oldestTag","oldWrapper","newWrapper","isSameTag","newPropsArray","priorPropConfig","priorPropsArray","argPosition","priorProps","newCallback","syncFunctionProps","newOldest","buildNewTag","oldInsertBefore","updateExistingValue","valueType","displaySubject","hasLastValue","newType","destroySimpleValue","arraySubject","wasArray","isValueTag","checkDestroyPrevious","subjectSup","newestState","prepareUpdateToComponent","isClass","valueSupport","handleStillTag","interpolateTemplate","hasAttribute","variableName","existingSubject","subscribeToTemplate","called","onValue","mutatingCallback","afterElmBuild","elm","textarea","match","dynamic","_elm","_name","scanTextAreaValue","diff","onInitDoubleWrap","oninit","onInitWrap","target","elementInitCheck","interpolateContentTemplates","tagComponents","nextClones","subChild","isRenderEndTemplate","nextTagComponent","tagName","interpolateElement","container","interpolatedTemplates","interpolation","content","nextTagComponents","processChildrenAttributes","interpolateString","expression","startsWith","id","interpolateToTemplates","afterInterpolateElement","temporary","firstChild","nextNextSibling","buildClones","prefixSearch","BaseTagSupport","isApp","appElement","hasLiveElements","kidValue","latest","kid","setTagPlaceholder","update","elementContainer","tempDraw","innerHTML","thisTag","updateContext","_string","oldValueFn","newValueFn","prevState","shareTemplaterGlobal","updateContextItem","processNewValue","version","byParent","firstDestroy","destroySubscriptions","subGlobal","mainPromise","promise","destroyClones","async","promises","oldClones","checkCloneRemoval","oldContext","customElm","ondestroy","onDestroyDoubleWrap","onDestroyWrap","elementDestroyCheck","compareClone","tempTag","updateConfig","updateValues","tags","tagCount","innerTagWrap","originalFunction","valuesValue","getTagWrap","updateResult","tagIndex","updateComponent","oneRenderFunction","appElements","tagElement","app","appElmIndex","appElm","runWrapper","templateElm","hmr"],"sourceRoot":""}