{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://taggedjs/webpack/bootstrap","webpack://taggedjs/webpack/runtime/define property getters","webpack://taggedjs/webpack/runtime/hasOwnProperty shorthand","webpack://taggedjs/./ts/tag/update/getNewGlobal.function.ts","webpack://taggedjs/./ts/tag/tag.types.ts","webpack://taggedjs/./ts/tag/DomTag.type.ts","webpack://taggedjs/./ts/interpolations/attributes/isSpecialAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagVarIndex.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/parseHTML.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/htmlInterpolationToDomMeta.function.ts","webpack://taggedjs/./ts/tag/ValueTypes.enum.ts","webpack://taggedjs/./ts/interpolations/optimizers/replacePlaceholders.function.ts","webpack://taggedjs/./ts/tag/getStringsId.function.ts","webpack://taggedjs/./ts/tag/domMetaCollector.ts","webpack://taggedjs/./ts/tag/isLastRunMatched.function.ts","webpack://taggedjs/./ts/interpolations/attributes/howToSetInputValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/specialAttribute.ts","webpack://taggedjs/./ts/isInstance.ts","webpack://taggedjs/./ts/state/handleProviderChanges.function.ts","webpack://taggedjs/./ts/state/providersChangeCheck.function.ts","webpack://taggedjs/./ts/deepFunctions.ts","webpack://taggedjs/./ts/tag/getSupportInCycle.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getSupportWithState.function.ts","webpack://taggedjs/./ts/state/states.utils.ts","webpack://taggedjs/./ts/state/state.utils.ts","webpack://taggedjs/./ts/state/getStateValue.function.ts","webpack://taggedjs/./ts/state/stateHandlers.ts","webpack://taggedjs/./ts/subject/combineLatest.function.ts","webpack://taggedjs/./ts/subject/subject.utils.ts","webpack://taggedjs/./ts/subject/Subject.class.ts","webpack://taggedjs/./ts/state/tagClosed$.subject.ts","webpack://taggedjs/./ts/state/setUseMemory.object.ts","webpack://taggedjs/./ts/state/syncStates.function.ts","webpack://taggedjs/./ts/tag/processUpdateContext.function.ts","webpack://taggedjs/./ts/render/update/updateSupportBy.function.ts","webpack://taggedjs/./ts/tag/cloneValueArray.function.ts","webpack://taggedjs/./ts/tag/props/clonePropsBy.function.ts","webpack://taggedjs/./ts/tag/createHtmlSupport.function.ts","webpack://taggedjs/./ts/tag/createSupport.function.ts","webpack://taggedjs/./ts/tag/update/tryUpdateToTag.function.ts","webpack://taggedjs/./ts/render/update/updateExistingTagComponent.function.ts","webpack://taggedjs/./ts/tag/hasSupportChanged.function.ts","webpack://taggedjs/./ts/tag/update/handleStillTag.function.ts","webpack://taggedjs/./ts/tag/update/tagValueUpdateHandler.function.ts","webpack://taggedjs/./ts/tag/tagRunner.ts","webpack://taggedjs/./ts/tag/destroyContext.function.ts","webpack://taggedjs/./ts/tag/checkDestroyPrevious.function.ts","webpack://taggedjs/./ts/tag/smartRemoveKids.function.ts","webpack://taggedjs/./ts/render/destroySupport.function.ts","webpack://taggedjs/./ts/tag/update/compareArrayItems.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectValue.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/domProcessContextItem.function.ts","webpack://taggedjs/./ts/castTextValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getSimpleTagVar.function.ts","webpack://taggedjs/./ts/tag/update/processRegularValue.function.ts","webpack://taggedjs/./ts/tagJsVars/getArrayTagJsVar.function.ts","webpack://taggedjs/./ts/tagJsVars/valueToTagJsVar.function.ts","webpack://taggedjs/./ts/tag/update/createAndProcessContextItem.function.ts","webpack://taggedjs/./ts/tag/update/processTagArray.ts","webpack://taggedjs/./ts/tag/update/updateToDiffValue.function.ts","webpack://taggedjs/./ts/tag/update/forceUpdateExistingValue.function.ts","webpack://taggedjs/./ts/tag/update/checkSubContext.function.ts","webpack://taggedjs/./ts/tag/update/onFirstSubContext.function.ts","webpack://taggedjs/./ts/tag/guaranteeInsertBefore.function.ts","webpack://taggedjs/./ts/tag/update/setupSubscribe.function.ts","webpack://taggedjs/./ts/tag/update/processSubscribe.function.ts","webpack://taggedjs/./ts/state/signal.function.ts","webpack://taggedjs/./ts/subject/ValueSubject.ts","webpack://taggedjs/./ts/subject/will.functions.ts","webpack://taggedjs/./ts/state/state.function.ts","webpack://taggedjs/./ts/state/watch.function.ts","webpack://taggedjs/./ts/state/subject.function.ts","webpack://taggedjs/./ts/state/states.function.ts","webpack://taggedjs/./ts/state/letProp.function.ts","webpack://taggedjs/./ts/state/providers.ts","webpack://taggedjs/./ts/errors.ts","webpack://taggedjs/./ts/state/callback.function.ts","webpack://taggedjs/./ts/state/callbackStateUpdate.function.ts","webpack://taggedjs/./ts/state/callbackMaker.function.ts","webpack://taggedjs/./ts/interpolations/attributes/renderTagArray.function.ts","webpack://taggedjs/./ts/interpolations/attributes/checkToResolvePromise.function.ts","webpack://taggedjs/./ts/state/onInit.ts","webpack://taggedjs/./ts/state/onDestroy.ts","webpack://taggedjs/./ts/state/array.function.ts","webpack://taggedjs/./ts/tag/isLikeTags.function.ts","webpack://taggedjs/./ts/tag/checkTagValueChange.function.ts","webpack://taggedjs/./ts/render/buildBeforeElement.function.ts","webpack://taggedjs/./ts/render/update/processTag.function.ts","webpack://taggedjs/./ts/tag/update/processNewSubjectTag.function.ts","webpack://taggedjs/./ts/tag/update/processTagInit.function.ts","webpack://taggedjs/./ts/tag/getTemplaterResult.function.ts","webpack://taggedjs/./ts/tag/tag.utils.ts","webpack://taggedjs/./ts/tag/props/safeRenderSupport.function.ts","webpack://taggedjs/./ts/tag/props/alterProp.function.ts","webpack://taggedjs/./ts/render/executeWrap.function.ts","webpack://taggedjs/./ts/tag/getTagWrap.function.ts","webpack://taggedjs/./ts/tag/update/oneRenderToSupport.function.ts","webpack://taggedjs/./ts/tag/checkStateMismatch.function.ts","webpack://taggedjs/./ts/render/afterRender.function.ts","webpack://taggedjs/./ts/render/renderTagOnly.function.ts","webpack://taggedjs/./ts/render/update/processRenderOnceInit.function.ts","webpack://taggedjs/./ts/tag/update/processFirstSubjectComponent.function.ts","webpack://taggedjs/./ts/tag/update/processTagResult.function.ts","webpack://taggedjs/./ts/tag/update/processTagComponentInit.function.ts","webpack://taggedjs/./ts/tagJsVars/tag.function.ts","webpack://taggedjs/./ts/tag/hasPropChanges.function.ts","webpack://taggedjs/./ts/tag/update/syncPriorPropFunction.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingArray.function.ts","webpack://taggedjs/./ts/tag/update/updateExistingObject.function.ts","webpack://taggedjs/./ts/render/softDestroySupport.function.ts","webpack://taggedjs/./ts/render/renderWithSupport.function.ts","webpack://taggedjs/./ts/render/renderExistingTag.function.ts","webpack://taggedjs/./ts/render/renderSupport.function.ts","webpack://taggedjs/./ts/interpolations/attributes/getUpTags.function.ts","webpack://taggedjs/./ts/interpolations/attributes/bindSubjectCallback.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processNameValueAttribute.function.ts","webpack://taggedjs/./ts/interpolations/attributes/addSupportEventListener.function.ts","webpack://taggedjs/./ts/interpolations/attributes/processAttributeCallback.function.ts","webpack://taggedjs/./ts/render/attributes/isNoDisplayValue.function.ts","webpack://taggedjs/./ts/interpolations/attributes/updateAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/processUpdateAttrContext.function.ts","webpack://taggedjs/./ts/render/attributes/processAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/createDynamicAttribute.function.ts","webpack://taggedjs/./ts/render/attributes/getTagJsVar.function.ts","webpack://taggedjs/./ts/interpolations/optimizers/attachDynamicDom.function.ts","webpack://taggedjs/./ts/render/dom/attachDomElements.function.ts","webpack://taggedjs/./ts/render/paint.function.ts","webpack://taggedjs/./ts/tag/update/deleteSubContext.function.ts","webpack://taggedjs/./ts/tag/update/processDomTagInit.function.ts","webpack://taggedjs/./ts/tag/processOuterDomTagInit.function.ts","webpack://taggedjs/./ts/tag/getDomTag.function.ts","webpack://taggedjs/./ts/tag/html.ts","webpack://taggedjs/./ts/render/registerNewTagElement.function.ts","webpack://taggedjs/./ts/tag/loadNewBaseSupport.function.ts","webpack://taggedjs/./ts/render/renderTagElement.function.ts","webpack://taggedjs/./ts/tag/tagElement.ts","webpack://taggedjs/./ts/tag/output.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribe.function.ts","webpack://taggedjs/./ts/tagJsVars/getInnerHTML.function.ts","webpack://taggedjs/./ts/tagJsVars/pipe.function.ts","webpack://taggedjs/./ts/tagJsVars/host.function.ts","webpack://taggedjs/./ts/tagJsVars/subscribeWith.function.ts","webpack://taggedjs/./ts/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function getNewGlobal(contextItem) {\n    ;\n    contextItem.renderCount = contextItem.renderCount || 0;\n    return contextItem.global = {};\n}\n","export class RouteQuery {\n    get(_name) {\n        return 'todo';\n    }\n}\n","// taggedjs-no-compile\nexport const variablePrefix = ':tagvar';\nexport const variableSuffix = ':';\n","/** Looking for (class | style) followed by a period */\nexport function isSpecialAttr(attrName) {\n    if (attrName.startsWith('class.')) {\n        return 'class';\n    }\n    const specialAction = isSpecialAction(attrName);\n    if (specialAction !== false) {\n        return specialAction;\n    }\n    if (attrName.startsWith('style.')) {\n        return 'style';\n    }\n    return false;\n}\nexport function isSpecialAction(attrName) {\n    switch (attrName) {\n        case 'autoselect':\n            return 'autoselect';\n        case 'autofocus':\n            return 'autofocus';\n        case 'oninit': // when read in compile process\n        case 'init': // when read in realtime\n            return 'init';\n        case 'ondestroy': // when read in compile process\n        case 'destroy': // when read in realtime\n            return 'destroy';\n    }\n    return false;\n}\n","import { variableSuffix, variablePrefix } from \"../../tag/DomTag.type.js\";\nexport const placeholderRegex = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'g');\nexport function getTagVarIndex(value) {\n    if (value.search && value.startsWith(variablePrefix)) {\n        return value.search(placeholderRegex);\n    }\n    return -1;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { isSpecialAttr } from \"../attributes/isSpecialAttribute.function.js\";\nimport { fakeTagsRegEx, findRealTagsRegEx } from \"./htmlInterpolationToDomMeta.function.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst fragFindAny = /(:tagvar\\d+:)/;\nconst ondoubleclick = 'ondoubleclick';\nconst regexAttr = /([:_a-zA-Z0-9\\-.]+)\\s*(?:=\\s*\"([^\"]*)\"|=\\s*(\\S+))?/g;\nconst regexTagOrg = /<\\/?([a-zA-Z0-9-]+)((?:\\s+[a-zA-Z_:*][\\w:.-]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>`]+))?)+\\s*|\\s*)\\/?>/g;\n/** Main start of string parsing */\nexport function parseHTML(html) {\n    const valuePositions = [];\n    const elements = [];\n    const stack = [];\n    let currentElement = null;\n    let valueIndex = -1;\n    let position = 0;\n    const regexTag = new RegExp(regexTagOrg, 'g');\n    html = preprocessTagsInComments(html);\n    while (position < html.length) {\n        const tagMatch = regexTag.exec(html);\n        if (!tagMatch) {\n            break;\n        }\n        const [fullMatch, tagName, attrString] = tagMatch;\n        const isClosingTag = fullMatch.startsWith('</');\n        const isSelfClosing = fullMatch.endsWith('/>');\n        if (position < tagMatch.index) {\n            const textContent = html.slice(position, tagMatch.index);\n            if (textContent.trim()) {\n                const textVarMatches = splitByTagVar(textContent);\n                for (let textContent of textVarMatches) {\n                    if (textContent.startsWith(variablePrefix) && textContent.search(fragFindAny) >= 0) {\n                        // if its not fake then lets now consider this a real variable\n                        if (textContent.search(fakeTagsRegEx) === -1) {\n                            textContent = variablePrefix + (++valueIndex) + variableSuffix;\n                        }\n                    }\n                    pushTextTo(currentElement, elements, textContent);\n                }\n            }\n        }\n        position = tagMatch.index + fullMatch.length;\n        if (isClosingTag) {\n            currentElement = stack.pop() || null;\n            continue;\n        }\n        const attributes = [];\n        let attrMatch;\n        while ((attrMatch = regexAttr.exec(attrString)) !== null) {\n            valueIndex = parseAttrString(attrMatch, valueIndex, valuePositions, attributes);\n        }\n        const element = {\n            nn: tagName, // nodeName\n        };\n        if (attributes.length) {\n            element.at = attributes;\n        }\n        if (currentElement) {\n            if (!currentElement.ch) {\n                currentElement.ch = [];\n            }\n            currentElement.ch.push(element);\n        }\n        else {\n            elements.push(element);\n        }\n        if (!isSelfClosing) {\n            stack.push(currentElement);\n            currentElement = element;\n        }\n    }\n    if (position < html.length) {\n        const textContent = html.slice(position);\n        if (textContent.trim()) {\n            const textVarMatches = splitByTagVar(textContent);\n            for (const textContent of textVarMatches) {\n                if (textContent.startsWith(variablePrefix)) {\n                    ++valueIndex;\n                }\n                pushTextTo(currentElement, elements, textContent);\n            }\n        }\n    }\n    return elements;\n}\nconst removeCommentRegX = new RegExp('(<!--[\\\\s\\\\S]*?-->)', 'g');\nfunction preprocessTagsInComments(html) {\n    // Use a regex to find all HTML comments\n    return html.replace(removeCommentRegX, function (match) {\n        // For each comment found, replace < and > inside it\n        return match.replace(/\\[l t\\]/g, '[l&nbsp;t]').replace(/\\[g t\\]/g, '[g&nbsp;t]').replace(/</g, '[l t]').replace(/>/g, '[g t]');\n    });\n}\nfunction cleanEventName(eventName) {\n    if (eventName.startsWith('on')) {\n        const couldByDblClick = eventName.length === ondoubleclick.length && eventName === ondoubleclick;\n        if (couldByDblClick) {\n            return 'dblclick';\n        }\n        return eventName.slice(2, eventName.length);\n    }\n    return eventName;\n}\nfunction pushTextTo(currentElement, elements, textContent) {\n    const textNode = {\n        nn: 'text', // nodeName\n        tc: postProcessTagsInComments(textContent), // textContent\n    };\n    pushTo(currentElement, elements, textNode);\n}\n/** TODO: This has got to be too expensive */\nfunction postProcessTagsInComments(html) {\n    // Use a regex to find all segments that look like processed comments\n    return html.replace(/(\\[l t\\]!--[\\s\\S]*?--\\[g t\\])/g, function (match) {\n        // For each processed comment found, replace *lt* and *gt* back to < and >\n        return match.replace(/\\[l t\\]/g, '<').replace(/\\[g t\\]/g, '>').replace(/\\[l&nbsp;t\\]/g, '[l t]').replace(/\\[g&nbsp;t\\]/g, '[g t]');\n    });\n}\nfunction pushTo(currentElement, elements, textNode) {\n    if (currentElement) {\n        if (!currentElement.ch) {\n            currentElement.ch = [];\n        }\n        currentElement.ch.push(textNode);\n    }\n    else {\n        elements.push(textNode);\n    }\n}\nfunction splitByTagVar(inputString) {\n    // Split the string using the regular expression, keep delimiters in the output\n    const parts = inputString.split(fragFindAny);\n    // Filter out any empty strings from the results\n    const filteredParts = parts.filter(notEmptyStringMapper);\n    return filteredParts;\n}\nfunction notEmptyStringMapper(part) {\n    return part !== '';\n}\nfunction parseAttrString(attrMatch, valueIndex, valuePositions, attributes) {\n    const attrName = attrMatch[1] || attrMatch[3] || attrMatch[5];\n    const attrChoice = attrMatch[2] || attrMatch[4] || attrMatch[6];\n    let attrValue = attrChoice;\n    if (attrName === undefined) {\n        return valueIndex;\n    }\n    const notEmpty = attrMatch[2] !== '';\n    const noValue = attrValue === undefined && notEmpty;\n    const lowerName = attrName.toLowerCase();\n    const fixedName = lowerName.startsWith('on') ? cleanEventName(lowerName) : lowerName;\n    if (noValue) {\n        const standAloneVar = attrName.slice(0, variablePrefix.length) === variablePrefix;\n        if (standAloneVar) {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            valuePositions.push(['at', valueName]);\n            attributes.push([valueName]); // the name itself is dynamic\n            return valueIndex;\n        }\n        const startMatched = attrMatch[0].startsWith(attrName);\n        const standAloneAttr = startMatched && attrMatch[0].slice(attrName.length, attrMatch[0].length).search(/\\s+$/) >= 0;\n        if (standAloneAttr) {\n            attributes.push([fixedName]);\n            return valueIndex;\n        }\n        const wholeValue = attrMatch[3];\n        const isFakeTag = wholeValue.search(fakeTagsRegEx) >= 0;\n        if (isFakeTag) {\n            attrValue = wholeValue;\n            // to restore: wholeValue.replace(fakeTagsRegEx,variablePrefix+'$1$3$4'+variableSuffix)\n            const attrSet = [fixedName, attrValue];\n            attributes.push(attrSet);\n            return valueIndex;\n        }\n        else {\n            const valueName = variablePrefix + (++valueIndex) + variableSuffix;\n            attrValue = valueName;\n        }\n    }\n    if (!notEmpty) {\n        attrValue = attrMatch[2];\n    }\n    // concat attributes as array\n    const attrValueSplit = attrValue.split(findRealTagsRegEx).filter((x) => x.length > 0);\n    if (attrValueSplit.length > 1) {\n        attrValue = attrValueSplit;\n        attrValueSplit.forEach((value) => {\n            if (value.search(placeholderRegex) >= 0) {\n                ++valueIndex;\n            }\n        });\n    }\n    const attrSet = [fixedName, attrValue];\n    const isSpecial = isSpecialAttr(lowerName); // check original name for \"oninit\" or \"autofocus\"\n    if (isSpecial) {\n        attrSet.push(isSpecial);\n    }\n    // force style to be first so other style manipulating attributes do not get overwritten\n    if (fixedName === 'style') {\n        attributes.unshift(attrSet);\n        return valueIndex;\n    }\n    attributes.push(attrSet);\n    return valueIndex;\n}\n","import { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { parseHTML } from \"./parseHTML.function.js\";\nexport const realTagsRegEx = new RegExp(variablePrefix + '(\\\\d+)' + variableSuffix, 'gi');\nexport const findRealTagsRegEx = new RegExp('(' + variablePrefix + '\\\\d+' + variableSuffix + ')', 'gi');\n// without last letter\nconst shortFront = variablePrefix.slice(0, variablePrefix.length - 1);\nexport const fakeTagsRegEx = new RegExp(shortFront + '&#x72;(\\\\d+)' + variableSuffix, 'gi');\n// variable prefix minus one letter and then the letter \"r\" as hex\nconst replacement = shortFront + '&#x72;$1' + variableSuffix;\n/** Run only during compile step OR when no compile step occurred at runtime */\nexport function htmlInterpolationToDomMeta(strings, values) {\n    // Parse the modified fragments\n    const htmlString = htmlInterpolationToPlaceholders(strings, values).join('');\n    const domMeta = parseHTML(htmlString);\n    return domMeta;\n}\nexport function htmlInterpolationToPlaceholders(strings, values) {\n    // Sanitize placeholders in the fragments\n    const sanitizedFragments = strings;\n    // const sanitizedFragments = sanitizePlaceholders(strings)\n    // Add placeholders to the fragments\n    return addPlaceholders(sanitizedFragments, values);\n}\nfunction addPlaceholders(strings, values) {\n    const results = [];\n    for (let index = 0; index < strings.length; ++index) {\n        const fragment = strings[index];\n        const safeFragment = fragment.replace(realTagsRegEx, replacement);\n        if (index < values.length) {\n            results.push(safeFragment + variablePrefix + index + variableSuffix);\n            continue;\n        }\n        results.push(safeFragment);\n    }\n    balanceArrayByArrays(results, strings, values);\n    return results;\n}\nexport function balanceArrayByArrays(results, strings, values) {\n    const diff = values.length - strings.length;\n    if (diff > 0) {\n        for (let x = diff; x > 0; --x) {\n            results.push(variablePrefix + (strings.length + x - 1) + variableSuffix);\n        }\n    }\n}\n","export const empty = '';\nexport var ImmutableTypes;\n(function (ImmutableTypes) {\n    ImmutableTypes[\"string\"] = \"string\";\n    ImmutableTypes[\"number\"] = \"number\";\n    ImmutableTypes[\"boolean\"] = \"boolean\";\n    ImmutableTypes[\"undefined\"] = \"undefined\";\n})(ImmutableTypes || (ImmutableTypes = {}));\nexport var BasicTypes;\n(function (BasicTypes) {\n    BasicTypes[\"function\"] = \"function\";\n    BasicTypes[\"date\"] = \"date\";\n    BasicTypes[\"unknown\"] = \"unknown\";\n    BasicTypes[\"object\"] = \"object\";\n})(BasicTypes || (BasicTypes = {}));\nconst version = Date.now();\n/** Used as direct memory comparisons, the strings are never compared, just the array */\nexport const ValueTypes = {\n    tag: 'html', // html'' aka StringTag | DomTag\n    dom: 'dom', // compiled version of html''\n    templater: 'templater',\n    tagComponent: 'tagComponent',\n    tagArray: 'tagArray',\n    host: 'host',\n    subscribe: 'subscribe',\n    signal: 'signal',\n    renderOnce: 'renderOnce',\n    stateRender: 'stateRender',\n    version,\n};\n","// taggedjs-no-compile\nimport { ImmutableTypes } from \"../../tag/ValueTypes.enum.js\";\nimport { variablePrefix, variableSuffix } from \"../../tag/DomTag.type.js\";\nimport { placeholderRegex } from \"../../render/attributes/getTagVarIndex.function.js\";\nconst ch = 'ch'; // short for children\nexport function replacePlaceholders(dom, valueCount, valuePositions = [], currentTail = []) {\n    const elements = dom;\n    for (let i = 0; i < elements.length; i++) {\n        const loopTail = [...currentTail, i];\n        const element = elements[i];\n        if (element.at) {\n            const attrs = element.at;\n            element.at = processAttributes(attrs, valueCount);\n        }\n        if (element.ch) {\n            const children = element.ch;\n            const innerLoopTail = [...loopTail, ch];\n            element.ch = replacePlaceholders(children, valueCount, valuePositions, innerLoopTail);\n        }\n        i = examineChild(element, valueCount, elements, i);\n    }\n    return elements;\n}\nfunction examineChild(child, valueCount, children, index) {\n    if (child.nn !== 'text') {\n        return index;\n    }\n    const textChild = child;\n    let textContent = textChild.tc;\n    if (typeof textContent !== ImmutableTypes.string) {\n        return index;\n    }\n    let match;\n    while ((match = placeholderRegex.exec(textContent)) !== null) {\n        const secondMatch = match[1];\n        const wIndex = parseInt(secondMatch, 10);\n        const examine = !isNaN(wIndex) && wIndex < valueCount;\n        if (examine) {\n            const varContent = variablePrefix + wIndex + variableSuffix;\n            const after = textContent.slice(match.index + varContent.length);\n            children.splice(index, 1, {\n                nn: 'text',\n                v: wIndex\n            });\n            textContent = after;\n            placeholderRegex.lastIndex = 0; // Reset regex index due to split\n        }\n    }\n    textChild.tc = textContent;\n    return index;\n}\nfunction processAttributes(attributes, valueCount) {\n    const mapped = [];\n    for (const attrSet of attributes) {\n        const [key, value, isSpecial] = attrSet;\n        if (key.startsWith(variablePrefix)) {\n            const index = parseInt(key.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([{ tagJsVar: index }]);\n                continue;\n            }\n        }\n        if (typeof value === ImmutableTypes.string && value.startsWith(variablePrefix)) {\n            const index = parseInt(value.replace(variablePrefix, ''), 10);\n            if (!isNaN(index) && index < valueCount) {\n                mapped.push([key, { tagJsVar: index }, isSpecial]);\n                continue;\n            }\n        }\n        mapped.push(attrSet);\n    }\n    return mapped;\n}\n","export function getStringsId(strings) {\n    const array = strings.map(lengthMapper);\n    array.push(strings.length);\n    return Number(array.join(''));\n}\nfunction lengthMapper(x) {\n    return x.length;\n}\n","// taggedjs-no-compile\nimport { htmlInterpolationToDomMeta } from '../interpolations/optimizers/htmlInterpolationToDomMeta.function.js';\nimport { replacePlaceholders } from '../interpolations/optimizers/replacePlaceholders.function.js';\nimport { isLastRunMatched } from './isLastRunMatched.function.js';\nimport { getStringsId } from './getStringsId.function.js';\nconst lastRuns = {};\n/** Converts strings & values into dom meta */\nexport function getDomMeta(strings, values) {\n    const stringId = getStringsId(strings);\n    const lastRun = lastRuns[stringId];\n    const matches = lastRun && isLastRunMatched(strings, values, lastRun);\n    if (matches) {\n        return lastRun.domMetaMap;\n    }\n    const domMeta = htmlInterpolationToDomMeta(strings, values);\n    const map = replacePlaceholders(domMeta, values.length);\n    const template = {\n        interpolation: undefined,\n        string: undefined,\n        strings,\n        values,\n        domMetaMap: map,\n    };\n    lastRuns[stringId] = template;\n    return map;\n}\n","export function isLastRunMatched(strings, values, lastRun) {\n    if (lastRun) {\n        if (lastRun.strings.length === strings.length) {\n            const stringsMatch = lastRun.strings.every((string, index) => \n            // string.length === strings[index].length\n            string === strings[index]);\n            if (stringsMatch && lastRun.values.length === values.length) {\n                return true; // performance savings using the last time this component was rendered\n            }\n        }\n    }\n    return false;\n}\n","import { paintContent } from \"../../render/paint.function.js\";\n// Maybe more performant for updates but seemingly slower for first renders\nexport function howToSetInputValue(element, name, value) {\n    paintContent.push([howToSetFirstInputValue, [element, name, value]]);\n}\nexport function howToSetFirstInputValue(element, name, value) {\n    if (value === undefined || value === false || value === null) {\n        element.removeAttribute(name);\n        return;\n    }\n    element.setAttribute(name, value);\n}\n","import { paintAfters, paintContent } from \"../../render/paint.function.js\";\n/** handles init, destroy, autofocus, autoselect, style., class. */\nexport function specialAttribute(name, value, element, specialName, support, counts) {\n    switch (specialName) {\n        case 'init': { // aka oninit\n            const stagger = counts.added++;\n            // run delayed after elements placed down\n            paintAfters.push([paintSpecialAttribute, [element, stagger, value]]);\n            return;\n        }\n        case 'destroy': { // aka ondestroy\n            const stagger = counts.removed++;\n            const global = support.context.global;\n            global.destroys = global.destroys || [];\n            global.destroys.push(() => {\n                const event = {\n                    target: element,\n                    stagger,\n                };\n                return value(event); // call destroy/ondestroy\n            });\n            return;\n        }\n        case 'autofocus':\n            paintAfters.push([autofocus, [element]]);\n            return;\n        case 'autoselect':\n            paintAfters.push([autoselect, [element]]);\n            return;\n        case 'style': {\n            const names = name.split('.');\n            paintContent.push([paintStyle, [element, names, value]]); // attribute changes should come first\n            return;\n        }\n        case 'class':\n            processSpecialClass(name, value, element);\n            return;\n    }\n    throw new Error(`Invalid special attribute of ${specialName}. ${name}`);\n}\nfunction paintStyle(element, names, value) {\n    const smallName = names[1];\n    element.style[smallName] = value;\n    element.style.setProperty(smallName, value);\n}\nfunction processSpecialClass(name, value, element) {\n    const names = name.split('.');\n    names.shift(); // remove class\n    // truthy\n    if (value) {\n        for (const name of names) {\n            paintContent.push([classListAdd, [element, name]]);\n        }\n        return;\n    }\n    // falsy\n    for (const name of names) {\n        paintContent.push([classListRemove, [element, name]]);\n    }\n}\nfunction classListAdd(element, name) {\n    element.classList.add(name);\n}\nfunction classListRemove(element, name) {\n    element.classList.remove(name);\n}\nfunction autoselect(element) {\n    element.select();\n}\nfunction autofocus(element) {\n    element.focus();\n}\nfunction paintSpecialAttribute(element, stagger, value) {\n    const event = {\n        target: element,\n        stagger,\n    };\n    value(event); // call init/oninit\n}\n","import { BasicTypes, ImmutableTypes, ValueTypes } from './tag/ValueTypes.enum.js';\nexport function isSimpleType(value) {\n    switch (value) {\n        case ImmutableTypes.string:\n        case ImmutableTypes.number:\n        case ImmutableTypes.boolean:\n            return true;\n    }\n    return false;\n}\n/** Indicates if tag() was used */\nexport function isStaticTag(value) {\n    if (!value) {\n        return false;\n    }\n    const tagJsType = value.tagJsType;\n    switch (tagJsType) {\n        case ValueTypes.dom:\n        case ValueTypes.tag:\n        case ValueTypes.templater:\n            return true;\n    }\n    return false;\n}\n/** passed in is expected to be a TemplaterResult */\nexport function isTagComponent(value) {\n    const tagType = value?.tagJsType;\n    return tagType === ValueTypes.tagComponent || tagType === ValueTypes.stateRender;\n}\n// isSubjectLike\nexport function isSubjectInstance(subject) {\n    return isObject(subject) && typeof subject.subscribe === BasicTypes.function;\n}\nexport function isPromise(value) {\n    return value && isFunction(value.then);\n}\nexport function isFunction(value) {\n    return typeof value === BasicTypes.function;\n}\nexport function isObject(value) {\n    return typeof (value) === BasicTypes.object && value !== null;\n}\nexport function isArray(value) {\n    return Array.isArray(value);\n}\n","export function handleProviderChanges(appSupport, provider) {\n    const tagsWithProvider = getTagsWithProvider(appSupport, provider);\n    return tagsWithProvider;\n}\n/** Updates and returns memory of tag providers */\nfunction getTagsWithProvider(support, provider, memory = []) {\n    const subject = support.context;\n    memory.push({\n        support,\n        renderCount: subject.renderCount,\n        provider,\n    });\n    const childTags = provider.children;\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const child = childTags[index];\n        const cSubject = child.context;\n        memory.push({\n            support: child,\n            renderCount: cSubject.renderCount,\n            provider,\n        });\n    }\n    return memory;\n}\n","import { handleProviderChanges } from './handleProviderChanges.function.js';\nexport function providersChangeCheck(support) {\n    const global = support.context.global;\n    const providers = global.providers;\n    if (!providers) {\n        return [];\n    }\n    const prosWithChanges = [];\n    // reset clones\n    for (const provider of providers) {\n        const owner = provider.owner;\n        const hasChange = handleProviderChanges(owner, provider);\n        prosWithChanges.push(...hasChange.map(mapToSupport));\n    }\n    return prosWithChanges;\n}\nfunction mapToSupport(x) {\n    return x.support;\n}\n","import { isArray, isFunction } from './isInstance.js';\nimport { BasicTypes } from './tag/ValueTypes.enum.js';\nexport function deepClone(obj, maxDepth) {\n    // return makeDeepClone(obj, new WeakMap())\n    return makeDeepClone(obj, maxDepth);\n}\nfunction makeDeepClone(obj, \n// visited: WeakMap<any, any>\nmaxDepth) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== BasicTypes.object) {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    /*\n    if (visited.has(obj)) {\n      return visited.get(obj)\n    }\n    */\n    if (maxDepth < 0) {\n        return obj;\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Clone each property or element of the object or array\n    if (isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], maxDepth - 1);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clone[key] = makeDeepClone(obj[key], maxDepth - 1);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2, maxDepth) {\n    return isDeepEqual(obj1, obj2, maxDepth);\n}\nfunction isDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    // if (visited.has(obj1)) {\n    if (maxDepth < 0) {\n        return true;\n    }\n    if (typeof obj1 === BasicTypes.object && typeof obj2 === BasicTypes.object) {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return obj1.getTime() === obj2.getTime();\n        }\n        // Register the cloned object to avoid cyclic references\n        // visited.set(obj1, 0)\n        // Check if obj1 and obj2 are both arrays\n        if (isArray(obj1) && isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, maxDepth - 1);\n        }\n        else if (isArray(obj1) || isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        // return isObjectDeepEqual(obj1, obj2, visited)\n        return isObjectDeepEqual(obj1, obj2, maxDepth - 1);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, \n// visited: WeakMap<any, any>,\nmaxDepth) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, maxDepth) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], maxDepth - 1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = isFunction(fn0) && isFunction(fn1);\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","import { setUseMemory } from '../state/index.js';\nexport function getSupportInCycle() {\n    return setUseMemory.stateConfig.support;\n}\nexport function setSupportInCycle(support) {\n    return setUseMemory.stateConfig.support = support;\n}\n","import { isTagComponent } from '../../isInstance.js';\nexport function getSupportWithState(support) {\n    // get actual component owner not just the html`` support\n    let component = support;\n    while (component.ownerSupport && !isTagComponent(component.templater)) {\n        component = component.ownerSupport;\n    }\n    return component.context.global.newest || component;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nfunction returnArgs(...args) {\n    return args;\n}\nexport function firstStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(returnArgs);\n}\n/** aka statesHandler */\nexport function reStatesHandler(setter) {\n    const config = setUseMemory.stateConfig;\n    const statesIndex = config.statesIndex;\n    const prevSupport = getSupportWithState(config.prevSupport);\n    const prevStates = prevSupport.states;\n    // const prevStates = config.states\n    const oldStates = prevStates[statesIndex];\n    let lastValues = [];\n    oldStates(function regetter(...args) {\n        lastValues = args;\n        return args;\n    });\n    const resetter = function stateResetter(..._args) {\n        return lastValues;\n    };\n    config.states[config.statesIndex] = setter;\n    ++config.statesIndex;\n    return setter(resetter);\n}\n","import { runFirstState, runRestate } from './stateHandlers.js';\nimport { firstStatesHandler, reStatesHandler } from './states.utils.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function initState(support) {\n    const config = setUseMemory.stateConfig;\n    config.handlers.handler = runFirstState;\n    config.handlers.statesHandler = firstStatesHandler;\n    config.rearray = [];\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    setSupportInCycle(support);\n}\nexport function reState(newSupport, prevSupport, prevState) {\n    const config = setUseMemory.stateConfig;\n    // set previous state memory\n    config.rearray = prevState;\n    config.stateArray = [];\n    config.states = [];\n    config.statesIndex = 0;\n    config.handlers.handler = runRestate;\n    config.handlers.statesHandler = reStatesHandler;\n    config.prevSupport = prevSupport;\n    setSupportInCycle(newSupport);\n}\nexport class StateEchoBack {\n}\n/** sends a fake value and then sets back to received value */\nexport function getCallbackValue(callback) {\n    const [value] = callback(StateEchoBack); // get value and set to undefined\n    const [checkValue] = callback(value); // set back to original value\n    return [value, checkValue];\n}\n","import { getCallbackValue } from './state.utils.js';\nexport function getStateValue(state) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const [value] = getCallbackValue(callback);\n    return value;\n}\n","import { setUseMemory } from './setUseMemory.object.js';\nimport { getStateValue } from './getStateValue.function.js';\nimport { BasicTypes } from '../tag/ValueTypes.enum.js';\nexport function runRestate() {\n    const config = setUseMemory.stateConfig;\n    const rearray = config.rearray;\n    const restate = rearray[config.stateArray.length];\n    config.stateArray.push(restate);\n    return restate.defaultValue;\n}\nexport function runFirstState(defaultValue) {\n    const config = setUseMemory.stateConfig;\n    // State first time run\n    let initValue = defaultValue;\n    if (typeof (defaultValue) === BasicTypes.function) {\n        initValue = defaultValue();\n    }\n    // the state is actually intended to be a function\n    if (typeof (initValue) === BasicTypes.function) {\n        const original = initValue;\n        initValue = function initValueFun(...args) {\n            const result = original(...args);\n            return result;\n        };\n        initValue.original = original;\n    }\n    const push = {\n        get: function pushState() {\n            return getStateValue(push);\n        },\n        defaultValue: initValue,\n    };\n    config.stateArray.push(push);\n    return initValue;\n}\n","import { Subject } from './Subject.class.js';\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            const countMatched = valuesSeen.length === subjects.length;\n            if (!countMatched) {\n                return;\n            }\n            for (const item of valuesSeen) {\n                if (!item) {\n                    return;\n                }\n            }\n            // everyone has reported values\n            callback(values, subscription);\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => {\n            return subject.subscribe(x => setValue(x, index + 1));\n        });\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","import { Subject } from './Subject.class.js';\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nexport function getSubscription(subject, callback, subscribers) {\n    const countSubject = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(countSubject.value + 1);\n    const subscription = function () {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = function () {\n        return unsubscribe(subscription, subscribers, callback);\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nexport function runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\nfunction unsubscribe(subscription, subscribers, callback) {\n    removeSubFromArray(subscribers, callback); // each will be called when update comes in\n    const valSub = Subject.globalSubCount$;\n    Subject.globalSubCount$.next(valSub.value - 1);\n    // any double unsubscribes will be ignored\n    subscription.unsubscribe = () => subscription;\n    // unsubscribe from any combined subjects\n    const subscriptions = subscription.subscriptions;\n    for (const sub of subscriptions) {\n        sub.unsubscribe();\n    }\n    return subscription;\n}\n","import { isSubjectInstance } from '../isInstance.js';\nimport { combineLatest } from './combineLatest.function.js';\nimport { getSubscription, runPipedMethods } from './subject.utils.js';\nexport class Subject {\n    value;\n    onSubscription;\n    // private?\n    methods = [];\n    isSubject = true;\n    // private?\n    subscribers = [];\n    subscribeWith;\n    constructor(value, \n    // private? - only used by extending classes\n    onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n        // defineValueOn(this)\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback, this.subscribers);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    next(value) {\n        this.value = value;\n        this.emit();\n    }\n    set = this.next.bind(this);\n    emit() {\n        const value = this.value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n    toPromise() {\n        return new Promise(res => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    /** like toPromise but faster. Only get called once. No subscription to manage */\n    toCallback(callback) {\n        const subscription = this.subscribe((x, runtimeSub) => {\n            const tagJsUnsub = runtimeSub?.unsubscribe;\n            if (tagJsUnsub) {\n                tagJsUnsub(); // its from taggedjs\n            }\n            else {\n                setTimeout(() => subscription.unsubscribe(), 0);\n            }\n            callback(x);\n        });\n        return this;\n    }\n    pipe(...operations) {\n        const subject = new Subject(this.value);\n        subject.setMethods(operations);\n        subject.subscribeWith = (x) => this.subscribe(x);\n        subject.next = x => this.next(x);\n        return subject;\n    }\n    setMethods(operations) {\n        this.methods = operations;\n    }\n    static all(args) {\n        const switched = args.map(arg => {\n            if (isSubjectInstance(arg))\n                return arg;\n            // Call the callback immediately with the current value\n            const x = new Subject(arg, subscription => {\n                subscription.next(arg);\n                return subscription;\n            });\n            return x;\n        });\n        return combineLatest(switched);\n    }\n    static globalSubCount$ = new Subject(0); // for ease of debugging}\n}\nexport class Subjective extends Subject {\n    value;\n    onSubscription;\n    _value;\n    constructor(value, \n    // private?\n    onSubscription) {\n        super(value, onSubscription);\n        this.value = value;\n        this.onSubscription = onSubscription;\n        this._value = value;\n        defineValueOn(this);\n    }\n    next(value) {\n        this._value = value;\n        this.emit();\n    }\n    emit() {\n        const value = this._value;\n        // Notify all subscribers with the new value\n        // const subs = [...this.subscribers] // subs may change as we call callbacks\n        const subs = this.subscribers; // subs may change as we call callbacks\n        // const length = subs.length\n        for (const sub of subs) {\n            sub.callback(value, sub);\n        }\n    }\n}\nexport function defineValueOn(subject) {\n    Object.defineProperty(subject, 'value', {\n        // supports subject.value = x\n        set(value) {\n            subject._value = value;\n            subject.emit();\n        },\n        // supports subject.value\n        get() {\n            return subject._value;\n        }\n    });\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering  */\nexport const tagClosed$ = new Subject(undefined, function tagCloser(subscription) {\n    if (!getSupportInCycle()) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n","import { firstStatesHandler } from './states.utils.js';\nimport { runFirstState } from './stateHandlers.js';\nimport { tagClosed$ } from './tagClosed$.subject.js';\nexport const setUseMemory = {\n    stateConfig: {\n        stateArray: [], // state memory on the first render\n        version: Date.now(),\n        handlers: {\n            handler: runFirstState,\n            statesHandler: firstStatesHandler,\n        }\n    },\n    tagClosed$,\n};\n","/**\n * Sync two supports\n * @param support FROM\n * @param newestSupport  ONTO\n * @returns\n */\nexport function syncSupports(support, // from\nnewestSupport) {\n    return syncStatesArray(support.states, newestSupport.states);\n}\nexport function syncStatesArray(from, onto) {\n    for (let index = 0; index < from.length; ++index) {\n        const getter = from[index];\n        const setter = onto[index];\n        syncStates(getter, setter);\n    }\n}\nlet got;\nfunction syncFromState(...x) {\n    got = x;\n    return x;\n}\nfunction syncOntoState() {\n    return got;\n}\nexport function syncStates(from, onto) {\n    from(syncFromState, 1);\n    onto(syncOntoState, 2);\n}\n/** @deprecated favor using syncSupports */\nexport function oldSyncStates(stateFrom, stateTo, intoStates, statesFrom) {\n    for (let index = stateFrom.length - 1; index >= 0; --index) {\n        const stateFromTarget = stateFrom[index];\n        const fromValue = stateFromTarget.get(); // get without setting\n        // const fromValue = getStateValue(stateFromTarget) // get without setting\n        const stateToTarget = stateTo[index];\n        const callback = stateToTarget.callback; // is it a let state?\n        if (!callback) {\n            continue;\n        }\n        callback(fromValue); // set the value\n    }\n    // loop statesFrom to set on the oldStates\n    for (let index = statesFrom.length - 1; index >= 0; --index) {\n        oldValues.length = 0;\n        getIndex = 0;\n        const stateFromTarget = statesFrom[index];\n        // trigger getting all old values\n        stateFromTarget(oldGetCallback);\n        // trigger setting updated values\n        intoStates[index](newSetCallback);\n    }\n}\nlet getIndex = 0;\nconst oldValues = [];\nfunction oldGetCallback(...args) {\n    oldValues.push(args);\n    return args;\n}\n// This is the \"get\" argument that will be called and all arguments are ignored\nfunction newSetCallback(..._) {\n    return oldValues[getIndex++];\n}\n","export function processUpdateContext(support, contexts) {\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    let index = 0;\n    const len = values.length;\n    const counts = { added: 0, removed: 0 };\n    while (index < len) {\n        processUpdateOneContext(values, index, contexts, support, counts);\n        ++index;\n    }\n    return contexts;\n}\n/** returns boolean of did render */\nfunction processUpdateOneContext(values, // the interpolated values\nindex, context, ownerSupport, counts) {\n    const newValue = values[index];\n    const contextItem = context[index];\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate(newValue, ownerSupport, contextItem, counts, values);\n    contextItem.value = newValue;\n    // contextItem.tagJsVar = valueToTagJsVar(newValue)\n}\n","import { paint, painting } from '../paint.function.js';\nimport { processUpdateContext } from '../../tag/processUpdateContext.function.js';\nexport function updateSupportBy(olderSupport, newerSupport) {\n    const global = olderSupport.context.global;\n    const context = global.contexts;\n    updateSupportValuesBy(olderSupport, newerSupport);\n    ++painting.locks;\n    processUpdateContext(olderSupport, context);\n    --painting.locks;\n    paint();\n}\nexport function updateSupportValuesBy(olderSupport, newerSupport) {\n    const newTemplate = newerSupport.templater;\n    const tempTag = newerSupport.templater.tag;\n    const values = newTemplate.values || tempTag.values;\n    const tag = olderSupport.templater.tag;\n    tag.values = values;\n}\n","import { deepClone } from '../deepFunctions.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { isArray } from '../isInstance.js';\nexport function cloneValueArray(values) {\n    return values.map(cloneTagJsValue);\n}\n/** clones only what is needed to compare differences later */\nexport function cloneTagJsValue(value, maxDepth) {\n    const tag = value;\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        switch (tagJsType) {\n            case ValueTypes.signal:\n            case ValueTypes.subscribe:\n            case ValueTypes.stateRender:\n                return undefined;\n            case ValueTypes.dom:\n            case ValueTypes.tag:\n            case ValueTypes.templater:\n                return cloneValueArray(tag.values);\n        }\n    }\n    if (isArray(value)) {\n        return cloneValueArray(tag);\n    }\n    return deepClone(value, maxDepth);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { cloneTagJsValue } from '../cloneValueArray.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from '../hasSupportChanged.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function clonePropsBy(support, props, castProps) {\n    const templater = support.templater;\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return support.propsConfig = {\n                latest: props,\n                castProps,\n            };\n        case PropWatches.SHALLOW:\n            return support.propsConfig = {\n                latest: props.map(shallowMapper),\n                castProps,\n            };\n    }\n    return support.propsConfig = {\n        latest: props.map(deepMapper),\n        castProps,\n    };\n}\nfunction shallowMapper(x) {\n    return cloneTagJsValue(x, shallowCompareDepth);\n}\nfunction deepMapper(props) {\n    return cloneTagJsValue(props, deepCompareDepth);\n}\n","import { clonePropsBy } from './props/clonePropsBy.function.js';\nimport { Subject } from '../subject/Subject.class.js';\n/** used only for apps, otherwise use Support */\nexport function getBaseSupport(templater, context, castedProps) {\n    const baseSupport = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    // baseSupport.appSupport = baseSupport\n    const global = context.global;\n    global.blocked = [];\n    global.destroy$ = new Subject();\n    return baseSupport;\n}\n/** Sets support states to empty array and clones props */\nexport function upgradeBaseToSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nsupport, appSupport, castedProps) {\n    // ;(support as AnySupport).state = []\n    // ;(support as AnySupport).states = []\n    support.appSupport = appSupport;\n    const props = templater.props; // natural props\n    if (props) {\n        support.propsConfig = clonePropsBy(support, props, castedProps);\n    }\n    return support;\n}\nexport function createHtmlSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, context, castedProps) {\n    const support = {\n        templater,\n        context,\n        castedProps,\n        appSupport: undefined,\n    };\n    support.ownerSupport = ownerSupport;\n    support.appSupport = appSupport;\n    return support;\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function createSupport(templater, // at runtime rendering of a tag, it needs to be married to a new Support()\nownerSupport, appSupport, subject, castedProps) {\n    const support = getBaseSupport(templater, subject, castedProps);\n    support.ownerSupport = ownerSupport;\n    return upgradeBaseToSupport(templater, support, appSupport, castedProps);\n}\n","import { BasicTypes } from '../ValueTypes.enum.js';\nimport { isTagComponent } from '../../isInstance.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { handleStillTag } from './handleStillTag.function.js';\nimport { updateExistingTagComponent } from '../../render/update/updateExistingTagComponent.function.js';\nimport { createSupport } from '../createSupport.function.js';\n/** result is an indication to ignore further processing but that does not seem in use anymore */\nexport function tryUpdateToTag(contextItem, newValue, // newValue\nownerSupport, counts) {\n    const isComp = isTagComponent(newValue);\n    contextItem.tagJsVar = newValue;\n    if (isComp) {\n        if (contextItem.global === undefined) {\n            getNewGlobal(contextItem);\n        }\n        prepareUpdateToComponent(newValue, contextItem, ownerSupport, counts);\n        return true;\n    }\n    // detect if previous value was a tag\n    const global = contextItem.global;\n    if (global) {\n        // its html/dom based tag\n        const support = global.newest;\n        if (support) {\n            if (typeof (newValue) === BasicTypes.function) {\n                return true;\n            }\n            handleStillTag(support, contextItem, newValue, ownerSupport);\n            return true;\n        }\n    }\n    ;\n    newValue.processInit(newValue, contextItem, ownerSupport, counts, undefined, // appendTo,\n    contextItem.placeholder);\n    return true;\n}\nfunction prepareUpdateToComponent(templater, contextItem, ownerSupport, counts) {\n    const global = contextItem.global;\n    // When last value was not a component\n    if (!global.newest) {\n        ;\n        templater.processInit(templater, contextItem, ownerSupport, counts, undefined, // appendTo,\n        contextItem.placeholder);\n        return;\n    }\n    const support = createSupport(templater, ownerSupport, ownerSupport.appSupport, contextItem);\n    updateExistingTagComponent(ownerSupport, support, // latest value\n    contextItem);\n}\n","import { deepCompareDepth, hasSupportChanged, shallowCompareDepth } from '../../tag/hasSupportChanged.function.js';\nimport { castProps } from '../../tag/props/alterProp.function.js';\nimport { renderSupport } from '../renderSupport.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { destroySupport } from '../destroySupport.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { isLikeTags } from '../../tag/isLikeTags.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nimport { syncPriorPropFunction } from '../../tag/update/syncPriorPropFunction.function.js';\nexport function updateExistingTagComponent(ownerSupport, newSupport, // lastest\nsubject) {\n    const global = subject.global;\n    const oldSupport = global.newest;\n    const oldWrapper = oldSupport.templater.wrapper;\n    let newWrapper = newSupport.templater.wrapper;\n    let isSameTag = false;\n    const tagJsType = newSupport.templater.tagJsType;\n    const skipComparing = ValueTypes.stateRender === tagJsType || ValueTypes.renderOnce === tagJsType;\n    if (skipComparing) {\n        isSameTag = newSupport.templater.tagJsType === ValueTypes.renderOnce || isLikeTags(oldSupport, newSupport);\n    }\n    else if (oldWrapper && newWrapper) {\n        // is this perhaps an outerHTML compare?\n        const innerHTML = oldSupport.templater.tag?._innerHTML;\n        if (innerHTML) {\n            // newWrapper = innerHTML.outerHTML as any as Wrapper\n            newWrapper = newSupport.outerHTML;\n        }\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        // string compare both functions\n        isSameTag = oldFunction === newFunction;\n    }\n    const templater = newSupport.templater;\n    if (!isSameTag) {\n        swapTags(subject, templater, ownerSupport);\n        return;\n    }\n    const hasChanged = skipComparing || hasSupportChanged(oldSupport, templater);\n    // everyhing has matched, no display needs updating.\n    if (!hasChanged) {\n        const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n        syncSupports(templater, newSupport, oldSupport, ownerSupport, maxDepth);\n        return;\n    }\n    if (subject.locked) {\n        global.blocked.push(newSupport);\n        return;\n    }\n    renderSupport(newSupport);\n    ++subject.renderCount;\n    return;\n}\nexport function syncFunctionProps(newSupport, oldSupport, ownerSupport, newPropsArray, // templater.props\nmaxDepth, depth = -1) {\n    const subject = oldSupport.context;\n    const global = subject.global;\n    const newest = global.newest;\n    if (!newest) {\n        const castedProps = castProps(newPropsArray, newSupport, depth);\n        newPropsArray.push(...castedProps);\n        const propsConfig = newSupport.propsConfig;\n        propsConfig.castProps = castedProps;\n        return newPropsArray;\n    }\n    oldSupport = newest || oldSupport;\n    const priorPropConfig = oldSupport.propsConfig;\n    const priorPropsArray = priorPropConfig.castProps;\n    const newArray = [];\n    for (let index = 0; index < newPropsArray.length; ++index) {\n        const prop = newPropsArray[index];\n        const priorProp = priorPropsArray[index];\n        const newValue = syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth + 1);\n        newArray.push(newValue);\n    }\n    const newPropsConfig = newSupport.propsConfig;\n    newPropsConfig.castProps = newArray;\n    return newArray;\n}\nexport function moveProviders(oldSupport, newSupport) {\n    const global = oldSupport.context.global;\n    let pIndex = -1;\n    const providers = global.providers = global.providers || [];\n    const pLen = providers.length - 1;\n    while (pIndex++ < pLen) {\n        const provider = providers[pIndex];\n        let index = -1;\n        const pcLen = provider.children.length - 1;\n        while (index++ < pcLen) {\n            const child = provider.children[index];\n            const wasSameGlobals = global === child.context.global;\n            if (wasSameGlobals) {\n                provider.children.splice(index, 1);\n                provider.children.push(newSupport);\n                return;\n            }\n        }\n    }\n}\n/** Exchanges entire propsConfigs */\nfunction syncSupports(templater, support, oldSupport, ownerSupport, maxDepth) {\n    // update function refs to use latest references\n    const newProps = templater.props;\n    const castedProps = syncFunctionProps(support, oldSupport, ownerSupport, newProps, maxDepth);\n    const propsConfig = support.propsConfig;\n    // When new support actually makes call to real function, use these pre casted props\n    propsConfig.castProps = castedProps;\n    const lastPropsConfig = oldSupport.propsConfig;\n    // update support to think it has different cloned props\n    lastPropsConfig.latest = propsConfig.latest;\n    return oldSupport; // its the same tag component  \n}\n/** Was tag, will be tag */\nfunction swapTags(contextItem, templater, // new tag\nownerSupport) {\n    const global = contextItem.global;\n    const oldestSupport = global.oldest;\n    destroySupport(oldestSupport, global);\n    getNewGlobal(contextItem);\n    templater.processInit(templater, contextItem, ownerSupport, { added: 0, removed: 0 }, undefined, // appendTo,\n    contextItem.placeholder);\n}\n","import { isArray } from '../isInstance.js';\nimport { hasPropChanges } from './hasPropChanges.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/** Used when deciding if a support will even change (are the arguments the same?) */\nexport function hasSupportChanged(oldSupport, newTemplater) {\n    const latestProps = newTemplater.props;\n    const propsConfig = oldSupport.propsConfig;\n    const pastCloneProps = propsConfig.latest;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps, oldSupport.templater.propWatch);\n    return propsChanged;\n}\nexport function immutablePropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (prop !== pastProp) {\n            return 2;\n        }\n    }\n    return false; // false means has not changed\n}\nexport function shallowPropMatch(props, pastCloneProps) {\n    // if every prop the same, then no changes\n    const len = props.length;\n    for (let index = 0; index < len; ++index) {\n        const prop = props[index];\n        const pastProp = pastCloneProps[index];\n        if (isArray(prop) && isArray(pastProp)) {\n            if (prop === pastProp) {\n                continue;\n            }\n            return 3.0; // not equal array\n        }\n        if (typeof (prop) === BasicTypes.function && typeof (pastProp) === BasicTypes.function) {\n            continue; // considered good\n        }\n        if (typeof (prop) === BasicTypes.object) {\n            if (typeof (pastCloneProps) === BasicTypes.object) {\n                const obEntries = Object.entries(prop);\n                for (const subItem of obEntries) {\n                    const result = objectItemMatches(subItem, pastProp);\n                    if (!result) {\n                        return 3.1;\n                    }\n                }\n            }\n            continue; // all sub objects matched\n        }\n        if (prop === pastProp) {\n            continue; // matched good\n        }\n        return 3.3; // not equal\n    }\n    return false; // false means has not changed\n}\nexport const shallowCompareDepth = 3;\nexport const deepCompareDepth = 10;\nfunction objectItemMatches([name, value], pastProp) {\n    const pastValue = pastProp[name];\n    if (typeof (value) === BasicTypes.function && typeof (pastValue) === BasicTypes.function) {\n        return true;\n    }\n    return pastValue === value;\n}\n","import { updateSupportBy } from '../../render/update/updateSupportBy.function.js';\nimport { createSupport } from '../createSupport.function.js';\nexport function handleStillTag(oldSupport, subject, value, ownerSupport) {\n    // Value is result of either tag(() => html``) or () => html``\n    let templater = value.templater || value;\n    const oldTtag = oldSupport.templater.tag;\n    if (oldTtag) {\n        const innerHTML = oldTtag._innerHTML;\n        if (innerHTML) {\n            // Value has innerHTML that is either tag() or html``\n            templater = value.outerHTML || value._innerHTML.outerHTML;\n        }\n    }\n    const valueSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const lastSubject = oldSupport.context;\n    const newGlobal = lastSubject.global;\n    const oldest = newGlobal.oldest;\n    updateSupportBy(oldest, valueSupport);\n}\n","import { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\n/** Checks if value has changed before updating. Used for all tag value updates. Determines if value changed since last render */\nexport function tagValueUpdateHandler(newValue, // newValue\nownerSupport, contextItem, counts) {\n    // Do not continue if the value is just the same\n    if (newValue === contextItem.value) {\n        return;\n    }\n    forceUpdateExistingValue(contextItem, newValue, ownerSupport, counts);\n}\n","// Life cycle 4 - end of life\nexport function runBeforeDestroy(support, global) {\n    const providers = global.providers;\n    if (providers) {\n        for (const provider of providers) {\n            for (let index = provider.children.length - 1; index >= 0; --index) {\n                const child = provider.children[index];\n                if (child.context.global === global) {\n                    provider.children.splice(index, 1);\n                }\n            }\n        }\n    }\n    if (global.destroy$) {\n        global.destroy$.next();\n    }\n    support.context.renderCount = 0; // if it comes back, wont be considered an update\n}\n","import { isTagComponent } from '../isInstance.js';\nimport { runBeforeDestroy } from './tagRunner.js';\nimport { ValueTypes } from './ValueTypes.enum.js';\nexport function destroyContext(childTags, ownerSupport) {\n    for (const child of childTags) {\n        // deleting arrays\n        const lastArray = child.lastArray;\n        if (lastArray) {\n            // recurse\n            destroyContext(lastArray, ownerSupport);\n            continue;\n        }\n        const childValue = child.value;\n        if (childValue?.tagJsType === ValueTypes.subscribe) {\n            childValue.delete(child, ownerSupport);\n            continue;\n        }\n        const global = child.global;\n        if (!global) {\n            continue; // not a support contextItem\n        }\n        const support = global.newest;\n        const iSubs = global.subscriptions;\n        if (iSubs) {\n            iSubs.forEach(unsubscribeFrom);\n        }\n        if (isTagComponent(support.templater)) {\n            runBeforeDestroy(support, global);\n        }\n        const subTags = global.contexts;\n        // recurse\n        destroyContext(subTags, support);\n    }\n}\nexport function getChildTagsToSoftDestroy(childTags, tags = [], subs = []) {\n    for (const child of childTags) {\n        const global = child.global;\n        if (!global) {\n            continue;\n        }\n        const support = global.newest;\n        if (support) {\n            tags.push(support);\n            const iSubs = global.subscriptions;\n            if (iSubs) {\n                subs.push(...iSubs);\n            }\n        }\n        const subTags = global.contexts;\n        if (subTags) {\n            getChildTagsToSoftDestroy(subTags, tags, subs);\n        }\n    }\n    return { tags, subs };\n}\nexport function unsubscribeFrom(from) {\n    from.unsubscribe();\n}\n","import { destroyArrayItem } from './update/compareArrayItems.function.js';\nimport { isArray } from '../isInstance.js';\nexport function checkArrayValueChange(newValue, subject) {\n    // no longer an array?\n    if (!isArray(newValue)) {\n        destroyArrayContextItem(subject);\n        return 9; // 'array'\n    }\n    return false;\n}\nexport function destroyArrayContextItem(subject) {\n    const lastArray = subject.lastArray;\n    destroyArray(subject, lastArray);\n}\nexport function destroyArray(subject, lastArray) {\n    for (let index = 0; index < lastArray.length; ++index) {\n        destroyArrayItem(lastArray[index]);\n    }\n    delete subject.lastArray;\n}\n","import { destroyArray } from './checkDestroyPrevious.function.js';\nimport { paint, painting, addPaintRemover } from '../render/paint.function.js';\n/** sets global.deleted on support and all children */\nexport function smartRemoveKids(global, allPromises) {\n    const context = global.contexts;\n    const destroys = global.destroys;\n    if (destroys) {\n        return processContextDestroys(destroys, global, allPromises);\n    }\n    smartRemoveByContext(context, allPromises);\n    destroyClones(global);\n}\nconst promises = [];\nfunction destroyCall(destroy) {\n    const maybePromise = destroy();\n    const isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        promises.push(maybePromise);\n    }\n}\n// Elements that have a destroy or ondestroy attribute\nfunction processContextDestroys(destroys, global, allPromises) {\n    promises.length = 0;\n    destroys.forEach(destroyCall);\n    if (promises.length) {\n        const lastPromise = Promise.all(promises)\n            .then(() => {\n            ++painting.locks;\n            // continue to remove\n            smartRemoveByContext(global.contexts, allPromises);\n            destroyClones(global);\n            --painting.locks;\n            paint();\n        });\n        // run destroy animations\n        allPromises.push(lastPromise);\n        return;\n    }\n    ++painting.locks;\n    smartRemoveByContext(global.contexts, allPromises);\n    destroyClones(global);\n    --painting.locks;\n    paint();\n}\nfunction smartRemoveByContext(context, allPromises) {\n    for (const subject of context) {\n        if (subject.locked) {\n            continue;\n        }\n        if (subject.withinOwnerElement) {\n            const tagJsVar = subject.tagJsVar;\n            if (tagJsVar && tagJsVar.tagJsType === 'host') {\n                const newest = subject.supportOwner;\n                tagJsVar.delete(subject, newest);\n            }\n            continue; // i live within my owner variable. I will be deleted with owner\n        }\n        const lastArray = subject.lastArray;\n        if (lastArray) {\n            destroyArray(subject, lastArray);\n            continue;\n        }\n        // regular values, no placeholders\n        const elm = subject.simpleValueElm;\n        if (elm) {\n            delete subject.simpleValueElm;\n            addPaintRemover(elm);\n            continue;\n        }\n        const subGlobal = subject.global;\n        if (subGlobal === undefined) {\n            continue; // subject\n        }\n        if (subGlobal.deleted === true) {\n            continue; // already deleted\n        }\n        subGlobal.deleted = true;\n        const oldest = subGlobal.oldest;\n        if (oldest) {\n            smartRemoveKids(subGlobal, allPromises);\n            continue;\n        }\n    }\n}\n/** Destroy dom elements and dom space markers */\nfunction destroyClones(global) {\n    const htmlDomMeta = global.htmlDomMeta;\n    // check subjects that may have clones attached to them\n    for (let index = htmlDomMeta.length - 1; index >= 0; --index) {\n        const clone = htmlDomMeta[index];\n        destroyClone(clone);\n        htmlDomMeta.splice(index, 1);\n    }\n}\nfunction destroyClone(clone) {\n    const marker = clone.marker;\n    if (marker) {\n        addPaintRemover(marker);\n    }\n    const dom = clone.domElement;\n    if (!dom) {\n        return;\n    }\n    addPaintRemover(dom);\n}\n","import { destroyContext } from '../tag/destroyContext.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\nimport { runBeforeDestroy } from '../tag/tagRunner.js';\nexport function destroySupport(support, global) {\n    const subject = support.context;\n    global.deleted = true;\n    subject.renderCount = 0; // if it comes back, wont be considered an update\n    const promises = [];\n    const context = global.contexts;\n    destroyContext(context, support);\n    if (global.destroy$) {\n        runBeforeDestroy(support, global);\n    }\n    smartRemoveKids(global, promises);\n    return promises;\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nimport { destroySupport } from '../../render/destroySupport.function.js';\nexport function compareArrayItems(value, index, lastArray, removed) {\n    const newLength = value.length - 1;\n    const at = index - removed;\n    const lessLength = at < 0 || newLength < at;\n    const prevContext = lastArray[index];\n    if (lessLength) {\n        destroyArrayItem(prevContext);\n        return 1;\n    }\n    const oldKey = prevContext.value.arrayValue;\n    const newValueTag = value[index];\n    const result = runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index);\n    return result;\n}\nfunction runArrayItemDiff(oldKey, newValueTag, prevContext, lastArray, index) {\n    const isDiff = newValueTag && oldKey !== newValueTag.arrayValue;\n    if (isDiff) {\n        destroyArrayItem(prevContext);\n        lastArray.splice(index, 1);\n        return 2;\n    }\n    return 0;\n}\nexport function destroyArrayItem(item) {\n    const global = item.global;\n    destroyArrayItemByGlobal(global, item);\n}\nfunction destroyArrayItemByGlobal(global, item) {\n    if (global) {\n        const support = global.oldest;\n        destroySupport(support, global);\n        return;\n    }\n    const element = item.simpleValueElm;\n    delete item.simpleValueElm;\n    addPaintRemover(element);\n}\n","export function processFirstSubjectValue(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    // const tagJsVar = valueToTagJsVar(value)\n    // contextItem.tagJsVar = tagJsVar\n    const tagJsVar = contextItem.tagJsVar;\n    return tagJsVar.processInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { processFirstSubjectValue } from \"../../tag/update/processFirstSubjectValue.function.js\";\nexport function domProcessContextItem(value, support, contextItem, counts, // used for animation stagger computing\nappendTo, insertBefore) {\n    // how to handle value updates\n    // contextItem.handler = tagValueUpdateHandler\n    const subject = support.context;\n    subject.locked = true;\n    processFirstSubjectValue(value, contextItem, support, counts, appendTo, insertBefore);\n    delete subject.locked;\n    contextItem.value = value;\n}\n","import { empty } from './tag/ValueTypes.enum.js';\nexport function castTextValue(value) {\n    switch (value) {\n        case undefined:\n        case false:\n        case null:\n            return empty;\n    }\n    return value;\n}\n","import { castTextValue } from '../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, addPaintRemover } from \"../render/paint.function.js\";\nimport { BasicTypes } from \"../index.js\";\nimport { processUpdateRegularValue } from \"../tag/update/processRegularValue.function.js\";\nimport { tagValueUpdateHandler } from \"../tag/update/tagValueUpdateHandler.function.js\";\nexport function getSimpleTagVar(value) {\n    return {\n        tagJsType: 'simple',\n        value,\n        processInit: processSimpleValueInit,\n        delete: deleteSimpleValue,\n        // TODO: get down to only one\n        checkValueChange: checkSimpleValueChange,\n        processUpdate: tagValueUpdateHandler,\n    };\n}\nfunction processSimpleValueInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo, insertBefore) {\n    // value = value.value\n    const castedValue = castTextValue(value);\n    insertBefore = contextItem.placeholder;\n    // always insertBefore for content\n    const paint = contextItem.paint = [paintBeforeText, [insertBefore, castedValue, function afterSimpleValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\nexport function deleteSimpleValue(contextItem) {\n    const elm = contextItem.simpleValueElm;\n    delete contextItem.simpleValueElm;\n    addPaintRemover(elm);\n}\nexport function checkSimpleValueChange(newValue, contextItem) {\n    const isBadValue = newValue === null || newValue === undefined;\n    if (isBadValue || !(typeof (newValue) === BasicTypes.object)) {\n        // This will cause all other values to render\n        processUpdateRegularValue(newValue, contextItem);\n        return -1; // no need to destroy, just update display\n    }\n    deleteSimpleValue(contextItem);\n    return 6; // 'changed-simple-value'\n}\n","import { castTextValue } from '../../castTextValue.function.js';\nimport { paintBeforeText, paintCommands, paintContent, setContent } from '../../render/paint.function.js';\nimport { getSimpleTagVar } from '../../tagJsVars/getSimpleTagVar.function.js';\nexport function processUpdateRegularValue(value, contextItem) {\n    const castedValue = castTextValue(value);\n    if (contextItem.paint) {\n        // its already painting, just provide new text paint[function, [element, text]]\n        contextItem.paint[1][1] = castedValue;\n        return;\n    }\n    const oldClone = contextItem.simpleValueElm; // placeholder\n    paintContent.push([setContent, [castedValue, oldClone]]);\n}\n/** Used during updates that were another value/tag first but now simple string */\nexport function processNowRegularValue(value, contextItem) {\n    contextItem.value = value;\n    contextItem.tagJsVar = getSimpleTagVar(value);\n    const before = contextItem.placeholder;\n    const castedValue = castTextValue(value);\n    const paint = contextItem.paint = [paintBeforeText, [before, castedValue, function cleanRegularValue(x) {\n                contextItem.simpleValueElm = x;\n                delete contextItem.paint;\n            }]];\n    paintCommands.push(paint);\n}\n","import { checkArrayValueChange, destroyArrayContextItem } from '../tag/checkDestroyPrevious.function.js';\nimport { processTagArray } from '../tag/update/processTagArray.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nexport function getArrayTagVar(value) {\n    return {\n        tagJsType: 'array',\n        value,\n        processInit: processArrayInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkArrayValueChange,\n        delete: destroyArrayContextItem,\n    };\n}\nfunction processArrayInit(value, // TemplateValue | StringTag | SubscribeValue | SignalObject,\ncontextItem, ownerSupport, counts, appendTo) {\n    const subValue = value;\n    processTagArray(contextItem, subValue, ownerSupport, counts, appendTo);\n}\n","import { isArray } from '../isInstance.js';\nimport { getSimpleTagVar } from './getSimpleTagVar.function.js';\nimport { getArrayTagVar } from './getArrayTagJsVar.function.js';\nexport function valueToTagJsVar(value) {\n    const tagJsType = value?.tagJsType;\n    if (tagJsType) {\n        return value;\n    }\n    return getBasicTagVar(value);\n}\nfunction getBasicTagVar(value) {\n    if (isArray(value)) {\n        return getArrayTagVar(value);\n    }\n    return getSimpleTagVar(value);\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { domProcessContextItem } from '../../interpolations/optimizers/domProcessContextItem.function.js';\nimport { empty } from '../ValueTypes.enum.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Must provide insertBefore OR appendTo */\nexport function createAndProcessContextItem(value, ownerSupport, counts, insertBefore, // used during updates\nappendTo) {\n    const element = document.createTextNode(empty);\n    const contextItem = {\n        value,\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement: false,\n        placeholder: element,\n    };\n    if (!appendTo) {\n        paintCommands.push([paintBefore, [insertBefore, element]]);\n    }\n    domProcessContextItem(value, ownerSupport, contextItem, counts, appendTo, insertBefore);\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, element]]);\n    }\n    return contextItem;\n}\n","// taggedjs-no-compile\nimport { tagValueUpdateHandler } from './tagValueUpdateHandler.function.js';\nimport { compareArrayItems } from './compareArrayItems.function.js';\nimport { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function processTagArray(subject, value, // arry of Tag classes\nownerSupport, counts, appendTo) {\n    const noLast = subject.lastArray === undefined;\n    if (noLast) {\n        subject.lastArray = [];\n    }\n    const lastArray = subject.lastArray;\n    let runtimeInsertBefore = subject.placeholder;\n    let removed = 0;\n    /**  remove previous items first */\n    const filteredLast = [];\n    // if not first time, then check for deletes\n    if (!noLast) {\n        // on each loop check the new length\n        for (let index = 0; index < lastArray.length; ++index) {\n            const item = lastArray[index];\n            //  COMPARE & REMOVE\n            const newRemoved = compareArrayItems(value, index, lastArray, removed);\n            if (newRemoved === 0) {\n                filteredLast.push(item);\n                continue;\n            }\n            // do the same number again because it was a mid delete\n            if (newRemoved === 2) {\n                index = index - 1;\n                continue;\n            }\n            removed = removed + newRemoved;\n        }\n        subject.lastArray = filteredLast;\n    }\n    const length = value.length;\n    for (let index = 0; index < length; ++index) {\n        const newSubject = reviewArrayItem(value, index, subject.lastArray, ownerSupport, runtimeInsertBefore, counts, appendTo);\n        runtimeInsertBefore = newSubject.placeholder;\n    }\n}\nfunction reviewArrayItem(array, index, lastArray, ownerSupport, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const item = array[index];\n    const previous = lastArray[index];\n    if (previous) {\n        return reviewPreviousArrayItem(item, previous, lastArray, ownerSupport, index, runtimeInsertBefore, counts, appendTo);\n    }\n    const contextItem = createAndProcessContextItem(item, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\nfunction reviewPreviousArrayItem(value, itemSubject, lastArray, ownerSupport, index, runtimeInsertBefore, // used during updates\ncounts, appendTo) {\n    const couldBeSame = lastArray.length > index;\n    if (couldBeSame) {\n        tagValueUpdateHandler(value, ownerSupport, itemSubject, counts);\n        return itemSubject;\n    }\n    const contextItem = createAndProcessContextItem(value, ownerSupport, counts, runtimeInsertBefore, appendTo);\n    // Added to previous array\n    lastArray.push(contextItem);\n    return contextItem;\n}\n","import { BasicTypes, ValueTypes } from '../index.js';\nimport { tryUpdateToTag } from './tryUpdateToTag.function.js';\nimport { isArray } from '../../isInstance.js';\nimport { processTagArray } from './processTagArray.js';\nimport { processNowRegularValue } from './processRegularValue.function.js';\nimport { getArrayTagVar } from '../../tagJsVars/getArrayTagJsVar.function.js';\nexport function updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts) {\n    // is new value a tag?\n    const tagJsType = newValue && newValue.tagJsType;\n    if (tagJsType) {\n        if (tagJsType === ValueTypes.renderOnce) {\n            return;\n        }\n        tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        return;\n    }\n    if (isArray(newValue)) {\n        processTagArray(contextItem, newValue, ownerSupport, counts);\n        contextItem.tagJsVar = getArrayTagVar(newValue);\n        return;\n    }\n    if (typeof (newValue) === BasicTypes.function) {\n        contextItem.value = newValue; // do not render functions that are not explicity defined as tag html processing\n        return;\n    }\n    if (ignoreOrDestroyed) {\n        processNowRegularValue(newValue, contextItem);\n    }\n}\n","import { updateToDiffValue } from './updateToDiffValue.function.js';\n/** Used for all tag value updates. Determines if value changed since last render */\nexport function forceUpdateExistingValue(contextItem, newValue, // newValue\nownerSupport, counts) {\n    // Have the context check itself (avoid having to detect old value)\n    const tagJsVar = contextItem.tagJsVar;\n    const ignoreOrDestroyed = tagJsVar.checkValueChange(newValue, contextItem, counts, ownerSupport);\n    // ignore\n    if (ignoreOrDestroyed === -1) {\n        return; // do nothing\n    }\n    updateToDiffValue(newValue, contextItem, ownerSupport, ignoreOrDestroyed, counts);\n}\n","import { ValueTypes } from '../ValueTypes.enum.js';\nimport { updateToDiffValue } from './updateToDiffValue.function.js';\nexport function checkSubContext(newValue, ownerSupport, contextItem, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.subscribe, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const subscription = contextItem.subContext;\n    if (!subscription || !subscription.hasEmitted) {\n        return -1;\n    }\n    subscription.callback = newValue.callback;\n    subscription.valuesHandler(subscription.lastValues);\n    return -1;\n}\nexport function handleTagTypeChangeFrom(originalType, newValue, ownerSupport, contextItem, counts) {\n    if (!newValue || !newValue.tagJsType || newValue.tagJsType !== originalType) {\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.delete(contextItem, ownerSupport);\n        updateToDiffValue(newValue, contextItem, ownerSupport, 99, counts);\n        return 99;\n    }\n}\n","import { createAndProcessContextItem } from './createAndProcessContextItem.function.js';\nexport function onFirstSubContext(value, subContext, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore) {\n    subContext.hasEmitted = true;\n    return subContext.contextItem = createAndProcessContextItem(value, ownerSupport, counts, insertBefore);\n}\n","import { paintAppend, paintAppends } from '../render/paint.function.js';\nimport { empty } from './ValueTypes.enum.js';\nexport function guaranteeInsertBefore(appendTo, insertBefore) {\n    let appendMarker;\n    // do we need to append now but process subscription later?\n    if (appendTo) {\n        appendMarker = insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n    }\n    return {\n        appendMarker,\n        insertBefore: insertBefore,\n    };\n}\n","import { paint } from '../../render/paint.function.js';\nimport { setUseMemory } from '../../state/setUseMemory.object.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nimport { forceUpdateExistingValue } from './forceUpdateExistingValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\nimport { deleteSubContext } from './deleteSubContext.function.js';\nimport { checkSubContext } from './checkSubContext.function.js';\nimport { onFirstSubContext } from './onFirstSubContext.function.js';\nimport { guaranteeInsertBefore } from '../guaranteeInsertBefore.function.js';\nexport function setupSubscribe(observables, contextItem, ownerSupport, counts, callback, appendTo, insertBeforeOriginal) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = setupSubscribeCallbackProcessor(observables, ownerSupport, counts, insertBefore, callback);\n    subContext.appendMarker = appendMarker;\n    contextItem.subContext = subContext;\n    // contextItem.handler = checkSubContext\n    contextItem.tagJsVar.processUpdate = checkSubContext;\n    return subContext;\n}\nexport function setupSubscribeCallbackProcessor(observables, ownerSupport, // ownerSupport ?\ncounts, // used for animation stagger computing\ninsertBefore, callback) {\n    const component = getSupportWithState(ownerSupport);\n    let onOutput = function onSubValue(value) {\n        onFirstSubContext(value, subContext, ownerSupport, counts, insertBefore);\n        checkToPaint(syncRun);\n        // MUTATION: from now on just run update\n        onOutput = function subscriptionUpdate(updateValue) {\n            const aContext = subContext.contextItem;\n            forceUpdateExistingValue(aContext, updateValue, ownerSupport, { added: 0, removed: 0 });\n            checkToPaint(syncRun);\n        };\n    };\n    // onValue mutates so function below calls original and mutation\n    function valueHandler(value, index) {\n        subContext.lastValues[index] = value;\n        valuesHandler(subContext.lastValues);\n    }\n    function valuesHandler(values) {\n        const newComponent = component.context.global.newest;\n        syncSupports(newComponent, component);\n        if (subContext.callback) {\n            const responseValue = subContext.callback(...values);\n            onOutput(responseValue);\n            return;\n        }\n        onOutput(values[0]);\n    }\n    let syncRun = true;\n    const subContext = {\n        lastValues: [],\n        valueHandler,\n        valuesHandler,\n        callback,\n        subscriptions: [],\n    };\n    // HINT: Must subscribe AFTER initial variable created above incase subscribing causes immediate run\n    observables.forEach((observable, index) => {\n        syncRun = true;\n        subContext.subscriptions.push(observable.subscribe(value => valueHandler(value, index)));\n        syncRun = false;\n    });\n    return subContext;\n}\nexport function deleteAndUnsubscribe(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.subscriptions.forEach(sub => sub.unsubscribe());\n    return deleteSubContext(contextItem, ownerSupport);\n}\nfunction checkToPaint(syncRun) {\n    if (!syncRun && !setUseMemory.stateConfig.support) {\n        paint();\n    }\n}\n","import { setupSubscribe } from './setupSubscribe.function.js';\nexport function processSubscribe(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    return setupSubscribe(value.Observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n}\nexport function processSubscribeWith(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    const observables = value.Observables;\n    const subscription = setupSubscribe(observables, contextItem, ownerSupport, counts, value.callback, appendTo, insertBefore);\n    if (!subscription.hasEmitted) {\n        const obValue = observables[0]?.value;\n        subscription.valueHandler((obValue || value.withDefault), 0);\n    }\n    return subscription;\n}\nexport function processSignal(value, contextItem, ownerSupport, counts, appendTo) {\n    setupSubscribe([value], contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { state } from './index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { processSignal } from '../tag/update/processSubscribe.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { deleteAndUnsubscribe } from '../tag/update/setupSubscribe.function.js';\nimport { handleTagTypeChangeFrom } from '../tag/update/checkSubContext.function.js';\n/** Checks if rendering cycle in process. Then creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function signal(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => Signal(initialValue));\n    }\n    return Signal(initialValue);\n}\n/** Creates object with \"value\" key and ability to \"subscribe\" to value changes */\nexport function Signal(initialValue) {\n    let value = initialValue;\n    const subscribers = new Set();\n    const emit = (newValue) => {\n        // Notify all subscribers\n        subscribers.forEach(callback => callback(newValue));\n    };\n    return {\n        tagJsType: ValueTypes.signal,\n        processInit: processSignal,\n        processUpdate: (newValue, ownerSupport, contextItem, counts) => handleTagTypeChangeFrom(ValueTypes.signal, newValue, ownerSupport, contextItem, counts),\n        get value() {\n            return value;\n        },\n        set value(newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                emit(newValue);\n            }\n        },\n        delete: deleteAndUnsubscribe,\n        emit,\n        subscribe(callback) {\n            callback(value); // emit initial value\n            subscribers.add(callback);\n            // Return an unsubscribe function\n            const unsub = () => subscribers.delete(callback);\n            // support traditional unsubscribe\n            unsub.unsubscribe = unsub;\n            return unsub;\n        },\n    };\n}\n","import { Subject, defineValueOn } from './Subject.class.js';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\nexport class ValueSubjective extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this._value = value;\n        defineValueOn(this); // if you extend this AND have a constructor, you must call this in your extension\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this._value, subscription);\n        return subscription;\n    }\n}\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    return setUseMemory.stateConfig.handlers.handler(defaultValue);\n}\n","import { ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/**\n * When an item in watch array changes, callback function will be triggered.\n * Triggers on initial watch setup. TIP: try watch.noInit()\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport const watch = ((currentValues, callback) => {\n    return setupWatch(currentValues, callback);\n});\nconst defaultFinally = (x) => x;\nfunction newWatch(setup) {\n    const method = (currentValues, callback) => {\n        return setupWatch(currentValues, callback, setup);\n    };\n    method.setup = setup;\n    defineOnMethod(() => method, method);\n    return method;\n}\n/**\n * puts above functionality together\n * @param currentValues values being watched\n * @param callback (currentValue, previousValues) => resolveToValue\n * @param param2\n * @returns\n */\nconst setupWatch = (currentValues, callback, { init, before, final = defaultFinally, } = {}) => {\n    const previous = state({\n        pastResult: undefined,\n        values: undefined,\n    });\n    const previousValues = previous.values;\n    // First time running watch?\n    if (previousValues === undefined) {\n        if (before && !before(currentValues)) {\n            previous.values = currentValues;\n            return previous.pastResult; // do not continue\n        }\n        const castedInit = init || callback;\n        const result = castedInit(currentValues, previousValues);\n        previous.pastResult = final(result);\n        previous.values = currentValues;\n        return previous.pastResult;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return previous.pastResult;\n    }\n    if (before && !before(currentValues)) {\n        previous.values = currentValues;\n        return previous.pastResult; // do not continue\n    }\n    const result = callback(currentValues, previousValues);\n    previous.pastResult = final(result);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return previous.pastResult;\n};\nfunction defineOnMethod(getWatch, attachTo) {\n    Object.defineProperty(attachTo, 'noInit', {\n        get() {\n            const watch = getWatch();\n            watch.setup.init = () => undefined;\n            return watch;\n        },\n    });\n    Object.defineProperty(attachTo, 'asSubject', {\n        get() {\n            const oldWatch = getWatch();\n            const firstSupport = state(() => getSupportInCycle());\n            const subject = state(() => new ValueSubject(undefined));\n            const oldState = state(() => ({\n                stateArray: setUseMemory.stateConfig.stateArray,\n                states: setUseMemory.stateConfig.states,\n            }));\n            const method = (currentValues, callback) => {\n                setupWatch(currentValues, (currentValues, previousValues) => {\n                    const nowSupport = getSupportInCycle();\n                    const setTo = callback(currentValues, previousValues);\n                    if (nowSupport !== firstSupport) {\n                        const newestState = oldState.stateArray;\n                        const global = firstSupport.context.global;\n                        const oldest = global.oldest;\n                        const oldestState = oldest.state;\n                        const newStates = oldState.states;\n                        const oldStates = oldest.states;\n                        oldSyncStates(newestState, oldestState, newStates, oldStates);\n                    }\n                    subject.next(setTo);\n                }, oldWatch.setup);\n                return subject;\n            };\n            method.setup = oldWatch.setup;\n            defineOnMethod(() => method, method);\n            return method;\n        },\n    });\n    Object.defineProperty(attachTo, 'truthy', {\n        get() {\n            const watch = getWatch();\n            watch.setup.before = (currentValues) => currentValues.every(x => x);\n            return watch;\n        },\n    });\n    return attachTo;\n}\ndefineOnMethod(() => newWatch({}), watch);\n","import { Subject, ValueSubject } from '../subject/index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nimport { oldSyncStates } from './syncStates.function.js';\n/** Create a Subject that on updates will sync state values to keep chained functions using latest variables */\nexport function subject(initialValue) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => new Subject(initialValue));\n    }\n    return new Subject(initialValue);\n}\nsubject._value = (value) => {\n    const oldestState = state(function subjectValue() {\n        return {\n            stateArray: setUseMemory.stateConfig.stateArray,\n            states: setUseMemory.stateConfig.states,\n        };\n    });\n    const nowSupport = getSupportInCycle();\n    return state(function subjectValue() {\n        const subject = new ValueSubject(value).pipe(x => {\n            oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n            return x;\n        });\n        return subject;\n    });\n};\nfunction all(args) {\n    const oldestState = state(() => ({\n        stateArray: setUseMemory.stateConfig.stateArray,\n        states: setUseMemory.stateConfig.states,\n    }));\n    const nowSupport = getSupportInCycle();\n    return Subject.all(args).pipe(x => {\n        oldSyncStates(nowSupport.state, oldestState.stateArray, nowSupport.states, oldestState.states);\n        return x;\n    });\n}\nsubject.all = all;\n","import { setUseMemory } from './setUseMemory.object.js';\n/** Used for variables that need to remain the same variable during render passes. If defaultValue is a function it is called only once, its return value is first state, and let value can changed */\nexport function states(setter) {\n    const config = setUseMemory.stateConfig;\n    return config.handlers.statesHandler(setter);\n}\n","import { signal } from './signal.function.js';\nimport { states } from './states.function.js';\nimport { watch } from './watch.function.js';\n/**\n * Enables the ability to maintain a change to a props value until the prop itself changes\n * @param prop typically the name of an existing prop\n * @returns immediately call the returned function: letProp(y)(x => [y, y=x])\n */\nexport function letProp(setter) {\n    const propStates2 = signal([]);\n    const passes = signal(0);\n    const passedOn = signal(0);\n    let nowValues = [];\n    let passed = 0;\n    passedOn.value = passes.value;\n    setter((...values) => {\n        nowValues = values;\n        return propStates2.value;\n    });\n    // When the watched variable changes, then the local prop variable has to update\n    watch(nowValues, () => {\n        ++passed; // first time values and changed values cause new state\n        propStates2.value = nowValues;\n        setter(() => nowValues);\n    });\n    // called and only used during sync'ing processes\n    states((_x, direction) => {\n        // now its collection of variables time\n        if (passed) {\n            setter((...values) => {\n                if (!direction || direction === 1) {\n                    propStates2.value = values;\n                }\n                return propStates2.value;\n            });\n            passedOn.value = passes.value;\n            ++passes.value;\n            return;\n        }\n        // this in an insync call, we do not care about the values here\n        setter(() => {\n            return propStates2.value;\n        });\n    });\n    ++passed;\n    return propStates2.value;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { state } from './state.function.js';\nfunction getBlankDiffMemory() {\n    return { stateDiff: 0, provider: undefined };\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const stateDiffMemory = state(getBlankDiffMemory);\n        // mimic how many states were called the first time\n        if (stateDiffMemory.stateDiff) {\n            let x = stateDiffMemory.stateDiff;\n            while (x--) {\n                state(undefined);\n            }\n            const result = state(undefined);\n            return result;\n        }\n        const result = state(() => {\n            const stateConfig = setUseMemory.stateConfig;\n            const oldStateCount = stateConfig.stateArray.length;\n            // Providers with provider requirements just need to use providers.create() and providers.inject()\n            const instance = constructMethod.prototype ? new constructMethod() : constructMethod();\n            const support = stateConfig.support;\n            const stateDiff = stateConfig.stateArray.length - oldStateCount;\n            const provider = {\n                constructMethod,\n                instance,\n                stateDiff,\n                owner: support,\n                children: [],\n            };\n            stateDiffMemory.provider = provider;\n            const global = support.context.global;\n            const providers = global.providers = global.providers || [];\n            providers.push(provider);\n            stateDiffMemory.stateDiff = stateDiff;\n            return instance;\n        });\n        const cm = constructMethod;\n        const compareTo = cm.compareTo = cm.toString();\n        stateDiffMemory.provider.constructMethod.compareTo = compareTo;\n        return result;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: providerInject\n};\nfunction providerInject(constructor) {\n    // find once, return same every time after\n    return state(function providerInjectState() {\n        // const memory = setUse.memory\n        const cm = constructor;\n        const compareTo = cm.compareTo = cm.compareTo || constructor.toString();\n        const support = getSupportInCycle(); // memory.stateConfig.support as AnySupport\n        const providers = [];\n        let owner = {\n            ownerSupport: support.ownerSupport\n        };\n        while (owner.ownerSupport) {\n            const ownGlobal = owner.ownerSupport.context.global;\n            const ownerProviders = ownGlobal.providers;\n            if (!ownerProviders) {\n                owner = owner.ownerSupport; // cause reloop checking next parent\n                continue;\n            }\n            const provider = ownerProviders.find(provider => {\n                providers.push(provider);\n                const constructorMatch = provider.constructMethod.compareTo === compareTo;\n                if (constructorMatch) {\n                    return true;\n                }\n            });\n            if (provider) {\n                const global = support.context.global;\n                const providers = global.providers = global.providers || [];\n                providers.push(provider);\n                provider.children.push(support);\n                return provider.instance;\n            }\n            owner = owner.ownerSupport; // cause reloop checking next parent\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, providers);\n        throw new Error(msg);\n    });\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import callbackStateUpdate from './callbackStateUpdate.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { syncError } from './callbackMaker.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\n/** Wrap a function that will be called back. After the wrapper and function are called, a rendering cycle will update display */\nexport function callback(callback) {\n    const support = getSupportInCycle();\n    if (!support) {\n        throw syncError;\n    }\n    return createTrigger(support, setUseMemory.stateConfig, // setUseMemory.stateConfig.stateArray\n    callback);\n}\nexport function createTrigger(support, oldState, toCallback) {\n    // const oldStates = [...oldState.states]\n    const oldStates = oldState.states;\n    return function trigger(...args) {\n        const callbackMaker = support.context.renderCount > 0;\n        if (callbackMaker) {\n            return callbackStateUpdate(support, oldStates, toCallback, ...args);\n        }\n        // we are in sync with rendering, just run callback naturally\n        return toCallback(...args);\n    };\n}\n","import { renderSupport } from '../render/renderSupport.function.js';\nimport { isPromise } from '../isInstance.js';\nexport default function callbackStateUpdate(support, oldStates, callback, ...args) {\n    const global = support.context.global;\n    const newestSupport = global.newest;\n    // NEWEST UPDATE OLDEST: ensure that the oldest has the latest values first\n    //syncStatesArray(newestSupport.states, oldStates)\n    // run the callback\n    const maybePromise = callback(...args);\n    // OLDEST UPDATE NEWEST: send the oldest state changes into the newest\n    //syncStatesArray(oldStates, newestSupport.states)\n    renderSupport(newestSupport);\n    if (isPromise(maybePromise)) {\n        maybePromise.finally(() => {\n            // send the oldest state changes into the newest\n            // syncStatesArray(oldStates, newestSupport.states)\n            renderSupport(newestSupport);\n        });\n    }\n    // return undefined as T\n    return maybePromise;\n}\n","import { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { setUseMemory } from './setUseMemory.object.js';\nimport { SyncCallbackError } from '../errors.js';\nimport { createTrigger } from './callback.function.js';\nexport const callbackMaker = () => {\n    const support = getSupportInCycle();\n    // callback as typeof innerCallback\n    if (!support) {\n        throw syncError;\n    }\n    const oldState = setUseMemory.stateConfig; // .stateArray\n    return function triggerMaker(callback) {\n        return createTrigger(support, oldState, callback);\n    };\n};\nexport const syncError = new SyncCallbackError('callback() was called outside of synchronous rendering. Use `callback = callbackMaker()` to create a callback that could be called out of sync with rendering');\n","import { paint, painting } from '../../render/paint.function.js';\nimport { renderSupport } from '../../render/renderSupport.function.js';\nexport function renderTagUpdateArray(supports) {\n    ++painting.locks;\n    supports.forEach(mapTagUpdate);\n    --painting.locks;\n    paint();\n}\nfunction mapTagUpdate(support) {\n    const global = support.context.global;\n    if (!global) {\n        return; // while rendering a parent, a child may have been deleted (pinbowl)\n    }\n    renderSupport(global.newest);\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { isPromise } from '../../isInstance.js';\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { syncSupports } from '../../state/syncStates.function.js';\nexport function checkToResolvePromise(callbackResult, last, global, mode, { resolvePromise, resolveValue }) {\n    const isProm = isPromise(callbackResult);\n    if (isProm) {\n        const subject = last.context;\n        subject.locked = true;\n        return callbackResult.then(thenResolveBy(last, resolvePromise));\n    }\n    return resolveValue(callbackResult);\n}\nexport function thenResolveBy(last, resolvePromise) {\n    return (x) => {\n        const global = last.context.global;\n        //clearTimeout(timeout)\n        if (global.deleted === true) {\n            return resolvePromise(x); // tag was deleted during event processing\n        }\n        const subject = last.context;\n        const global1 = last.context.global;\n        delete subject.locked;\n        // The promise may have then changed old variables, lets update forward\n        syncSupports(last, global1.newest);\n        const tagsToUpdate = getUpTags(last);\n        renderTagUpdateArray(tagsToUpdate);\n        return resolvePromise(x);\n    };\n}\n","import { checkToResolvePromise } from '../interpolations/attributes/checkToResolvePromise.function.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { state } from './state.function.js';\n/** runs a callback function one time and never again. Same as calling state(() => ...) */\nexport function onInit(callback) {\n    state(() => {\n        const result = callback();\n        const nowSupport = getSupportInCycle();\n        return checkToResolvePromise(result, nowSupport, nowSupport.context.global, 'onInit', { resolvePromise, resolveValue });\n    });\n}\nfunction resolvePromise(x) {\n    return x;\n}\nfunction resolveValue(x) {\n    return x;\n}\n","import { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { state } from \"./state.function.js\";\nexport function onDestroy(callback) {\n    state(function stateDestroy() {\n        const support = getSupportInCycle();\n        const global = support.context.global;\n        global.destroy$.toCallback(callback);\n    });\n}\n","import { state } from '../index.js';\nimport { getSupportInCycle } from '../tag/getSupportInCycle.function.js';\nimport { Signal } from './signal.function.js';\n/** returns a signal that contains an array and mocks acting like an array to support root array functionality */\nexport function array(initialValue = []) {\n    const support = getSupportInCycle();\n    if (support) {\n        return state(() => firstSignal(Signal(initialValue)));\n    }\n    return firstSignal(Signal(initialValue));\n}\nfunction firstSignal(sig) {\n    const editors = ['push', 'pop', 'splice', 'shift', 'unshift'];\n    const readers = ['map', 'reduce', 'forEach', 'every'];\n    const overwriteEmitter = (action) => {\n        return resignal[action] = (...args) => {\n            const result = sig.value[action](...args);\n            sig.emit(sig.value);\n            return result;\n        };\n    };\n    const resignal = new Proxy(sig, {\n        get(target, prop) {\n            // If accessing numeric index like '0', '1', etc.\n            if (!isNaN(prop)) {\n                return sig.value[prop];\n            }\n            if (prop === 'length') {\n                return sig.value.length;\n            }\n            if (editors.includes(prop)) {\n                return overwriteEmitter(prop);\n                // return sig.value[prop]\n            }\n            if (readers.includes(prop)) {\n                return sig.value[prop].bind(sig.value);\n            }\n            return sig[prop];\n        },\n        set(target, prop, value) {\n            if (!isNaN(prop)) {\n                sig.value[prop] = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            if (prop === 'length') {\n                sig.value.length = value;\n                sig.emit(sig.value);\n                return true;\n            }\n            // Applies to the signal and not the signal.value array\n            ;\n            sig[prop] = value;\n            return true;\n        }\n    });\n    return resignal;\n}\n","import { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nexport function isLikeTags(newSupport, // new\noldSupport) {\n    const isLike = isLikeBaseTags(newSupport, oldSupport);\n    // is this perhaps an outerHTML compare?      \n    if (!isLike && oldSupport.templater.tag?._innerHTML) {\n        if (isLikeBaseTags(newSupport.outerHTML, oldSupport)) {\n            return true;\n        }\n    }\n    return isLike;\n}\nfunction isLikeBaseTags(newSupport, // new\noldSupport) {\n    const templater0 = newSupport.templater;\n    const templater1 = oldSupport.templater;\n    const newTag = templater0?.tag || newSupport;\n    const oldTag = templater1.tag; // || (oldSupport as any)\n    if (templater0?.tagJsType === ValueTypes.stateRender) {\n        return templater0.dom === templater1.dom;\n    }\n    switch (newTag.tagJsType) {\n        case ValueTypes.dom: {\n            if (oldTag?.tagJsType !== ValueTypes.dom) {\n                return false; // newTag is not even same type\n            }\n            return isLikeDomTags(newTag, oldTag);\n        }\n        case ValueTypes.tag: {\n            const like = isLikeStringTags(newTag, oldTag, newSupport, oldSupport);\n            return like;\n        }\n    }\n    throw new Error(`unknown tagJsType of ${newTag.tagJsType}`);\n}\n// used when compiler was used\nexport function isLikeDomTags(newTag, oldTag) {\n    const domMeta0 = newTag.dom;\n    const domMeta1 = oldTag.dom;\n    return domMeta0 === domMeta1;\n}\n// used for no compiling\nfunction isLikeStringTags(newTag, oldTag, newSupport, // new\noldSupport) {\n    const strings0 = newTag.strings;\n    const strings1 = oldTag.strings;\n    if (strings0.length !== strings1.length) {\n        return false;\n    }\n    const everyStringMatched = strings0.every((string, index) => strings1[index].length === string.length // performance, just compare length of strings // TODO: Document this\n    );\n    if (!everyStringMatched) {\n        return false;\n    }\n    const values0 = newSupport.templater.values || newTag.values;\n    const values1 = oldSupport.templater.values || oldTag.values;\n    return isLikeValueSets(values0, values1);\n}\nexport function isLikeValueSets(values0, values1) {\n    const valuesLengthsMatch = values0.length === values1.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = values1.every(function isEveryValueAlike(value, index) {\n        const compareTo = values0[index];\n        const isFunctions = typeof (value) === BasicTypes.function && typeof (compareTo) === BasicTypes.function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { isStaticTag } from '../isInstance.js';\nimport { isLikeTags } from './isLikeTags.function.js';\nimport { tryUpdateToTag } from './update/tryUpdateToTag.function.js';\nexport function checkTagValueChange(newValue, contextItem, counts) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    const isValueTag = isStaticTag(newValue);\n    const newTag = newValue;\n    if (isValueTag) {\n        // its a different tag now\n        const likeTags = isLikeTags(newTag, lastSupport);\n        if (!likeTags) {\n            destroySupport(lastSupport, global);\n            getNewGlobal(contextItem);\n            return 7; // 'tag-swap'\n        }\n        // always cause a redraw of static tags (was false)\n        tryUpdateToTag(contextItem, newValue, lastSupport, counts);\n        return -1;\n    }\n    const isTag = newValue?.tagJsType;\n    if (isTag) {\n        const support = global.newest;\n        const ownerSupport = support.ownerSupport;\n        const result = tryUpdateToTag(contextItem, newValue, ownerSupport, counts);\n        const doNotRedraw = result === true;\n        if (doNotRedraw) {\n            return -1;\n        }\n        return 88; // its same tag with new values\n    }\n    destroySupportByContextItem(contextItem);\n    return 8; // 'no-longer-tag'\n}\nexport function destroySupportByContextItem(contextItem) {\n    const global = contextItem.global;\n    const lastSupport = global?.newest;\n    // destroy old component, value is not a component\n    destroySupport(lastSupport, global);\n    delete contextItem.global;\n    contextItem.renderCount = 0;\n}\n","import { attachDomElements } from './dom/attachDomElements.function.js';\nimport { getDomMeta } from '../tag/domMetaCollector.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { painting } from './paint.function.js';\nimport { valueToTagJsVar } from '../tagJsVars/valueToTagJsVar.function.js';\n/** Function that kicks off actually putting tags down as HTML elements */\nexport function buildBeforeElement(support, counts, appendTo, insertBefore) {\n    const subject = support.context;\n    const global = subject.global;\n    global.oldest = support;\n    global.newest = support;\n    ++painting.locks;\n    const result = attachHtmlDomMeta(support, counts, appendTo, insertBefore);\n    global.htmlDomMeta = result.dom;\n    --painting.locks;\n    // return fragment\n    return result;\n}\nfunction attachHtmlDomMeta(support, counts, appendTo, insertBefore) {\n    const domMeta = loadDomMeta(support);\n    const thisTag = support.templater.tag;\n    const values = thisTag.values;\n    const contexts = [];\n    const global = support.context.global;\n    global.contexts = contexts;\n    const result = attachDomElements(domMeta, values, support, counts, contexts, 0, appendTo, insertBefore);\n    return result;\n}\nfunction loadDomMeta(support) {\n    const templater = support.templater;\n    const thisTag = templater.tag;\n    if (thisTag.tagJsType === ValueTypes.dom) {\n        return thisTag.dom;\n    }\n    const strings = thisTag.strings;\n    return getDomMeta(strings, thisTag.values);\n}\nexport function addOneContext(value, context, withinOwnerElement) {\n    const contextItem = {\n        value,\n        tagJsVar: valueToTagJsVar(value),\n        withinOwnerElement,\n    };\n    context.push(contextItem);\n    return contextItem;\n}\n","import { createHtmlSupport } from '../../tag/createHtmlSupport.function.js';\nimport { checkTagValueChange } from '../../tag/checkTagValueChange.function.js';\nimport { buildBeforeElement } from '../buildBeforeElement.function.js';\nimport { ValueTypes } from '../../tag/ValueTypes.enum.js';\nimport { processTagInit } from '../../tag/update/processTagInit.function.js';\n/** When first time render, adds to owner childTags\n * Used for BOTH inserts & updates to values that were something else\n * Intended use only for updates\n*/\nexport function processTag(ownerSupport, // owner\ncontextItem, // could be tag via result.tag\ncounts) {\n    const global = contextItem.global;\n    const support = global.newest;\n    const ph = contextItem.placeholder;\n    support.ownerSupport = ownerSupport;\n    buildBeforeElement(support, counts, undefined, ph);\n    return support;\n}\nexport function tagFakeTemplater(tag) {\n    const templater = getFakeTemplater();\n    templater.tag = tag;\n    tag.templater = templater;\n    return templater;\n}\nexport function getFakeTemplater() {\n    const fake = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        checkValueChange: checkTagValueChange,\n    };\n    return fake;\n}\n/** Create support for a tag component */\nexport function newSupportByTemplater(templater, ownerSupport, subject) {\n    const support = createHtmlSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const global = subject.global;\n    global.contexts = [];\n    return support;\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from '../../render/paint.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nexport function processNewSubjectTag(templater, subject, // could be tag via result.tag\nownerSupport, // owner\ncounts, appendTo, insertBefore) {\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    support.ownerSupport = ownerSupport;\n    const result = buildBeforeElement(support, counts, appendTo, appendTo ? undefined : insertBefore);\n    for (const dom of result.dom) {\n        if (dom.marker) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.marker]]);\n            }\n        }\n        if (dom.domElement) {\n            if (appendTo) {\n                paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n            }\n            else {\n                paintCommands.push([paintBefore, [insertBefore, dom.domElement]]);\n            }\n        }\n    }\n    return support;\n}\n","import { processTag } from '../../render/update/processTag.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processTagInit(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    if (appendTo) {\n        return processNewSubjectTag(value, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    return processTag(ownerSupport, contextItem, counts);\n}\n","import { ValueTypes } from './ValueTypes.enum.js';\nimport { processTagInit } from './update/processTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nexport function getTemplaterResult(propWatch, props) {\n    const templater = {\n        tagJsType: ValueTypes.templater,\n        processInit: processTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        propWatch,\n        props,\n        key: function keyTemplate(arrayValue) {\n            templater.arrayValue = arrayValue;\n            return templater;\n        }\n    };\n    return templater;\n}\n","export const tags = [];\n","import { isInlineHtml, renderInlineHtml } from '../../render/renderSupport.function.js';\nimport { renderExistingSupport } from '../../render/renderExistingTag.function.js';\nexport function safeRenderSupport(newest) {\n    const subject = newest.context;\n    const isInline = isInlineHtml(newest.templater);\n    if (isInline) {\n        return renderInlineHtml(newest);\n    }\n    return renderExistingSupport(newest, newest, subject);\n}\n","import { getSupportInCycle } from '../getSupportInCycle.function.js';\nimport { deepCompareDepth } from '../hasSupportChanged.function.js';\nimport { isArray, isStaticTag } from '../../isInstance.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { setUseMemory } from '../../state/index.js';\nimport { safeRenderSupport } from './safeRenderSupport.function.js';\nexport function castProps(props, newSupport, depth) {\n    return props.map(function eachCastProp(prop) {\n        return alterProp(prop, newSupport.ownerSupport, newSupport, depth);\n    });\n}\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nfunction alterProp(prop, ownerSupport, newSupport, depth) {\n    if (isStaticTag(prop) || !prop) {\n        return prop;\n    }\n    if (!ownerSupport) {\n        return prop; // no one above me\n    }\n    return checkProp(prop, ownerSupport, newSupport, depth);\n}\nexport function checkProp(value, ownerSupport, newSupport, depth, owner) {\n    if (!value) {\n        return value;\n    }\n    if (value.tagJsType) {\n        return value;\n    }\n    if (typeof (value) === BasicTypes.function) {\n        if (depth <= 1) {\n            // only wrap function at depth 0 and 1\n            return getPropWrap(value, owner, ownerSupport);\n        }\n        return value;\n    }\n    if (depth === deepCompareDepth) {\n        return value;\n    }\n    const skip = isSkipPropValue(value);\n    if (skip) {\n        return value; // no children to crawl through\n    }\n    if (isArray(value)) {\n        return checkArrayProp(value, newSupport, ownerSupport, depth);\n    }\n    return checkObjectProp(value, newSupport, ownerSupport, depth);\n}\nfunction checkArrayProp(value, newSupport, ownerSupport, depth) {\n    for (let index = value.length - 1; index >= 0; --index) {\n        const subValue = value[index];\n        value[index] = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        if (typeof (subValue) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, index, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction checkObjectProp(value, newSupport, ownerSupport, depth) {\n    const keys = Object.keys(value);\n    for (const name of keys) {\n        const subValue = value[name];\n        const result = checkProp(subValue, ownerSupport, newSupport, depth + 1, value);\n        const newSubValue = value[name];\n        if (newSubValue === result) {\n            continue;\n        }\n        const getset = Object.getOwnPropertyDescriptor(value, name);\n        const hasSetter = getset?.get || getset?.set;\n        if (hasSetter) {\n            continue;\n        }\n        value[name] = result;\n        if (typeof (result) === BasicTypes.function) {\n            if (subValue.mem) {\n                continue;\n            }\n            afterCheckProp(depth + 1, name, subValue, value, newSupport);\n        }\n    }\n    return value;\n}\nfunction afterCheckProp(depth, index, originalValue, newProp, newSupport) {\n    // restore object to have original function on destroy\n    if (depth > 0) {\n        const global = newSupport.context.global;\n        newProp[index].subscription = global.destroy$.toCallback(function alterCheckProcessor() {\n            newProp[index] = originalValue;\n        });\n    }\n}\nexport function getPropWrap(value, owner, ownerSupport) {\n    const already = value.mem;\n    // already previously converted by a parent?\n    if (already) {\n        return value;\n    }\n    const wrap = function wrapRunner(...args) {\n        return callbackPropOwner(wrap.mem, owner, args, ownerSupport);\n    }; // what gets called can switch over parent state changes\n    wrap.original = value;\n    wrap.mem = value;\n    // copy data properties that maybe on source function\n    Object.assign(wrap, value);\n    return wrap;\n}\n/** Function shared by alterProps() and updateExistingTagComponent... TODO: May want to have to functions to reduce cycle checking?  */\nexport function callbackPropOwner(toCall, // original function\nowner, callWith, ownerSupport) {\n    const global = ownerSupport.context.global;\n    const newest = global?.newest || ownerSupport;\n    const supportInCycle = getSupportInCycle();\n    const noCycle = supportInCycle === undefined;\n    // actual function call to original method\n    const callbackResult = toCall.apply(owner, callWith);\n    const run = function propCallbackProcessor() {\n        const subject = newest.context;\n        const global = subject.global;\n        if (!global || subject.locked === true) {\n            return callbackResult; // currently in the middle of rendering\n        }\n        safeRenderSupport(newest);\n        return callbackResult;\n    };\n    if (noCycle) {\n        return run();\n    }\n    setUseMemory.tagClosed$.toCallback(run);\n    return callbackResult;\n}\nexport function isSkipPropValue(value) {\n    return typeof (value) !== BasicTypes.object || !value || value.tagJsType;\n}\n","import { BasicTypes, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { setUseMemory } from '../state/setUseMemory.object.js';\nimport { setSupportInCycle } from '../tag/getSupportInCycle.function.js';\nexport function executeWrap(templater, result, useSupport, castedProps) {\n    const originalFunction = result.original; // (innerTagWrap as any).original as unknown as TagComponent\n    const stateless = templater.tagJsType === ValueTypes.stateRender;\n    const config = setUseMemory.stateConfig;\n    setSupportInCycle(useSupport);\n    let tag;\n    if (stateless) {\n        tag = templater();\n    }\n    else {\n        tag = originalFunction(...castedProps);\n        // CALL ORIGINAL COMPONENT FUNCTION\n        if (typeof (tag) === BasicTypes.function) {\n            tag = tag();\n        }\n    }\n    tag.templater = templater;\n    templater.tag = tag;\n    useSupport.state = config.stateArray;\n    useSupport.states = config.states;\n    // useSupport.states = [...config.states]\n    return useSupport;\n}\n","import { castProps } from './props/alterProp.function.js';\nimport { syncFunctionProps } from '../render/update/updateExistingTagComponent.function.js';\nimport { executeWrap } from '../render/executeWrap.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { deepCompareDepth, shallowCompareDepth } from './hasSupportChanged.function.js';\nimport { createSupport } from './createSupport.function.js';\n/** creates/returns a function that when called then calls the original component function\n * Gets used as templater.wrapper()\n */\nexport function getTagWrap(templater, result) {\n    // this function gets called by taggedjs\n    const wrapper = function tagFunWrap(newSupport, subject, lastSupport // subject.global.newest\n    ) {\n        // wrap any prop functions that are passed in\n        const castedProps = getCastedProps(templater, newSupport, lastSupport);\n        const ownerSupport = newSupport.ownerSupport;\n        const useSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject, castedProps);\n        return executeWrap(templater, result, useSupport, castedProps);\n    };\n    return wrapper;\n}\nexport function getCastedProps(templater, newSupport, lastSupport) {\n    const maxDepth = templater.propWatch === PropWatches.DEEP ? deepCompareDepth : shallowCompareDepth;\n    const props = templater.props;\n    const propsConfig = newSupport.propsConfig;\n    // When defined, this must be an update where my new props have already been made for me\n    let preCastedProps = propsConfig.castProps;\n    const lastPropsConfig = lastSupport?.propsConfig;\n    const lastCastProps = lastPropsConfig?.castProps;\n    if (lastCastProps) {\n        propsConfig.castProps = lastCastProps;\n        preCastedProps = syncFunctionProps(newSupport, lastSupport, lastSupport.ownerSupport, props, maxDepth);\n    }\n    const castedProps = preCastedProps || castProps(props, newSupport, 0);\n    return castedProps;\n}\n","import { getTemplaterResult } from '../getTemplaterResult.function.js';\nimport { newSupportByTemplater } from '../../render/update/processTag.function.js';\nimport { PropWatches } from '../../tagJsVars/tag.function.js';\nexport function oneRenderToSupport(wrapper, subject, ownerSupport) {\n    const templater = getTemplaterResult(PropWatches.DEEP);\n    templater.tagJsType = wrapper.tagJsType;\n    const support = newSupportByTemplater(templater, ownerSupport, subject);\n    let tag;\n    function wrap() {\n        templater.tag = tag || wrapper();\n        return support;\n    }\n    templater.wrapper = wrap;\n    wrap.tagJsType = wrapper.tagJsType;\n    wrap.original = wrapper.original || wrapper;\n    return support;\n}\n","import { StateMismatchError } from '../errors.js';\nexport function checkStateMismatch(config, support) {\n    const rearray = config.rearray;\n    if (rearray.length && rearray.length !== config.stateArray.length) {\n        throwStateMismatch(rearray, support, config);\n    }\n}\nconst hint = 'State tracking requires same number of state calls on every render. This error typically occurs when a state call is only reachable behind a condition. Also, wrapping tags that have state, with tag(), often helps when tag is only reachable by a condition.';\nfunction throwStateMismatch(rearray, support, config) {\n    const message = `Saved states between renders are inconsistent. Expected ${rearray.length} states got ${config.stateArray.length}.`;\n    const wrapper = support.templater?.wrapper;\n    let tagFunction = wrapper;\n    if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    else if (wrapper?.original) {\n        tagFunction = wrapper.original;\n    }\n    const details = {\n        oldStates: config.stateArray,\n        newStates: config.rearray,\n        tagFunction,\n        templater: support.templater,\n    };\n    const error = new StateMismatchError(message, details);\n    console.error(hint, details);\n    throw error;\n}\n","import { setUseMemory } from '../state/setUseMemory.object.js';\nimport { checkStateMismatch } from '../tag/checkStateMismatch.function.js';\n/** Compares states of previous renders\n * @property support - The workflow that supports a single tag\n * @property ownerSupport - undefined when \"support\" is the app element\n */\nexport function runAfterRender(support, ownerSupport) {\n    const subject = support.context;\n    ++subject.renderCount;\n    const config = setUseMemory.stateConfig;\n    support.state = config.stateArray;\n    support.states = config.states;\n    subject.global.newest = support;\n    checkStateMismatch(config, support);\n    delete config.prevSupport; // only this one really needed\n    delete config.support;\n    delete config.stateArray;\n    delete config.states;\n    setUseMemory.tagClosed$.next(ownerSupport);\n}\n","import { executeWrap } from './executeWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { runAfterRender } from './afterRender.function.js';\nimport { initState, reState } from '../state/state.utils.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nexport function renderTagOnly(newSupport, prevSupport, // causes restate\nsubject, ownerSupport) {\n    runBeforeRender(newSupport, prevSupport);\n    const templater = newSupport.templater;\n    let reSupport;\n    // NEW TAG CREATED HERE\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        const result = templater; // .wrapper as any// || {original: templater} as any\n        reSupport = createSupport(templater, ownerSupport, newSupport.appSupport, // ownerSupport.appSupport as AnySupport,\n        subject);\n        executeWrap(templater, result, reSupport);\n    }\n    else {\n        // functions wrapped in tag()\n        const wrapper = templater.wrapper;\n        // calls the function returned from getTagWrap()\n        reSupport = wrapper(newSupport, subject, prevSupport);\n    }\n    runAfterRender(reSupport, ownerSupport);\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return reSupport;\n}\nfunction runBeforeRender(newSupport, prevSupport) {\n    const prevState = prevSupport?.state;\n    if (prevState) {\n        reState(newSupport, prevSupport, prevState);\n        return;\n    }\n    initState(newSupport);\n}\n","import { oneRenderToSupport } from '../../tag/update/oneRenderToSupport.function.js';\nimport { renderTagOnly } from '../renderTagOnly.function.js';\nimport { getNewGlobal } from '../../tag/update/getNewGlobal.function.js';\nimport { processNewSubjectTag } from '../../tag/update/processNewSubjectTag.function.js';\nexport function processRenderOnceInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    getNewGlobal(contextItem);\n    const support = oneRenderToSupport(value, contextItem, ownerSupport);\n    renderTagOnly(support, undefined, contextItem);\n    return processNewSubjectTag(support.templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n}\n","import { processFirstTagResult } from './processTagResult.function.js';\nimport { ValueTypes } from '../ValueTypes.enum.js';\nimport { getCastedProps } from '../getTagWrap.function.js';\nimport { createSupport } from '../createSupport.function.js';\nimport { renderTagOnly } from '../../render/renderTagOnly.function.js';\nimport { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nexport function processReplacementComponent(templater, subject, ownerSupport, counts) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    buildBeforeElement(support, counts, undefined, // element for append child\n    subject.placeholder);\n    return support;\n}\nexport function processFirstSubjectComponent(templater, subject, ownerSupport, counts, appendTo) {\n    const newSupport = createSupport(templater, ownerSupport, ownerSupport.appSupport, subject);\n    const newPropsConfig = newSupport.propsConfig;\n    if (newPropsConfig) {\n        const castedProps = templater.tagJsType !== ValueTypes.tagComponent ? [] : getCastedProps(templater, newSupport);\n        newPropsConfig.castProps = castedProps;\n    }\n    const global = subject.global;\n    const support = renderTagOnly(newSupport, global.newest, // existing tag\n    subject);\n    return processFirstTagResult(support, counts, appendTo);\n}\n","import { buildBeforeElement } from '../../render/buildBeforeElement.function.js';\nimport { paintAppend, paintAppends } from '../../render/paint.function.js';\nexport function processFirstTagResult(support, counts, appendTo) {\n    const result = buildBeforeElement(support, counts, appendTo, undefined);\n    for (const dom of result.dom) {\n        if (dom.domElement) {\n            paintAppends.push([paintAppend, [appendTo, dom.domElement]]);\n        }\n        if (dom.marker) {\n            paintAppends.push([paintAppend, [appendTo, dom.marker]]);\n        }\n    }\n    return support;\n}\n","import { processFirstSubjectComponent, processReplacementComponent } from './processFirstSubjectComponent.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nexport function processTagComponentInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo) {\n    getNewGlobal(contextItem);\n    if (appendTo) {\n        const processResult = processFirstSubjectComponent(value, contextItem, ownerSupport, counts, appendTo);\n        return processResult;\n    }\n    const processResult = processReplacementComponent(value, contextItem, ownerSupport, counts);\n    return processResult;\n}\n","// taggedjs-no-compile\nimport { setUseMemory } from '../state/index.js';\nimport { getTemplaterResult } from '../tag/getTemplaterResult.function.js';\nimport { tags } from '../tag/tag.utils.js';\nimport { getTagWrap } from '../tag/getTagWrap.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { processRenderOnceInit } from '../render/update/processRenderOnceInit.function.js';\nimport { processTagComponentInit } from '../tag/update/processTagComponentInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../tag/checkTagValueChange.function.js';\nimport { tagValueUpdateHandler } from '../tag/update/tagValueUpdateHandler.function.js';\nlet tagCount = 0;\n/** How to handle checking for prop changes aka argument changes */\nexport var PropWatches;\n(function (PropWatches) {\n    PropWatches[\"DEEP\"] = \"deep\";\n    /** checks all values up to 2 levels deep */\n    PropWatches[\"SHALLOW\"] = \"shallow\";\n    PropWatches[\"NONE\"] = \"none\";\n    PropWatches[\"IMMUTABLE\"] = \"immutable\";\n})(PropWatches || (PropWatches = {}));\n/** Wraps a function tag in a state manager and calls wrapped function on event cycles\n * For single rendering, no event cycles, use: tag.renderOnce = (props) => html``\n */\nexport function tag(tagComponent, propWatch = PropWatches.SHALLOW) {\n    /** function developer triggers */\n    const parentWrap = function tagWrapper(...props) {\n        const templater = getTemplaterResult(propWatch, props);\n        templater.tagJsType = ValueTypes.tagComponent;\n        templater.processInit = processTagComponentInit;\n        // attach memory back to original function that contains developer display logic\n        const innerTagWrap = getTagWrap(templater, parentWrap);\n        innerTagWrap.original = tagComponent;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }; // we override the function provided and pretend original is what's returned\n    const tag = tagComponent;\n    parentWrap.original = tagComponent;\n    // group tags together and have hmr pickup\n    tag.tags = tags;\n    tag.setUse = setUseMemory;\n    tag.ValueTypes = ValueTypes;\n    tag.tagIndex = tagCount++; // needed for things like HMR\n    tags.push(parentWrap);\n    return parentWrap;\n}\n/** Use to structure and define a browser tag route handler\n * Example: export default tag.route = (routeProps: RouteProps) => (state) => html``\n */\nfunction routeFn(_routeProps) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n}\nfunction renderOnceFn() {\n    throw new Error('Do not call tag.renderOnce as a function but instead set it as: `(props) => tag.renderOnce = () => html`` `');\n}\n/** Used to create variable scoping when calling a function that lives within a prop container function */\nfunction tagUseFn() {\n    throw new Error('Do not call tag.use as a function but instead set it as: `(props) => tag.use = (use) => html`` `');\n}\n;\ntag.renderOnce = renderOnceFn;\ntag.use = tagUseFn;\ntag.deepPropWatch = tag;\ntag.route = routeFn;\ntag.app = function (_routeTag) {\n    throw new Error('Do not call tag.route as a function but instead set it as: `tag.route = (routeProps: RouteProps) => (state) => html`` `');\n};\ntag.immutableProps = function immutableProps(tagComponent) {\n    return tag(tagComponent, PropWatches.IMMUTABLE);\n};\ntag.watchProps = function watchProps(tagComponent) {\n    return tag(tagComponent, PropWatches.SHALLOW);\n};\n/* BELOW: Cast functions into setters with no getters */\nObject.defineProperty(tag, 'renderOnce', {\n    set(oneRenderFunction) {\n        oneRenderFunction.tagJsType = ValueTypes.renderOnce;\n        oneRenderFunction.processInit = processRenderOnceInit;\n        oneRenderFunction.processUpdate = tagValueUpdateHandler;\n        oneRenderFunction.delete = destroySupportByContextItem;\n        oneRenderFunction.checkValueChange = function renderOnceNeverChanges() {\n            return -1;\n        };\n    },\n});\nObject.defineProperty(tag, 'use', {\n    set(renderFunction) {\n        renderFunction.original = {\n            setUse: setUseMemory,\n            tags,\n        };\n        renderFunction.tagJsType = ValueTypes.stateRender;\n        renderFunction.processInit = processTagComponentInit;\n        renderFunction.processUpdate = tagValueUpdateHandler;\n        renderFunction.checkValueChange = checkTagValueChange;\n        renderFunction.delete = destroySupportByContextItem;\n    },\n});\n","import { deepEqual } from '../deepFunctions.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from './hasSupportChanged.function.js';\nimport { hasPropLengthsChanged } from '../render/renderSupport.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { BasicTypes } from './ValueTypes.enum.js';\n/**\n *\n * @param props\n * @param pastCloneProps\n * @returns WHEN number then props have changed. WHEN false props have not changed\n */\nexport function hasPropChanges(props, // natural props\npastCloneProps, // previously cloned props\npropWatch) {\n    const hasLenChanged = hasPropLengthsChanged(props, pastCloneProps);\n    if (hasLenChanged) {\n        return 11;\n    }\n    switch (propWatch) {\n        case PropWatches.NONE:\n            return 1; // always render\n        case PropWatches.SHALLOW: // determining equal is same as immutable, its the previous cloning step thats different\n            return shallowPropMatch(props, pastCloneProps);\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(props, pastCloneProps);\n    }\n    return deepPropChangeCompare(props, pastCloneProps);\n}\nfunction deepPropChangeCompare(props, pastCloneProps) {\n    // DEEP watch\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    castedProps = [...props];\n    castedPastProps = [...(pastCloneProps || [])];\n    const allFunctionsMatch = castedProps.every((value, index) => onePropCompare(value, index, castedProps, castedPastProps));\n    if (!allFunctionsMatch) {\n        return 7; // a change has been detected by function comparisons\n    }\n    return false;\n}\nfunction onePropCompare(value, index, castedProps, castedPastProps) {\n    const compare = castedPastProps[index];\n    if (typeof (value) === BasicTypes.object) {\n        const subCastedProps = { ...value };\n        const subCompareProps = { ...compare || {} };\n        const matched = Object.entries(subCastedProps).every(([key, value]) => compareProps(value, subCompareProps[key], () => {\n            delete subCastedProps[key]; // its a function and not needed to be compared\n            delete subCompareProps[key]; // its a function and not needed to be compared\n        }));\n        return matched;\n    }\n    return compareProps(value, compare, function propComparer() {\n        castedProps.splice(index, 1);\n        castedPastProps.splice(index, 1);\n    });\n}\n/** returning a number means true good comparison */\nfunction compareProps(value, compare, onDelete) {\n    if (!(typeof (value) === BasicTypes.function)) {\n        return deepEqual(value, compare, deepCompareDepth) ? 4 : false;\n    }\n    const compareFn = compare;\n    if (!(typeof (compareFn) === BasicTypes.function)) {\n        return false; // its a function now but was not before\n    }\n    // ensure we are comparing apples to apples as function get wrapped\n    const compareOriginal = compare?.original;\n    if (compareOriginal) {\n        compare = compareOriginal;\n    }\n    const original = value.original;\n    if (original) {\n        value = value.original;\n    }\n    const valueString = value.toString();\n    const compareString = compare.toString();\n    if (valueString === compareString) {\n        onDelete();\n        return 5; // both are function the same\n    }\n    onDelete();\n    return 6;\n}\n","import { isSkipPropValue } from '../props/alterProp.function.js';\nimport { BasicTypes } from '../ValueTypes.enum.js';\nimport { isArray } from '../../isInstance.js';\nimport { updateExistingObject } from './updateExistingObject.function.js';\nimport { updateExistingArray } from './updateExistingArray.function.js';\nexport function syncPriorPropFunction(priorProp, prop, newSupport, ownerSupport, maxDepth, depth) {\n    if (priorProp === undefined || priorProp === null) {\n        return prop;\n    }\n    // prevent infinite recursion\n    if (depth > maxDepth) {\n        return prop;\n    }\n    if (typeof (priorProp) === BasicTypes.function) {\n        // the prop i am receiving, is already being monitored/controlled by another parent\n        if (prop.mem) {\n            priorProp.mem = prop.mem;\n            return prop;\n        }\n        priorProp.mem = prop;\n        return priorProp;\n    }\n    if (isSkipPropValue(prop)) {\n        return prop; // no children to crawl through\n    }\n    if (isArray(prop)) {\n        return updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n    }\n    return updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth);\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingArray(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    for (let index = prop.length - 1; index >= 0; --index) {\n        const x = prop[index];\n        const oldProp = priorProp[index];\n        prop[index] = syncPriorPropFunction(oldProp, x, newSupport, ownerSupport, maxDepth, depth + 1);\n    }\n    return prop;\n}\n","import { syncPriorPropFunction } from './syncPriorPropFunction.function.js';\nexport function updateExistingObject(prop, priorProp, newSupport, ownerSupport, depth, maxDepth) {\n    const keys = Object.keys(prop);\n    for (const name of keys) {\n        const subValue = prop[name];\n        const oldProp = priorProp[name];\n        const result = syncPriorPropFunction(oldProp, subValue, newSupport, ownerSupport, maxDepth, depth + 1);\n        if (subValue === result) {\n            continue;\n        }\n        const hasSetter = Object.getOwnPropertyDescriptor(prop, name)?.set;\n        if (hasSetter) {\n            continue;\n        }\n        prop[name] = result;\n    }\n    return prop;\n}\n","import { getChildTagsToSoftDestroy, unsubscribeFrom } from '../tag/destroyContext.function.js';\nimport { getNewGlobal } from '../tag/update/getNewGlobal.function.js';\nimport { smartRemoveKids } from '../tag/smartRemoveKids.function.js';\n/** used when a tag swaps content returned */\nexport function softDestroySupport(lastSupport) {\n    const subject = lastSupport.context;\n    const global = subject.global;\n    const { subs, tags } = getChildTagsToSoftDestroy(global.contexts);\n    softDestroyOne(global);\n    for (const child of tags) {\n        const cGlobal = child.context.global;\n        if (cGlobal.deleted === true) {\n            return;\n        }\n        softDestroyOne(cGlobal);\n    }\n    const mySubs = global.subscriptions;\n    if (mySubs) {\n        subs.forEach(unsubscribeFrom);\n    }\n    getNewGlobal(subject);\n}\nfunction softDestroyOne(global) {\n    global.deleted = true; // the children are truly destroyed but the main support will be swapped\n    smartRemoveKids(global, []);\n}\n","import { moveProviders } from './update/updateExistingTagComponent.function.js';\nimport { softDestroySupport } from './softDestroySupport.function.js';\nimport { renderTagOnly } from './renderTagOnly.function.js';\nimport { isLikeTags } from '../tag/isLikeTags.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\n/** TODO: This seems to support both new and updates and should be separated? */\nexport function renderWithSupport(newSupport, lastSupport, // previous (global.newest)\nsubject) {\n    const reSupport = renderTagOnly(newSupport, lastSupport, subject);\n    const isLikeTag = !lastSupport || isLikeTags(lastSupport, reSupport);\n    if (!isLikeTag) {\n        moveProviders(lastSupport, reSupport);\n        softDestroySupport(lastSupport);\n        const global = reSupport.context.global;\n        global.oldest = reSupport;\n        global.newest = reSupport;\n    }\n    else if (lastSupport) {\n        const tag = lastSupport.templater.tag;\n        if (tag && subject.renderCount > 0) {\n            const lastTemplater = lastSupport?.templater;\n            const lastTag = lastTemplater?.tag;\n            checkTagSoftDestroy(tag, lastSupport, lastTag);\n        }\n    }\n    reSupport.ownerSupport = newSupport.ownerSupport; // || lastOwnerSupport) as AnySupport\n    return { support: reSupport, wasLikeTags: isLikeTag };\n}\nfunction checkTagSoftDestroy(tag, lastSupport, lastTag) {\n    if (tag.tagJsType === ValueTypes.dom) {\n        const lastDom = lastTag?.dom;\n        const newDom = tag.dom;\n        if (lastDom !== newDom) {\n            softDestroySupport(lastSupport);\n        }\n        return;\n    }\n    if (lastTag) {\n        const lastStrings = lastTag.strings;\n        if (lastStrings) {\n            const oldLength = lastStrings?.length;\n            const newLength = tag.strings.length;\n            if (oldLength !== newLength) {\n                softDestroySupport(lastSupport);\n            }\n        }\n    }\n}\n","import { renderWithSupport } from './renderWithSupport.function.js';\nimport { processTag } from './update/processTag.function.js';\nimport { updateSupportBy } from './update/updateSupportBy.function.js';\nexport function renderExistingSupport(lastSupport, // should be global.newest\nnewSupport, // new to be rendered\nsubject) {\n    const global = subject.global;\n    const result = renderWithSupport(newSupport, lastSupport, subject);\n    if (result.wasLikeTags) {\n        updateSupportBy(global.oldest, result.support);\n        return result.support;\n    }\n    return processTag(newSupport, subject, { added: 0, removed: 0 });\n}\n","import { deepEqual } from '../deepFunctions.js';\nimport { renderExistingSupport } from './renderExistingTag.function.js';\nimport { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { PropWatches } from '../index.js';\nimport { deepCompareDepth, immutablePropMatch, shallowPropMatch } from '../tag/hasSupportChanged.function.js';\nimport { getSupportWithState } from '../interpolations/attributes/getSupportWithState.function.js';\nexport function isInlineHtml(templater) {\n    return ValueTypes.templater === templater.tagJsType;\n}\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderSupport(support) {\n    const subject = support.context;\n    const global = subject.global;\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    if (subject.locked) {\n        global.blocked.push(support);\n        return support;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        const result = renderInlineHtml(support);\n        return result;\n    }\n    subject.locked = true;\n    if (global.blocked.length) {\n        support = global.blocked.pop();\n        global.blocked = [];\n    }\n    const tag = renderExistingSupport(global.newest, support, subject);\n    delete subject.locked;\n    return tag;\n}\n/** Renders the owner of the inline HTML even if the owner itself is inline html */\nexport function renderInlineHtml(support) {\n    const ownerSupport = getSupportWithState(support);\n    const ownGlobal = ownerSupport.context.global;\n    const newest = ownGlobal.newest;\n    // Function below may call renderInlineHtml again if owner is just inline HTML\n    const result = renderSupport(newest);\n    return result;\n}\nexport function checkRenderUp(templater, support) {\n    const selfPropChange = hasPropsToOwnerChanged(templater, support);\n    // render owner up first and that will cause me to re-render\n    if (selfPropChange) {\n        return true;\n    }\n    return false;\n}\n/** Used when crawling up the chain of child-to-parent tags. See hasSupportChanged for the downward direction */\nfunction hasPropsToOwnerChanged(templater, support) {\n    const nowProps = templater.props;\n    const propsConfig = support.propsConfig;\n    const latestProps = propsConfig.latest;\n    const compareLen = hasPropLengthsChanged(nowProps, latestProps);\n    if (compareLen) {\n        return true;\n    }\n    switch (templater.propWatch) {\n        case PropWatches.IMMUTABLE:\n            return immutablePropMatch(nowProps, latestProps);\n        case PropWatches.SHALLOW:\n            return shallowPropMatch(nowProps, latestProps);\n    }\n    return !deepEqual(nowProps, latestProps, deepCompareDepth);\n}\nexport function hasPropLengthsChanged(nowProps, latestProps) {\n    const nowLen = nowProps.length;\n    const latestLen = latestProps.length;\n    return nowLen !== latestLen;\n}\n","import { isTagComponent } from \"../../isInstance.js\";\nimport { providersChangeCheck } from \"../../state/providersChangeCheck.function.js\";\nimport { checkRenderUp, isInlineHtml } from \"../../render/renderSupport.function.js\";\nimport { ValueTypes } from \"../../tag/ValueTypes.enum.js\";\nexport function getUpTags(support, supports = []) {\n    const subject = support.context;\n    // const global = support.context.global as SupportTagGlobal\n    const templater = support.templater;\n    const inlineHtml = isInlineHtml(templater);\n    const ownerSupport = support.ownerSupport;\n    if (subject.locked) {\n        supports.push(support);\n        return supports;\n    }\n    // is it just a vanilla tag, not component?\n    if (inlineHtml) {\n        return getUpTags(ownerSupport, supports);\n    }\n    const newSupport = support; // global.newest as AnySupport\n    const isComponent = isTagComponent(newSupport.templater);\n    const tagJsType = support.templater.tagJsType;\n    const canContinueUp = ownerSupport && tagJsType !== ValueTypes.stateRender;\n    const continueUp = canContinueUp && (!isComponent || checkRenderUp(newSupport.templater, newSupport));\n    const proSupports = providersChangeCheck(newSupport);\n    supports.push(...proSupports);\n    if (continueUp) {\n        getUpTags(ownerSupport, supports);\n        if (isComponent) {\n            supports.push(newSupport);\n        }\n        return supports; // more to keep going up, do not push this child for review\n    }\n    supports.push(newSupport);\n    return supports;\n}\n","// taggedjs-no-compile\n/** File largely responsible for reacting to element events, such as onclick */\nimport { getUpTags } from './getUpTags.function.js';\nimport { renderTagUpdateArray } from './renderTagArray.function.js';\nimport { getSupportWithState } from './getSupportWithState.function.js';\nimport { checkToResolvePromise } from './checkToResolvePromise.function.js';\nexport function bindSubjectCallback(value, support) {\n    const global = support.context.global;\n    // MAIN EVENT CALLBACK PROCESSOR\n    const subjectFunction = function callbackReplacement(element, args) {\n        if (global.deleted === true) {\n            return;\n        }\n        // const newest = global.newest as AnySupport // || subjectFunction.support\n        return runTagCallback(subjectFunction.tagFunction, subjectFunction.support, // newest\n        // subjectFunction.states, // newest\n        element, args);\n    };\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    // const component = getSupportWithState(support)\n    subjectFunction.support = support;\n    // subjectFunction.otherSupport = component\n    //const states = component.states // ?.[0]\n    // subjectFunction.states = states\n    return subjectFunction;\n}\nexport function runTagCallback(value, support, \n// states: StatesSetter[],\nbindTo, args) {\n    // get actual component owner not just the html`` support\n    const component = getSupportWithState(support);\n    const subject = component.context;\n    // const global = subject.global as SupportTagGlobal // tag.subject.global as TagGlobal\n    subject.locked = true; // prevent another render from re-rendering this tag\n    // sync the new states to the old before the old does any processing\n    // syncStatesArray(component.subject.global.newest.states, states)\n    // ACTUAL CALLBACK TO ORIGINAL FUNCTION\n    const callbackResult = value.apply(bindTo, args);\n    // sync the old states to the new\n    // syncStatesArray(states, component.subject.global.newest.states)\n    delete subject.locked;\n    const result = afterTagCallback(callbackResult, component);\n    return result;\n}\nexport function afterTagCallback(callbackResult, eventHandlerSupport) {\n    const global = eventHandlerSupport.context.global; // tag.subject.global as SupportTagGlobal\n    return renderCallbackSupport(eventHandlerSupport, callbackResult, global);\n}\nfunction renderCallbackSupport(last, callbackResult, global) {\n    const tagsToUpdate = getUpTags(last);\n    renderTagUpdateArray(tagsToUpdate);\n    return checkToResolvePromise(callbackResult, last, global, 'bind', { resolvePromise, resolveValue });\n}\nconst noData = 'no-data-ever';\nconst promiseNoData = 'promise-no-data-ever';\nfunction resolvePromise() {\n    return promiseNoData;\n}\nfunction resolveValue() {\n    return noData;\n}\n","import { specialAttribute } from './specialAttribute.js';\nimport { processTagCallbackFun } from '../../render/attributes/processAttribute.function.js';\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nconst actions = ['init', 'destroy']; // oninit ondestroy\nexport function processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial) {\n    contextItem.element = element;\n    contextItem.howToSet = howToSet;\n    if (typeof (value) === BasicTypes.function) {\n        if (isSpecial && actions.includes(attrName)) {\n            specialAttribute(attrName, value, element, attrName, support, counts);\n            return;\n        }\n        return processTagCallbackFun(contextItem, value, support, attrName, element);\n    }\n    contextItem.attrName = attrName;\n    contextItem.isSpecial = isSpecial;\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nexport function processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial) {\n    if (isSpecial) {\n        return specialAttribute(attrName, value, element, isSpecial, support, counts);\n    }\n    howToSet(element, attrName, value);\n}\n","export function addSupportEventListener(support, eventName, element, callback) {\n    const elm = support.appElement;\n    // cast events that do not bubble up into ones that do\n    if (eventName === 'blur') {\n        eventName = 'focusout';\n    }\n    const replaceEventName = '_' + eventName;\n    // const replaceEventName = eventName\n    const global = support.context.global;\n    const eventReg = global.events;\n    if (!eventReg[eventName]) {\n        const listener = function eventCallback(event) {\n            event.originalStopPropagation = event.stopPropagation;\n            bubbleEvent(event, replaceEventName, event.target);\n        };\n        eventReg[eventName] = listener;\n        elm.addEventListener(eventName, listener);\n    }\n    // attach to element but not as \"_click\" and \"_keyup\"\n    ;\n    element[replaceEventName] = callback;\n    element[eventName] = callback;\n}\nfunction bubbleEvent(event, replaceEventName, target) {\n    const callback = target[replaceEventName];\n    if (callback) {\n        let stopped = false;\n        event.stopPropagation = function () {\n            stopped = true;\n            event.originalStopPropagation.call(event);\n        };\n        callback(event);\n        if (event.defaultPrevented || stopped) {\n            return;\n        }\n    }\n    const parentNode = target.parentNode;\n    if (parentNode) {\n        bubbleEvent(event, replaceEventName, parentNode);\n    }\n}\n","import { addSupportEventListener } from './addSupportEventListener.function.js';\nexport function processAttributeFunction(element, newAttrValue, support, attrName) {\n    const fun = function (...args) {\n        return fun.tagFunction(element, args);\n    };\n    // access to original function\n    fun.tagFunction = newAttrValue;\n    fun.support = support;\n    addSupportEventListener(support.appSupport, attrName, element, // support.appSupport.appElement as Element,\n    fun);\n}\n","export function isNoDisplayValue(attrValue) {\n    return undefined === attrValue || null === attrValue || false === attrValue;\n}\n","// taggedjs-no-compile\nimport { BasicTypes } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../../render/paint.function.js';\nimport { processNameOnlyAttrValue } from '../../render/attributes/processAttribute.function.js';\nimport { isNoDisplayValue } from '../../render/attributes/isNoDisplayValue.function.js';\nexport function updateNameOnlyAttrValue(values, attrValue, lastValue, element, ownerSupport, howToSet, context, counts) {\n    // check to remove previous attribute(s)\n    if (lastValue) {\n        if (isNoDisplayValue(attrValue)) {\n            element.removeAttribute(lastValue);\n            return;\n        }\n        if (typeof (lastValue) === BasicTypes.object) {\n            const isObStill = typeof (attrValue) === BasicTypes.object;\n            if (isObStill) {\n                for (const name in lastValue) {\n                    // if((attrValue as any)[name]) {\n                    if (name in attrValue) {\n                        continue;\n                    }\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n            else {\n                for (const name in lastValue) {\n                    paintContent.push([removeAttribute, [element, name]]);\n                }\n            }\n        }\n    }\n    processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts);\n}\nfunction removeAttribute(element, name) {\n    element.removeAttribute(name);\n}\n","import { processAttributeEmit } from './processAttribute.function.js';\nimport { updateNameOnlyAttrValue } from '../../interpolations/attributes/updateAttribute.function.js';\nexport function processUpdateAttrContext(value, ownerSupport, contextItem, _counts, values) {\n    if (contextItem.isNameOnly) {\n        updateNameOnlyAttrValue(values, value, contextItem.value, contextItem.element, // global.element as Element,\n        ownerSupport, contextItem.howToSet, [], // Context, but we dont want to alter current\n        { added: 0, removed: 0 });\n        contextItem.value = value;\n        return;\n    }\n    const element = contextItem.element;\n    processAttributeEmit(value, contextItem.attrName, contextItem, element, ownerSupport, contextItem.howToSet, contextItem.isSpecial, { added: 0, removed: 0 });\n    contextItem.value = value;\n    return;\n}\n","// taggedjs-no-compile\nimport { specialAttribute } from '../../interpolations/attributes/specialAttribute.js';\nimport { isFunction } from '../../isInstance.js';\nimport { bindSubjectCallback } from '../../interpolations/attributes/bindSubjectCallback.function.js';\nimport { BasicTypes, ValueTypes, empty } from '../../tag/ValueTypes.enum.js';\nimport { paintContent } from '../paint.function.js';\nimport { processNonDynamicAttr } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { addOneContext } from '../index.js';\nimport { processAttributeFunction } from '../../interpolations/attributes/processAttributeCallback.function.js';\nimport { isSpecialAttr } from '../../interpolations/attributes/isSpecialAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { createDynamicArrayAttribute, createDynamicAttribute } from './createDynamicAttribute.function.js';\nimport { getTagJsVar } from './getTagJsVar.function.js';\nimport { isNoDisplayValue } from './isNoDisplayValue.function.js';\nimport { getSupportWithState } from '../../interpolations/attributes/getSupportWithState.function.js';\n/** MAIN FUNCTION. Sets attribute value, subscribes to value updates  */\nexport function processAttribute(values, // all the variables inside html``\nattrName, element, support, howToSet, //  = howToSetInputValue\ncontext, isSpecial, counts, value) {\n    const nameVar = getTagJsVar(attrName);\n    const isNameVar = nameVar >= 0;\n    if (isNameVar) {\n        const value = values[nameVar];\n        const contextItem = addOneContext(value, context, true);\n        contextItem.isAttr = true;\n        contextItem.element = element;\n        contextItem.isNameOnly = true;\n        if (value.tagJsType) {\n            contextItem.tagJsVar = value;\n            contextItem.stateOwner = getSupportWithState(support);\n            contextItem.supportOwner = support;\n            return processHost(element, value, contextItem);\n        }\n        contextItem.howToSet = howToSet;\n        const tagJsVar = contextItem.tagJsVar;\n        tagJsVar.processUpdate = processUpdateAttrContext;\n        // stand alone attributes\n        processNameOnlyAttrValue(values, value, element, support, howToSet, context, counts);\n        return;\n    }\n    if (Array.isArray(value)) {\n        return createDynamicArrayAttribute(attrName, value, element, context, howToSet, support, counts, values);\n    }\n    const valueVar = getTagJsVar(value);\n    if (valueVar >= 0) {\n        const value = values[valueVar];\n        return createDynamicAttribute(attrName, value, element, context, howToSet, support, counts, isSpecial);\n    }\n    return processNonDynamicAttr(attrName, value, element, howToSet, counts, support, isSpecial);\n}\nfunction processHost(element, hostVar, contextItem) {\n    hostVar.processInit(element, hostVar, contextItem);\n    return;\n}\nexport function processNameOnlyAttrValue(values, attrValue, element, ownerSupport, howToSet, context, counts) {\n    if (isNoDisplayValue(attrValue)) {\n        return;\n    }\n    // process an object of attributes ${{class:'something, checked:true}}\n    if (typeof attrValue === BasicTypes.object) {\n        for (const name in attrValue) {\n            const value = attrValue[name];\n            processAttribute(values, name, element, ownerSupport, howToSet, context, isSpecialAttr(name), // only object variables are evaluated for is special attr\n            counts, value);\n        }\n        return;\n    }\n    // regular attributes\n    if (attrValue.length === 0) {\n        return; // ignore, do not set at this time\n    }\n    howToSet(element, attrValue, empty);\n}\nexport function processAttributeEmit(newAttrValue, attrName, subject, element, support, howToSet, isSpecial, counts) {\n    // should the function be wrapped so every time its called we re-render?\n    if (isFunction(newAttrValue)) {\n        return callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\n/** figure out what type of attribute we are dealing with and/or feed value into handler to figure how to update */\nexport function processAttributeSubjectValue(newAttrValue, element, attrName, special, howToSet, support, counts) {\n    // process adding/removing style. class. (false means remove)\n    if (special !== false) {\n        specialAttribute(attrName, newAttrValue, element, special, // string name of special\n        support, counts);\n        return;\n    }\n    switch (newAttrValue) {\n        case undefined:\n        case false:\n        case null:\n            paintContent.push([paintContentPush, [element, attrName]]);\n            return;\n    }\n    if (isFunction(newAttrValue)) {\n        return processAttributeFunction(element, newAttrValue, support, attrName);\n    }\n    // value is 0\n    howToSet(element, attrName, newAttrValue);\n}\nfunction callbackFun(support, newAttrValue, element, attrName, isSpecial, howToSet, subject, counts) {\n    const wrapper = support.templater.wrapper;\n    const tagJsType = wrapper?.tagJsType || wrapper?.original?.tagJsType;\n    const oneRender = tagJsType === ValueTypes.renderOnce;\n    if (!oneRender) {\n        return processTagCallbackFun(subject, newAttrValue, support, attrName, element);\n    }\n    return processAttributeSubjectValue(newAttrValue, element, attrName, isSpecial, howToSet, support, counts);\n}\nexport function processTagCallbackFun(subject, newAttrValue, support, attrName, element) {\n    // tag has state and will need all functions wrapped to cause re-renders\n    newAttrValue = bindSubjectCallback(newAttrValue, support);\n    const tagJsVar = subject.tagJsVar; // = valueToTagJsVar(newAttrValue)\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    return processAttributeFunction(element, newAttrValue, support, attrName);\n}\nfunction paintContentPush(element, attrName) {\n    element.removeAttribute(attrName);\n}\n","// taggedjs-no-compile\nimport { processDynamicNameValueAttribute } from '../../interpolations/attributes/processNameValueAttribute.function.js';\nimport { processUpdateAttrContext } from './processUpdateAttrContext.function.js';\nimport { getTagVarIndex } from './getTagVarIndex.function.js';\nimport { valueToTagJsVar } from '../../tagJsVars/valueToTagJsVar.function.js';\n/** Support string attributes with dynamics Ex: <div style=\"color:black;font-size::${fontSize};\"></div> */\nexport function createDynamicArrayAttribute(attrName, array, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, values) {\n    const startIndex = context.length;\n    // loop all to attach context and processors\n    array.forEach((value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = context.length;\n            const tagJsVar = valueToTagJsVar(value);\n            const contextItem = {\n                isAttr: true,\n                element,\n                attrName: attrName,\n                withinOwnerElement: true,\n                tagJsVar,\n            };\n            // contextItem.handler =\n            tagJsVar.processUpdate = function arrayItemHanlder(value, newSupport, contextItem, counts, newValues) {\n                setBy(newValues);\n            };\n            const pushValue = values[myIndex];\n            contextItem.value = pushValue;\n            context.push(contextItem);\n        }\n    });\n    function setBy(values) {\n        const concatValue = buildNewValueFromArray(array, values, startIndex).join('');\n        howToSet(element, attrName, concatValue);\n    }\n    setBy(values);\n}\nfunction buildNewValueFromArray(array, values, startIndex) {\n    return array.reduce((all, value) => {\n        const valueVar = getTagVarIndex(value);\n        if (valueVar >= 0) {\n            const myIndex = startIndex++;\n            const pushValue = values[myIndex];\n            all.push(pushValue);\n            return all;\n        }\n        all.push(value);\n        return all;\n    }, []);\n}\nexport function createDynamicAttribute(attrName, value, element, context, howToSet, //  = howToSetInputValue\nsupport, counts, isSpecial) {\n    const tagJsVar = valueToTagJsVar(value);\n    const contextItem = {\n        isAttr: true,\n        element,\n        attrName,\n        withinOwnerElement: true,\n        tagJsVar,\n    };\n    context.push(contextItem);\n    tagJsVar.processUpdate = processUpdateAttrContext;\n    processDynamicNameValueAttribute(attrName, value, contextItem, element, howToSet, support, counts, isSpecial);\n    contextItem.value = value;\n}\n","// taggedjs-no-compile\nimport { isObject } from '../../isInstance.js';\nexport function getTagJsVar(attrPart) {\n    if (isObject(attrPart) && 'tagJsVar' in attrPart)\n        return attrPart.tagJsVar;\n    return -1;\n    // return (attrPart as TagVarIdNum)?.tagJsVar || -1\n}\n","// taggedjs-no-compile\nimport { paintAppend, paintAppends, paintBefore, paintCommands } from \"../../render/paint.function.js\";\nimport { addOneContext } from \"../../render/index.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { domProcessContextItem } from \"./domProcessContextItem.function.js\";\nexport function attachDynamicDom(value, context, support, // owner\ncounts, // used for animation stagger computing\ndepth, // used to indicate if variable lives within an owner's element\nappendTo, insertBefore) {\n    const marker = document.createTextNode(empty);\n    const isWithinOwnerElement = depth > 0;\n    const contextItem = addOneContext(value, context, isWithinOwnerElement);\n    contextItem.placeholder = marker;\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, marker]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, marker]]);\n    }\n    domProcessContextItem(value, support, contextItem, counts, appendTo, insertBefore);\n}\n","// taggedjs-no-compile\nimport { howToSetFirstInputValue } from \"../../interpolations/attributes/howToSetInputValue.function.js\";\nimport { paintAppend, paintAppendElementString, paintAppends, paintBefore, paintBeforeElementString, paintCommands } from \"../paint.function.js\";\nimport { processAttribute } from \"../attributes/processAttribute.function.js\";\nimport { empty } from \"../../tag/ValueTypes.enum.js\";\nimport { attachDynamicDom } from \"../../interpolations/optimizers/attachDynamicDom.function.js\";\nexport const blankHandler = function blankHandler() {\n    return undefined;\n};\nexport function attachDomElements(nodes, values, support, counts, // used for animation stagger computing\ncontext, depth, // used to know if dynamic variables live within parent owner tag/support\nappendTo, insertBefore) {\n    const dom = [];\n    if (appendTo && insertBefore === undefined) {\n        insertBefore = document.createTextNode(empty);\n        paintAppends.push([paintAppend, [appendTo, insertBefore]]);\n        appendTo = undefined;\n    }\n    for (let index = 0; index < nodes.length; ++index) {\n        const node = nodes[index];\n        const value = node.v;\n        const isNum = !isNaN(value);\n        if (isNum) {\n            const index = context.length;\n            const value = values[index];\n            attachDynamicDom(value, context, support, counts, depth, appendTo, insertBefore);\n            continue;\n        }\n        const newNode = {}; // DomObjectText\n        dom.push(newNode);\n        if (node.nn === 'text') {\n            attachDomText(newNode, node, appendTo, insertBefore);\n            continue;\n        }\n        // one single html element\n        const domElement = attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore);\n        if (node.ch) {\n            newNode.ch = attachDomElements(node.ch, values, support, counts, context, depth + 1, domElement, insertBefore).dom;\n        }\n    }\n    return { dom, context };\n}\nfunction attachDomElement(newNode, node, values, support, context, counts, appendTo, insertBefore) {\n    const domElement = newNode.domElement = document.createElement(node.nn);\n    // attributes that may effect style, come first for performance\n    if (node.at) {\n        for (const attr of node.at) {\n            const name = attr[0];\n            const value = attr[1];\n            const isSpecial = attr[2] || false;\n            const howToSet = howToSetFirstInputValue;\n            processAttribute(values, name, domElement, support, howToSet, context, isSpecial, counts, value);\n        }\n    }\n    if (appendTo) {\n        paintAppends.push([paintAppend, [appendTo, domElement]]);\n    }\n    else {\n        paintCommands.push([paintBefore, [insertBefore, domElement]]);\n    }\n    return domElement;\n}\nfunction attachDomText(newNode, node, owner, insertBefore) {\n    const textNode = newNode;\n    const string = textNode.tc = node.tc;\n    if (owner) {\n        paintAppends.push([paintAppendElementString, [owner, string, function afterAppenDomText(elm) {\n                    textNode.domElement = elm;\n                }]]);\n        return;\n    }\n    paintCommands.push([paintBeforeElementString, [insertBefore, string, function afterInsertDomText(elm) {\n                textNode.domElement = elm;\n            }]]);\n}\n","import { blankHandler } from \"./dom/attachDomElements.function.js\";\n/** Typically used for animations to run before clearing elements */\nexport function addPaintRemoveAwait(promise) {\n    if (paintRemoveAwaits.length) {\n        paintRemoveAwaits[paintRemoveAwaits.length - 1].paintRemoves.push(...paintRemoves);\n        paintRemoves = [];\n    }\n    paintRemoveAwaits.push({ promise, paintRemoves });\n    paintRemoves = [];\n}\nlet paintRemoveAwaits = [];\nexport let paintCommands = [];\nexport let paintRemoves = [];\nexport let paintContent = [];\n// TODO: This this is duplicate of paintCommands (however timing is currently and issue and cant be removed)\nexport let paintAppends = [];\nexport let paintAfters = []; // callbacks after all painted\nexport const painting = {\n    locks: 0,\n    removeLocks: 0,\n};\nexport function setContent(text, textNode) {\n    textNode.textContent = text;\n}\nexport function paint() {\n    if (painting.locks > 0) {\n        return;\n    }\n    return runCycles();\n}\nfunction runCycles() {\n    runPaintCycles();\n    runAfterCycle();\n}\nfunction runAfterCycle() {\n    paintReset();\n    const nowPaintAfters = paintAfters;\n    paintAfters = []; // prevent paintAfters calls from endless recursion\n    for (const content of nowPaintAfters) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintRemoves() {\n    if (paintRemoveAwaits.length) {\n        const currentAwaits = paintRemoveAwaits.map(data => data.promise.then(() => {\n            const paintRemoves = data.paintRemoves;\n            for (const content of paintRemoves) {\n                content[0](...content[1]);\n            }\n        }));\n        paintRemoveAwaits = [];\n        const outerPaintRemoves = paintRemoves;\n        return Promise.all(currentAwaits).then(() => {\n            for (const content of outerPaintRemoves) {\n                content[0](...content[1]);\n            }\n        });\n    }\n    // element.parentNode.removeChild\n    for (const content of paintRemoves) {\n        content[0](...content[1]);\n    }\n}\nfunction runPaintCycles() {\n    runPaintRemoves();\n    paintRemoves = [];\n    // styles/attributes and textElement.textContent\n    for (const content of paintContent) {\n        content[0](...content[1]);\n    }\n    // .appendChild\n    for (const content of paintAppends) {\n        content[0](...content[1]);\n    }\n    // element.insertBefore\n    for (const content of paintCommands) {\n        content[0](...content[1]);\n    }\n}\nfunction paintReset() {\n    paintCommands = [];\n    paintContent = [];\n    paintAppends = [];\n}\nexport function addPaintRemover(element) {\n    paintRemoves.push([paintRemover, [element]]);\n}\n/** must be used with paintRemoves */\nfunction paintRemover(element) {\n    const parentNode = element.parentNode;\n    parentNode.removeChild(element);\n}\nexport function paintBefore(relative, element) {\n    relative.parentNode.insertBefore(element, relative);\n}\nexport function paintAppend(relative, element) {\n    relative.appendChild(element);\n}\nconst contentCleaner = (typeof document === 'object' && document.createElement('div')); // used for content cleaning\nfunction toPlainTextElm(text) {\n    // swap &gt; for >\n    contentCleaner.innerHTML = text; // script tags should have already been sanitized before this step\n    // delete <!-- -->\n    return document.createTextNode(contentCleaner.innerHTML);\n}\nexport function paintBeforeText(relative, text, callback = blankHandler) {\n    const textElm = toPlainTextElm(text);\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\nexport function paintAppendText(relative, text, callback) {\n    const textElm = toPlainTextElm(text);\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintBeforeElementString(relative, text, callback = blankHandler) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintBefore(relative, textElm);\n    callback(textElm);\n}\n/** Used when HTML content is safe and expected */\nexport function paintAppendElementString(relative, text, callback) {\n    contentCleaner.innerHTML = text;\n    const textElm = document.createTextNode(contentCleaner.textContent); // toPlainTextElm(text)\n    paintAppend(relative, textElm);\n    callback(textElm);\n}\n","import { addPaintRemover } from '../../render/paint.function.js';\nexport function deleteSubContext(contextItem, ownerSupport) {\n    const subscription = contextItem.subContext;\n    subscription.deleted = true;\n    delete contextItem.subContext;\n    const appendMarker = subscription.appendMarker;\n    if (appendMarker) {\n        addPaintRemover(appendMarker);\n        delete subscription.appendMarker;\n    }\n    delete contextItem.delete;\n    // contextItem.handler = tagValueUpdateHandler\n    // const tagJsVar = contextItem.tagJsVar as TagJsVar\n    //tagJsVar.processUpdate = tagValueUpdateHandler\n    if (!subscription.hasEmitted) {\n        return;\n    }\n    const subContextItem = subscription.contextItem;\n    const subTagJsVar = subContextItem.tagJsVar;\n    subTagJsVar.delete(subContextItem, ownerSupport);\n    return 76;\n}\n","import { newSupportByTemplater, processTag, tagFakeTemplater } from '../../render/update/processTag.function.js';\nimport { getNewGlobal } from './getNewGlobal.function.js';\nimport { processNewSubjectTag } from './processNewSubjectTag.function.js';\nexport function processDomTagInit(value, // StringTag,\ncontextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const tag = value;\n    let templater = tag.templater;\n    if (!templater) {\n        templater = tagFakeTemplater(tag);\n    }\n    const global = getNewGlobal(contextItem);\n    if (appendTo) {\n        return processNewSubjectTag(templater, contextItem, ownerSupport, counts, appendTo, insertBefore);\n    }\n    global.newest = newSupportByTemplater(templater, ownerSupport, contextItem);\n    return processTag(ownerSupport, contextItem, counts);\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { forceUpdateExistingValue } from './update/forceUpdateExistingValue.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** Used to override the html`` processing that will first render outerHTML and then its innerHTML */\nexport function processOuterDomTagInit(value, contextItem, // could be tag via result.tag\nownerSupport, // owningSupport\ncounts, appendTo, insertBefore) {\n    const outerHTML = value.outerHTML;\n    processDomTagInit(outerHTML, contextItem, // could be tag via result.tag\n    ownerSupport, // owningSupport\n    counts, appendTo, insertBefore);\n    // contextItem.handler = function outDomTagHanlder(\n    const tagJsVar = contextItem.tagJsVar;\n    tagJsVar.processUpdate = function outDomTagHanlder(value, newSupport, contextItem2, counts) {\n        forceUpdateExistingValue(contextItem2, value?.outerHTML || value, newSupport, counts);\n    };\n    // TODO: Not best idea to swap out the original values changeChecker\n    value.checkValueChange = checkOuterTagValueChange;\n}\nfunction checkOuterTagValueChange(newValue, contextItem, counts) {\n    return checkTagValueChange(newValue, // (newValue as Tag)?.outerHTML || newValue,\n    contextItem, // subContext.contextItem as any,\n    counts);\n}\n/** When runtime is in browser */\nexport function getStringTag(strings, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        tagJsType: ValueTypes.tag,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        strings,\n        /** Used within an array.map() that returns html aka array.map(x => html``.key(x)) */\n        key(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        /** aka setInnerHTML */\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: function html(strings, values) {\n            tag.children = { strings, values };\n            return tag;\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","// taggedjs-no-compile\nimport { ValueTypes } from './ValueTypes.enum.js';\nimport { getSupportInCycle } from './getSupportInCycle.function.js';\nimport { processDomTagInit } from './update/processDomTagInit.function.js';\nimport { checkTagValueChange, destroySupportByContextItem } from '../index.js';\nimport { processOuterDomTagInit } from './processOuterDomTagInit.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\n/** When compiled to then run in browser */\nexport function getDomTag(dom, values) {\n    const tag = {\n        values,\n        ownerSupport: getSupportInCycle(),\n        dom,\n        tagJsType: ValueTypes.dom,\n        processInit: processDomTagInit,\n        processUpdate: tagValueUpdateHandler,\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        key: function keyFun(arrayValue) {\n            tag.arrayValue = arrayValue;\n            return tag;\n        },\n        setHTML: function setHTML(innerHTML) {\n            innerHTML.outerHTML = tag;\n            tag._innerHTML = innerHTML;\n            innerHTML.oldProcessInit = innerHTML.processInit;\n            // TODO: Not best idea to override the init\n            innerHTML.processInit = processOuterDomTagInit;\n            return tag;\n        },\n        /** Used within the outerHTML tag to signify that it can use innerHTML */\n        acceptInnerHTML: function acceptInnerHTML(useTagVar) {\n            // TODO: datatype\n            useTagVar.owner = tag;\n            return tag;\n        },\n        html: {\n            dom: function dom(dom, // ObjectChildren\n            values) {\n                tag.children = { dom: dom, values };\n                return tag;\n            }\n        }\n    };\n    Object.defineProperty(tag, 'innerHTML', {\n        set(innerHTML) {\n            return tag.setHTML(innerHTML);\n        },\n    });\n    return tag;\n}\n","import { getDomTag } from './getDomTag.function.js';\nimport { PropWatches } from '../tagJsVars/tag.function.js';\nimport { getTemplaterResult } from './getTemplaterResult.function.js';\nimport { getStringTag } from './processOuterDomTagInit.function.js';\n/** Used as html`<div></div>` */\nexport function html(strings, ...values) {\n    const stringTag = getStringTag(strings, values);\n    const templater = getTemplaterResult(PropWatches.NONE);\n    templater.tag = stringTag;\n    stringTag.templater = templater;\n    return stringTag;\n}\nhtml.dom = function (dom, ...values) {\n    return getDomTag(dom, values);\n};\n","import { ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { appElements, buildBeforeElement } from '../index.js';\nexport function registerTagElement(support, element, global, templater, app, placeholder) {\n    console.debug(' Building element into tag...', { element, app, support });\n    const result = buildBeforeElement(support, { added: 0, removed: 0 }, element, undefined);\n    global.oldest = support;\n    global.newest = support;\n    let setUse = templater.setUse;\n    if (templater.tagJsType !== ValueTypes.stateRender) {\n        const wrap = app;\n        const original = wrap.original;\n        setUse = original.setUse;\n        original.isApp = true;\n    }\n    ;\n    element.setUse = setUse;\n    element.ValueTypes = ValueTypes;\n    appElements.push({ element, support });\n    const newFragment = document.createDocumentFragment();\n    newFragment.appendChild(placeholder);\n    for (const domItem of result.dom) {\n        putOneDomDown(domItem, newFragment);\n    }\n    console.debug(' Element Tag DOM built ');\n    return newFragment;\n}\nfunction putOneDomDown(dom, newFragment) {\n    if (dom.domElement) {\n        newFragment.appendChild(dom.domElement);\n    }\n    if (dom.marker) {\n        newFragment.appendChild(dom.marker);\n    }\n}\n","import { getBaseSupport, upgradeBaseToSupport } from './createHtmlSupport.function.js';\nexport function loadNewBaseSupport(templater, subject, appElement) {\n    const global = subject.global;\n    const newSupport = getBaseSupport(templater, subject);\n    upgradeBaseToSupport(templater, newSupport, newSupport);\n    newSupport.appElement = appElement;\n    global.oldest = global.oldest || newSupport;\n    global.newest = newSupport;\n    return newSupport;\n}\n","import { tags } from '../tag/tag.utils.js';\nimport { empty, ValueTypes } from '../tag/ValueTypes.enum.js';\nimport { destroySupport } from './destroySupport.function.js';\nimport { paint, painting } from './paint.function.js';\nimport { createSupport } from '../tag/createSupport.function.js';\nimport { runAfterRender } from '../render/afterRender.function.js';\nimport { executeWrap } from './executeWrap.function.js';\nimport { registerTagElement } from './registerNewTagElement.function.js';\nimport { loadNewBaseSupport } from '../tag/loadNewBaseSupport.function.js';\nimport { reState } from '../state/state.utils.js';\nexport function renderTagElement(app, global, templater, templater2, element, subject, isAppFunction) {\n    const placeholder = document.createTextNode(empty);\n    tags.push((templater.wrapper || { original: templater }));\n    const support = runWrapper(templater, placeholder, element, subject, isAppFunction);\n    global.isApp = true;\n    if (isAppFunction) {\n        templater2.tag = support.templater.tag;\n    }\n    if (!element) {\n        throw new Error(`Cannot tagElement, element received is type ${typeof element} and not type Element`);\n    }\n    // enables hmr destroy so it can control entire app\n    ;\n    element.destroy = function () {\n        const events = global.events;\n        for (const eventName in events) {\n            const callback = events[eventName];\n            element.removeEventListener(eventName, callback);\n        }\n        global.events = {};\n        ++painting.locks;\n        const toAwait = destroySupport(support, global); // never return anything here\n        --painting.locks;\n        paint();\n        return toAwait;\n    };\n    ++painting.locks;\n    const newFragment = registerTagElement(support, element, global, templater, app, placeholder);\n    --painting.locks;\n    paint();\n    element.appendChild(newFragment);\n    return {\n        support,\n        tags,\n        ValueTypes,\n    };\n}\nexport function runWrapper(templater, placeholder, appElement, subject, isAppFunction) {\n    subject.placeholder = placeholder;\n    const global = subject.global;\n    const oldest = global.oldest;\n    const isFirstRender = global.newest === oldest;\n    const newSupport = createSupport(templater, global.newest, global.newest.appSupport, // ownerSupport.appSupport as AnySupport,\n    subject);\n    if (!isFirstRender) {\n        reState(newSupport, global.newest, // global.oldest, // global.newest,\n        oldest.state);\n    }\n    if (templater.tagJsType === ValueTypes.stateRender) {\n        return executeStateWrap(templater, isAppFunction, newSupport, subject, appElement);\n    }\n    // Call the apps function for our tag templater\n    const wrapper = templater.wrapper;\n    const nowSupport = wrapper(newSupport, subject);\n    runAfterRender(newSupport);\n    return nowSupport;\n}\nfunction executeStateWrap(templater, isAppFunction, newSupport, subject, appElement) {\n    const result = (templater.wrapper || { original: templater });\n    if (!isAppFunction) {\n        const newSupport = loadNewBaseSupport(templater, subject, appElement);\n        runAfterRender(newSupport);\n        return newSupport;\n    }\n    executeWrap(templater, result, newSupport);\n    runAfterRender(newSupport);\n    return newSupport;\n}\n","import { getNewGlobal } from './update/getNewGlobal.function.js';\nimport { BasicTypes, ValueTypes } from './ValueTypes.enum.js';\nimport { destroySupport } from '../render/destroySupport.function.js';\nimport { PropWatches } from './index.js';\nimport { initState } from '../state/state.utils.js';\nimport { isTagComponent } from '../isInstance.js';\nimport { checkTagValueChange, destroySupportByContextItem } from './checkTagValueChange.function.js';\nimport { renderTagElement } from '../render/renderTagElement.function.js';\nimport { loadNewBaseSupport } from './loadNewBaseSupport.function.js';\nimport { tagValueUpdateHandler } from './update/tagValueUpdateHandler.function.js';\nif (typeof (document) === 'object') {\n    if (document.taggedJs) {\n        console.warn(' Multiple versions of taggedjs are loaded. May cause issues.');\n    }\n    document.taggedJs = true;\n}\nexport const appElements = [];\n/**\n *\n * @param app taggedjs tag\n * @param element HTMLElement\n * @param props object\n * @returns\n */\nexport function tagElement(app, element, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        const support = appElements[appElmIndex].support;\n        destroySupport(support, support.context.global);\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    let templater = (() => templater2(props));\n    templater.propWatch = PropWatches.NONE;\n    templater.tagJsType = ValueTypes.stateRender;\n    templater.processUpdate = tagValueUpdateHandler;\n    // todo: props should be an array\n    templater.props = [props];\n    templater.isApp = true;\n    // create observable the app lives on\n    const subject = getNewSubject(templater, element);\n    const global = subject.global;\n    initState(global.newest);\n    let templater2 = app(props);\n    const isAppFunction = typeof templater2 == BasicTypes.function;\n    if (!isAppFunction) {\n        if (!isTagComponent(templater2)) {\n            templater.tag = templater2;\n            templater2 = app;\n        }\n        else {\n            global.newest.propsConfig = {\n                latest: [props],\n                castProps: [props],\n            };\n            templater.propWatch = templater2.propWatch;\n            templater.tagJsType = templater2.tagJsType;\n            templater.wrapper = templater2.wrapper;\n            templater = templater2;\n        }\n    }\n    return renderTagElement(app, global, templater, templater2, element, subject, isAppFunction);\n}\nfunction getNewSubject(templater, appElement) {\n    const tagJsVar = {\n        tagJsType: 'templater',\n        checkValueChange: checkTagValueChange,\n        delete: destroySupportByContextItem,\n        processInit: function appDoNothing() {\n            console.debug('do nothing app function');\n        },\n        processUpdate: tagValueUpdateHandler,\n    };\n    const subject = {\n        value: templater,\n        withinOwnerElement: false, // i am the highest owner\n        renderCount: 0,\n        global: undefined, // gets set below in getNewGlobal()\n        tagJsVar,\n    };\n    const global = getNewGlobal(subject);\n    // TODO: events are only needed on the base and not every support\n    // for click events and such read at a higher level\n    global.events = {};\n    loadNewBaseSupport(templater, subject, appElement);\n    return subject;\n}\n","import { paint } from \"../index.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { paintAfters, painting } from \"../render/paint.function.js\";\nimport { syncStatesArray } from \"../state/syncStates.function.js\";\nimport { getSupportInCycle } from \"./getSupportInCycle.function.js\";\nimport { safeRenderSupport } from \"./props/safeRenderSupport.function.js\";\n/** Used to call a function that belongs to a calling tag but is not with root arguments */\nexport function output(callback) {\n    if (!callback) {\n        return blankHandler; // output used on an argument that was not passed in\n    }\n    const support = getSupportInCycle();\n    if (!support) {\n        throw new Error('output must be used in render sync fashion');\n    }\n    return (...args) => {\n        const ownerSupport = support.ownerSupport;\n        return syncWrapCallback(args, callback, ownerSupport);\n    };\n}\nexport function syncWrapCallback(args, callback, ownerSupport) {\n    const newestOwner = ownerSupport.context.global.newest;\n    // sync the new states to the old before the old does any processing\n    syncStatesArray(newestOwner.states, ownerSupport.states);\n    const c = callback(...args); // call the latest callback\n    // sync the old states to the new\n    syncStatesArray(ownerSupport.states, newestOwner.states);\n    // now render the owner\n    paintAfters.push([() => {\n            ++painting.locks;\n            safeRenderSupport(newestOwner);\n            --painting.locks;\n            paint();\n        }, []]);\n    return c;\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { checkSubContext, ValueTypes } from \"../tag/index.js\";\nimport { processSubscribe } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions. Automatically unsubscribes for you */\nexport function subscribe(Observable, callback) {\n    const support = getSupportInCycle();\n    const states = support ? getSupportWithState(support).states : [];\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribe,\n        processUpdate: checkSubContext,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states,\n        Observables: [Observable],\n    };\n}\n","import { deleteSubContext, guaranteeInsertBefore, onFirstSubContext } from \"../index.js\";\nimport { forceUpdateExistingValue } from \"../tag/update/index.js\";\nfunction handleInnerHTML(value, newSupport, contextItem, counts) {\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    const context = contextItem.subContext?.contextItem;\n    forceUpdateExistingValue(context, realValue, newSupport, counts);\n}\nfunction processInnerHTML(value, contextItem, ownerSupport, counts, appendTo, insertBefore) {\n    contextItem.subContext = {};\n    // contextItem.handler = handleInnerHTML\n    value.processUpdate = handleInnerHTML;\n    checkInnerHTML(value, ownerSupport, contextItem, counts, insertBefore, appendTo);\n}\nfunction checkInnerHTML(value, ownerSupport, contextItem, counts, insertBeforeOriginal, appendTo) {\n    const { appendMarker, insertBefore } = guaranteeInsertBefore(appendTo, insertBeforeOriginal);\n    const subContext = contextItem.subContext;\n    subContext.appendMarker = appendMarker;\n    const owner = value.owner;\n    const realValue = owner._innerHTML;\n    realValue.processInit = realValue.oldProcessInit;\n    /** Render the content that will CONTAIN the innerHTML */\n    onFirstSubContext(realValue, subContext, ownerSupport, counts, insertBefore);\n}\nexport function getInnerHTML() {\n    return {\n        tagJsType: 'innerHTML',\n        processInit: processInnerHTML,\n        processUpdate: handleInnerHTML,\n        delete: deleteSubContext,\n    };\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { deleteAndUnsubscribe, setupSubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function pipe(Observables, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processPipe,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables,\n    };\n}\nfunction processPipe(values, contextItem, ownerSupport, counts, appendTo) {\n    return setupSubscribe(values, contextItem, ownerSupport, counts, undefined, appendTo);\n}\n","import { ValueTypes } from \"../tag/index.js\";\nimport { syncWrapCallback } from \"../tag/output.function.js\";\nimport { handleTagTypeChangeFrom } from \"../tag/update/checkSubContext.function.js\";\n/** Use to gain access to element */\nexport function host(callback, options = {}) {\n    return {\n        tagJsType: ValueTypes.host,\n        processInit: processHost,\n        processUpdate: processHostUpdate,\n        delete: deleteHost,\n        options: { callback, ...options },\n    };\n}\nfunction processHostUpdate(newValue, ownerSupport, contextItem, counts) {\n    const hasChanged = handleTagTypeChangeFrom(ValueTypes.host, newValue, ownerSupport, contextItem, counts);\n    if (hasChanged) {\n        return hasChanged;\n    }\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    const element = contextItem.element;\n    options.callback(element, newValue, contextItem);\n}\nfunction processHost(element, tagJsVar, contextItem) {\n    tagJsVar.options.callback(element, tagJsVar, contextItem);\n    const options = tagJsVar.options;\n    if (options.onInit) {\n        const element = contextItem.element;\n        options.onInit(element, tagJsVar, contextItem);\n    }\n}\nfunction deleteHost(contextItem) {\n    const tagJsVar = contextItem.tagJsVar;\n    const options = tagJsVar.options;\n    if (options.onDestroy) {\n        const element = contextItem.element;\n        const hostDestroy = function processHostDestroy() {\n            return options.onDestroy(element, tagJsVar, contextItem);\n        };\n        const stateOwner = contextItem.stateOwner;\n        syncWrapCallback([], hostDestroy, stateOwner);\n    }\n}\n","import { getSupportWithState } from \"../interpolations/attributes/getSupportWithState.function.js\";\nimport { blankHandler } from \"../render/dom/attachDomElements.function.js\";\nimport { getSupportInCycle } from \"../tag/getSupportInCycle.function.js\";\nimport { ValueTypes } from \"../tag/index.js\";\nimport { processSubscribeWith } from \"../tag/update/processSubscribe.function.js\";\nimport { deleteAndUnsubscribe } from \"../tag/update/setupSubscribe.function.js\";\n/** Have an html tagged value as value of subscribe emissions, with initial default value emission. Automatically unsubscribes for you */\nexport function subscribeWith(Observable, withDefault, callback) {\n    return {\n        tagJsType: ValueTypes.subscribe,\n        processInit: processSubscribeWith,\n        // processUpdate: tagValueUpdateHandler,\n        processUpdate: blankHandler,\n        delete: deleteAndUnsubscribe,\n        callback,\n        withDefault,\n        states: getSupportWithState(getSupportInCycle()).states,\n        Observables: [Observable],\n    };\n}\n","export * from './tag/index.js';\nexport * from './state/index.js';\nexport * from './render/index.js';\nexport * from './subject/index.js';\nexport * from './tagJsVars/index.js';\nexport * from './interpolations/index.js';\nexport * from './errors.js';\nexport * from './isInstance.js';\nexport { states } from './state/states.function.js';\nexport * from './tag/createHtmlSupport.function.js';\nexport * from './interpolations/attributes/howToSetInputValue.function.js';\nexport * from './TagJsEvent.type.js';\nimport { renderTagOnly } from './render/renderTagOnly.function.js';\nimport { renderSupport } from './render/renderSupport.function.js';\nimport { renderWithSupport } from './render/renderWithSupport.function.js';\nimport { tagElement } from './tag/tagElement.js';\nimport { paint } from './render/paint.function.js';\nexport const hmr = {\n    tagElement, renderWithSupport, renderSupport,\n    renderTagOnly, paint,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","getNewGlobal","contextItem","renderCount","global","RouteQuery","_name","variablePrefix","variableSuffix","isSpecialAttr","attrName","startsWith","specialAction","isSpecialAction","placeholderRegex","RegExp","getTagVarIndex","value","search","fragFindAny","ondoubleclick","regexAttr","regexTagOrg","parseHTML","html","valuePositions","elements","stack","currentElement","valueIndex","position","regexTag","replace","removeCommentRegX","match","preprocessTagsInComments","length","tagMatch","exec","fullMatch","tagName","attrString","isClosingTag","isSelfClosing","endsWith","index","textContent","slice","trim","textVarMatches","splitByTagVar","fakeTagsRegEx","pushTextTo","pop","attributes","attrMatch","parseAttrString","element","nn","at","ch","push","textNode","pushTo","tc","postProcessTagsInComments","inputString","split","filter","notEmptyStringMapper","part","attrValue","undefined","notEmpty","noValue","lowerName","toLowerCase","fixedName","eventName","cleanEventName","valueName","wholeValue","attrSet","attrValueSplit","findRealTagsRegEx","x","forEach","isSpecial","unshift","realTagsRegEx","shortFront","replacement","htmlInterpolationToDomMeta","strings","values","htmlString","sanitizedFragments","results","safeFragment","diff","balanceArrayByArrays","addPlaceholders","htmlInterpolationToPlaceholders","join","empty","ImmutableTypes","BasicTypes","ValueTypes","tag","dom","templater","tagComponent","tagArray","host","subscribe","signal","renderOnce","stateRender","version","Date","now","replacePlaceholders","valueCount","currentTail","i","loopTail","attrs","processAttributes","children","innerLoopTail","examineChild","child","textChild","string","secondMatch","wIndex","parseInt","isNaN","varContent","after","splice","v","lastIndex","mapped","tagJsVar","lengthMapper","lastRuns","getDomMeta","stringId","array","map","Number","getStringsId","lastRun","matches","every","isLastRunMatched","domMetaMap","template","interpolation","howToSetInputValue","name","paintContent","howToSetFirstInputValue","setAttribute","removeAttribute","specialAttribute","specialName","support","counts","stagger","added","paintAfters","paintSpecialAttribute","removed","context","destroys","target","autofocus","autoselect","names","paintStyle","shift","classListAdd","classListRemove","processSpecialClass","Error","smallName","style","setProperty","classList","add","remove","select","focus","isSimpleType","number","boolean","isStaticTag","tagJsType","isTagComponent","tagType","isSubjectInstance","subject","isObject","function","isPromise","isFunction","then","object","isArray","Array","handleProviderChanges","appSupport","provider","tagsWithProvider","memory","childTags","cSubject","getTagsWithProvider","mapToSupport","deepClone","maxDepth","makeDeepClone","clone","create","getPrototypeOf","deepEqual","obj1","obj2","isDeepEqual","fn0","fn1","toString","getTime","isArrayDeepEqual","keys1","keys","keys2","includes","isObjectDeepEqual","getSupportInCycle","setUseMemory","stateConfig","setSupportInCycle","getSupportWithState","component","ownerSupport","newest","returnArgs","args","firstStatesHandler","setter","config","states","statesIndex","reStatesHandler","oldStates","prevSupport","lastValues","_args","initState","handlers","handler","runFirstState","statesHandler","rearray","stateArray","reState","newSupport","prevState","runRestate","StateEchoBack","getStateValue","state","callback","defaultValue","checkValue","getCallbackValue","restate","initValue","original","combineLatest","subjects","output","Subject","subscribeWith","valuesSeen","setValue","item","subscription","clones","subscriptions","getSubscription","subscribers","countSubject","globalSubCount$","next","unsubscribe","findIndex","sub","removeSubFromArray","valSub","runPipedMethods","methods","onComplete","cloneMethods","firstMethod","newValue","methodResponse","setHandler","onSubscription","isSubject","constructor","this","orgCallback","lastValue","emit","set","bind","subs","toPromise","Promise","res","toCallback","runtimeSub","tagJsUnsub","setTimeout","pipe","operations","setMethods","all","arg","static","Subjective","_value","super","defineValueOn","tagClosed$","syncSupports","newestSupport","syncStatesArray","from","onto","syncStates","got","syncFromState","syncOntoState","oldSyncStates","stateFrom","stateTo","intoStates","statesFrom","fromValue","oldValues","getIndex","stateFromTarget","oldGetCallback","newSetCallback","_","processUpdateOneContext","processUpdate","updateSupportBy","olderSupport","newerSupport","contexts","newTemplate","tempTag","updateSupportValuesBy","painting","locks","len","processUpdateContext","paint","cloneValueArray","cloneTagJsValue","shallowMapper","shallowCompareDepth","deepMapper","props","deepCompareDepth","getBaseSupport","castedProps","baseSupport","blocked","destroy$","upgradeBaseToSupport","propsConfig","castProps","propWatch","PropWatches","IMMUTABLE","latest","SHALLOW","clonePropsBy","createHtmlSupport","createSupport","tryUpdateToTag","isComp","processInit","placeholder","oldSupport","oldWrapper","wrapper","newWrapper","isSameTag","skipComparing","isLikeTags","innerHTML","_innerHTML","outerHTML","oldestSupport","oldest","destroySupport","swapTags","hasChanged","newTemplater","latestProps","pastCloneProps","propsChanged","hasPropChanges","hasSupportChanged","newProps","syncFunctionProps","lastPropsConfig","DEEP","locked","renderSupport","updateExistingTagComponent","prepareUpdateToComponent","oldTtag","valueSupport","handleStillTag","tagValueUpdateHandler","forceUpdateExistingValue","runBeforeDestroy","providers","destroyContext","lastArray","childValue","delete","iSubs","unsubscribeFrom","getChildTagsToSoftDestroy","tags","subTags","checkArrayValueChange","destroyArrayContextItem","destroyArray","destroyArrayItem","smartRemoveKids","allPromises","promises","destroyCall","lastPromise","smartRemoveByContext","destroyClones","processContextDestroys","destroy","maybePromise","withinOwnerElement","supportOwner","elm","simpleValueElm","addPaintRemover","subGlobal","deleted","htmlDomMeta","destroyClone","marker","domElement","compareArrayItems","newLength","lessLength","prevContext","result","oldKey","newValueTag","isDiff","arrayValue","runArrayItemDiff","destroyArrayItemByGlobal","processFirstSubjectValue","appendTo","insertBefore","domProcessContextItem","castTextValue","getSimpleTagVar","processSimpleValueInit","deleteSimpleValue","checkValueChange","checkSimpleValueChange","castedValue","paintBeforeText","paintCommands","oldClone","setContent","processUpdateRegularValue","getArrayTagVar","processArrayInit","processTagArray","valueToTagJsVar","getBasicTagVar","createAndProcessContextItem","document","createTextNode","paintBefore","paintAppends","paintAppend","noLast","runtimeInsertBefore","filteredLast","newRemoved","reviewArrayItem","previous","itemSubject","couldBeSame","reviewPreviousArrayItem","updateToDiffValue","ignoreOrDestroyed","before","processNowRegularValue","checkSubContext","handleTagTypeChangeFrom","subContext","hasEmitted","valuesHandler","originalType","onFirstSubContext","guaranteeInsertBefore","appendMarker","setupSubscribe","observables","insertBeforeOriginal","onOutput","checkToPaint","syncRun","updateValue","valueHandler","responseValue","observable","setupSubscribeCallbackProcessor","deleteAndUnsubscribe","deleteSubContext","processSubscribe","Observables","processSubscribeWith","obValue","withDefault","processSignal","initialValue","Signal","Set","unsub","ValueSubject","ValueSubjective","willCallback","utils","willPromise","willSubscribe","watch","currentValues","setupWatch","defaultFinally","init","final","pastResult","previousValues","defineOnMethod","getWatch","attachTo","setup","oldWatch","firstSupport","oldState","method","nowSupport","setTo","newestState","letProp","propStates2","passes","passedOn","nowValues","passed","_x","direction","getBlankDiffMemory","stateDiff","newWatch","oldestState","constructMethod","stateDiffMemory","oldStateCount","instance","owner","cm","compareTo","inject","ownerProviders","find","msg","console","warn","TagError","details","message","errorCode","ArrayNoKeyError","StateMismatchError","SyncCallbackError","syncError","createTrigger","finally","callbackStateUpdate","callbackMaker","renderTagUpdateArray","supports","mapTagUpdate","checkToResolvePromise","callbackResult","last","mode","resolvePromise","resolveValue","global1","getUpTags","thenResolveBy","onInit","onDestroy","firstSignal","sig","editors","readers","resignal","Proxy","action","isLike","isLikeBaseTags","templater0","templater1","newTag","oldTag","domMeta0","domMeta1","isLikeDomTags","like","strings0","strings1","values0","values1","valuesLengthsMatch","allVarsMatch","isLikeValueSets","isLikeStringTags","checkTagValueChange","lastSupport","isTag","destroySupportByContextItem","buildBeforeElement","domMeta","thisTag","loadDomMeta","attachDomElements","attachHtmlDomMeta","addOneContext","processTag","ph","tagFakeTemplater","processTagInit","newSupportByTemplater","processNewSubjectTag","getTemplaterResult","safeRenderSupport","isInlineHtml","renderInlineHtml","renderExistingSupport","depth","checkProp","alterProp","already","mem","wrap","toCall","callWith","noCycle","apply","run","callbackPropOwner","assign","getPropWrap","isSkipPropValue","subValue","afterCheckProp","checkArrayProp","getset","getOwnPropertyDescriptor","checkObjectProp","originalValue","newProp","executeWrap","useSupport","originalFunction","stateless","getCastedProps","preCastedProps","lastCastProps","oneRenderToSupport","checkStateMismatch","tagFunction","newStates","error","hint","throwStateMismatch","runAfterRender","renderTagOnly","runBeforeRender","reSupport","processRenderOnceInit","processFirstSubjectComponent","newPropsConfig","processFirstTagResult","processTagComponentInit","processResult","processReplacementComponent","tagCount","parentWrap","innerTagWrap","getTagWrap","setUse","tagIndex","hasPropLengthsChanged","NONE","shallowPropMatch","immutablePropMatch","castedPastProps","compare","subCastedProps","subCompareProps","matched","entries","compareProps","onePropCompare","deepPropChangeCompare","onDelete","compareOriginal","pastProp","obEntries","subItem","objectItemMatches","use","deepPropWatch","route","_routeProps","app","_routeTag","immutableProps","watchProps","oneRenderFunction","renderFunction","pastValue","syncPriorPropFunction","priorProp","oldProp","updateExistingArray","hasSetter","updateExistingObject","newPropsArray","priorPropsArray","newArray","softDestroySupport","softDestroyOne","cGlobal","renderWithSupport","isLikeTag","lastTemplater","lastTag","lastDom","lastStrings","oldLength","checkTagSoftDestroy","pIndex","pLen","pcLen","moveProviders","wasLikeTags","inlineHtml","checkRenderUp","selfPropChange","nowProps","hasPropsToOwnerChanged","isComponent","continueUp","proSupports","prosWithChanges","hasChange","providersChangeCheck","bindSubjectCallback","subjectFunction","bindTo","eventHandlerSupport","renderCallbackSupport","afterTagCallback","runTagCallback","noData","promiseNoData","actions","processNonDynamicAttr","howToSet","addSupportEventListener","appElement","replaceEventName","eventReg","events","listener","event","originalStopPropagation","stopPropagation","bubbleEvent","addEventListener","stopped","defaultPrevented","parentNode","processAttributeFunction","newAttrValue","fun","isNoDisplayValue","processUpdateAttrContext","_counts","isNameOnly","processNameOnlyAttrValue","updateNameOnlyAttrValue","processTagCallbackFun","processAttributeSubjectValue","callbackFun","processAttributeEmit","createDynamicArrayAttribute","startIndex","setBy","concatValue","reduce","myIndex","pushValue","buildNewValueFromArray","isAttr","newValues","createDynamicAttribute","processDynamicNameValueAttribute","getTagJsVar","attrPart","processAttribute","nameVar","stateOwner","hostVar","processHost","valueVar","special","paintContentPush","attachDynamicDom","blankHandler","nodes","node","newNode","attachDomText","attachDomElement","createElement","attr","paintAppendElementString","paintBeforeElementString","addPaintRemoveAwait","promise","paintRemoveAwaits","paintRemoves","removeLocks","text","currentAwaits","data","content","outerPaintRemoves","runPaintRemoves","runPaintCycles","nowPaintAfters","runAfterCycle","paintRemover","removeChild","relative","appendChild","contentCleaner","toPlainTextElm","textElm","subContextItem","processDomTagInit","processOuterDomTagInit","contextItem2","checkOuterTagValueChange","getDomTag","setHTML","oldProcessInit","acceptInnerHTML","useTagVar","stringTag","getStringTag","putOneDomDown","newFragment","loadNewBaseSupport","renderTagElement","templater2","isAppFunction","isFirstRender","executeStateWrap","runWrapper","isApp","removeEventListener","toAwait","debug","appElements","createDocumentFragment","domItem","registerTagElement","taggedJs","tagElement","appElmIndex","appElm","getNewSubject","syncWrapCallback","newestOwner","c","Observable","handleInnerHTML","realValue","processInnerHTML","checkInnerHTML","getInnerHTML","processPipe","options","processHostUpdate","deleteHost","hmr"],"sourceRoot":""}